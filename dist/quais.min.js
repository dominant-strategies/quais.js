const __$G=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};import*as pb_1 from"google-protobuf";import ecc from"@bitcoinerlab/secp256k1";const version="1.0.0-alpha.33";function checkType(value,type,name){const types=type.split("|").map(t=>t.trim());for(let i=0;i<types.length;i++){switch(type){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof value===type){return}}}const error=new Error(`invalid value for type ${type}`);error.code="INVALID_ARGUMENT";error.argument=`value.${name}`;error.value=value;throw error}async function resolveProperties(value){const keys=Object.keys(value);const results=await Promise.all(keys.map(k=>Promise.resolve(value[k])));return results.reduce((accum,v,index)=>{accum[keys[index]]=v;return accum},{})}function getStatic(ctor,key){for(let i=0;i<32;i++){if(ctor[key]){return ctor[key]}if(!ctor.prototype||typeof ctor.prototype!=="object"){break}ctor=Object.getPrototypeOf(ctor.prototype).constructor}return null}function defineProperties(target,values,types){for(const key in values){const value=values[key];const type=types?types[key]:null;if(type){checkType(value,type,key)}Object.defineProperty(target,key,{enumerable:true,value:value,writable:false})}}function stringify(value){if(value==null){return"null"}if(Array.isArray(value)){return"[ "+value.map(stringify).join(", ")+" ]"}if(value instanceof Uint8Array){const HEX="0123456789abcdef";let result="0x";for(let i=0;i<value.length;i++){result+=HEX[value[i]>>4];result+=HEX[value[i]&15]}return result}if(typeof value==="object"&&typeof value.toJSON==="function"){return stringify(value.toJSON())}switch(typeof value){case"boolean":case"symbol":return value.toString();case"bigint":return BigInt(value).toString();case"number":return value.toString();case"string":return JSON.stringify(value);case"object":{const keys=Object.keys(value);keys.sort();return"{ "+keys.map(k=>`${stringify(k)}: ${stringify(value[k])}`).join(", ")+" }"}}return`[ COULD NOT SERIALIZE ]`}function isError(error,code){return error&&error.code===code}function isCallException(error){return isError(error,"CALL_EXCEPTION")}function makeError(message,code,info){const shortMessage=message;{const details=[];if(info){if("message"in info||"code"in info||"name"in info){throw new Error(`value will overwrite populated values: ${stringify(info)}`)}for(const key in info){if(key==="shortMessage"){continue}const value=info[key];details.push(key+"="+stringify(value))}}details.push(`code=${code}`);details.push(`version=${version}`);if(details.length){message+=" ("+details.join(", ")+")"}}let error;switch(code){case"INVALID_ARGUMENT":error=new TypeError(message);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":error=new RangeError(message);break;default:error=new Error(message)}defineProperties(error,{code:code});if(info){Object.assign(error,info)}if(error.shortMessage==null){defineProperties(error,{shortMessage:shortMessage})}return error}function assert$1(check,message,code,info){if(!check){throw makeError(message,code,info)}}function assertArgument(check,message,name,value){assert$1(check,message,"INVALID_ARGUMENT",{argument:name,value:value})}function assertArgumentCount(count,expectedCount,message){if(message==null){message=""}if(message){message=": "+message}assert$1(count>=expectedCount,"missing arguemnt"+message,"MISSING_ARGUMENT",{count:count,expectedCount:expectedCount});assert$1(count<=expectedCount,"too many arguemnts"+message,"UNEXPECTED_ARGUMENT",{count:count,expectedCount:expectedCount})}const _normalizeForms=["NFD","NFC","NFKD","NFKC"].reduce((accum,form)=>{try{if("test".normalize(form)!=="test"){throw new Error("bad")}if(form==="NFD"){const check=String.fromCharCode(233).normalize("NFD");const expected=String.fromCharCode(101,769);if(check!==expected){throw new Error("broken")}}accum.push(form)}catch(error){}return accum},[]);function assertNormalize(form){assert$1(_normalizeForms.indexOf(form)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:form}})}function assertPrivate(givenGuard,guard,className){if(className==null){className=""}if(givenGuard!==guard){let method=className,operation="new";if(className){method+=".";operation+=" "+className}assert$1(false,`private constructor; use ${method}from* methods`,"UNSUPPORTED_OPERATION",{operation:operation})}}function _getBytes(value,name,copy){if(value instanceof Uint8Array){if(copy){return new Uint8Array(value)}return value}if(typeof value==="string"&&value.match(/^0x([0-9a-f][0-9a-f])*$/i)){const result=new Uint8Array((value.length-2)/2);let offset=2;for(let i=0;i<result.length;i++){result[i]=parseInt(value.substring(offset,offset+2),16);offset+=2}return result}assertArgument(false,"invalid BytesLike value",name||"value",value)}function getBytes(value,name){return _getBytes(value,name,false)}function getBytesCopy(value,name){return _getBytes(value,name,true)}function isHexString(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(typeof length==="number"&&value.length!==2+2*length){return false}if(length===true&&value.length%2!==0){return false}return true}function isBytesLike(value){return isHexString(value,true)||value instanceof Uint8Array}const HexCharacters="0123456789abcdef";function hexlify(data){const bytes=getBytes(data);let result="0x";for(let i=0;i<bytes.length;i++){const v=bytes[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}function concat(datas){return"0x"+datas.map(d=>hexlify(d).substring(2)).join("")}function dataLength(data){if(isHexString(data,true)){return(data.length-2)/2}return getBytes(data).length}function dataSlice(data,start,end){const bytes=getBytes(data);if(end!=null&&end>bytes.length){assert$1(false,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:bytes,length:bytes.length,offset:end})}return hexlify(bytes.slice(start==null?0:start,end==null?bytes.length:end))}function stripZerosLeft(data){let bytes=hexlify(data).substring(2);while(bytes.startsWith("00")){bytes=bytes.substring(2)}return"0x"+bytes}function zeroPad(data,length,left){const bytes=getBytes(data);assert$1(length>=bytes.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(bytes),length:length,offset:length+1});const result=new Uint8Array(length);result.fill(0);if(left){result.set(bytes,length-bytes.length)}else{result.set(bytes,0)}return hexlify(result)}function zeroPadValue(data,length){return zeroPad(data,length,true)}function zeroPadBytes(data,length){return zeroPad(data,length,false)}class EventPayload{filter;emitter;#listener;constructor(emitter,listener,filter){this.#listener=listener;defineProperties(this,{emitter:emitter,filter:filter})}async removeListener(){if(this.#listener==null){return}await this.emitter.off(this.filter,this.#listener)}}function decodeBase64(textData){textData=atob(textData);const data=new Uint8Array(textData.length);for(let i=0;i<textData.length;i++){data[i]=textData.charCodeAt(i)}return getBytes(data)}function encodeBase64(_data){const data=getBytes(_data);let textData="";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}function encodeBytes32(text){const bytes=toUtf8Bytes(text);if(bytes.length>31){throw new Error("bytes32 string must be less than 32 bytes")}return zeroPadBytes(bytes,32)}function decodeBytes32(_bytes){const data=getBytes(_bytes,"bytes");if(data.length!==32){throw new Error("invalid bytes32 - not 32 bytes long")}if(data[31]!==0){throw new Error("invalid bytes32 string - no null terminator")}let length=31;while(data[length-1]===0){length--}return toUtf8String(data.slice(0,length))}const BN_0$8=BigInt(0);const BN_1$4=BigInt(1);const maxValue=9007199254740991;function fromTwos(_value,_width){const value=getUint(_value,"value");const width=BigInt(getNumber(_width,"width"));assert$1(value>>width===BN_0$8,"overflow","NUMERIC_FAULT",{operation:"fromTwos",fault:"overflow",value:_value});if(value>>width-BN_1$4){const mask=(BN_1$4<<width)-BN_1$4;return-((~value&mask)+BN_1$4)}return value}function toTwos(_value,_width){let value=getBigInt(_value,"value");const width=BigInt(getNumber(_width,"width"));const limit=BN_1$4<<width-BN_1$4;if(value<BN_0$8){value=-value;assert$1(value<=limit,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value});const mask=(BN_1$4<<width)-BN_1$4;return(~value&mask)+BN_1$4}else{assert$1(value<limit,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value})}return value}function mask(_value,_bits){const value=getUint(_value,"value");const bits=BigInt(getNumber(_bits,"bits"));return value&(BN_1$4<<bits)-BN_1$4}function getBigInt(value,name){switch(typeof value){case"bigint":return value;case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return BigInt(value);case"string":try{if(value===""){throw new Error("empty string")}if(value[0]==="-"&&value[1]!=="-"){return-BigInt(value.substring(1))}return BigInt(value)}catch(e){assertArgument(false,`invalid BigNumberish string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid BigNumberish value",name||"value",value)}function getUint(value,name){const result=getBigInt(value,name);assert$1(result>=BN_0$8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:value});return result}const Nibbles$1="0123456789abcdef";function toBigInt(value){if(value instanceof Uint8Array){let result="0x0";for(const v of value){result+=Nibbles$1[v>>4];result+=Nibbles$1[v&15]}return BigInt(result)}return getBigInt(value)}function getNumber(value,name){switch(typeof value){case"bigint":assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return Number(value);case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return value;case"string":try{if(value===""){throw new Error("empty string")}return getNumber(BigInt(value),name)}catch(e){assertArgument(false,`invalid numeric string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid numeric value",name||"value",value)}function toNumber(value){return getNumber(toBigInt(value))}function toBeHex(_value,_width){const value=getUint(_value,"value");let result=value.toString(16);if(_width==null){if(result.length%2){result="0"+result}}else{const width=getNumber(_width,"width");assert$1(width*2>=result.length,`value exceeds width (${width} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:_value});while(result.length<width*2){result="0"+result}}return"0x"+result}function toBeArray(_value){const value=getUint(_value,"value");if(value===BN_0$8){return new Uint8Array([])}let hex=value.toString(16);if(hex.length%2){hex="0"+hex}const result=new Uint8Array(hex.length/2);for(let i=0;i<result.length;i++){const offset=i*2;result[i]=parseInt(hex.substring(offset,offset+2),16)}return result}function toQuantity(value){let result=hexlify(isBytesLike(value)?value:toBeArray(value)).substring(2);while(result.startsWith("0")){result=result.substring(1)}if(result===""){result="0"}return"0x"+result}const Alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";let Lookup=null;function getAlpha(letter){if(Lookup==null){Lookup={};for(let i=0;i<Alphabet.length;i++){Lookup[Alphabet[i]]=BigInt(i)}}const result=Lookup[letter];assertArgument(result!=null,`invalid base58 value`,"letter",letter);return result}const BN_0$7=BigInt(0);const BN_58=BigInt(58);function encodeBase58(_value){const bytes=getBytes(_value);let value=toBigInt(bytes);let result="";while(value){result=Alphabet[Number(value%BN_58)]+result;value/=BN_58}for(let i=0;i<bytes.length;i++){if(bytes[i]){break}result=Alphabet[0]+result}return result}function decodeBase58(value){let result=BN_0$7;for(let i=0;i<value.length;i++){result*=BN_58;result+=getAlpha(value[i])}return result}var common;(function(common){class ProtoLocation extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("value"in data&&data.value!=undefined){this.value=data.value}}}get value(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set value(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoLocation({});if(data.value!=null){message.value=data.value}return message}toObject(){const data={};if(this.value!=null){data.value=this.value}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.value.length)writer.writeBytes(1,this.value);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoLocation;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.value=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoLocation.deserialize(bytes)}}common.ProtoLocation=ProtoLocation;class ProtoHash extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("value"in data&&data.value!=undefined){this.value=data.value}}}get value(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set value(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoHash({});if(data.value!=null){message.value=data.value}return message}toObject(){const data={};if(this.value!=null){data.value=this.value}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.value.length)writer.writeBytes(1,this.value);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoHash;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.value=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoHash.deserialize(bytes)}}common.ProtoHash=ProtoHash;class ProtoHashes extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("hashes"in data&&data.hashes!=undefined){this.hashes=data.hashes}}}get hashes(){return pb_1.Message.getRepeatedWrapperField(this,ProtoHash,1)}set hashes(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoHashes({});if(data.hashes!=null){message.hashes=data.hashes.map(item=>ProtoHash.fromObject(item))}return message}toObject(){const data={};if(this.hashes!=null){data.hashes=this.hashes.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.hashes.length)writer.writeRepeatedMessage(1,this.hashes,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoHashes;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.hashes,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoHash.deserialize(reader),ProtoHash));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoHashes.deserialize(bytes)}}common.ProtoHashes=ProtoHashes;class ProtoAddress extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("value"in data&&data.value!=undefined){this.value=data.value}}}get value(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set value(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoAddress({});if(data.value!=null){message.value=data.value}return message}toObject(){const data={};if(this.value!=null){data.value=this.value}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.value.length)writer.writeBytes(1,this.value);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoAddress;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.value=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoAddress.deserialize(bytes)}}common.ProtoAddress=ProtoAddress;class ProtoNumber extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("value"in data&&data.value!=undefined){this.value=data.value}}}get value(){return pb_1.Message.getFieldWithDefault(this,1,0)}set value(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoNumber({});if(data.value!=null){message.value=data.value}return message}toObject(){const data={};if(this.value!=null){data.value=this.value}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.value!=0)writer.writeUint64(1,this.value);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoNumber;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.value=reader.readUint64();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoNumber.deserialize(bytes)}}common.ProtoNumber=ProtoNumber;class ProtoLocations extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("locations"in data&&data.locations!=undefined){this.locations=data.locations}}}get locations(){return pb_1.Message.getRepeatedWrapperField(this,ProtoLocation,1)}set locations(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoLocations({});if(data.locations!=null){message.locations=data.locations.map(item=>ProtoLocation.fromObject(item))}return message}toObject(){const data={};if(this.locations!=null){data.locations=this.locations.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.locations.length)writer.writeRepeatedMessage(1,this.locations,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoLocations;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.locations,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoLocation.deserialize(reader),ProtoLocation));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoLocations.deserialize(bytes)}}common.ProtoLocations=ProtoLocations})(common||(common={}));var block;(function(block){class ProtoHeader extends pb_1.Message{#one_of_decls=[[2],[3],[4],[5],[6],[8],[9],[13],[15],[16],[17],[18],[19],[20],[21],[22],[23],[24],[25],[26],[27],[28],[29],[30],[31],[32],[33],[34],[35],[36]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1,7,10,11,12,14],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("parent_hash"in data&&data.parent_hash!=undefined){this.parent_hash=data.parent_hash}if("uncle_hash"in data&&data.uncle_hash!=undefined){this.uncle_hash=data.uncle_hash}if("evm_root"in data&&data.evm_root!=undefined){this.evm_root=data.evm_root}if("tx_hash"in data&&data.tx_hash!=undefined){this.tx_hash=data.tx_hash}if("outbound_etx_hash"in data&&data.outbound_etx_hash!=undefined){this.outbound_etx_hash=data.outbound_etx_hash}if("etx_rollup_hash"in data&&data.etx_rollup_hash!=undefined){this.etx_rollup_hash=data.etx_rollup_hash}if("manifest_hash"in data&&data.manifest_hash!=undefined){this.manifest_hash=data.manifest_hash}if("receipt_hash"in data&&data.receipt_hash!=undefined){this.receipt_hash=data.receipt_hash}if("difficulty"in data&&data.difficulty!=undefined){this.difficulty=data.difficulty}if("parent_entropy"in data&&data.parent_entropy!=undefined){this.parent_entropy=data.parent_entropy}if("parent_delta_entropy"in data&&data.parent_delta_entropy!=undefined){this.parent_delta_entropy=data.parent_delta_entropy}if("parent_uncled_delta_entropy"in data&&data.parent_uncled_delta_entropy!=undefined){this.parent_uncled_delta_entropy=data.parent_uncled_delta_entropy}if("uncled_entropy"in data&&data.uncled_entropy!=undefined){this.uncled_entropy=data.uncled_entropy}if("number"in data&&data.number!=undefined){this.number=data.number}if("gas_limit"in data&&data.gas_limit!=undefined){this.gas_limit=data.gas_limit}if("gas_used"in data&&data.gas_used!=undefined){this.gas_used=data.gas_used}if("base_fee"in data&&data.base_fee!=undefined){this.base_fee=data.base_fee}if("location"in data&&data.location!=undefined){this.location=data.location}if("extra"in data&&data.extra!=undefined){this.extra=data.extra}if("mix_hash"in data&&data.mix_hash!=undefined){this.mix_hash=data.mix_hash}if("nonce"in data&&data.nonce!=undefined){this.nonce=data.nonce}if("utxo_root"in data&&data.utxo_root!=undefined){this.utxo_root=data.utxo_root}if("etx_set_root"in data&&data.etx_set_root!=undefined){this.etx_set_root=data.etx_set_root}if("efficiency_score"in data&&data.efficiency_score!=undefined){this.efficiency_score=data.efficiency_score}if("threshold_count"in data&&data.threshold_count!=undefined){this.threshold_count=data.threshold_count}if("expansion_number"in data&&data.expansion_number!=undefined){this.expansion_number=data.expansion_number}if("etx_eligible_slices"in data&&data.etx_eligible_slices!=undefined){this.etx_eligible_slices=data.etx_eligible_slices}if("prime_terminus_hash"in data&&data.prime_terminus_hash!=undefined){this.prime_terminus_hash=data.prime_terminus_hash}if("interlink_root_hash"in data&&data.interlink_root_hash!=undefined){this.interlink_root_hash=data.interlink_root_hash}if("state_limit"in data&&data.state_limit!=undefined){this.state_limit=data.state_limit}if("state_used"in data&&data.state_used!=undefined){this.state_used=data.state_used}if("quai_state_size"in data&&data.quai_state_size!=undefined){this.quai_state_size=data.quai_state_size}if("secondary_coinbase"in data&&data.secondary_coinbase!=undefined){this.secondary_coinbase=data.secondary_coinbase}if("exchange_rate"in data&&data.exchange_rate!=undefined){this.exchange_rate=data.exchange_rate}if("quai_to_qi"in data&&data.quai_to_qi!=undefined){this.quai_to_qi=data.quai_to_qi}if("qi_to_quai"in data&&data.qi_to_quai!=undefined){this.qi_to_quai=data.qi_to_quai}}}get parent_hash(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,1)}set parent_hash(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}get uncle_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,2)}set uncle_hash(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[0],value)}get has_uncle_hash(){return pb_1.Message.getField(this,2)!=null}get evm_root(){return pb_1.Message.getWrapperField(this,common.ProtoHash,3)}set evm_root(value){pb_1.Message.setOneofWrapperField(this,3,this.#one_of_decls[1],value)}get has_evm_root(){return pb_1.Message.getField(this,3)!=null}get tx_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,4)}set tx_hash(value){pb_1.Message.setOneofWrapperField(this,4,this.#one_of_decls[2],value)}get has_tx_hash(){return pb_1.Message.getField(this,4)!=null}get outbound_etx_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,5)}set outbound_etx_hash(value){pb_1.Message.setOneofWrapperField(this,5,this.#one_of_decls[3],value)}get has_outbound_etx_hash(){return pb_1.Message.getField(this,5)!=null}get etx_rollup_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,6)}set etx_rollup_hash(value){pb_1.Message.setOneofWrapperField(this,6,this.#one_of_decls[4],value)}get has_etx_rollup_hash(){return pb_1.Message.getField(this,6)!=null}get manifest_hash(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,7)}set manifest_hash(value){pb_1.Message.setRepeatedWrapperField(this,7,value)}get receipt_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,8)}set receipt_hash(value){pb_1.Message.setOneofWrapperField(this,8,this.#one_of_decls[5],value)}get has_receipt_hash(){return pb_1.Message.getField(this,8)!=null}get difficulty(){return pb_1.Message.getFieldWithDefault(this,9,new Uint8Array(0))}set difficulty(value){pb_1.Message.setOneofField(this,9,this.#one_of_decls[6],value)}get has_difficulty(){return pb_1.Message.getField(this,9)!=null}get parent_entropy(){return pb_1.Message.getFieldWithDefault(this,10,[])}set parent_entropy(value){pb_1.Message.setField(this,10,value)}get parent_delta_entropy(){return pb_1.Message.getFieldWithDefault(this,11,[])}set parent_delta_entropy(value){pb_1.Message.setField(this,11,value)}get parent_uncled_delta_entropy(){return pb_1.Message.getFieldWithDefault(this,12,[])}set parent_uncled_delta_entropy(value){pb_1.Message.setField(this,12,value)}get uncled_entropy(){return pb_1.Message.getFieldWithDefault(this,13,new Uint8Array(0))}set uncled_entropy(value){pb_1.Message.setOneofField(this,13,this.#one_of_decls[7],value)}get has_uncled_entropy(){return pb_1.Message.getField(this,13)!=null}get number(){return pb_1.Message.getFieldWithDefault(this,14,[])}set number(value){pb_1.Message.setField(this,14,value)}get gas_limit(){return pb_1.Message.getFieldWithDefault(this,15,0)}set gas_limit(value){pb_1.Message.setOneofField(this,15,this.#one_of_decls[8],value)}get has_gas_limit(){return pb_1.Message.getField(this,15)!=null}get gas_used(){return pb_1.Message.getFieldWithDefault(this,16,0)}set gas_used(value){pb_1.Message.setOneofField(this,16,this.#one_of_decls[9],value)}get has_gas_used(){return pb_1.Message.getField(this,16)!=null}get base_fee(){return pb_1.Message.getFieldWithDefault(this,17,new Uint8Array(0))}set base_fee(value){pb_1.Message.setOneofField(this,17,this.#one_of_decls[10],value)}get has_base_fee(){return pb_1.Message.getField(this,17)!=null}get location(){return pb_1.Message.getWrapperField(this,common.ProtoLocation,18)}set location(value){pb_1.Message.setOneofWrapperField(this,18,this.#one_of_decls[11],value)}get has_location(){return pb_1.Message.getField(this,18)!=null}get extra(){return pb_1.Message.getFieldWithDefault(this,19,new Uint8Array(0))}set extra(value){pb_1.Message.setOneofField(this,19,this.#one_of_decls[12],value)}get has_extra(){return pb_1.Message.getField(this,19)!=null}get mix_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,20)}set mix_hash(value){pb_1.Message.setOneofWrapperField(this,20,this.#one_of_decls[13],value)}get has_mix_hash(){return pb_1.Message.getField(this,20)!=null}get nonce(){return pb_1.Message.getFieldWithDefault(this,21,0)}set nonce(value){pb_1.Message.setOneofField(this,21,this.#one_of_decls[14],value)}get has_nonce(){return pb_1.Message.getField(this,21)!=null}get utxo_root(){return pb_1.Message.getWrapperField(this,common.ProtoHash,22)}set utxo_root(value){pb_1.Message.setOneofWrapperField(this,22,this.#one_of_decls[15],value)}get has_utxo_root(){return pb_1.Message.getField(this,22)!=null}get etx_set_root(){return pb_1.Message.getWrapperField(this,common.ProtoHash,23)}set etx_set_root(value){pb_1.Message.setOneofWrapperField(this,23,this.#one_of_decls[16],value)}get has_etx_set_root(){return pb_1.Message.getField(this,23)!=null}get efficiency_score(){return pb_1.Message.getFieldWithDefault(this,24,0)}set efficiency_score(value){pb_1.Message.setOneofField(this,24,this.#one_of_decls[17],value)}get has_efficiency_score(){return pb_1.Message.getField(this,24)!=null}get threshold_count(){return pb_1.Message.getFieldWithDefault(this,25,0)}set threshold_count(value){pb_1.Message.setOneofField(this,25,this.#one_of_decls[18],value)}get has_threshold_count(){return pb_1.Message.getField(this,25)!=null}get expansion_number(){return pb_1.Message.getFieldWithDefault(this,26,0)}set expansion_number(value){pb_1.Message.setOneofField(this,26,this.#one_of_decls[19],value)}get has_expansion_number(){return pb_1.Message.getField(this,26)!=null}get etx_eligible_slices(){return pb_1.Message.getWrapperField(this,common.ProtoHash,27)}set etx_eligible_slices(value){pb_1.Message.setOneofWrapperField(this,27,this.#one_of_decls[20],value)}get has_etx_eligible_slices(){return pb_1.Message.getField(this,27)!=null}get prime_terminus_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,28)}set prime_terminus_hash(value){pb_1.Message.setOneofWrapperField(this,28,this.#one_of_decls[21],value)}get has_prime_terminus_hash(){return pb_1.Message.getField(this,28)!=null}get interlink_root_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,29)}set interlink_root_hash(value){pb_1.Message.setOneofWrapperField(this,29,this.#one_of_decls[22],value)}get has_interlink_root_hash(){return pb_1.Message.getField(this,29)!=null}get state_limit(){return pb_1.Message.getFieldWithDefault(this,30,0)}set state_limit(value){pb_1.Message.setOneofField(this,30,this.#one_of_decls[23],value)}get has_state_limit(){return pb_1.Message.getField(this,30)!=null}get state_used(){return pb_1.Message.getFieldWithDefault(this,31,0)}set state_used(value){pb_1.Message.setOneofField(this,31,this.#one_of_decls[24],value)}get has_state_used(){return pb_1.Message.getField(this,31)!=null}get quai_state_size(){return pb_1.Message.getFieldWithDefault(this,32,new Uint8Array(0))}set quai_state_size(value){pb_1.Message.setOneofField(this,32,this.#one_of_decls[25],value)}get has_quai_state_size(){return pb_1.Message.getField(this,32)!=null}get secondary_coinbase(){return pb_1.Message.getFieldWithDefault(this,33,new Uint8Array(0))}set secondary_coinbase(value){pb_1.Message.setOneofField(this,33,this.#one_of_decls[26],value)}get has_secondary_coinbase(){return pb_1.Message.getField(this,33)!=null}get exchange_rate(){return pb_1.Message.getFieldWithDefault(this,34,new Uint8Array(0))}set exchange_rate(value){pb_1.Message.setOneofField(this,34,this.#one_of_decls[27],value)}get has_exchange_rate(){return pb_1.Message.getField(this,34)!=null}get quai_to_qi(){return pb_1.Message.getFieldWithDefault(this,35,new Uint8Array(0))}set quai_to_qi(value){pb_1.Message.setOneofField(this,35,this.#one_of_decls[28],value)}get has_quai_to_qi(){return pb_1.Message.getField(this,35)!=null}get qi_to_quai(){return pb_1.Message.getFieldWithDefault(this,36,new Uint8Array(0))}set qi_to_quai(value){pb_1.Message.setOneofField(this,36,this.#one_of_decls[29],value)}get has_qi_to_quai(){return pb_1.Message.getField(this,36)!=null}get _uncle_hash(){const cases={0:"none",2:"uncle_hash"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _evm_root(){const cases={0:"none",3:"evm_root"};return cases[pb_1.Message.computeOneofCase(this,[3])]}get _tx_hash(){const cases={0:"none",4:"tx_hash"};return cases[pb_1.Message.computeOneofCase(this,[4])]}get _outbound_etx_hash(){const cases={0:"none",5:"outbound_etx_hash"};return cases[pb_1.Message.computeOneofCase(this,[5])]}get _etx_rollup_hash(){const cases={0:"none",6:"etx_rollup_hash"};return cases[pb_1.Message.computeOneofCase(this,[6])]}get _receipt_hash(){const cases={0:"none",8:"receipt_hash"};return cases[pb_1.Message.computeOneofCase(this,[8])]}get _difficulty(){const cases={0:"none",9:"difficulty"};return cases[pb_1.Message.computeOneofCase(this,[9])]}get _uncled_entropy(){const cases={0:"none",13:"uncled_entropy"};return cases[pb_1.Message.computeOneofCase(this,[13])]}get _gas_limit(){const cases={0:"none",15:"gas_limit"};return cases[pb_1.Message.computeOneofCase(this,[15])]}get _gas_used(){const cases={0:"none",16:"gas_used"};return cases[pb_1.Message.computeOneofCase(this,[16])]}get _base_fee(){const cases={0:"none",17:"base_fee"};return cases[pb_1.Message.computeOneofCase(this,[17])]}get _location(){const cases={0:"none",18:"location"};return cases[pb_1.Message.computeOneofCase(this,[18])]}get _extra(){const cases={0:"none",19:"extra"};return cases[pb_1.Message.computeOneofCase(this,[19])]}get _mix_hash(){const cases={0:"none",20:"mix_hash"};return cases[pb_1.Message.computeOneofCase(this,[20])]}get _nonce(){const cases={0:"none",21:"nonce"};return cases[pb_1.Message.computeOneofCase(this,[21])]}get _utxo_root(){const cases={0:"none",22:"utxo_root"};return cases[pb_1.Message.computeOneofCase(this,[22])]}get _etx_set_root(){const cases={0:"none",23:"etx_set_root"};return cases[pb_1.Message.computeOneofCase(this,[23])]}get _efficiency_score(){const cases={0:"none",24:"efficiency_score"};return cases[pb_1.Message.computeOneofCase(this,[24])]}get _threshold_count(){const cases={0:"none",25:"threshold_count"};return cases[pb_1.Message.computeOneofCase(this,[25])]}get _expansion_number(){const cases={0:"none",26:"expansion_number"};return cases[pb_1.Message.computeOneofCase(this,[26])]}get _etx_eligible_slices(){const cases={0:"none",27:"etx_eligible_slices"};return cases[pb_1.Message.computeOneofCase(this,[27])]}get _prime_terminus_hash(){const cases={0:"none",28:"prime_terminus_hash"};return cases[pb_1.Message.computeOneofCase(this,[28])]}get _interlink_root_hash(){const cases={0:"none",29:"interlink_root_hash"};return cases[pb_1.Message.computeOneofCase(this,[29])]}get _state_limit(){const cases={0:"none",30:"state_limit"};return cases[pb_1.Message.computeOneofCase(this,[30])]}get _state_used(){const cases={0:"none",31:"state_used"};return cases[pb_1.Message.computeOneofCase(this,[31])]}get _quai_state_size(){const cases={0:"none",32:"quai_state_size"};return cases[pb_1.Message.computeOneofCase(this,[32])]}get _secondary_coinbase(){const cases={0:"none",33:"secondary_coinbase"};return cases[pb_1.Message.computeOneofCase(this,[33])]}get _exchange_rate(){const cases={0:"none",34:"exchange_rate"};return cases[pb_1.Message.computeOneofCase(this,[34])]}get _quai_to_qi(){const cases={0:"none",35:"quai_to_qi"};return cases[pb_1.Message.computeOneofCase(this,[35])]}get _qi_to_quai(){const cases={0:"none",36:"qi_to_quai"};return cases[pb_1.Message.computeOneofCase(this,[36])]}static fromObject(data){const message=new ProtoHeader({});if(data.parent_hash!=null){message.parent_hash=data.parent_hash.map(item=>common.ProtoHash.fromObject(item))}if(data.uncle_hash!=null){message.uncle_hash=common.ProtoHash.fromObject(data.uncle_hash)}if(data.evm_root!=null){message.evm_root=common.ProtoHash.fromObject(data.evm_root)}if(data.tx_hash!=null){message.tx_hash=common.ProtoHash.fromObject(data.tx_hash)}if(data.outbound_etx_hash!=null){message.outbound_etx_hash=common.ProtoHash.fromObject(data.outbound_etx_hash)}if(data.etx_rollup_hash!=null){message.etx_rollup_hash=common.ProtoHash.fromObject(data.etx_rollup_hash)}if(data.manifest_hash!=null){message.manifest_hash=data.manifest_hash.map(item=>common.ProtoHash.fromObject(item))}if(data.receipt_hash!=null){message.receipt_hash=common.ProtoHash.fromObject(data.receipt_hash)}if(data.difficulty!=null){message.difficulty=data.difficulty}if(data.parent_entropy!=null){message.parent_entropy=data.parent_entropy}if(data.parent_delta_entropy!=null){message.parent_delta_entropy=data.parent_delta_entropy}if(data.parent_uncled_delta_entropy!=null){message.parent_uncled_delta_entropy=data.parent_uncled_delta_entropy}if(data.uncled_entropy!=null){message.uncled_entropy=data.uncled_entropy}if(data.number!=null){message.number=data.number}if(data.gas_limit!=null){message.gas_limit=data.gas_limit}if(data.gas_used!=null){message.gas_used=data.gas_used}if(data.base_fee!=null){message.base_fee=data.base_fee}if(data.location!=null){message.location=common.ProtoLocation.fromObject(data.location)}if(data.extra!=null){message.extra=data.extra}if(data.mix_hash!=null){message.mix_hash=common.ProtoHash.fromObject(data.mix_hash)}if(data.nonce!=null){message.nonce=data.nonce}if(data.utxo_root!=null){message.utxo_root=common.ProtoHash.fromObject(data.utxo_root)}if(data.etx_set_root!=null){message.etx_set_root=common.ProtoHash.fromObject(data.etx_set_root)}if(data.efficiency_score!=null){message.efficiency_score=data.efficiency_score}if(data.threshold_count!=null){message.threshold_count=data.threshold_count}if(data.expansion_number!=null){message.expansion_number=data.expansion_number}if(data.etx_eligible_slices!=null){message.etx_eligible_slices=common.ProtoHash.fromObject(data.etx_eligible_slices)}if(data.prime_terminus_hash!=null){message.prime_terminus_hash=common.ProtoHash.fromObject(data.prime_terminus_hash)}if(data.interlink_root_hash!=null){message.interlink_root_hash=common.ProtoHash.fromObject(data.interlink_root_hash)}if(data.state_limit!=null){message.state_limit=data.state_limit}if(data.state_used!=null){message.state_used=data.state_used}if(data.quai_state_size!=null){message.quai_state_size=data.quai_state_size}if(data.secondary_coinbase!=null){message.secondary_coinbase=data.secondary_coinbase}if(data.exchange_rate!=null){message.exchange_rate=data.exchange_rate}if(data.quai_to_qi!=null){message.quai_to_qi=data.quai_to_qi}if(data.qi_to_quai!=null){message.qi_to_quai=data.qi_to_quai}return message}toObject(){const data={};if(this.parent_hash!=null){data.parent_hash=this.parent_hash.map(item=>item.toObject())}if(this.uncle_hash!=null){data.uncle_hash=this.uncle_hash.toObject()}if(this.evm_root!=null){data.evm_root=this.evm_root.toObject()}if(this.tx_hash!=null){data.tx_hash=this.tx_hash.toObject()}if(this.outbound_etx_hash!=null){data.outbound_etx_hash=this.outbound_etx_hash.toObject()}if(this.etx_rollup_hash!=null){data.etx_rollup_hash=this.etx_rollup_hash.toObject()}if(this.manifest_hash!=null){data.manifest_hash=this.manifest_hash.map(item=>item.toObject())}if(this.receipt_hash!=null){data.receipt_hash=this.receipt_hash.toObject()}if(this.difficulty!=null){data.difficulty=this.difficulty}if(this.parent_entropy!=null){data.parent_entropy=this.parent_entropy}if(this.parent_delta_entropy!=null){data.parent_delta_entropy=this.parent_delta_entropy}if(this.parent_uncled_delta_entropy!=null){data.parent_uncled_delta_entropy=this.parent_uncled_delta_entropy}if(this.uncled_entropy!=null){data.uncled_entropy=this.uncled_entropy}if(this.number!=null){data.number=this.number}if(this.gas_limit!=null){data.gas_limit=this.gas_limit}if(this.gas_used!=null){data.gas_used=this.gas_used}if(this.base_fee!=null){data.base_fee=this.base_fee}if(this.location!=null){data.location=this.location.toObject()}if(this.extra!=null){data.extra=this.extra}if(this.mix_hash!=null){data.mix_hash=this.mix_hash.toObject()}if(this.nonce!=null){data.nonce=this.nonce}if(this.utxo_root!=null){data.utxo_root=this.utxo_root.toObject()}if(this.etx_set_root!=null){data.etx_set_root=this.etx_set_root.toObject()}if(this.efficiency_score!=null){data.efficiency_score=this.efficiency_score}if(this.threshold_count!=null){data.threshold_count=this.threshold_count}if(this.expansion_number!=null){data.expansion_number=this.expansion_number}if(this.etx_eligible_slices!=null){data.etx_eligible_slices=this.etx_eligible_slices.toObject()}if(this.prime_terminus_hash!=null){data.prime_terminus_hash=this.prime_terminus_hash.toObject()}if(this.interlink_root_hash!=null){data.interlink_root_hash=this.interlink_root_hash.toObject()}if(this.state_limit!=null){data.state_limit=this.state_limit}if(this.state_used!=null){data.state_used=this.state_used}if(this.quai_state_size!=null){data.quai_state_size=this.quai_state_size}if(this.secondary_coinbase!=null){data.secondary_coinbase=this.secondary_coinbase}if(this.exchange_rate!=null){data.exchange_rate=this.exchange_rate}if(this.quai_to_qi!=null){data.quai_to_qi=this.quai_to_qi}if(this.qi_to_quai!=null){data.qi_to_quai=this.qi_to_quai}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.parent_hash.length)writer.writeRepeatedMessage(1,this.parent_hash,item=>item.serialize(writer));if(this.has_uncle_hash)writer.writeMessage(2,this.uncle_hash,()=>this.uncle_hash.serialize(writer));if(this.has_evm_root)writer.writeMessage(3,this.evm_root,()=>this.evm_root.serialize(writer));if(this.has_tx_hash)writer.writeMessage(4,this.tx_hash,()=>this.tx_hash.serialize(writer));if(this.has_outbound_etx_hash)writer.writeMessage(5,this.outbound_etx_hash,()=>this.outbound_etx_hash.serialize(writer));if(this.has_etx_rollup_hash)writer.writeMessage(6,this.etx_rollup_hash,()=>this.etx_rollup_hash.serialize(writer));if(this.manifest_hash.length)writer.writeRepeatedMessage(7,this.manifest_hash,item=>item.serialize(writer));if(this.has_receipt_hash)writer.writeMessage(8,this.receipt_hash,()=>this.receipt_hash.serialize(writer));if(this.has_difficulty)writer.writeBytes(9,this.difficulty);if(this.parent_entropy.length)writer.writeRepeatedBytes(10,this.parent_entropy);if(this.parent_delta_entropy.length)writer.writeRepeatedBytes(11,this.parent_delta_entropy);if(this.parent_uncled_delta_entropy.length)writer.writeRepeatedBytes(12,this.parent_uncled_delta_entropy);if(this.has_uncled_entropy)writer.writeBytes(13,this.uncled_entropy);if(this.number.length)writer.writeRepeatedBytes(14,this.number);if(this.has_gas_limit)writer.writeUint64(15,this.gas_limit);if(this.has_gas_used)writer.writeUint64(16,this.gas_used);if(this.has_base_fee)writer.writeBytes(17,this.base_fee);if(this.has_location)writer.writeMessage(18,this.location,()=>this.location.serialize(writer));if(this.has_extra)writer.writeBytes(19,this.extra);if(this.has_mix_hash)writer.writeMessage(20,this.mix_hash,()=>this.mix_hash.serialize(writer));if(this.has_nonce)writer.writeUint64(21,this.nonce);if(this.has_utxo_root)writer.writeMessage(22,this.utxo_root,()=>this.utxo_root.serialize(writer));if(this.has_etx_set_root)writer.writeMessage(23,this.etx_set_root,()=>this.etx_set_root.serialize(writer));if(this.has_efficiency_score)writer.writeUint64(24,this.efficiency_score);if(this.has_threshold_count)writer.writeUint64(25,this.threshold_count);if(this.has_expansion_number)writer.writeUint64(26,this.expansion_number);if(this.has_etx_eligible_slices)writer.writeMessage(27,this.etx_eligible_slices,()=>this.etx_eligible_slices.serialize(writer));if(this.has_prime_terminus_hash)writer.writeMessage(28,this.prime_terminus_hash,()=>this.prime_terminus_hash.serialize(writer));if(this.has_interlink_root_hash)writer.writeMessage(29,this.interlink_root_hash,()=>this.interlink_root_hash.serialize(writer));if(this.has_state_limit)writer.writeUint64(30,this.state_limit);if(this.has_state_used)writer.writeUint64(31,this.state_used);if(this.has_quai_state_size)writer.writeBytes(32,this.quai_state_size);if(this.has_secondary_coinbase)writer.writeBytes(33,this.secondary_coinbase);if(this.has_exchange_rate)writer.writeBytes(34,this.exchange_rate);if(this.has_quai_to_qi)writer.writeBytes(35,this.quai_to_qi);if(this.has_qi_to_quai)writer.writeBytes(36,this.qi_to_quai);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoHeader;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.parent_hash,()=>pb_1.Message.addToRepeatedWrapperField(message,1,common.ProtoHash.deserialize(reader),common.ProtoHash));break;case 2:reader.readMessage(message.uncle_hash,()=>message.uncle_hash=common.ProtoHash.deserialize(reader));break;case 3:reader.readMessage(message.evm_root,()=>message.evm_root=common.ProtoHash.deserialize(reader));break;case 4:reader.readMessage(message.tx_hash,()=>message.tx_hash=common.ProtoHash.deserialize(reader));break;case 5:reader.readMessage(message.outbound_etx_hash,()=>message.outbound_etx_hash=common.ProtoHash.deserialize(reader));break;case 6:reader.readMessage(message.etx_rollup_hash,()=>message.etx_rollup_hash=common.ProtoHash.deserialize(reader));break;case 7:reader.readMessage(message.manifest_hash,()=>pb_1.Message.addToRepeatedWrapperField(message,7,common.ProtoHash.deserialize(reader),common.ProtoHash));break;case 8:reader.readMessage(message.receipt_hash,()=>message.receipt_hash=common.ProtoHash.deserialize(reader));break;case 9:message.difficulty=reader.readBytes();break;case 10:pb_1.Message.addToRepeatedField(message,10,reader.readBytes());break;case 11:pb_1.Message.addToRepeatedField(message,11,reader.readBytes());break;case 12:pb_1.Message.addToRepeatedField(message,12,reader.readBytes());break;case 13:message.uncled_entropy=reader.readBytes();break;case 14:pb_1.Message.addToRepeatedField(message,14,reader.readBytes());break;case 15:message.gas_limit=reader.readUint64();break;case 16:message.gas_used=reader.readUint64();break;case 17:message.base_fee=reader.readBytes();break;case 18:reader.readMessage(message.location,()=>message.location=common.ProtoLocation.deserialize(reader));break;case 19:message.extra=reader.readBytes();break;case 20:reader.readMessage(message.mix_hash,()=>message.mix_hash=common.ProtoHash.deserialize(reader));break;case 21:message.nonce=reader.readUint64();break;case 22:reader.readMessage(message.utxo_root,()=>message.utxo_root=common.ProtoHash.deserialize(reader));break;case 23:reader.readMessage(message.etx_set_root,()=>message.etx_set_root=common.ProtoHash.deserialize(reader));break;case 24:message.efficiency_score=reader.readUint64();break;case 25:message.threshold_count=reader.readUint64();break;case 26:message.expansion_number=reader.readUint64();break;case 27:reader.readMessage(message.etx_eligible_slices,()=>message.etx_eligible_slices=common.ProtoHash.deserialize(reader));break;case 28:reader.readMessage(message.prime_terminus_hash,()=>message.prime_terminus_hash=common.ProtoHash.deserialize(reader));break;case 29:reader.readMessage(message.interlink_root_hash,()=>message.interlink_root_hash=common.ProtoHash.deserialize(reader));break;case 30:message.state_limit=reader.readUint64();break;case 31:message.state_used=reader.readUint64();break;case 32:message.quai_state_size=reader.readBytes();break;case 33:message.secondary_coinbase=reader.readBytes();break;case 34:message.exchange_rate=reader.readBytes();break;case 35:message.quai_to_qi=reader.readBytes();break;case 36:message.qi_to_quai=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoHeader.deserialize(bytes)}}block.ProtoHeader=ProtoHeader;class ProtoTransaction extends pb_1.Message{#one_of_decls=[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("type"in data&&data.type!=undefined){this.type=data.type}if("to"in data&&data.to!=undefined){this.to=data.to}if("nonce"in data&&data.nonce!=undefined){this.nonce=data.nonce}if("value"in data&&data.value!=undefined){this.value=data.value}if("gas"in data&&data.gas!=undefined){this.gas=data.gas}if("data"in data&&data.data!=undefined){this.data=data.data}if("chain_id"in data&&data.chain_id!=undefined){this.chain_id=data.chain_id}if("miner_tip"in data&&data.miner_tip!=undefined){this.miner_tip=data.miner_tip}if("gas_price"in data&&data.gas_price!=undefined){this.gas_price=data.gas_price}if("access_list"in data&&data.access_list!=undefined){this.access_list=data.access_list}if("v"in data&&data.v!=undefined){this.v=data.v}if("r"in data&&data.r!=undefined){this.r=data.r}if("s"in data&&data.s!=undefined){this.s=data.s}if("originating_tx_hash"in data&&data.originating_tx_hash!=undefined){this.originating_tx_hash=data.originating_tx_hash}if("etx_index"in data&&data.etx_index!=undefined){this.etx_index=data.etx_index}if("tx_ins"in data&&data.tx_ins!=undefined){this.tx_ins=data.tx_ins}if("tx_outs"in data&&data.tx_outs!=undefined){this.tx_outs=data.tx_outs}if("signature"in data&&data.signature!=undefined){this.signature=data.signature}if("etx_sender"in data&&data.etx_sender!=undefined){this.etx_sender=data.etx_sender}if("parent_hash"in data&&data.parent_hash!=undefined){this.parent_hash=data.parent_hash}if("mix_hash"in data&&data.mix_hash!=undefined){this.mix_hash=data.mix_hash}if("work_nonce"in data&&data.work_nonce!=undefined){this.work_nonce=data.work_nonce}if("etx_type"in data&&data.etx_type!=undefined){this.etx_type=data.etx_type}}}get type(){return pb_1.Message.getFieldWithDefault(this,1,0)}set type(value){pb_1.Message.setOneofField(this,1,this.#one_of_decls[0],value)}get has_type(){return pb_1.Message.getField(this,1)!=null}get to(){return pb_1.Message.getFieldWithDefault(this,2,new Uint8Array(0))}set to(value){pb_1.Message.setOneofField(this,2,this.#one_of_decls[1],value)}get has_to(){return pb_1.Message.getField(this,2)!=null}get nonce(){return pb_1.Message.getFieldWithDefault(this,3,0)}set nonce(value){pb_1.Message.setOneofField(this,3,this.#one_of_decls[2],value)}get has_nonce(){return pb_1.Message.getField(this,3)!=null}get value(){return pb_1.Message.getFieldWithDefault(this,4,new Uint8Array(0))}set value(value){pb_1.Message.setOneofField(this,4,this.#one_of_decls[3],value)}get has_value(){return pb_1.Message.getField(this,4)!=null}get gas(){return pb_1.Message.getFieldWithDefault(this,5,0)}set gas(value){pb_1.Message.setOneofField(this,5,this.#one_of_decls[4],value)}get has_gas(){return pb_1.Message.getField(this,5)!=null}get data(){return pb_1.Message.getFieldWithDefault(this,6,new Uint8Array(0))}set data(value){pb_1.Message.setOneofField(this,6,this.#one_of_decls[5],value)}get has_data(){return pb_1.Message.getField(this,6)!=null}get chain_id(){return pb_1.Message.getFieldWithDefault(this,7,new Uint8Array(0))}set chain_id(value){pb_1.Message.setOneofField(this,7,this.#one_of_decls[6],value)}get has_chain_id(){return pb_1.Message.getField(this,7)!=null}get miner_tip(){return pb_1.Message.getFieldWithDefault(this,8,new Uint8Array(0))}set miner_tip(value){pb_1.Message.setOneofField(this,8,this.#one_of_decls[7],value)}get has_miner_tip(){return pb_1.Message.getField(this,8)!=null}get gas_price(){return pb_1.Message.getFieldWithDefault(this,9,new Uint8Array(0))}set gas_price(value){pb_1.Message.setOneofField(this,9,this.#one_of_decls[8],value)}get has_gas_price(){return pb_1.Message.getField(this,9)!=null}get access_list(){return pb_1.Message.getWrapperField(this,ProtoAccessList,10)}set access_list(value){pb_1.Message.setOneofWrapperField(this,10,this.#one_of_decls[9],value)}get has_access_list(){return pb_1.Message.getField(this,10)!=null}get v(){return pb_1.Message.getFieldWithDefault(this,11,new Uint8Array(0))}set v(value){pb_1.Message.setOneofField(this,11,this.#one_of_decls[10],value)}get has_v(){return pb_1.Message.getField(this,11)!=null}get r(){return pb_1.Message.getFieldWithDefault(this,12,new Uint8Array(0))}set r(value){pb_1.Message.setOneofField(this,12,this.#one_of_decls[11],value)}get has_r(){return pb_1.Message.getField(this,12)!=null}get s(){return pb_1.Message.getFieldWithDefault(this,13,new Uint8Array(0))}set s(value){pb_1.Message.setOneofField(this,13,this.#one_of_decls[12],value)}get has_s(){return pb_1.Message.getField(this,13)!=null}get originating_tx_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,14)}set originating_tx_hash(value){pb_1.Message.setOneofWrapperField(this,14,this.#one_of_decls[13],value)}get has_originating_tx_hash(){return pb_1.Message.getField(this,14)!=null}get etx_index(){return pb_1.Message.getFieldWithDefault(this,15,0)}set etx_index(value){pb_1.Message.setOneofField(this,15,this.#one_of_decls[14],value)}get has_etx_index(){return pb_1.Message.getField(this,15)!=null}get tx_ins(){return pb_1.Message.getWrapperField(this,ProtoTxIns,16)}set tx_ins(value){pb_1.Message.setOneofWrapperField(this,16,this.#one_of_decls[15],value)}get has_tx_ins(){return pb_1.Message.getField(this,16)!=null}get tx_outs(){return pb_1.Message.getWrapperField(this,ProtoTxOuts,17)}set tx_outs(value){pb_1.Message.setOneofWrapperField(this,17,this.#one_of_decls[16],value)}get has_tx_outs(){return pb_1.Message.getField(this,17)!=null}get signature(){return pb_1.Message.getFieldWithDefault(this,18,new Uint8Array(0))}set signature(value){pb_1.Message.setOneofField(this,18,this.#one_of_decls[17],value)}get has_signature(){return pb_1.Message.getField(this,18)!=null}get etx_sender(){return pb_1.Message.getFieldWithDefault(this,19,new Uint8Array(0))}set etx_sender(value){pb_1.Message.setOneofField(this,19,this.#one_of_decls[18],value)}get has_etx_sender(){return pb_1.Message.getField(this,19)!=null}get parent_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,20)}set parent_hash(value){pb_1.Message.setOneofWrapperField(this,20,this.#one_of_decls[19],value)}get has_parent_hash(){return pb_1.Message.getField(this,20)!=null}get mix_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,21)}set mix_hash(value){pb_1.Message.setOneofWrapperField(this,21,this.#one_of_decls[20],value)}get has_mix_hash(){return pb_1.Message.getField(this,21)!=null}get work_nonce(){return pb_1.Message.getFieldWithDefault(this,22,0)}set work_nonce(value){pb_1.Message.setOneofField(this,22,this.#one_of_decls[21],value)}get has_work_nonce(){return pb_1.Message.getField(this,22)!=null}get etx_type(){return pb_1.Message.getFieldWithDefault(this,23,0)}set etx_type(value){pb_1.Message.setOneofField(this,23,this.#one_of_decls[22],value)}get has_etx_type(){return pb_1.Message.getField(this,23)!=null}get _type(){const cases={0:"none",1:"type"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _to(){const cases={0:"none",2:"to"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _nonce(){const cases={0:"none",3:"nonce"};return cases[pb_1.Message.computeOneofCase(this,[3])]}get _value(){const cases={0:"none",4:"value"};return cases[pb_1.Message.computeOneofCase(this,[4])]}get _gas(){const cases={0:"none",5:"gas"};return cases[pb_1.Message.computeOneofCase(this,[5])]}get _data(){const cases={0:"none",6:"data"};return cases[pb_1.Message.computeOneofCase(this,[6])]}get _chain_id(){const cases={0:"none",7:"chain_id"};return cases[pb_1.Message.computeOneofCase(this,[7])]}get _miner_tip(){const cases={0:"none",8:"miner_tip"};return cases[pb_1.Message.computeOneofCase(this,[8])]}get _gas_price(){const cases={0:"none",9:"gas_price"};return cases[pb_1.Message.computeOneofCase(this,[9])]}get _access_list(){const cases={0:"none",10:"access_list"};return cases[pb_1.Message.computeOneofCase(this,[10])]}get _v(){const cases={0:"none",11:"v"};return cases[pb_1.Message.computeOneofCase(this,[11])]}get _r(){const cases={0:"none",12:"r"};return cases[pb_1.Message.computeOneofCase(this,[12])]}get _s(){const cases={0:"none",13:"s"};return cases[pb_1.Message.computeOneofCase(this,[13])]}get _originating_tx_hash(){const cases={0:"none",14:"originating_tx_hash"};return cases[pb_1.Message.computeOneofCase(this,[14])]}get _etx_index(){const cases={0:"none",15:"etx_index"};return cases[pb_1.Message.computeOneofCase(this,[15])]}get _tx_ins(){const cases={0:"none",16:"tx_ins"};return cases[pb_1.Message.computeOneofCase(this,[16])]}get _tx_outs(){const cases={0:"none",17:"tx_outs"};return cases[pb_1.Message.computeOneofCase(this,[17])]}get _signature(){const cases={0:"none",18:"signature"};return cases[pb_1.Message.computeOneofCase(this,[18])]}get _etx_sender(){const cases={0:"none",19:"etx_sender"};return cases[pb_1.Message.computeOneofCase(this,[19])]}get _parent_hash(){const cases={0:"none",20:"parent_hash"};return cases[pb_1.Message.computeOneofCase(this,[20])]}get _mix_hash(){const cases={0:"none",21:"mix_hash"};return cases[pb_1.Message.computeOneofCase(this,[21])]}get _work_nonce(){const cases={0:"none",22:"work_nonce"};return cases[pb_1.Message.computeOneofCase(this,[22])]}get _etx_type(){const cases={0:"none",23:"etx_type"};return cases[pb_1.Message.computeOneofCase(this,[23])]}static fromObject(data){const message=new ProtoTransaction({});if(data.type!=null){message.type=data.type}if(data.to!=null){message.to=data.to}if(data.nonce!=null){message.nonce=data.nonce}if(data.value!=null){message.value=data.value}if(data.gas!=null){message.gas=data.gas}if(data.data!=null){message.data=data.data}if(data.chain_id!=null){message.chain_id=data.chain_id}if(data.miner_tip!=null){message.miner_tip=data.miner_tip}if(data.gas_price!=null){message.gas_price=data.gas_price}if(data.access_list!=null){message.access_list=ProtoAccessList.fromObject(data.access_list)}if(data.v!=null){message.v=data.v}if(data.r!=null){message.r=data.r}if(data.s!=null){message.s=data.s}if(data.originating_tx_hash!=null){message.originating_tx_hash=common.ProtoHash.fromObject(data.originating_tx_hash)}if(data.etx_index!=null){message.etx_index=data.etx_index}if(data.tx_ins!=null){message.tx_ins=ProtoTxIns.fromObject(data.tx_ins)}if(data.tx_outs!=null){message.tx_outs=ProtoTxOuts.fromObject(data.tx_outs)}if(data.signature!=null){message.signature=data.signature}if(data.etx_sender!=null){message.etx_sender=data.etx_sender}if(data.parent_hash!=null){message.parent_hash=common.ProtoHash.fromObject(data.parent_hash)}if(data.mix_hash!=null){message.mix_hash=common.ProtoHash.fromObject(data.mix_hash)}if(data.work_nonce!=null){message.work_nonce=data.work_nonce}if(data.etx_type!=null){message.etx_type=data.etx_type}return message}toObject(){const data={};if(this.type!=null){data.type=this.type}if(this.to!=null){data.to=this.to}if(this.nonce!=null){data.nonce=this.nonce}if(this.value!=null){data.value=this.value}if(this.gas!=null){data.gas=this.gas}if(this.data!=null){data.data=this.data}if(this.chain_id!=null){data.chain_id=this.chain_id}if(this.miner_tip!=null){data.miner_tip=this.miner_tip}if(this.gas_price!=null){data.gas_price=this.gas_price}if(this.access_list!=null){data.access_list=this.access_list.toObject()}if(this.v!=null){data.v=this.v}if(this.r!=null){data.r=this.r}if(this.s!=null){data.s=this.s}if(this.originating_tx_hash!=null){data.originating_tx_hash=this.originating_tx_hash.toObject()}if(this.etx_index!=null){data.etx_index=this.etx_index}if(this.tx_ins!=null){data.tx_ins=this.tx_ins.toObject()}if(this.tx_outs!=null){data.tx_outs=this.tx_outs.toObject()}if(this.signature!=null){data.signature=this.signature}if(this.etx_sender!=null){data.etx_sender=this.etx_sender}if(this.parent_hash!=null){data.parent_hash=this.parent_hash.toObject()}if(this.mix_hash!=null){data.mix_hash=this.mix_hash.toObject()}if(this.work_nonce!=null){data.work_nonce=this.work_nonce}if(this.etx_type!=null){data.etx_type=this.etx_type}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_type)writer.writeUint64(1,this.type);if(this.has_to)writer.writeBytes(2,this.to);if(this.has_nonce)writer.writeUint64(3,this.nonce);if(this.has_value)writer.writeBytes(4,this.value);if(this.has_gas)writer.writeUint64(5,this.gas);if(this.has_data)writer.writeBytes(6,this.data);if(this.has_chain_id)writer.writeBytes(7,this.chain_id);if(this.has_miner_tip)writer.writeBytes(8,this.miner_tip);if(this.has_gas_price)writer.writeBytes(9,this.gas_price);if(this.has_access_list)writer.writeMessage(10,this.access_list,()=>this.access_list.serialize(writer));if(this.has_v)writer.writeBytes(11,this.v);if(this.has_r)writer.writeBytes(12,this.r);if(this.has_s)writer.writeBytes(13,this.s);if(this.has_originating_tx_hash)writer.writeMessage(14,this.originating_tx_hash,()=>this.originating_tx_hash.serialize(writer));if(this.has_etx_index)writer.writeUint32(15,this.etx_index);if(this.has_tx_ins)writer.writeMessage(16,this.tx_ins,()=>this.tx_ins.serialize(writer));if(this.has_tx_outs)writer.writeMessage(17,this.tx_outs,()=>this.tx_outs.serialize(writer));if(this.has_signature)writer.writeBytes(18,this.signature);if(this.has_etx_sender)writer.writeBytes(19,this.etx_sender);if(this.has_parent_hash)writer.writeMessage(20,this.parent_hash,()=>this.parent_hash.serialize(writer));if(this.has_mix_hash)writer.writeMessage(21,this.mix_hash,()=>this.mix_hash.serialize(writer));if(this.has_work_nonce)writer.writeUint64(22,this.work_nonce);if(this.has_etx_type)writer.writeUint64(23,this.etx_type);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTransaction;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.type=reader.readUint64();break;case 2:message.to=reader.readBytes();break;case 3:message.nonce=reader.readUint64();break;case 4:message.value=reader.readBytes();break;case 5:message.gas=reader.readUint64();break;case 6:message.data=reader.readBytes();break;case 7:message.chain_id=reader.readBytes();break;case 8:message.miner_tip=reader.readBytes();break;case 9:message.gas_price=reader.readBytes();break;case 10:reader.readMessage(message.access_list,()=>message.access_list=ProtoAccessList.deserialize(reader));break;case 11:message.v=reader.readBytes();break;case 12:message.r=reader.readBytes();break;case 13:message.s=reader.readBytes();break;case 14:reader.readMessage(message.originating_tx_hash,()=>message.originating_tx_hash=common.ProtoHash.deserialize(reader));break;case 15:message.etx_index=reader.readUint32();break;case 16:reader.readMessage(message.tx_ins,()=>message.tx_ins=ProtoTxIns.deserialize(reader));break;case 17:reader.readMessage(message.tx_outs,()=>message.tx_outs=ProtoTxOuts.deserialize(reader));break;case 18:message.signature=reader.readBytes();break;case 19:message.etx_sender=reader.readBytes();break;case 20:reader.readMessage(message.parent_hash,()=>message.parent_hash=common.ProtoHash.deserialize(reader));break;case 21:reader.readMessage(message.mix_hash,()=>message.mix_hash=common.ProtoHash.deserialize(reader));break;case 22:message.work_nonce=reader.readUint64();break;case 23:message.etx_type=reader.readUint64();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTransaction.deserialize(bytes)}}block.ProtoTransaction=ProtoTransaction;class ProtoTransactions extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("transactions"in data&&data.transactions!=undefined){this.transactions=data.transactions}}}get transactions(){return pb_1.Message.getRepeatedWrapperField(this,ProtoTransaction,1)}set transactions(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoTransactions({});if(data.transactions!=null){message.transactions=data.transactions.map(item=>ProtoTransaction.fromObject(item))}return message}toObject(){const data={};if(this.transactions!=null){data.transactions=this.transactions.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.transactions.length)writer.writeRepeatedMessage(1,this.transactions,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTransactions;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.transactions,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoTransaction.deserialize(reader),ProtoTransaction));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTransactions.deserialize(bytes)}}block.ProtoTransactions=ProtoTransactions;class ProtoHeaders extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("headers"in data&&data.headers!=undefined){this.headers=data.headers}}}get headers(){return pb_1.Message.getRepeatedWrapperField(this,ProtoHeader,1)}set headers(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoHeaders({});if(data.headers!=null){message.headers=data.headers.map(item=>ProtoHeader.fromObject(item))}return message}toObject(){const data={};if(this.headers!=null){data.headers=this.headers.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.headers.length)writer.writeRepeatedMessage(1,this.headers,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoHeaders;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.headers,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoHeader.deserialize(reader),ProtoHeader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoHeaders.deserialize(bytes)}}block.ProtoHeaders=ProtoHeaders;class ProtoManifest extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("manifest"in data&&data.manifest!=undefined){this.manifest=data.manifest}}}get manifest(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,1)}set manifest(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoManifest({});if(data.manifest!=null){message.manifest=data.manifest.map(item=>common.ProtoHash.fromObject(item))}return message}toObject(){const data={};if(this.manifest!=null){data.manifest=this.manifest.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.manifest.length)writer.writeRepeatedMessage(1,this.manifest,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoManifest;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.manifest,()=>pb_1.Message.addToRepeatedWrapperField(message,1,common.ProtoHash.deserialize(reader),common.ProtoHash));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoManifest.deserialize(bytes)}}block.ProtoManifest=ProtoManifest;class ProtoAccessList extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("access_tuples"in data&&data.access_tuples!=undefined){this.access_tuples=data.access_tuples}}}get access_tuples(){return pb_1.Message.getRepeatedWrapperField(this,ProtoAccessTuple,1)}set access_tuples(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoAccessList({});if(data.access_tuples!=null){message.access_tuples=data.access_tuples.map(item=>ProtoAccessTuple.fromObject(item))}return message}toObject(){const data={};if(this.access_tuples!=null){data.access_tuples=this.access_tuples.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.access_tuples.length)writer.writeRepeatedMessage(1,this.access_tuples,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoAccessList;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.access_tuples,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoAccessTuple.deserialize(reader),ProtoAccessTuple));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoAccessList.deserialize(bytes)}}block.ProtoAccessList=ProtoAccessList;class ProtoWorkObjectHeader extends pb_1.Message{#one_of_decls=[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("header_hash"in data&&data.header_hash!=undefined){this.header_hash=data.header_hash}if("parent_hash"in data&&data.parent_hash!=undefined){this.parent_hash=data.parent_hash}if("number"in data&&data.number!=undefined){this.number=data.number}if("difficulty"in data&&data.difficulty!=undefined){this.difficulty=data.difficulty}if("tx_hash"in data&&data.tx_hash!=undefined){this.tx_hash=data.tx_hash}if("nonce"in data&&data.nonce!=undefined){this.nonce=data.nonce}if("location"in data&&data.location!=undefined){this.location=data.location}if("mix_hash"in data&&data.mix_hash!=undefined){this.mix_hash=data.mix_hash}if("time"in data&&data.time!=undefined){this.time=data.time}if("prime_terminus_number"in data&&data.prime_terminus_number!=undefined){this.prime_terminus_number=data.prime_terminus_number}if("lock"in data&&data.lock!=undefined){this.lock=data.lock}if("primary_coinbase"in data&&data.primary_coinbase!=undefined){this.primary_coinbase=data.primary_coinbase}}}get header_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,1)}set header_hash(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_header_hash(){return pb_1.Message.getField(this,1)!=null}get parent_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,2)}set parent_hash(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_parent_hash(){return pb_1.Message.getField(this,2)!=null}get number(){return pb_1.Message.getFieldWithDefault(this,3,new Uint8Array(0))}set number(value){pb_1.Message.setOneofField(this,3,this.#one_of_decls[2],value)}get has_number(){return pb_1.Message.getField(this,3)!=null}get difficulty(){return pb_1.Message.getFieldWithDefault(this,4,new Uint8Array(0))}set difficulty(value){pb_1.Message.setOneofField(this,4,this.#one_of_decls[3],value)}get has_difficulty(){return pb_1.Message.getField(this,4)!=null}get tx_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,5)}set tx_hash(value){pb_1.Message.setOneofWrapperField(this,5,this.#one_of_decls[4],value)}get has_tx_hash(){return pb_1.Message.getField(this,5)!=null}get nonce(){return pb_1.Message.getFieldWithDefault(this,6,0)}set nonce(value){pb_1.Message.setOneofField(this,6,this.#one_of_decls[5],value)}get has_nonce(){return pb_1.Message.getField(this,6)!=null}get location(){return pb_1.Message.getWrapperField(this,common.ProtoLocation,7)}set location(value){pb_1.Message.setOneofWrapperField(this,7,this.#one_of_decls[6],value)}get has_location(){return pb_1.Message.getField(this,7)!=null}get mix_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,8)}set mix_hash(value){pb_1.Message.setOneofWrapperField(this,8,this.#one_of_decls[7],value)}get has_mix_hash(){return pb_1.Message.getField(this,8)!=null}get time(){return pb_1.Message.getFieldWithDefault(this,9,0)}set time(value){pb_1.Message.setOneofField(this,9,this.#one_of_decls[8],value)}get has_time(){return pb_1.Message.getField(this,9)!=null}get prime_terminus_number(){return pb_1.Message.getFieldWithDefault(this,10,new Uint8Array(0))}set prime_terminus_number(value){pb_1.Message.setOneofField(this,10,this.#one_of_decls[9],value)}get has_prime_terminus_number(){return pb_1.Message.getField(this,10)!=null}get lock(){return pb_1.Message.getFieldWithDefault(this,11,0)}set lock(value){pb_1.Message.setOneofField(this,11,this.#one_of_decls[10],value)}get has_lock(){return pb_1.Message.getField(this,11)!=null}get primary_coinbase(){return pb_1.Message.getWrapperField(this,common.ProtoAddress,12)}set primary_coinbase(value){pb_1.Message.setOneofWrapperField(this,12,this.#one_of_decls[11],value)}get has_primary_coinbase(){return pb_1.Message.getField(this,12)!=null}get _header_hash(){const cases={0:"none",1:"header_hash"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _parent_hash(){const cases={0:"none",2:"parent_hash"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _number(){const cases={0:"none",3:"number"};return cases[pb_1.Message.computeOneofCase(this,[3])]}get _difficulty(){const cases={0:"none",4:"difficulty"};return cases[pb_1.Message.computeOneofCase(this,[4])]}get _tx_hash(){const cases={0:"none",5:"tx_hash"};return cases[pb_1.Message.computeOneofCase(this,[5])]}get _nonce(){const cases={0:"none",6:"nonce"};return cases[pb_1.Message.computeOneofCase(this,[6])]}get _location(){const cases={0:"none",7:"location"};return cases[pb_1.Message.computeOneofCase(this,[7])]}get _mix_hash(){const cases={0:"none",8:"mix_hash"};return cases[pb_1.Message.computeOneofCase(this,[8])]}get _time(){const cases={0:"none",9:"time"};return cases[pb_1.Message.computeOneofCase(this,[9])]}get _prime_terminus_number(){const cases={0:"none",10:"prime_terminus_number"};return cases[pb_1.Message.computeOneofCase(this,[10])]}get _lock(){const cases={0:"none",11:"lock"};return cases[pb_1.Message.computeOneofCase(this,[11])]}get _primary_coinbase(){const cases={0:"none",12:"primary_coinbase"};return cases[pb_1.Message.computeOneofCase(this,[12])]}static fromObject(data){const message=new ProtoWorkObjectHeader({});if(data.header_hash!=null){message.header_hash=common.ProtoHash.fromObject(data.header_hash)}if(data.parent_hash!=null){message.parent_hash=common.ProtoHash.fromObject(data.parent_hash)}if(data.number!=null){message.number=data.number}if(data.difficulty!=null){message.difficulty=data.difficulty}if(data.tx_hash!=null){message.tx_hash=common.ProtoHash.fromObject(data.tx_hash)}if(data.nonce!=null){message.nonce=data.nonce}if(data.location!=null){message.location=common.ProtoLocation.fromObject(data.location)}if(data.mix_hash!=null){message.mix_hash=common.ProtoHash.fromObject(data.mix_hash)}if(data.time!=null){message.time=data.time}if(data.prime_terminus_number!=null){message.prime_terminus_number=data.prime_terminus_number}if(data.lock!=null){message.lock=data.lock}if(data.primary_coinbase!=null){message.primary_coinbase=common.ProtoAddress.fromObject(data.primary_coinbase)}return message}toObject(){const data={};if(this.header_hash!=null){data.header_hash=this.header_hash.toObject()}if(this.parent_hash!=null){data.parent_hash=this.parent_hash.toObject()}if(this.number!=null){data.number=this.number}if(this.difficulty!=null){data.difficulty=this.difficulty}if(this.tx_hash!=null){data.tx_hash=this.tx_hash.toObject()}if(this.nonce!=null){data.nonce=this.nonce}if(this.location!=null){data.location=this.location.toObject()}if(this.mix_hash!=null){data.mix_hash=this.mix_hash.toObject()}if(this.time!=null){data.time=this.time}if(this.prime_terminus_number!=null){data.prime_terminus_number=this.prime_terminus_number}if(this.lock!=null){data.lock=this.lock}if(this.primary_coinbase!=null){data.primary_coinbase=this.primary_coinbase.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_header_hash)writer.writeMessage(1,this.header_hash,()=>this.header_hash.serialize(writer));if(this.has_parent_hash)writer.writeMessage(2,this.parent_hash,()=>this.parent_hash.serialize(writer));if(this.has_number)writer.writeBytes(3,this.number);if(this.has_difficulty)writer.writeBytes(4,this.difficulty);if(this.has_tx_hash)writer.writeMessage(5,this.tx_hash,()=>this.tx_hash.serialize(writer));if(this.has_nonce)writer.writeUint64(6,this.nonce);if(this.has_location)writer.writeMessage(7,this.location,()=>this.location.serialize(writer));if(this.has_mix_hash)writer.writeMessage(8,this.mix_hash,()=>this.mix_hash.serialize(writer));if(this.has_time)writer.writeUint64(9,this.time);if(this.has_prime_terminus_number)writer.writeBytes(10,this.prime_terminus_number);if(this.has_lock)writer.writeUint32(11,this.lock);if(this.has_primary_coinbase)writer.writeMessage(12,this.primary_coinbase,()=>this.primary_coinbase.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectHeader;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.header_hash,()=>message.header_hash=common.ProtoHash.deserialize(reader));break;case 2:reader.readMessage(message.parent_hash,()=>message.parent_hash=common.ProtoHash.deserialize(reader));break;case 3:message.number=reader.readBytes();break;case 4:message.difficulty=reader.readBytes();break;case 5:reader.readMessage(message.tx_hash,()=>message.tx_hash=common.ProtoHash.deserialize(reader));break;case 6:message.nonce=reader.readUint64();break;case 7:reader.readMessage(message.location,()=>message.location=common.ProtoLocation.deserialize(reader));break;case 8:reader.readMessage(message.mix_hash,()=>message.mix_hash=common.ProtoHash.deserialize(reader));break;case 9:message.time=reader.readUint64();break;case 10:message.prime_terminus_number=reader.readBytes();break;case 11:message.lock=reader.readUint32();break;case 12:reader.readMessage(message.primary_coinbase,()=>message.primary_coinbase=common.ProtoAddress.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectHeader.deserialize(bytes)}}block.ProtoWorkObjectHeader=ProtoWorkObjectHeader;class ProtoWorkObjectHeaders extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("wo_headers"in data&&data.wo_headers!=undefined){this.wo_headers=data.wo_headers}}}get wo_headers(){return pb_1.Message.getRepeatedWrapperField(this,ProtoWorkObjectHeader,1)}set wo_headers(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoWorkObjectHeaders({});if(data.wo_headers!=null){message.wo_headers=data.wo_headers.map(item=>ProtoWorkObjectHeader.fromObject(item))}return message}toObject(){const data={};if(this.wo_headers!=null){data.wo_headers=this.wo_headers.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.wo_headers.length)writer.writeRepeatedMessage(1,this.wo_headers,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectHeaders;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.wo_headers,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoWorkObjectHeader.deserialize(reader),ProtoWorkObjectHeader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectHeaders.deserialize(bytes)}}block.ProtoWorkObjectHeaders=ProtoWorkObjectHeaders;class ProtoWorkObjectBody extends pb_1.Message{#one_of_decls=[[1],[2],[3],[4],[5],[6]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("header"in data&&data.header!=undefined){this.header=data.header}if("transactions"in data&&data.transactions!=undefined){this.transactions=data.transactions}if("uncles"in data&&data.uncles!=undefined){this.uncles=data.uncles}if("outbound_etxs"in data&&data.outbound_etxs!=undefined){this.outbound_etxs=data.outbound_etxs}if("manifest"in data&&data.manifest!=undefined){this.manifest=data.manifest}if("interlink_hashes"in data&&data.interlink_hashes!=undefined){this.interlink_hashes=data.interlink_hashes}}}get header(){return pb_1.Message.getWrapperField(this,ProtoHeader,1)}set header(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_header(){return pb_1.Message.getField(this,1)!=null}get transactions(){return pb_1.Message.getWrapperField(this,ProtoTransactions,2)}set transactions(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_transactions(){return pb_1.Message.getField(this,2)!=null}get uncles(){return pb_1.Message.getWrapperField(this,ProtoWorkObjectHeaders,3)}set uncles(value){pb_1.Message.setOneofWrapperField(this,3,this.#one_of_decls[2],value)}get has_uncles(){return pb_1.Message.getField(this,3)!=null}get outbound_etxs(){return pb_1.Message.getWrapperField(this,ProtoTransactions,4)}set outbound_etxs(value){pb_1.Message.setOneofWrapperField(this,4,this.#one_of_decls[3],value)}get has_outbound_etxs(){return pb_1.Message.getField(this,4)!=null}get manifest(){return pb_1.Message.getWrapperField(this,ProtoManifest,5)}set manifest(value){pb_1.Message.setOneofWrapperField(this,5,this.#one_of_decls[4],value)}get has_manifest(){return pb_1.Message.getField(this,5)!=null}get interlink_hashes(){return pb_1.Message.getWrapperField(this,common.ProtoHashes,6)}set interlink_hashes(value){pb_1.Message.setOneofWrapperField(this,6,this.#one_of_decls[5],value)}get has_interlink_hashes(){return pb_1.Message.getField(this,6)!=null}get _header(){const cases={0:"none",1:"header"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _transactions(){const cases={0:"none",2:"transactions"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _uncles(){const cases={0:"none",3:"uncles"};return cases[pb_1.Message.computeOneofCase(this,[3])]}get _outbound_etxs(){const cases={0:"none",4:"outbound_etxs"};return cases[pb_1.Message.computeOneofCase(this,[4])]}get _manifest(){const cases={0:"none",5:"manifest"};return cases[pb_1.Message.computeOneofCase(this,[5])]}get _interlink_hashes(){const cases={0:"none",6:"interlink_hashes"};return cases[pb_1.Message.computeOneofCase(this,[6])]}static fromObject(data){const message=new ProtoWorkObjectBody({});if(data.header!=null){message.header=ProtoHeader.fromObject(data.header)}if(data.transactions!=null){message.transactions=ProtoTransactions.fromObject(data.transactions)}if(data.uncles!=null){message.uncles=ProtoWorkObjectHeaders.fromObject(data.uncles)}if(data.outbound_etxs!=null){message.outbound_etxs=ProtoTransactions.fromObject(data.outbound_etxs)}if(data.manifest!=null){message.manifest=ProtoManifest.fromObject(data.manifest)}if(data.interlink_hashes!=null){message.interlink_hashes=common.ProtoHashes.fromObject(data.interlink_hashes)}return message}toObject(){const data={};if(this.header!=null){data.header=this.header.toObject()}if(this.transactions!=null){data.transactions=this.transactions.toObject()}if(this.uncles!=null){data.uncles=this.uncles.toObject()}if(this.outbound_etxs!=null){data.outbound_etxs=this.outbound_etxs.toObject()}if(this.manifest!=null){data.manifest=this.manifest.toObject()}if(this.interlink_hashes!=null){data.interlink_hashes=this.interlink_hashes.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_header)writer.writeMessage(1,this.header,()=>this.header.serialize(writer));if(this.has_transactions)writer.writeMessage(2,this.transactions,()=>this.transactions.serialize(writer));if(this.has_uncles)writer.writeMessage(3,this.uncles,()=>this.uncles.serialize(writer));if(this.has_outbound_etxs)writer.writeMessage(4,this.outbound_etxs,()=>this.outbound_etxs.serialize(writer));if(this.has_manifest)writer.writeMessage(5,this.manifest,()=>this.manifest.serialize(writer));if(this.has_interlink_hashes)writer.writeMessage(6,this.interlink_hashes,()=>this.interlink_hashes.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectBody;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.header,()=>message.header=ProtoHeader.deserialize(reader));break;case 2:reader.readMessage(message.transactions,()=>message.transactions=ProtoTransactions.deserialize(reader));break;case 3:reader.readMessage(message.uncles,()=>message.uncles=ProtoWorkObjectHeaders.deserialize(reader));break;case 4:reader.readMessage(message.outbound_etxs,()=>message.outbound_etxs=ProtoTransactions.deserialize(reader));break;case 5:reader.readMessage(message.manifest,()=>message.manifest=ProtoManifest.deserialize(reader));break;case 6:reader.readMessage(message.interlink_hashes,()=>message.interlink_hashes=common.ProtoHashes.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectBody.deserialize(bytes)}}block.ProtoWorkObjectBody=ProtoWorkObjectBody;class ProtoWorkObject extends pb_1.Message{#one_of_decls=[[1],[2],[3]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("wo_header"in data&&data.wo_header!=undefined){this.wo_header=data.wo_header}if("wo_body"in data&&data.wo_body!=undefined){this.wo_body=data.wo_body}if("tx"in data&&data.tx!=undefined){this.tx=data.tx}}}get wo_header(){return pb_1.Message.getWrapperField(this,ProtoWorkObjectHeader,1)}set wo_header(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_wo_header(){return pb_1.Message.getField(this,1)!=null}get wo_body(){return pb_1.Message.getWrapperField(this,ProtoWorkObjectBody,2)}set wo_body(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_wo_body(){return pb_1.Message.getField(this,2)!=null}get tx(){return pb_1.Message.getWrapperField(this,ProtoTransaction,3)}set tx(value){pb_1.Message.setOneofWrapperField(this,3,this.#one_of_decls[2],value)}get has_tx(){return pb_1.Message.getField(this,3)!=null}get _wo_header(){const cases={0:"none",1:"wo_header"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _wo_body(){const cases={0:"none",2:"wo_body"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _tx(){const cases={0:"none",3:"tx"};return cases[pb_1.Message.computeOneofCase(this,[3])]}static fromObject(data){const message=new ProtoWorkObject({});if(data.wo_header!=null){message.wo_header=ProtoWorkObjectHeader.fromObject(data.wo_header)}if(data.wo_body!=null){message.wo_body=ProtoWorkObjectBody.fromObject(data.wo_body)}if(data.tx!=null){message.tx=ProtoTransaction.fromObject(data.tx)}return message}toObject(){const data={};if(this.wo_header!=null){data.wo_header=this.wo_header.toObject()}if(this.wo_body!=null){data.wo_body=this.wo_body.toObject()}if(this.tx!=null){data.tx=this.tx.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_wo_header)writer.writeMessage(1,this.wo_header,()=>this.wo_header.serialize(writer));if(this.has_wo_body)writer.writeMessage(2,this.wo_body,()=>this.wo_body.serialize(writer));if(this.has_tx)writer.writeMessage(3,this.tx,()=>this.tx.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObject;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.wo_header,()=>message.wo_header=ProtoWorkObjectHeader.deserialize(reader));break;case 2:reader.readMessage(message.wo_body,()=>message.wo_body=ProtoWorkObjectBody.deserialize(reader));break;case 3:reader.readMessage(message.tx,()=>message.tx=ProtoTransaction.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObject.deserialize(bytes)}}block.ProtoWorkObject=ProtoWorkObject;class ProtoWorkObjects extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("work_objects"in data&&data.work_objects!=undefined){this.work_objects=data.work_objects}}}get work_objects(){return pb_1.Message.getRepeatedWrapperField(this,ProtoWorkObject,1)}set work_objects(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoWorkObjects({});if(data.work_objects!=null){message.work_objects=data.work_objects.map(item=>ProtoWorkObject.fromObject(item))}return message}toObject(){const data={};if(this.work_objects!=null){data.work_objects=this.work_objects.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.work_objects.length)writer.writeRepeatedMessage(1,this.work_objects,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjects;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.work_objects,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoWorkObject.deserialize(reader),ProtoWorkObject));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjects.deserialize(bytes)}}block.ProtoWorkObjects=ProtoWorkObjects;class ProtoWorkObjectBlockView extends pb_1.Message{#one_of_decls=[[1]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("work_object"in data&&data.work_object!=undefined){this.work_object=data.work_object}}}get work_object(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set work_object(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_work_object(){return pb_1.Message.getField(this,1)!=null}get _work_object(){const cases={0:"none",1:"work_object"};return cases[pb_1.Message.computeOneofCase(this,[1])]}static fromObject(data){const message=new ProtoWorkObjectBlockView({});if(data.work_object!=null){message.work_object=ProtoWorkObject.fromObject(data.work_object)}return message}toObject(){const data={};if(this.work_object!=null){data.work_object=this.work_object.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_work_object)writer.writeMessage(1,this.work_object,()=>this.work_object.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectBlockView;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.work_object,()=>message.work_object=ProtoWorkObject.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectBlockView.deserialize(bytes)}}block.ProtoWorkObjectBlockView=ProtoWorkObjectBlockView;class ProtoWorkObjectBlocksView extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("work_objects"in data&&data.work_objects!=undefined){this.work_objects=data.work_objects}}}get work_objects(){return pb_1.Message.getRepeatedWrapperField(this,ProtoWorkObjectBlockView,1)}set work_objects(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoWorkObjectBlocksView({});if(data.work_objects!=null){message.work_objects=data.work_objects.map(item=>ProtoWorkObjectBlockView.fromObject(item))}return message}toObject(){const data={};if(this.work_objects!=null){data.work_objects=this.work_objects.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.work_objects.length)writer.writeRepeatedMessage(1,this.work_objects,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectBlocksView;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.work_objects,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoWorkObjectBlockView.deserialize(reader),ProtoWorkObjectBlockView));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectBlocksView.deserialize(bytes)}}block.ProtoWorkObjectBlocksView=ProtoWorkObjectBlocksView;class ProtoWorkObjectHeaderView extends pb_1.Message{#one_of_decls=[[1]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("work_object"in data&&data.work_object!=undefined){this.work_object=data.work_object}}}get work_object(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set work_object(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_work_object(){return pb_1.Message.getField(this,1)!=null}get _work_object(){const cases={0:"none",1:"work_object"};return cases[pb_1.Message.computeOneofCase(this,[1])]}static fromObject(data){const message=new ProtoWorkObjectHeaderView({});if(data.work_object!=null){message.work_object=ProtoWorkObject.fromObject(data.work_object)}return message}toObject(){const data={};if(this.work_object!=null){data.work_object=this.work_object.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_work_object)writer.writeMessage(1,this.work_object,()=>this.work_object.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectHeaderView;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.work_object,()=>message.work_object=ProtoWorkObject.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectHeaderView.deserialize(bytes)}}block.ProtoWorkObjectHeaderView=ProtoWorkObjectHeaderView;class ProtoWorkObjectShareView extends pb_1.Message{#one_of_decls=[[1]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("work_object"in data&&data.work_object!=undefined){this.work_object=data.work_object}}}get work_object(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set work_object(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_work_object(){return pb_1.Message.getField(this,1)!=null}get _work_object(){const cases={0:"none",1:"work_object"};return cases[pb_1.Message.computeOneofCase(this,[1])]}static fromObject(data){const message=new ProtoWorkObjectShareView({});if(data.work_object!=null){message.work_object=ProtoWorkObject.fromObject(data.work_object)}return message}toObject(){const data={};if(this.work_object!=null){data.work_object=this.work_object.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_work_object)writer.writeMessage(1,this.work_object,()=>this.work_object.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoWorkObjectShareView;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.work_object,()=>message.work_object=ProtoWorkObject.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoWorkObjectShareView.deserialize(bytes)}}block.ProtoWorkObjectShareView=ProtoWorkObjectShareView;class ProtoAccessTuple extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[2],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("address"in data&&data.address!=undefined){this.address=data.address}if("storage_key"in data&&data.storage_key!=undefined){this.storage_key=data.storage_key}}}get address(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set address(value){pb_1.Message.setField(this,1,value)}get storage_key(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,2)}set storage_key(value){pb_1.Message.setRepeatedWrapperField(this,2,value)}static fromObject(data){const message=new ProtoAccessTuple({});if(data.address!=null){message.address=data.address}if(data.storage_key!=null){message.storage_key=data.storage_key.map(item=>common.ProtoHash.fromObject(item))}return message}toObject(){const data={};if(this.address!=null){data.address=this.address}if(this.storage_key!=null){data.storage_key=this.storage_key.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.address.length)writer.writeBytes(1,this.address);if(this.storage_key.length)writer.writeRepeatedMessage(2,this.storage_key,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoAccessTuple;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.address=reader.readBytes();break;case 2:reader.readMessage(message.storage_key,()=>pb_1.Message.addToRepeatedWrapperField(message,2,common.ProtoHash.deserialize(reader),common.ProtoHash));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoAccessTuple.deserialize(bytes)}}block.ProtoAccessTuple=ProtoAccessTuple;class ProtoReceiptForStorage extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("post_state_or_status"in data&&data.post_state_or_status!=undefined){this.post_state_or_status=data.post_state_or_status}if("cumulative_gas_used"in data&&data.cumulative_gas_used!=undefined){this.cumulative_gas_used=data.cumulative_gas_used}if("logs"in data&&data.logs!=undefined){this.logs=data.logs}if("tx_hash"in data&&data.tx_hash!=undefined){this.tx_hash=data.tx_hash}if("contract_address"in data&&data.contract_address!=undefined){this.contract_address=data.contract_address}if("gas_used"in data&&data.gas_used!=undefined){this.gas_used=data.gas_used}if("outbound_etxs"in data&&data.outbound_etxs!=undefined){this.outbound_etxs=data.outbound_etxs}}}get post_state_or_status(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set post_state_or_status(value){pb_1.Message.setField(this,1,value)}get cumulative_gas_used(){return pb_1.Message.getFieldWithDefault(this,2,0)}set cumulative_gas_used(value){pb_1.Message.setField(this,2,value)}get logs(){return pb_1.Message.getWrapperField(this,ProtoLogsForStorage,3)}set logs(value){pb_1.Message.setWrapperField(this,3,value)}get has_logs(){return pb_1.Message.getField(this,3)!=null}get tx_hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,4)}set tx_hash(value){pb_1.Message.setWrapperField(this,4,value)}get has_tx_hash(){return pb_1.Message.getField(this,4)!=null}get contract_address(){return pb_1.Message.getWrapperField(this,common.ProtoAddress,5)}set contract_address(value){pb_1.Message.setWrapperField(this,5,value)}get has_contract_address(){return pb_1.Message.getField(this,5)!=null}get gas_used(){return pb_1.Message.getFieldWithDefault(this,6,0)}set gas_used(value){pb_1.Message.setField(this,6,value)}get outbound_etxs(){return pb_1.Message.getWrapperField(this,ProtoTransactions,7)}set outbound_etxs(value){pb_1.Message.setWrapperField(this,7,value)}get has_outbound_etxs(){return pb_1.Message.getField(this,7)!=null}static fromObject(data){const message=new ProtoReceiptForStorage({});if(data.post_state_or_status!=null){message.post_state_or_status=data.post_state_or_status}if(data.cumulative_gas_used!=null){message.cumulative_gas_used=data.cumulative_gas_used}if(data.logs!=null){message.logs=ProtoLogsForStorage.fromObject(data.logs)}if(data.tx_hash!=null){message.tx_hash=common.ProtoHash.fromObject(data.tx_hash)}if(data.contract_address!=null){message.contract_address=common.ProtoAddress.fromObject(data.contract_address)}if(data.gas_used!=null){message.gas_used=data.gas_used}if(data.outbound_etxs!=null){message.outbound_etxs=ProtoTransactions.fromObject(data.outbound_etxs)}return message}toObject(){const data={};if(this.post_state_or_status!=null){data.post_state_or_status=this.post_state_or_status}if(this.cumulative_gas_used!=null){data.cumulative_gas_used=this.cumulative_gas_used}if(this.logs!=null){data.logs=this.logs.toObject()}if(this.tx_hash!=null){data.tx_hash=this.tx_hash.toObject()}if(this.contract_address!=null){data.contract_address=this.contract_address.toObject()}if(this.gas_used!=null){data.gas_used=this.gas_used}if(this.outbound_etxs!=null){data.outbound_etxs=this.outbound_etxs.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.post_state_or_status.length)writer.writeBytes(1,this.post_state_or_status);if(this.cumulative_gas_used!=0)writer.writeUint64(2,this.cumulative_gas_used);if(this.has_logs)writer.writeMessage(3,this.logs,()=>this.logs.serialize(writer));if(this.has_tx_hash)writer.writeMessage(4,this.tx_hash,()=>this.tx_hash.serialize(writer));if(this.has_contract_address)writer.writeMessage(5,this.contract_address,()=>this.contract_address.serialize(writer));if(this.gas_used!=0)writer.writeUint64(6,this.gas_used);if(this.has_outbound_etxs)writer.writeMessage(7,this.outbound_etxs,()=>this.outbound_etxs.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoReceiptForStorage;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.post_state_or_status=reader.readBytes();break;case 2:message.cumulative_gas_used=reader.readUint64();break;case 3:reader.readMessage(message.logs,()=>message.logs=ProtoLogsForStorage.deserialize(reader));break;case 4:reader.readMessage(message.tx_hash,()=>message.tx_hash=common.ProtoHash.deserialize(reader));break;case 5:reader.readMessage(message.contract_address,()=>message.contract_address=common.ProtoAddress.deserialize(reader));break;case 6:message.gas_used=reader.readUint64();break;case 7:reader.readMessage(message.outbound_etxs,()=>message.outbound_etxs=ProtoTransactions.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoReceiptForStorage.deserialize(bytes)}}block.ProtoReceiptForStorage=ProtoReceiptForStorage;class ProtoReceiptsForStorage extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("receipts"in data&&data.receipts!=undefined){this.receipts=data.receipts}}}get receipts(){return pb_1.Message.getRepeatedWrapperField(this,ProtoReceiptForStorage,1)}set receipts(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoReceiptsForStorage({});if(data.receipts!=null){message.receipts=data.receipts.map(item=>ProtoReceiptForStorage.fromObject(item))}return message}toObject(){const data={};if(this.receipts!=null){data.receipts=this.receipts.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.receipts.length)writer.writeRepeatedMessage(1,this.receipts,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoReceiptsForStorage;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.receipts,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoReceiptForStorage.deserialize(reader),ProtoReceiptForStorage));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoReceiptsForStorage.deserialize(bytes)}}block.ProtoReceiptsForStorage=ProtoReceiptsForStorage;class ProtoLogForStorage extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[2],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("address"in data&&data.address!=undefined){this.address=data.address}if("topics"in data&&data.topics!=undefined){this.topics=data.topics}if("data"in data&&data.data!=undefined){this.data=data.data}}}get address(){return pb_1.Message.getWrapperField(this,common.ProtoAddress,1)}set address(value){pb_1.Message.setWrapperField(this,1,value)}get has_address(){return pb_1.Message.getField(this,1)!=null}get topics(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,2)}set topics(value){pb_1.Message.setRepeatedWrapperField(this,2,value)}get data(){return pb_1.Message.getFieldWithDefault(this,3,new Uint8Array(0))}set data(value){pb_1.Message.setField(this,3,value)}static fromObject(data){const message=new ProtoLogForStorage({});if(data.address!=null){message.address=common.ProtoAddress.fromObject(data.address)}if(data.topics!=null){message.topics=data.topics.map(item=>common.ProtoHash.fromObject(item))}if(data.data!=null){message.data=data.data}return message}toObject(){const data={};if(this.address!=null){data.address=this.address.toObject()}if(this.topics!=null){data.topics=this.topics.map(item=>item.toObject())}if(this.data!=null){data.data=this.data}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_address)writer.writeMessage(1,this.address,()=>this.address.serialize(writer));if(this.topics.length)writer.writeRepeatedMessage(2,this.topics,item=>item.serialize(writer));if(this.data.length)writer.writeBytes(3,this.data);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoLogForStorage;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.address,()=>message.address=common.ProtoAddress.deserialize(reader));break;case 2:reader.readMessage(message.topics,()=>pb_1.Message.addToRepeatedWrapperField(message,2,common.ProtoHash.deserialize(reader),common.ProtoHash));break;case 3:message.data=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoLogForStorage.deserialize(bytes)}}block.ProtoLogForStorage=ProtoLogForStorage;class ProtoLogsForStorage extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("logs"in data&&data.logs!=undefined){this.logs=data.logs}}}get logs(){return pb_1.Message.getRepeatedWrapperField(this,ProtoLogForStorage,1)}set logs(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoLogsForStorage({});if(data.logs!=null){message.logs=data.logs.map(item=>ProtoLogForStorage.fromObject(item))}return message}toObject(){const data={};if(this.logs!=null){data.logs=this.logs.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.logs.length)writer.writeRepeatedMessage(1,this.logs,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoLogsForStorage;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.logs,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoLogForStorage.deserialize(reader),ProtoLogForStorage));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoLogsForStorage.deserialize(bytes)}}block.ProtoLogsForStorage=ProtoLogsForStorage;class ProtoPendingHeader extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("wo"in data&&data.wo!=undefined){this.wo=data.wo}if("termini"in data&&data.termini!=undefined){this.termini=data.termini}}}get wo(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set wo(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_wo(){return pb_1.Message.getField(this,1)!=null}get termini(){return pb_1.Message.getWrapperField(this,ProtoTermini,2)}set termini(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_termini(){return pb_1.Message.getField(this,2)!=null}get _wo(){const cases={0:"none",1:"wo"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _termini(){const cases={0:"none",2:"termini"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoPendingHeader({});if(data.wo!=null){message.wo=ProtoWorkObject.fromObject(data.wo)}if(data.termini!=null){message.termini=ProtoTermini.fromObject(data.termini)}return message}toObject(){const data={};if(this.wo!=null){data.wo=this.wo.toObject()}if(this.termini!=null){data.termini=this.termini.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_wo)writer.writeMessage(1,this.wo,()=>this.wo.serialize(writer));if(this.has_termini)writer.writeMessage(2,this.termini,()=>this.termini.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoPendingHeader;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.wo,()=>message.wo=ProtoWorkObject.deserialize(reader));break;case 2:reader.readMessage(message.termini,()=>message.termini=ProtoTermini.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoPendingHeader.deserialize(bytes)}}block.ProtoPendingHeader=ProtoPendingHeader;class ProtoTermini extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1,2],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("dom_termini"in data&&data.dom_termini!=undefined){this.dom_termini=data.dom_termini}if("sub_termini"in data&&data.sub_termini!=undefined){this.sub_termini=data.sub_termini}}}get dom_termini(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,1)}set dom_termini(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}get sub_termini(){return pb_1.Message.getRepeatedWrapperField(this,common.ProtoHash,2)}set sub_termini(value){pb_1.Message.setRepeatedWrapperField(this,2,value)}static fromObject(data){const message=new ProtoTermini({});if(data.dom_termini!=null){message.dom_termini=data.dom_termini.map(item=>common.ProtoHash.fromObject(item))}if(data.sub_termini!=null){message.sub_termini=data.sub_termini.map(item=>common.ProtoHash.fromObject(item))}return message}toObject(){const data={};if(this.dom_termini!=null){data.dom_termini=this.dom_termini.map(item=>item.toObject())}if(this.sub_termini!=null){data.sub_termini=this.sub_termini.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.dom_termini.length)writer.writeRepeatedMessage(1,this.dom_termini,item=>item.serialize(writer));if(this.sub_termini.length)writer.writeRepeatedMessage(2,this.sub_termini,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTermini;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.dom_termini,()=>pb_1.Message.addToRepeatedWrapperField(message,1,common.ProtoHash.deserialize(reader),common.ProtoHash));break;case 2:reader.readMessage(message.sub_termini,()=>pb_1.Message.addToRepeatedWrapperField(message,2,common.ProtoHash.deserialize(reader),common.ProtoHash));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTermini.deserialize(bytes)}}block.ProtoTermini=ProtoTermini;class ProtoEtxSet extends pb_1.Message{#one_of_decls=[[1]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("etx_hashes"in data&&data.etx_hashes!=undefined){this.etx_hashes=data.etx_hashes}}}get etx_hashes(){return pb_1.Message.getFieldWithDefault(this,1,new Uint8Array(0))}set etx_hashes(value){pb_1.Message.setOneofField(this,1,this.#one_of_decls[0],value)}get has_etx_hashes(){return pb_1.Message.getField(this,1)!=null}get _etx_hashes(){const cases={0:"none",1:"etx_hashes"};return cases[pb_1.Message.computeOneofCase(this,[1])]}static fromObject(data){const message=new ProtoEtxSet({});if(data.etx_hashes!=null){message.etx_hashes=data.etx_hashes}return message}toObject(){const data={};if(this.etx_hashes!=null){data.etx_hashes=this.etx_hashes}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_etx_hashes)writer.writeBytes(1,this.etx_hashes);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoEtxSet;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.etx_hashes=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoEtxSet.deserialize(bytes)}}block.ProtoEtxSet=ProtoEtxSet;class ProtoPendingEtxs extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("header"in data&&data.header!=undefined){this.header=data.header}if("outbound_etxs"in data&&data.outbound_etxs!=undefined){this.outbound_etxs=data.outbound_etxs}}}get header(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set header(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_header(){return pb_1.Message.getField(this,1)!=null}get outbound_etxs(){return pb_1.Message.getWrapperField(this,ProtoTransactions,2)}set outbound_etxs(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_outbound_etxs(){return pb_1.Message.getField(this,2)!=null}get _header(){const cases={0:"none",1:"header"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _outbound_etxs(){const cases={0:"none",2:"outbound_etxs"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoPendingEtxs({});if(data.header!=null){message.header=ProtoWorkObject.fromObject(data.header)}if(data.outbound_etxs!=null){message.outbound_etxs=ProtoTransactions.fromObject(data.outbound_etxs)}return message}toObject(){const data={};if(this.header!=null){data.header=this.header.toObject()}if(this.outbound_etxs!=null){data.outbound_etxs=this.outbound_etxs.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_header)writer.writeMessage(1,this.header,()=>this.header.serialize(writer));if(this.has_outbound_etxs)writer.writeMessage(2,this.outbound_etxs,()=>this.outbound_etxs.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoPendingEtxs;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.header,()=>message.header=ProtoWorkObject.deserialize(reader));break;case 2:reader.readMessage(message.outbound_etxs,()=>message.outbound_etxs=ProtoTransactions.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoPendingEtxs.deserialize(bytes)}}block.ProtoPendingEtxs=ProtoPendingEtxs;class ProtoPendingEtxsRollup extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("header"in data&&data.header!=undefined){this.header=data.header}if("etxs_rollup"in data&&data.etxs_rollup!=undefined){this.etxs_rollup=data.etxs_rollup}}}get header(){return pb_1.Message.getWrapperField(this,ProtoWorkObject,1)}set header(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_header(){return pb_1.Message.getField(this,1)!=null}get etxs_rollup(){return pb_1.Message.getWrapperField(this,ProtoTransactions,2)}set etxs_rollup(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_etxs_rollup(){return pb_1.Message.getField(this,2)!=null}get _header(){const cases={0:"none",1:"header"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _etxs_rollup(){const cases={0:"none",2:"etxs_rollup"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoPendingEtxsRollup({});if(data.header!=null){message.header=ProtoWorkObject.fromObject(data.header)}if(data.etxs_rollup!=null){message.etxs_rollup=ProtoTransactions.fromObject(data.etxs_rollup)}return message}toObject(){const data={};if(this.header!=null){data.header=this.header.toObject()}if(this.etxs_rollup!=null){data.etxs_rollup=this.etxs_rollup.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_header)writer.writeMessage(1,this.header,()=>this.header.serialize(writer));if(this.has_etxs_rollup)writer.writeMessage(2,this.etxs_rollup,()=>this.etxs_rollup.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoPendingEtxsRollup;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.header,()=>message.header=ProtoWorkObject.deserialize(reader));break;case 2:reader.readMessage(message.etxs_rollup,()=>message.etxs_rollup=ProtoTransactions.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoPendingEtxsRollup.deserialize(bytes)}}block.ProtoPendingEtxsRollup=ProtoPendingEtxsRollup;class ProtoTxIns extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("tx_ins"in data&&data.tx_ins!=undefined){this.tx_ins=data.tx_ins}}}get tx_ins(){return pb_1.Message.getRepeatedWrapperField(this,ProtoTxIn,1)}set tx_ins(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoTxIns({});if(data.tx_ins!=null){message.tx_ins=data.tx_ins.map(item=>ProtoTxIn.fromObject(item))}return message}toObject(){const data={};if(this.tx_ins!=null){data.tx_ins=this.tx_ins.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.tx_ins.length)writer.writeRepeatedMessage(1,this.tx_ins,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTxIns;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.tx_ins,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoTxIn.deserialize(reader),ProtoTxIn));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTxIns.deserialize(bytes)}}block.ProtoTxIns=ProtoTxIns;class ProtoTxOuts extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("tx_outs"in data&&data.tx_outs!=undefined){this.tx_outs=data.tx_outs}}}get tx_outs(){return pb_1.Message.getRepeatedWrapperField(this,ProtoTxOut,1)}set tx_outs(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoTxOuts({});if(data.tx_outs!=null){message.tx_outs=data.tx_outs.map(item=>ProtoTxOut.fromObject(item))}return message}toObject(){const data={};if(this.tx_outs!=null){data.tx_outs=this.tx_outs.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.tx_outs.length)writer.writeRepeatedMessage(1,this.tx_outs,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTxOuts;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.tx_outs,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoTxOut.deserialize(reader),ProtoTxOut));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTxOuts.deserialize(bytes)}}block.ProtoTxOuts=ProtoTxOuts;class ProtoTxIn extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("previous_out_point"in data&&data.previous_out_point!=undefined){this.previous_out_point=data.previous_out_point}if("pub_key"in data&&data.pub_key!=undefined){this.pub_key=data.pub_key}}}get previous_out_point(){return pb_1.Message.getWrapperField(this,ProtoOutPoint,1)}set previous_out_point(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_previous_out_point(){return pb_1.Message.getField(this,1)!=null}get pub_key(){return pb_1.Message.getFieldWithDefault(this,2,new Uint8Array(0))}set pub_key(value){pb_1.Message.setOneofField(this,2,this.#one_of_decls[1],value)}get has_pub_key(){return pb_1.Message.getField(this,2)!=null}get _previous_out_point(){const cases={0:"none",1:"previous_out_point"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _pub_key(){const cases={0:"none",2:"pub_key"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoTxIn({});if(data.previous_out_point!=null){message.previous_out_point=ProtoOutPoint.fromObject(data.previous_out_point)}if(data.pub_key!=null){message.pub_key=data.pub_key}return message}toObject(){const data={};if(this.previous_out_point!=null){data.previous_out_point=this.previous_out_point.toObject()}if(this.pub_key!=null){data.pub_key=this.pub_key}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_previous_out_point)writer.writeMessage(1,this.previous_out_point,()=>this.previous_out_point.serialize(writer));if(this.has_pub_key)writer.writeBytes(2,this.pub_key);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTxIn;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.previous_out_point,()=>message.previous_out_point=ProtoOutPoint.deserialize(reader));break;case 2:message.pub_key=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTxIn.deserialize(bytes)}}block.ProtoTxIn=ProtoTxIn;class ProtoOutPoint extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("hash"in data&&data.hash!=undefined){this.hash=data.hash}if("index"in data&&data.index!=undefined){this.index=data.index}}}get hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,1)}set hash(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_hash(){return pb_1.Message.getField(this,1)!=null}get index(){return pb_1.Message.getFieldWithDefault(this,2,0)}set index(value){pb_1.Message.setOneofField(this,2,this.#one_of_decls[1],value)}get has_index(){return pb_1.Message.getField(this,2)!=null}get _hash(){const cases={0:"none",1:"hash"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _index(){const cases={0:"none",2:"index"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoOutPoint({});if(data.hash!=null){message.hash=common.ProtoHash.fromObject(data.hash)}if(data.index!=null){message.index=data.index}return message}toObject(){const data={};if(this.hash!=null){data.hash=this.hash.toObject()}if(this.index!=null){data.index=this.index}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_hash)writer.writeMessage(1,this.hash,()=>this.hash.serialize(writer));if(this.has_index)writer.writeUint32(2,this.index);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoOutPoint;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.hash,()=>message.hash=common.ProtoHash.deserialize(reader));break;case 2:message.index=reader.readUint32();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoOutPoint.deserialize(bytes)}}block.ProtoOutPoint=ProtoOutPoint;class ProtoTxOut extends pb_1.Message{#one_of_decls=[[1],[2],[3]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("denomination"in data&&data.denomination!=undefined){this.denomination=data.denomination}if("address"in data&&data.address!=undefined){this.address=data.address}if("lock"in data&&data.lock!=undefined){this.lock=data.lock}}}get denomination(){return pb_1.Message.getFieldWithDefault(this,1,0)}set denomination(value){pb_1.Message.setOneofField(this,1,this.#one_of_decls[0],value)}get has_denomination(){return pb_1.Message.getField(this,1)!=null}get address(){return pb_1.Message.getFieldWithDefault(this,2,new Uint8Array(0))}set address(value){pb_1.Message.setOneofField(this,2,this.#one_of_decls[1],value)}get has_address(){return pb_1.Message.getField(this,2)!=null}get lock(){return pb_1.Message.getFieldWithDefault(this,3,new Uint8Array(0))}set lock(value){pb_1.Message.setOneofField(this,3,this.#one_of_decls[2],value)}get has_lock(){return pb_1.Message.getField(this,3)!=null}get _denomination(){const cases={0:"none",1:"denomination"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _address(){const cases={0:"none",2:"address"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _lock(){const cases={0:"none",3:"lock"};return cases[pb_1.Message.computeOneofCase(this,[3])]}static fromObject(data){const message=new ProtoTxOut({});if(data.denomination!=null){message.denomination=data.denomination}if(data.address!=null){message.address=data.address}if(data.lock!=null){message.lock=data.lock}return message}toObject(){const data={};if(this.denomination!=null){data.denomination=this.denomination}if(this.address!=null){data.address=this.address}if(this.lock!=null){data.lock=this.lock}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_denomination)writer.writeUint32(1,this.denomination);if(this.has_address)writer.writeBytes(2,this.address);if(this.has_lock)writer.writeBytes(3,this.lock);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoTxOut;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:message.denomination=reader.readUint32();break;case 2:message.address=reader.readBytes();break;case 3:message.lock=reader.readBytes();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoTxOut.deserialize(bytes)}}block.ProtoTxOut=ProtoTxOut;class ProtoOutPointAndDenomination extends pb_1.Message{#one_of_decls=[[1],[2],[3]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("hash"in data&&data.hash!=undefined){this.hash=data.hash}if("index"in data&&data.index!=undefined){this.index=data.index}if("denomination"in data&&data.denomination!=undefined){this.denomination=data.denomination}}}get hash(){return pb_1.Message.getWrapperField(this,common.ProtoHash,1)}set hash(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_hash(){return pb_1.Message.getField(this,1)!=null}get index(){return pb_1.Message.getFieldWithDefault(this,2,0)}set index(value){pb_1.Message.setOneofField(this,2,this.#one_of_decls[1],value)}get has_index(){return pb_1.Message.getField(this,2)!=null}get denomination(){return pb_1.Message.getFieldWithDefault(this,3,0)}set denomination(value){pb_1.Message.setOneofField(this,3,this.#one_of_decls[2],value)}get has_denomination(){return pb_1.Message.getField(this,3)!=null}get _hash(){const cases={0:"none",1:"hash"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _index(){const cases={0:"none",2:"index"};return cases[pb_1.Message.computeOneofCase(this,[2])]}get _denomination(){const cases={0:"none",3:"denomination"};return cases[pb_1.Message.computeOneofCase(this,[3])]}static fromObject(data){const message=new ProtoOutPointAndDenomination({});if(data.hash!=null){message.hash=common.ProtoHash.fromObject(data.hash)}if(data.index!=null){message.index=data.index}if(data.denomination!=null){message.denomination=data.denomination}return message}toObject(){const data={};if(this.hash!=null){data.hash=this.hash.toObject()}if(this.index!=null){data.index=this.index}if(this.denomination!=null){data.denomination=this.denomination}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_hash)writer.writeMessage(1,this.hash,()=>this.hash.serialize(writer));if(this.has_index)writer.writeUint32(2,this.index);if(this.has_denomination)writer.writeUint32(3,this.denomination);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoOutPointAndDenomination;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.hash,()=>message.hash=common.ProtoHash.deserialize(reader));break;case 2:message.index=reader.readUint32();break;case 3:message.denomination=reader.readUint32();break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoOutPointAndDenomination.deserialize(bytes)}}block.ProtoOutPointAndDenomination=ProtoOutPointAndDenomination;class ProtoAddressOutPoints extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("out_points"in data&&data.out_points!=undefined){this.out_points=data.out_points}}if(!this.out_points)this.out_points=new Map}get out_points(){return pb_1.Message.getField(this,1)}set out_points(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoAddressOutPoints({});if(typeof data.out_points=="object"){message.out_points=new Map(Object.entries(data.out_points).map(([key,value])=>[key,ProtoOutPointAndDenomination.fromObject(value)]))}return message}toObject(){const data={};if(this.out_points!=null){data.out_points=Object.fromEntries(Array.from(this.out_points).map(([key,value])=>[key,value.toObject()]))}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;for(const[key,value]of this.out_points){writer.writeMessage(1,this.out_points,()=>{writer.writeString(1,key);writer.writeMessage(2,value,()=>value.serialize(writer))})}if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoAddressOutPoints;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message,()=>pb_1.Map.deserializeBinary(message.out_points,reader,reader.readString,()=>{let value;reader.readMessage(message,()=>value=ProtoOutPointAndDenomination.deserialize(reader));return value}));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoAddressOutPoints.deserialize(bytes)}}block.ProtoAddressOutPoints=ProtoAddressOutPoints;class ProtoOutPointsMap extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("entries"in data&&data.entries!=undefined){this.entries=data.entries}}if(!this.entries)this.entries=new Map}get entries(){return pb_1.Message.getField(this,1)}set entries(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoOutPointsMap({});if(typeof data.entries=="object"){message.entries=new Map(Object.entries(data.entries).map(([key,value])=>[key,ProtoAddressOutPoints.fromObject(value)]))}return message}toObject(){const data={};if(this.entries!=null){data.entries=Object.fromEntries(Array.from(this.entries).map(([key,value])=>[key,value.toObject()]))}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;for(const[key,value]of this.entries){writer.writeMessage(1,this.entries,()=>{writer.writeString(1,key);writer.writeMessage(2,value,()=>value.serialize(writer))})}if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoOutPointsMap;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message,()=>pb_1.Map.deserializeBinary(message.entries,reader,reader.readString,()=>{let value;reader.readMessage(message,()=>value=ProtoAddressOutPoints.deserialize(reader));return value}));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoOutPointsMap.deserialize(bytes)}}block.ProtoOutPointsMap=ProtoOutPointsMap;class ProtoSpentUTXO extends pb_1.Message{#one_of_decls=[[1],[2]];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("outpoint"in data&&data.outpoint!=undefined){this.outpoint=data.outpoint}if("sutxo"in data&&data.sutxo!=undefined){this.sutxo=data.sutxo}}}get outpoint(){return pb_1.Message.getWrapperField(this,ProtoOutPoint,1)}set outpoint(value){pb_1.Message.setOneofWrapperField(this,1,this.#one_of_decls[0],value)}get has_outpoint(){return pb_1.Message.getField(this,1)!=null}get sutxo(){return pb_1.Message.getWrapperField(this,ProtoTxOut,2)}set sutxo(value){pb_1.Message.setOneofWrapperField(this,2,this.#one_of_decls[1],value)}get has_sutxo(){return pb_1.Message.getField(this,2)!=null}get _outpoint(){const cases={0:"none",1:"outpoint"};return cases[pb_1.Message.computeOneofCase(this,[1])]}get _sutxo(){const cases={0:"none",2:"sutxo"};return cases[pb_1.Message.computeOneofCase(this,[2])]}static fromObject(data){const message=new ProtoSpentUTXO({});if(data.outpoint!=null){message.outpoint=ProtoOutPoint.fromObject(data.outpoint)}if(data.sutxo!=null){message.sutxo=ProtoTxOut.fromObject(data.sutxo)}return message}toObject(){const data={};if(this.outpoint!=null){data.outpoint=this.outpoint.toObject()}if(this.sutxo!=null){data.sutxo=this.sutxo.toObject()}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.has_outpoint)writer.writeMessage(1,this.outpoint,()=>this.outpoint.serialize(writer));if(this.has_sutxo)writer.writeMessage(2,this.sutxo,()=>this.sutxo.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoSpentUTXO;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.outpoint,()=>message.outpoint=ProtoOutPoint.deserialize(reader));break;case 2:reader.readMessage(message.sutxo,()=>message.sutxo=ProtoTxOut.deserialize(reader));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoSpentUTXO.deserialize(bytes)}}block.ProtoSpentUTXO=ProtoSpentUTXO;class ProtoSpentUTXOs extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("sutxos"in data&&data.sutxos!=undefined){this.sutxos=data.sutxos}}}get sutxos(){return pb_1.Message.getRepeatedWrapperField(this,ProtoSpentUTXO,1)}set sutxos(value){pb_1.Message.setRepeatedWrapperField(this,1,value)}static fromObject(data){const message=new ProtoSpentUTXOs({});if(data.sutxos!=null){message.sutxos=data.sutxos.map(item=>ProtoSpentUTXO.fromObject(item))}return message}toObject(){const data={};if(this.sutxos!=null){data.sutxos=this.sutxos.map(item=>item.toObject())}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.sutxos.length)writer.writeRepeatedMessage(1,this.sutxos,item=>item.serialize(writer));if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoSpentUTXOs;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:reader.readMessage(message.sutxos,()=>pb_1.Message.addToRepeatedWrapperField(message,1,ProtoSpentUTXO.deserialize(reader),ProtoSpentUTXO));break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoSpentUTXOs.deserialize(bytes)}}block.ProtoSpentUTXOs=ProtoSpentUTXOs;class ProtoKeys extends pb_1.Message{#one_of_decls=[];constructor(data){super();pb_1.Message.initialize(this,Array.isArray(data)?data:[],0,-1,[1],this.#one_of_decls);if(!Array.isArray(data)&&typeof data=="object"){if("keys"in data&&data.keys!=undefined){this.keys=data.keys}}}get keys(){return pb_1.Message.getFieldWithDefault(this,1,[])}set keys(value){pb_1.Message.setField(this,1,value)}static fromObject(data){const message=new ProtoKeys({});if(data.keys!=null){message.keys=data.keys}return message}toObject(){const data={};if(this.keys!=null){data.keys=this.keys}return data}serialize(w){const writer=w||new pb_1.BinaryWriter;if(this.keys.length)writer.writeRepeatedBytes(1,this.keys);if(!w)return writer.getResultBuffer()}static deserialize(bytes){const reader=bytes instanceof pb_1.BinaryReader?bytes:new pb_1.BinaryReader(bytes),message=new ProtoKeys;while(reader.nextField()){if(reader.isEndGroup())break;switch(reader.getFieldNumber()){case 1:pb_1.Message.addToRepeatedField(message,1,reader.readBytes());break;default:reader.skipField()}}return message}serializeBinary(){return this.serialize()}static deserializeBinary(bytes){return ProtoKeys.deserialize(bytes)}}block.ProtoKeys=ProtoKeys})(block||(block={}));function encodeProtoTransaction(protoTx){const tx=block.ProtoTransaction.fromObject(protoTx);return hexlify(tx.serialize())}function decodeProtoTransaction(bytes){const tx=block.ProtoTransaction.deserialize(bytes);const result=tx.toObject();if(result.to?.length==0){result.to=null}return result}function errorFunc(reason,offset,bytes,output,badCodepoint){assertArgument(false,`invalid codepoint at offset ${offset}; ${reason}`,"bytes",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason==="BAD_PREFIX"||reason==="UNEXPECTED_CONTINUE"){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason==="OVERRUN"){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason==="OVERLONG"){assertArgument(typeof badCodepoint==="number","invalid bad code point for replacement","badCodepoint",badCodepoint);output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(_bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}const bytes=getBytes(_bytes,"bytes");const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError("UNEXPECTED_CONTINUE",i-1,bytes,result)}else{i+=onError("BAD_PREFIX",i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError("OVERRUN",i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){const nextChar=bytes[i];if((nextChar&192)!=128){i+=onError("MISSING_CONTINUE",i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError("OUT_OF_RANGE",i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError("UTF16_SURROGATE",i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError("OVERLONG",i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form){if(form!=null){assertNormalize(form);str=str.normalize(form)}const result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);assertArgument(i<str.length&&(c2&64512)===56320,"invalid surrogate pair","str",str);const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return new Uint8Array(result)}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join("")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function toUtf8CodePoints(str,form){return getUtf8CodePoints(toUtf8Bytes(str,form))}function createGetUrl(options){async function getUrl(req,_signal){const protocol=req.url.split(":")[0].toLowerCase();assert$1(protocol==="http"||protocol==="https",`unsupported protocol ${protocol}`,"UNSUPPORTED_OPERATION",{info:{protocol:protocol},operation:"request"});assert$1(protocol==="https"||!req.credentials||req.allowInsecureAuthentication,"insecure authorized connections unsupported","UNSUPPORTED_OPERATION",{operation:"request"});let signal=undefined;if(_signal){const controller=new AbortController;signal=controller.signal;_signal.addListener(()=>{controller.abort()})}const init={method:req.method,headers:new Headers(Array.from(req)),body:req.body||undefined,signal:signal};const resp=await fetch(req.url,init);const headers={};resp.headers.forEach((value,key)=>{headers[key.toLowerCase()]=value});const respBody=await resp.arrayBuffer();const body=respBody==null?null:new Uint8Array(respBody);return{statusCode:resp.status,statusMessage:resp.statusText,headers:headers,body:body}}return getUrl}const MAX_ATTEMPTS=12;const SLOT_INTERVAL=250;let defaultGetUrlFunc=createGetUrl();const reData=new RegExp("^data:([^;:]*)?(;base64)?,(.*)$","i");const reIpfs=new RegExp("^ipfs://(ipfs/)?(.*)$","i");let locked$5=false;async function dataGatewayFunc(url,signal){try{const match=url.match(reData);if(!match){throw new Error("invalid data")}return new FetchResponse(200,"OK",{"content-type":match[1]||"text/plain"},match[2]?decodeBase64(match[3]):unpercent(match[3]))}catch(error){return new FetchResponse(599,"BAD REQUEST (invalid data: URI)",{},null,new FetchRequest(url))}}function getIpfsGatewayFunc(baseUrl){async function gatewayIpfs(url,signal){try{const match=url.match(reIpfs);if(!match){throw new Error("invalid link")}return new FetchRequest(`${baseUrl}${match[2]}`)}catch(error){return new FetchResponse(599,"BAD REQUEST (invalid IPFS URI)",{},null,new FetchRequest(url))}}return gatewayIpfs}const Gateways={data:dataGatewayFunc,ipfs:getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")};const fetchSignals=new WeakMap;class FetchCancelSignal{#listeners;#cancelled;constructor(request){this.#listeners=[];this.#cancelled=false;fetchSignals.set(request,()=>{if(this.#cancelled){return}this.#cancelled=true;for(const listener of this.#listeners){setTimeout(()=>{listener()},0)}this.#listeners=[]})}addListener(listener){assert$1(!this.#cancelled,"singal already cancelled","UNSUPPORTED_OPERATION",{operation:"fetchCancelSignal.addCancelListener"});this.#listeners.push(listener)}get cancelled(){return this.#cancelled}checkSignal(){assert$1(!this.cancelled,"cancelled","CANCELLED",{})}}function checkSignal(signal){if(signal==null){throw new Error("missing signal; should not happen")}signal.checkSignal();return signal}class FetchRequest{#allowInsecure;#gzip;#headers;#method;#timeout;#url;#body;#bodyType;#creds;#preflight;#process;#retry;#signal;#throttle;#getUrlFunc;get url(){return this.#url}set url(url){this.#url=String(url)}get body(){if(this.#body==null){return null}return new Uint8Array(this.#body)}set body(body){if(body==null){this.#body=undefined;this.#bodyType=undefined}else if(typeof body==="string"){this.#body=toUtf8Bytes(body);this.#bodyType="text/plain"}else if(body instanceof Uint8Array){this.#body=body;this.#bodyType="application/octet-stream"}else if(typeof body==="object"){this.#body=toUtf8Bytes(JSON.stringify(body));this.#bodyType="application/json"}else{throw new Error("invalid body")}}hasBody(){return this.#body!=null}get method(){if(this.#method){return this.#method}if(this.hasBody()){return"POST"}return"GET"}set method(method){if(method==null){method=""}this.#method=String(method).toUpperCase()}get headers(){const headers=Object.assign({},this.#headers);if(this.#creds){headers["authorization"]=`Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`}if(this.allowGzip){headers["accept-encoding"]="gzip"}if(headers["content-type"]==null&&this.#bodyType){headers["content-type"]=this.#bodyType}if(this.body){headers["content-length"]=String(this.body.length)}return headers}getHeader(key){return this.headers[key.toLowerCase()]}setHeader(key,value){this.#headers[String(key).toLowerCase()]=String(value)}clearHeaders(){this.#headers={}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}get credentials(){return this.#creds||null}setCredentials(username,password){assertArgument(!username.match(/:/),"invalid basic authentication username","username","[REDACTED]");this.#creds=`${username}:${password}`}get allowGzip(){return this.#gzip}set allowGzip(value){this.#gzip=!!value}get allowInsecureAuthentication(){return!!this.#allowInsecure}set allowInsecureAuthentication(value){this.#allowInsecure=!!value}get timeout(){return this.#timeout}set timeout(timeout){assertArgument(timeout>=0,"timeout must be non-zero","timeout",timeout);this.#timeout=timeout}get preflightFunc(){return this.#preflight||null}set preflightFunc(preflight){this.#preflight=preflight}get processFunc(){return this.#process||null}set processFunc(process){this.#process=process}get retryFunc(){return this.#retry||null}set retryFunc(retry){this.#retry=retry}get getUrlFunc(){return this.#getUrlFunc||defaultGetUrlFunc}set getUrlFunc(value){this.#getUrlFunc=value}constructor(url){this.#url=String(url);this.#allowInsecure=false;this.#gzip=true;this.#headers={};this.#method="";this.#timeout=3e5;this.#throttle={slotInterval:SLOT_INTERVAL,maxAttempts:MAX_ATTEMPTS};this.#getUrlFunc=null}toString(){return`<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body?hexlify(this.#body):"null"}>`}setThrottleParams(params){if(params.slotInterval!=null){this.#throttle.slotInterval=params.slotInterval}if(params.maxAttempts!=null){this.#throttle.maxAttempts=params.maxAttempts}}async#send(attempt,expires,delay,_request,_response){if(attempt>=this.#throttle.maxAttempts){return _response.makeServerError("exceeded maximum retry limit")}assert$1(getTime$1()<=expires,"timeout","TIMEOUT",{operation:"request.send",reason:"timeout",request:_request});if(delay>0){await wait(delay)}let req=this.clone();const scheme=(req.url.split(":")[0]||"").toLowerCase();if(scheme in Gateways){const result=await Gateways[scheme](req.url,checkSignal(_request.#signal));if(result instanceof FetchResponse){let response=result;if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!=="number"){response.makeServerError("error in post-processing function",error).assertOk()}}}return response}req=result}if(this.preflightFunc){req=await this.preflightFunc(req)}const resp=await this.getUrlFunc(req,checkSignal(_request.#signal));let response=new FetchResponse(resp.statusCode,resp.statusMessage,resp.headers,resp.body,_request);if(response.statusCode===301||response.statusCode===302){try{const location=response.headers.location||"";return req.redirect(location).#send(attempt+1,expires,0,_request,response)}catch(error){}return response}else if(response.statusCode===429){if(this.retryFunc==null||await this.retryFunc(req,response,attempt)){const retryAfter=response.headers["retry-after"];let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(typeof retryAfter==="string"&&retryAfter.match(/^[1-9][0-9]*$/)){delay=parseInt(retryAfter)}return req.clone().#send(attempt+1,expires,delay,_request,response)}}if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!=="number"){response.makeServerError("error in post-processing function",error).assertOk()}let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(error.stall>=0){delay=error.stall}return req.clone().#send(attempt+1,expires,delay,_request,response)}}return response}send(){assert$1(this.#signal==null,"request already sent","UNSUPPORTED_OPERATION",{operation:"fetchRequest.send"});this.#signal=new FetchCancelSignal(this);return this.#send(0,getTime$1()+this.timeout,0,this,new FetchResponse(0,"",{},null,this))}cancel(){assert$1(this.#signal!=null,"request has not been sent","UNSUPPORTED_OPERATION",{operation:"fetchRequest.cancel"});const signal=fetchSignals.get(this);if(!signal){throw new Error("missing signal; should not happen")}signal()}redirect(location){const current=this.url.split(":")[0].toLowerCase();const target=location.split(":")[0].toLowerCase();assert$1(this.method==="GET"&&(current!=="https"||target!=="http")&&location.match(/^https?:/),`unsupported redirect`,"UNSUPPORTED_OPERATION",{operation:`redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`});const req=new FetchRequest(location);req.method="GET";req.allowGzip=this.allowGzip;req.timeout=this.timeout;req.#headers=Object.assign({},this.#headers);if(this.#body){req.#body=new Uint8Array(this.#body)}req.#bodyType=this.#bodyType;return req}clone(){const clone=new FetchRequest(this.url);clone.#method=this.#method;if(this.#body){clone.#body=this.#body}clone.#bodyType=this.#bodyType;clone.#headers=Object.assign({},this.#headers);clone.#creds=this.#creds;if(this.allowGzip){clone.allowGzip=true}clone.timeout=this.timeout;if(this.allowInsecureAuthentication){clone.allowInsecureAuthentication=true}clone.#preflight=this.#preflight;clone.#process=this.#process;clone.#retry=this.#retry;clone.#getUrlFunc=this.#getUrlFunc;return clone}static lockConfig(){locked$5=true}static getGateway(scheme){return Gateways[scheme.toLowerCase()]||null}static registerGateway(scheme,func){scheme=scheme.toLowerCase();if(scheme==="http"||scheme==="https"){throw new Error(`cannot intercept ${scheme}; use registerGetUrl`)}if(locked$5){throw new Error("gateways locked")}Gateways[scheme]=func}static registerGetUrl(getUrl){if(locked$5){throw new Error("gateways locked")}defaultGetUrlFunc=getUrl}static createGetUrlFunc(options){return createGetUrl()}static createDataGateway(){return dataGatewayFunc}static createIpfsGatewayFunc(baseUrl){return getIpfsGatewayFunc(baseUrl)}}class FetchResponse{#statusCode;#statusMessage;#headers;#body;#request;#error;toString(){return`<FetchResponse status=${this.statusCode} body=${this.#body?hexlify(this.#body):"null"}>`}get statusCode(){return this.#statusCode}get statusMessage(){return this.#statusMessage}get headers(){return Object.assign({},this.#headers)}get body(){return this.#body==null?null:new Uint8Array(this.#body)}get bodyText(){try{return this.#body==null?"":toUtf8String(this.#body)}catch(error){assert$1(false,"response body is not valid UTF-8 data","UNSUPPORTED_OPERATION",{operation:"bodyText",info:{response:this}})}}get bodyJson(){try{return JSON.parse(this.bodyText)}catch(error){assert$1(false,"response body is not valid JSON","UNSUPPORTED_OPERATION",{operation:"bodyJson",info:{response:this}})}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}constructor(statusCode,statusMessage,headers,body,request){this.#statusCode=statusCode;this.#statusMessage=statusMessage;this.#headers=Object.keys(headers).reduce((accum,k)=>{accum[k.toLowerCase()]=String(headers[k]);return accum},{});this.#body=body==null?null:new Uint8Array(body);this.#request=request||null;this.#error={message:""}}makeServerError(message,error){let statusMessage;if(!message){message=`${this.statusCode} ${this.statusMessage}`;statusMessage=`CLIENT ESCALATED SERVER ERROR (${message})`}else{statusMessage=`CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`}const response=new FetchResponse(599,statusMessage,this.headers,this.body,this.#request||undefined);response.#error={message:message,error:error};return response}throwThrottleError(message,stall){if(stall==null){stall=-1}else{assertArgument(Number.isInteger(stall)&&stall>=0,"invalid stall timeout","stall",stall)}const error=new Error(message||"throttling requests");defineProperties(error,{stall:stall,throttle:true});throw error}getHeader(key){return this.headers[key.toLowerCase()]}hasBody(){return this.#body!=null}get request(){return this.#request}ok(){return this.#error.message===""&&this.statusCode>=200&&this.statusCode<300}assertOk(){if(this.ok()){return}let{message,error}=this.#error;if(message===""){message=`server response ${this.statusCode} ${this.statusMessage}`}assert$1(false,message,"SERVER_ERROR",{request:this.request||"unknown request",response:this,error:error})}}function getTime$1(){return(new Date).getTime()}function unpercent(value){return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi,(all,code)=>{return String.fromCharCode(parseInt(code,16))}))}function wait(delay){return new Promise(resolve=>setTimeout(resolve,delay))}const BN_N1=BigInt(-1);const BN_0$6=BigInt(0);const BN_1$3=BigInt(1);const BN_5=BigInt(5);const _guard$7={};let Zeros="0000";while(Zeros.length<80){Zeros+=Zeros}function getTens(decimals){let result=Zeros;while(result.length<decimals){result+=result}return BigInt("1"+result.substring(0,decimals))}function checkValue(val,format,safeOp){const width=BigInt(format.width);if(format.signed){const limit=BN_1$3<<width-BN_1$3;assert$1(safeOp==null||val>=-limit&&val<limit,"overflow","NUMERIC_FAULT",{operation:safeOp,fault:"overflow",value:val});if(val>BN_0$6){val=fromTwos(mask(val,width),width)}else{val=-fromTwos(mask(-val,width),width)}}else{const limit=BN_1$3<<width;assert$1(safeOp==null||val>=0&&val<limit,"overflow","NUMERIC_FAULT",{operation:safeOp,fault:"overflow",value:val});val=(val%limit+limit)%limit&limit-BN_1$3}return val}function getFormat(value){if(typeof value==="number"){value=`fixed128x${value}`}let signed=true;let width=128;let decimals=18;if(typeof value==="string"){if(value==="fixed");else if(value==="ufixed"){signed=false}else{const match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);assertArgument(match,"invalid fixed format","format",value);signed=match[1]!=="u";width=parseInt(match[2]);decimals=parseInt(match[3])}}else if(value){const v=value;const check=(key,type,defaultValue)=>{if(v[key]==null){return defaultValue}assertArgument(typeof v[key]===type,"invalid fixed format ("+key+" not "+type+")","format."+key,v[key]);return v[key]};signed=check("signed","boolean",signed);width=check("width","number",width);decimals=check("decimals","number",decimals)}assertArgument(width%8===0,"invalid FixedNumber width (not byte aligned)","format.width",width);assertArgument(decimals<=80,"invalid FixedNumber decimals (too large)","format.decimals",decimals);const name=(signed?"":"u")+"fixed"+String(width)+"x"+String(decimals);return{signed:signed,width:width,decimals:decimals,name:name}}function toString(val,decimals){let negative="";if(val<BN_0$6){negative="-";val*=BN_N1}let str=val.toString();if(decimals===0){return negative+str}while(str.length<=decimals){str=Zeros+str}const index=str.length-decimals;str=str.substring(0,index)+"."+str.substring(index);while(str[0]==="0"&&str[1]!=="."){str=str.substring(1)}while(str[str.length-1]==="0"&&str[str.length-2]!=="."){str=str.substring(0,str.length-1)}return negative+str}class FixedNumber{format;#format;#val;#tens;_value;constructor(guard,value,format){assertPrivate(guard,_guard$7,"FixedNumber");this.#val=value;this.#format=format;const _value=toString(value,format.decimals);defineProperties(this,{format:format.name,_value:_value});this.#tens=getTens(format.decimals)}get signed(){return this.#format.signed}get width(){return this.#format.width}get decimals(){return this.#format.decimals}get value(){return this.#val}#checkFormat(other){assertArgument(this.format===other.format,"incompatible format; use fixedNumber.toFormat","other",other)}#checkValue(val,safeOp){val=checkValue(val,this.#format,safeOp);return new FixedNumber(_guard$7,val,this.#format)}#add(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val+o.#val,safeOp)}addUnsafe(other){return this.#add(other)}add(other){return this.#add(other,"add")}#sub(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val-o.#val,safeOp)}subUnsafe(other){return this.#sub(other)}sub(other){return this.#sub(other,"sub")}#mul(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val*o.#val/this.#tens,safeOp)}mulUnsafe(other){return this.#mul(other)}mul(other){return this.#mul(other,"mul")}mulSignal(other){this.#checkFormat(other);const value=this.#val*other.#val;assert$1(value%this.#tens===BN_0$6,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this});return this.#checkValue(value/this.#tens,"mulSignal")}#div(o,safeOp){assert$1(o.#val!==BN_0$6,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this});this.#checkFormat(o);return this.#checkValue(this.#val*this.#tens/o.#val,safeOp)}divUnsafe(other){return this.#div(other)}div(other){return this.#div(other,"div")}divSignal(other){assert$1(other.#val!==BN_0$6,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this});this.#checkFormat(other);const value=this.#val*this.#tens;assert$1(value%other.#val===BN_0$6,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this});return this.#checkValue(value/other.#val,"divSignal")}cmp(other){let a=this.value,b=other.value;const delta=this.decimals-other.decimals;if(delta>0){b*=getTens(delta)}else if(delta<0){a*=getTens(-delta)}if(a<b){return-1}if(a>b){return 1}return 0}eq(other){return this.cmp(other)===0}lt(other){return this.cmp(other)<0}lte(other){return this.cmp(other)<=0}gt(other){return this.cmp(other)>0}gte(other){return this.cmp(other)>=0}floor(){let val=this.#val;if(this.#val<BN_0$6){val-=this.#tens-BN_1$3}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,"floor")}ceiling(){let val=this.#val;if(this.#val>BN_0$6){val+=this.#tens-BN_1$3}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,"ceiling")}round(decimals){if(decimals==null){decimals=0}if(decimals>=this.decimals){return this}const delta=this.decimals-decimals;const bump=BN_5*getTens(delta-1);let value=this.value+bump;const tens=getTens(delta);value=value/tens*tens;checkValue(value,this.#format,"round");return new FixedNumber(_guard$7,value,this.#format)}isZero(){return this.#val===BN_0$6}isNegative(){return this.#val<BN_0$6}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(format){return FixedNumber.fromString(this.toString(),format)}static fromValue(_value,_decimals,_format){const decimals=_decimals==null?0:getNumber(_decimals);const format=getFormat(_format);let value=getBigInt(_value,"value");const delta=decimals-format.decimals;if(delta>0){const tens=getTens(delta);assert$1(value%tens===BN_0$6,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:_value});value/=tens}else if(delta<0){value*=getTens(-delta)}checkValue(value,format,"fromValue");return new FixedNumber(_guard$7,value,format)}static fromString(_value,_format){const match=_value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);assertArgument(match&&match[2].length+match[3].length>0,"invalid FixedNumber string value","value",_value);const format=getFormat(_format);const whole=match[2]||"0";let decimal=match[3]||"";while(decimal.length<format.decimals){decimal+=Zeros}assert$1(decimal.substring(format.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:_value});decimal=decimal.substring(0,format.decimals);const value=BigInt(match[1]+whole+decimal);checkValue(value,format,"fromString");return new FixedNumber(_guard$7,value,format)}static fromBytes(_value,_format){let value=toBigInt(getBytes(_value,"value"));const format=getFormat(_format);if(format.signed){value=fromTwos(value,format.width)}checkValue(value,format,"fromBytes");return new FixedNumber(_guard$7,value,format)}}const names=["wei","kwei","mwei","gwei","szabo","finney","ether"];function formatUnits(value,unit){let decimals=18;if(typeof unit==="string"){const index=names.indexOf(unit);assertArgument(index>=0,"invalid unit","unit",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,"unit")}return FixedNumber.fromValue(value,decimals,{decimals:decimals,width:512}).toString()}function parseUnits(value,unit){assertArgument(typeof value==="string","value must be a string","value",value);let decimals=18;if(typeof unit==="string"){const index=names.indexOf(unit);assertArgument(index>=0,"invalid unit","unit",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,"unit")}return FixedNumber.fromString(value,{decimals:decimals,width:512}).value}function formatQuai(wei){return formatUnits(wei,18)}function formatQi(value){return formatUnits(value,3)}function parseQuai(ether){return parseUnits(ether,18)}function parseQi(value){return parseUnits(value,3)}function uuidV4(randomBytes){const bytes=getBytes(randomBytes,"randomBytes");bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;const value=hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join("-")}var Zone;(function(Zone){Zone["Cyprus1"]="0x00";Zone["Cyprus2"]="0x01";Zone["Cyprus3"]="0x02";Zone["Paxos1"]="0x10";Zone["Paxos2"]="0x11";Zone["Paxos3"]="0x12";Zone["Hydra1"]="0x20";Zone["Hydra2"]="0x21";Zone["Hydra3"]="0x22"})(Zone||(Zone={}));var Ledger;(function(Ledger){Ledger[Ledger["Quai"]=0]="Quai";Ledger[Ledger["Qi"]=1]="Qi"})(Ledger||(Ledger={}));function zoneFromBytes(zone){switch(zone){case"0x00":return Zone.Cyprus1;case"0x01":return Zone.Cyprus2;case"0x02":return Zone.Cyprus3;case"0x10":return Zone.Paxos1;case"0x11":return Zone.Paxos2;case"0x12":return Zone.Paxos3;case"0x20":return Zone.Hydra1;case"0x21":return Zone.Hydra2;case"0x22":return Zone.Hydra3;default:throw new Error(`Invalid zone: ${zone}`)}}const ZoneData=[{name:"Cyprus One",nickname:"cyprus1",shard:"zone-0-0",context:2,byte:"0x00"},{name:"Cyprus Two",nickname:"cyprus2",shard:"zone-0-1",context:2,byte:"0x01"},{name:"Cyprus Three",nickname:"cyprus3",shard:"zone-0-2",context:2,byte:"0x02"},{name:"Paxos One",nickname:"paxos1",shard:"zone-1-0",context:2,byte:"0x10"},{name:"Paxos Two",nickname:"paxos2",shard:"zone-1-1",context:2,byte:"0x11"},{name:"Paxos Three",nickname:"paxos3",shard:"zone-1-2",context:2,byte:"0x12"},{name:"Hydra One",nickname:"hydra1",shard:"zone-2-0",context:2,byte:"0x20"},{name:"Hydra Two",nickname:"hydra2",shard:"zone-2-1",context:2,byte:"0x21"},{name:"Hydra Three",nickname:"hydra3",shard:"zone-2-2",context:2,byte:"0x22"}];function toZone(shard){return zoneFromBytes(ZoneData.find(it=>it.name==shard||it.byte==shard||it.nickname==shard||it.shard==shard)?.byte||"")}function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes(b,...lengths){if(!(b instanceof Uint8Array))throw new Error("Expected Uint8Array");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)}function hash(hash){if(typeof hash!=="function"||typeof hash.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number(hash.outputLen);number(hash.blockLen)}function exists(instance,checkFinished=true){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min){throw new Error(`digestInto() expects output buffer of length at least ${min}`)}}const crypto$1=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:undefined;const u8a$1=a=>a instanceof Uint8Array;const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);const rotr=(word,shift)=>word<<32-shift|word>>>shift;const isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function hexToBytes$1(hex){if(typeof hex!=="string")throw new Error("hex string expected, got "+typeof hex);const len=hex.length;if(len%2)throw new Error("padded hex string expected, got unpadded hex of length "+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=i*2;const hexByte=hex.slice(j,j+2);const byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error("Invalid byte sequence");array[i]=byte}return array}const nextTick=async()=>{};async function asyncLoop(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;if(diff>=0&&diff<tick)continue;await nextTick();ts+=diff}}function utf8ToBytes$1(str){if(typeof str!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){if(typeof data==="string")data=utf8ToBytes$1(data);if(!u8a$1(data))throw new Error(`expected Uint8Array, got ${typeof data}`);return data}function concatBytes$1(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a$1(a))throw new Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r}class Hash{clone(){return this._cloneInto()}}const toStr={}.toString;function checkOpts(defaults,opts){if(opts!==undefined&&toStr.call(opts)!=="[object Object]")throw new Error("Options should be object or undefined");const merged=Object.assign(defaults,opts);return merged}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest();const tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC}function randomBytes$2(bytesLength=32){if(crypto$1&&typeof crypto$1.getRandomValues==="function"){return crypto$1.getRandomValues(new Uint8Array(bytesLength))}throw new Error("crypto.getRandomValues must be defined")}class HMAC extends Hash{constructor(hash$1,_key){super();this.finished=false;this.destroyed=false;hash(hash$1);const key=toBytes(_key);this.iHash=hash$1.create();if(typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen;const pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash$1.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad);this.oHash=hash$1.create();for(let i=0;i<pad.length;i++)pad[i]^=54^92;this.oHash.update(pad);pad.fill(0)}update(buf){exists(this);this.iHash.update(buf);return this}digestInto(out){exists(this);bytes(out,this.outputLen);this.finished=true;this.iHash.digestInto(out);this.oHash.update(out);this.oHash.digestInto(out);this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);this.digestInto(out);return out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;to=to;to.finished=finished;to.destroyed=destroyed;to.blockLen=blockLen;to.outputLen=outputLen;to.oHash=oHash._cloneInto(to.oHash);to.iHash=iHash._cloneInto(to.iHash);return to}destroy(){this.destroyed=true;this.oHash.destroy();this.iHash.destroy()}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);function pbkdf2Init(hash$1,_password,_salt,_opts){hash(hash$1);const opts=checkOpts({dkLen:32,asyncTick:10},_opts);const{c,dkLen,asyncTick}=opts;number(c);number(dkLen);number(asyncTick);if(c<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const password=toBytes(_password);const salt=toBytes(_salt);const DK=new Uint8Array(dkLen);const PRF=hmac.create(hash$1,password);const PRFSalt=PRF._cloneInto().update(salt);return{c:c,dkLen:dkLen,asyncTick:asyncTick,DK:DK,PRF:PRF,PRFSalt:PRFSalt}}function pbkdf2Output(PRF,PRFSalt,DK,prfW,u){PRF.destroy();PRFSalt.destroy();if(prfW)prfW.destroy();u.fill(0);return DK}function pbkdf2$1(hash,password,salt,opts){const{c,dkLen,DK,PRF,PRFSalt}=pbkdf2Init(hash,password,salt,opts);let prfW;const arr=new Uint8Array(4);const view=createView(arr);const u=new Uint8Array(PRF.outputLen);for(let ti=1,pos=0;pos<dkLen;ti++,pos+=PRF.outputLen){const Ti=DK.subarray(pos,pos+PRF.outputLen);view.setInt32(0,ti,false);(prfW=PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);Ti.set(u.subarray(0,Ti.length));for(let ui=1;ui<c;ui++){PRF._cloneInto(prfW).update(u).digestInto(u);for(let i=0;i<Ti.length;i++)Ti[i]^=u[i]}}return pbkdf2Output(PRF,PRFSalt,DK,prfW,u)}function setBigUint64(view,byteOffset,value,isLE){if(typeof view.setBigUint64==="function")return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32);const _u32_max=BigInt(4294967295);const wh=Number(value>>_32n&_u32_max);const wl=Number(value&_u32_max);const h=isLE?4:0;const l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE);view.setUint32(byteOffset+l,wl,isLE)}class SHA2 extends Hash{constructor(blockLen,outputLen,padOffset,isLE){super();this.blockLen=blockLen;this.outputLen=outputLen;this.padOffset=padOffset;this.isLE=isLE;this.finished=false;this.length=0;this.pos=0;this.destroyed=false;this.buffer=new Uint8Array(blockLen);this.view=createView(this.buffer)}update(data){exists(this);const{view,buffer,blockLen}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos);continue}buffer.set(data.subarray(pos,pos+take),this.pos);this.pos+=take;pos+=take;if(this.pos===blockLen){this.process(view,0);this.pos=0}}this.length+=data.length;this.roundClean();return this}digestInto(out){exists(this);output(out,this);this.finished=true;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128;this.buffer.subarray(pos).fill(0);if(this.padOffset>blockLen-pos){this.process(view,0);pos=0}for(let i=pos;i<blockLen;i++)buffer[i]=0;setBigUint64(view,blockLen-8,BigInt(this.length*8),isLE);this.process(view,0);const oview=createView(out);const len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4;const state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);this.destroy();return res}_cloneInto(to){to||(to=new this.constructor);to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;to.length=length;to.pos=pos;to.finished=finished;to.destroyed=destroyed;if(length%blockLen)to.buffer.set(buffer);return to}}const Chi=(a,b,c)=>a&b^~a&c;const Maj=(a,b,c)=>a&b^a&c^b&c;const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,false);this.A=IV[0]|0;this.B=IV[1]|0;this.C=IV[2]|0;this.D=IV[3]|0;this.E=IV[4]|0;this.F=IV[5]|0;this.G=IV[6]|0;this.H=IV[7]|0}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=A|0;this.B=B|0;this.C=C|0;this.D=D|0;this.E=E|0;this.F=F|0;this.G=G|0;this.H=H|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,false);for(let i=16;i<64;i++){const W15=SHA256_W[i-15];const W2=SHA256_W[i-2];const s0=rotr(W15,7)^rotr(W15,18)^W15>>>3;const s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const sigma1=rotr(E,6)^rotr(E,11)^rotr(E,25);const T1=H+sigma1+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0;const sigma0=rotr(A,2)^rotr(A,13)^rotr(A,22);const T2=sigma0+Maj(A,B,C)|0;H=G;G=F;F=E;E=D+T1|0;D=C;C=B;B=A;A=T1+T2|0}A=A+this.A|0;B=B+this.B|0;C=C+this.C|0;D=D+this.D|0;E=E+this.E|0;F=F+this.F|0;G=G+this.G|0;H=H+this.H|0;this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0);this.buffer.fill(0)}}const sha256$1=wrapConstructor(()=>new SHA256);const U32_MASK64=BigInt(2**32-1);const _32n=BigInt(32);function fromBig(n,le=false){if(le)return{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)};return{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split(lst,le=false){let Ah=new Uint32Array(lst.length);let Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const toBig=(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0);const shrSH=(h,_l,s)=>h>>>s;const shrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrSH=(h,l,s)=>h>>>s|l<<32-s;const rotrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrBH=(h,l,s)=>h<<64-s|l>>>s-32;const rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;const rotr32H=(_h,l)=>l;const rotr32L=(h,_l)=>h;const rotlSH=(h,l,s)=>h<<s|l>>>32-s;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:l|0}}const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0);const add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0;const add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0);const add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0;const add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0);const add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0;const u64={fromBig:fromBig,split:split,toBig:toBig,shrSH:shrSH,shrSL:shrSL,rotrSH:rotrSH,rotrSL:rotrSL,rotrBH:rotrBH,rotrBL:rotrBL,rotr32H:rotr32H,rotr32L:rotr32L,rotlSH:rotlSH,rotlSL:rotlSL,rotlBH:rotlBH,rotlBL:rotlBL,add:add,add3L:add3L,add3H:add3H,add4L:add4L,add4H:add4H,add5H:add5H,add5L:add5L};const[SHA512_Kh,SHA512_Kl]=(()=>u64.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))();const SHA512_W_H=new Uint32Array(80);const SHA512_W_L=new Uint32Array(80);class SHA512 extends SHA2{constructor(){super(128,64,16,false);this.Ah=1779033703|0;this.Al=4089235720|0;this.Bh=3144134277|0;this.Bl=2227873595|0;this.Ch=1013904242|0;this.Cl=4271175723|0;this.Dh=2773480762|0;this.Dl=1595750129|0;this.Eh=1359893119|0;this.El=2917565137|0;this.Fh=2600822924|0;this.Fl=725511199|0;this.Gh=528734635|0;this.Gl=4215389547|0;this.Hh=1541459225|0;this.Hl=327033209|0}get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=Ah|0;this.Al=Al|0;this.Bh=Bh|0;this.Bl=Bl|0;this.Ch=Ch|0;this.Cl=Cl|0;this.Dh=Dh|0;this.Dl=Dl|0;this.Eh=Eh|0;this.El=El|0;this.Fh=Fh|0;this.Fl=Fl|0;this.Gh=Gh|0;this.Gl=Gl|0;this.Hh=Hh|0;this.Hl=Hl|0}process(view,offset){for(let i=0;i<16;i++,offset+=4){SHA512_W_H[i]=view.getUint32(offset);SHA512_W_L[i]=view.getUint32(offset+=4)}for(let i=16;i<80;i++){const W15h=SHA512_W_H[i-15]|0;const W15l=SHA512_W_L[i-15]|0;const s0h=u64.rotrSH(W15h,W15l,1)^u64.rotrSH(W15h,W15l,8)^u64.shrSH(W15h,W15l,7);const s0l=u64.rotrSL(W15h,W15l,1)^u64.rotrSL(W15h,W15l,8)^u64.shrSL(W15h,W15l,7);const W2h=SHA512_W_H[i-2]|0;const W2l=SHA512_W_L[i-2]|0;const s1h=u64.rotrSH(W2h,W2l,19)^u64.rotrBH(W2h,W2l,61)^u64.shrSH(W2h,W2l,6);const s1l=u64.rotrSL(W2h,W2l,19)^u64.rotrBL(W2h,W2l,61)^u64.shrSL(W2h,W2l,6);const SUMl=u64.add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]);const SUMh=u64.add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=SUMh|0;SHA512_W_L[i]=SUMl|0}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=u64.rotrSH(Eh,El,14)^u64.rotrSH(Eh,El,18)^u64.rotrBH(Eh,El,41);const sigma1l=u64.rotrSL(Eh,El,14)^u64.rotrSL(Eh,El,18)^u64.rotrBL(Eh,El,41);const CHIh=Eh&Fh^~Eh&Gh;const CHIl=El&Fl^~El&Gl;const T1ll=u64.add5L(Hl,sigma1l,CHIl,SHA512_Kl[i],SHA512_W_L[i]);const T1h=u64.add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]);const T1l=T1ll|0;const sigma0h=u64.rotrSH(Ah,Al,28)^u64.rotrBH(Ah,Al,34)^u64.rotrBH(Ah,Al,39);const sigma0l=u64.rotrSL(Ah,Al,28)^u64.rotrBL(Ah,Al,34)^u64.rotrBL(Ah,Al,39);const MAJh=Ah&Bh^Ah&Ch^Bh&Ch;const MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=Gh|0;Hl=Gl|0;Gh=Fh|0;Gl=Fl|0;Fh=Eh|0;Fl=El|0;({h:Eh,l:El}=u64.add(Dh|0,Dl|0,T1h|0,T1l|0));Dh=Ch|0;Dl=Cl|0;Ch=Bh|0;Cl=Bl|0;Bh=Ah|0;Bl=Al|0;const All=u64.add3L(T1l,sigma0l,MAJl);Ah=u64.add3H(All,T1h,sigma0h,MAJh);Al=All|0}({h:Ah,l:Al}=u64.add(this.Ah|0,this.Al|0,Ah|0,Al|0));({h:Bh,l:Bl}=u64.add(this.Bh|0,this.Bl|0,Bh|0,Bl|0));({h:Ch,l:Cl}=u64.add(this.Ch|0,this.Cl|0,Ch|0,Cl|0));({h:Dh,l:Dl}=u64.add(this.Dh|0,this.Dl|0,Dh|0,Dl|0));({h:Eh,l:El}=u64.add(this.Eh|0,this.El|0,Eh|0,El|0));({h:Fh,l:Fl}=u64.add(this.Fh|0,this.Fl|0,Fh|0,Fl|0));({h:Gh,l:Gl}=u64.add(this.Gh|0,this.Gl|0,Gh|0,Gl|0));({h:Hh,l:Hl}=u64.add(this.Hh|0,this.Hl|0,Hh|0,Hl|0));this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){SHA512_W_H.fill(0);SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0);this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sha512$1=wrapConstructor(()=>new SHA512);function getGlobal$1(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")}const anyGlobal=getGlobal$1();const crypto=anyGlobal.crypto||anyGlobal.msCrypto;function createHash(algo){switch(algo){case"sha256":return sha256$1.create();case"sha512":return sha512$1.create()}assertArgument(false,"invalid hashing algorithm name","algorithm",algo)}function createHmac(_algo,key){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,"invalid hmac algorithm","algorithm",_algo);return hmac.create(algo,key)}function pbkdf2Sync(password,salt,iterations,keylen,_algo){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,"invalid pbkdf2 algorithm","algorithm",_algo);return pbkdf2$1(algo,password,salt,{c:iterations,dkLen:keylen})}function randomBytes$1(length){assert$1(crypto!=null,"platform does not support secure random numbers","UNSUPPORTED_OPERATION",{operation:"randomBytes"});assertArgument(Number.isInteger(length)&&length>0&&length<=1024,"invalid length","length",length);const result=new Uint8Array(length);crypto.getRandomValues(result);return result}let locked$4=false;const _computeHmac=function(algorithm,key,data){return createHmac(algorithm,key).update(data).digest()};let __computeHmac=_computeHmac;function computeHmac(algorithm,_key,_data){const key=getBytes(_key,"key");const data=getBytes(_data,"data");return hexlify(__computeHmac(algorithm,key,data))}computeHmac._=_computeHmac;computeHmac.lock=function(){locked$4=true};computeHmac.register=function(func){if(locked$4){throw new Error("computeHmac is locked")}__computeHmac=func};Object.freeze(computeHmac);const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]];const _0n$6=BigInt(0);const _1n$6=BigInt(1);const _2n$4=BigInt(2);const _7n$1=BigInt(7);const _256n=BigInt(256);const _0x71n=BigInt(113);for(let round=0,R=_1n$6,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5];SHA3_PI.push(2*(5*y+x));SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n$6;for(let j=0;j<7;j++){R=(R<<_1n$6^(R>>_7n$1)*_0x71n)%_256n;if(R&_2n$4)t^=_1n$6<<(_1n$6<<BigInt(j))-_1n$6}_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split(_SHA3_IOTA,true);const rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s);const rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(5*2);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10;const idx0=(x+2)%10;const B0=B[idx0];const B1=B[idx0+1];const Th=rotlH(B0,B1,1)^B[idx1];const Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10){s[x+y]^=Th;s[x+y+1]^=Tl}}let curH=s[2];let curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t];const Th=rotlH(curH,curL,shift);const Tl=rotlL(curH,curL,shift);const PI=SHA3_PI[t];curH=s[PI];curL=s[PI+1];s[PI]=Th;s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round];s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=false,rounds=24){super();this.blockLen=blockLen;this.suffix=suffix;this.outputLen=outputLen;this.enableXOF=enableXOF;this.rounds=rounds;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;number(outputLen);if(0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200);this.state32=u32(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(data){exists(this);const{blockLen,state}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];if(this.pos===blockLen)this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix;if((suffix&128)!==0&&pos===blockLen-1)this.keccak();state[blockLen-1]^=128;this.keccak()}writeInto(out){exists(this,false);bytes(out);this.finish();const bufferOut=this.state;const{blockLen}=this;for(let pos=0,len=out.length;pos<len;){if(this.posOut>=blockLen)this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos);this.posOut+=take;pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){number(bytes);return this.xofInto(new Uint8Array(bytes))}digestInto(out){output(out,this);if(this.finished)throw new Error("digest() was already called");this.writeInto(out);this.destroy();return out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds));to.state32.set(this.state32);to.pos=this.pos;to.posOut=this.posOut;to.finished=this.finished;to.rounds=rounds;to.suffix=suffix;to.outputLen=outputLen;to.enableXOF=enableXOF;to.destroyed=this.destroyed;return to}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor(()=>new Keccak(blockLen,suffix,outputLen));const keccak_256=gen(1,136,256/8);let locked$3=false;const _keccak256=function(data){return keccak_256(data)};let __keccak256=_keccak256;function keccak256(_data){const data=getBytes(_data,"data");return hexlify(__keccak256(data))}keccak256._=_keccak256;keccak256.lock=function(){locked$3=true};keccak256.register=function(func){if(locked$3){throw new TypeError("keccak256 is locked")}__keccak256=func};Object.freeze(keccak256);const Rho=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]);const Id=Uint8Array.from({length:16},(_,i)=>i);const Pi=Id.map(i=>(9*i+5)%16);let idxL=[Id];let idxR=[Pi];for(let i=0;i<4;i++)for(let j of[idxL,idxR])j.push(j[i].map(k=>Rho[k]));const shifts=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(i=>new Uint8Array(i));const shiftsL=idxL.map((idx,i)=>idx.map(j=>shifts[i][j]));const shiftsR=idxR.map((idx,i)=>idx.map(j=>shifts[i][j]));const Kl=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]);const Kr=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);const rotl$1=(word,shift)=>word<<shift|word>>>32-shift;function f(group,x,y,z){if(group===0)return x^y^z;else if(group===1)return x&y|~x&z;else if(group===2)return(x|~y)^z;else if(group===3)return x&z|y&~z;else return x^(y|~z)}const BUF=new Uint32Array(16);class RIPEMD160 extends SHA2{constructor(){super(64,20,8,true);this.h0=1732584193|0;this.h1=4023233417|0;this.h2=2562383102|0;this.h3=271733878|0;this.h4=3285377520|0}get(){const{h0,h1,h2,h3,h4}=this;return[h0,h1,h2,h3,h4]}set(h0,h1,h2,h3,h4){this.h0=h0|0;this.h1=h1|0;this.h2=h2|0;this.h3=h3|0;this.h4=h4|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)BUF[i]=view.getUint32(offset,true);let al=this.h0|0,ar=al,bl=this.h1|0,br=bl,cl=this.h2|0,cr=cl,dl=this.h3|0,dr=dl,el=this.h4|0,er=el;for(let group=0;group<5;group++){const rGroup=4-group;const hbl=Kl[group],hbr=Kr[group];const rl=idxL[group],rr=idxR[group];const sl=shiftsL[group],sr=shiftsR[group];for(let i=0;i<16;i++){const tl=rotl$1(al+f(group,bl,cl,dl)+BUF[rl[i]]+hbl,sl[i])+el|0;al=el,el=dl,dl=rotl$1(cl,10)|0,cl=bl,bl=tl}for(let i=0;i<16;i++){const tr=rotl$1(ar+f(rGroup,br,cr,dr)+BUF[rr[i]]+hbr,sr[i])+er|0;ar=er,er=dr,dr=rotl$1(cr,10)|0,cr=br,br=tr}}this.set(this.h1+cl+dr|0,this.h2+dl+er|0,this.h3+el+ar|0,this.h4+al+br|0,this.h0+bl+cr|0)}roundClean(){BUF.fill(0)}destroy(){this.destroyed=true;this.buffer.fill(0);this.set(0,0,0,0,0)}}const ripemd160$1=wrapConstructor(()=>new RIPEMD160);let locked$2=false;const _ripemd160=function(data){return ripemd160$1(data)};let __ripemd160=_ripemd160;function ripemd160(_data){const data=getBytes(_data,"data");return hexlify(__ripemd160(data))}ripemd160._=_ripemd160;ripemd160.lock=function(){locked$2=true};ripemd160.register=function(func){if(locked$2){throw new TypeError("ripemd160 is locked")}__ripemd160=func};Object.freeze(ripemd160);let locked$1=false;const _pbkdf2=function(password,salt,iterations,keylen,algo){return pbkdf2Sync(password,salt,iterations,keylen,algo)};let __pbkdf2=_pbkdf2;function pbkdf2(_password,_salt,iterations,keylen,algo){const password=getBytes(_password,"password");const salt=getBytes(_salt,"salt");return hexlify(__pbkdf2(password,salt,iterations,keylen,algo))}pbkdf2._=_pbkdf2;pbkdf2.lock=function(){locked$1=true};pbkdf2.register=function(func){if(locked$1){throw new Error("pbkdf2 is locked")}__pbkdf2=func};Object.freeze(pbkdf2);let locked=false;const _randomBytes=function(length){return new Uint8Array(randomBytes$1(length))};let __randomBytes=_randomBytes;function randomBytes(length){return __randomBytes(length)}randomBytes._=_randomBytes;randomBytes.lock=function(){locked=true};randomBytes.register=function(func){if(locked){throw new Error("randomBytes is locked")}__randomBytes=func};Object.freeze(randomBytes);const rotl=(a,b)=>a<<b|a>>>32-b;function XorAndSalsa(prev,pi,input,ii,out,oi){let y00=prev[pi++]^input[ii++],y01=prev[pi++]^input[ii++];let y02=prev[pi++]^input[ii++],y03=prev[pi++]^input[ii++];let y04=prev[pi++]^input[ii++],y05=prev[pi++]^input[ii++];let y06=prev[pi++]^input[ii++],y07=prev[pi++]^input[ii++];let y08=prev[pi++]^input[ii++],y09=prev[pi++]^input[ii++];let y10=prev[pi++]^input[ii++],y11=prev[pi++]^input[ii++];let y12=prev[pi++]^input[ii++],y13=prev[pi++]^input[ii++];let y14=prev[pi++]^input[ii++],y15=prev[pi++]^input[ii++];let x00=y00,x01=y01,x02=y02,x03=y03,x04=y04,x05=y05,x06=y06,x07=y07,x08=y08,x09=y09,x10=y10,x11=y11,x12=y12,x13=y13,x14=y14,x15=y15;for(let i=0;i<8;i+=2){x04^=rotl(x00+x12|0,7);x08^=rotl(x04+x00|0,9);x12^=rotl(x08+x04|0,13);x00^=rotl(x12+x08|0,18);x09^=rotl(x05+x01|0,7);x13^=rotl(x09+x05|0,9);x01^=rotl(x13+x09|0,13);x05^=rotl(x01+x13|0,18);x14^=rotl(x10+x06|0,7);x02^=rotl(x14+x10|0,9);x06^=rotl(x02+x14|0,13);x10^=rotl(x06+x02|0,18);x03^=rotl(x15+x11|0,7);x07^=rotl(x03+x15|0,9);x11^=rotl(x07+x03|0,13);x15^=rotl(x11+x07|0,18);x01^=rotl(x00+x03|0,7);x02^=rotl(x01+x00|0,9);x03^=rotl(x02+x01|0,13);x00^=rotl(x03+x02|0,18);x06^=rotl(x05+x04|0,7);x07^=rotl(x06+x05|0,9);x04^=rotl(x07+x06|0,13);x05^=rotl(x04+x07|0,18);x11^=rotl(x10+x09|0,7);x08^=rotl(x11+x10|0,9);x09^=rotl(x08+x11|0,13);x10^=rotl(x09+x08|0,18);x12^=rotl(x15+x14|0,7);x13^=rotl(x12+x15|0,9);x14^=rotl(x13+x12|0,13);x15^=rotl(x14+x13|0,18)}out[oi++]=y00+x00|0;out[oi++]=y01+x01|0;out[oi++]=y02+x02|0;out[oi++]=y03+x03|0;out[oi++]=y04+x04|0;out[oi++]=y05+x05|0;out[oi++]=y06+x06|0;out[oi++]=y07+x07|0;out[oi++]=y08+x08|0;out[oi++]=y09+x09|0;out[oi++]=y10+x10|0;out[oi++]=y11+x11|0;out[oi++]=y12+x12|0;out[oi++]=y13+x13|0;out[oi++]=y14+x14|0;out[oi++]=y15+x15|0}function BlockMix(input,ii,out,oi,r){let head=oi+0;let tail=oi+16*r;for(let i=0;i<16;i++)out[tail+i]=input[ii+(2*r-1)*16+i];for(let i=0;i<r;i++,head+=16,ii+=16){XorAndSalsa(out,tail,input,ii,out,head);if(i>0)tail+=16;XorAndSalsa(out,head,input,ii+=16,out,tail)}}function scryptInit(password,salt,_opts){const opts=checkOpts({dkLen:32,asyncTick:10,maxmem:1024**3+1024},_opts);const{N,r,p,dkLen,asyncTick,maxmem,onProgress}=opts;number(N);number(r);number(p);number(dkLen);number(asyncTick);number(maxmem);if(onProgress!==undefined&&typeof onProgress!=="function")throw new Error("progressCb should be function");const blockSize=128*r;const blockSize32=blockSize/4;if(N<=1||(N&N-1)!==0||N>=2**(blockSize/8)||N>2**32){throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32")}if(p<0||p>(2**32-1)*32/blockSize){throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)")}if(dkLen<0||dkLen>(2**32-1)*32){throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32")}const memUsed=blockSize*(N+p);if(memUsed>maxmem){throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`)}const B=pbkdf2$1(sha256$1,password,salt,{c:1,dkLen:blockSize*p});const B32=u32(B);const V=u32(new Uint8Array(blockSize*N));const tmp=u32(new Uint8Array(blockSize));let blockMixCb=()=>{};if(onProgress){const totalBlockMix=2*N*p;const callbackPer=Math.max(Math.floor(totalBlockMix/1e4),1);let blockMixCnt=0;blockMixCb=()=>{blockMixCnt++;if(onProgress&&(!(blockMixCnt%callbackPer)||blockMixCnt===totalBlockMix))onProgress(blockMixCnt/totalBlockMix)}}return{N:N,r:r,p:p,dkLen:dkLen,blockSize32:blockSize32,V:V,B32:B32,B:B,tmp:tmp,blockMixCb:blockMixCb,asyncTick:asyncTick}}function scryptOutput(password,dkLen,B,V,tmp){const res=pbkdf2$1(sha256$1,password,B,{c:1,dkLen:dkLen});B.fill(0);V.fill(0);tmp.fill(0);return res}function scrypt$1(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];for(let i=0,pos=0;i<N-1;i++){BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()}BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();for(let i=0;i<N;i++){const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()}}return scryptOutput(password,dkLen,B,V,tmp)}async function scryptAsync(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb,asyncTick}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];let pos=0;await asyncLoop(N-1,asyncTick,()=>{BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()});BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();await asyncLoop(N,asyncTick,()=>{const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()})}return scryptOutput(password,dkLen,B,V,tmp)}let lockedSync=false,lockedAsync=false;const _scryptAsync=async function(passwd,salt,N,r,p,dkLen,onProgress){return await scryptAsync(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen,onProgress:onProgress})};const _scryptSync=function(passwd,salt,N,r,p,dkLen){return scrypt$1(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen})};let __scryptAsync=_scryptAsync;let __scryptSync=_scryptSync;async function scrypt(_passwd,_salt,N,r,p,dkLen,progress){const passwd=getBytes(_passwd,"passwd");const salt=getBytes(_salt,"salt");return hexlify(await __scryptAsync(passwd,salt,N,r,p,dkLen,progress))}scrypt._=_scryptAsync;scrypt.lock=function(){lockedAsync=true};scrypt.register=function(func){if(lockedAsync){throw new Error("scrypt is locked")}__scryptAsync=func};Object.freeze(scrypt);function scryptSync(_passwd,_salt,N,r,p,dkLen){const passwd=getBytes(_passwd,"passwd");const salt=getBytes(_salt,"salt");return hexlify(__scryptSync(passwd,salt,N,r,p,dkLen))}scryptSync._=_scryptSync;scryptSync.lock=function(){lockedSync=true};scryptSync.register=function(func){if(lockedSync){throw new Error("scryptSync is locked")}__scryptSync=func};Object.freeze(scryptSync);const _sha256=function(data){return createHash("sha256").update(data).digest()};const _sha512=function(data){return createHash("sha512").update(data).digest()};let __sha256=_sha256;let __sha512=_sha512;let locked256=false,locked512=false;function sha256(_data){const data=getBytes(_data,"data");return hexlify(__sha256(data))}sha256._=_sha256;sha256.lock=function(){locked256=true};sha256.register=function(func){if(locked256){throw new Error("sha256 is locked")}__sha256=func};Object.freeze(sha256);function sha512(_data){const data=getBytes(_data,"data");return hexlify(__sha512(data))}sha512._=_sha512;sha512.lock=function(){locked512=true};sha512.register=function(func){if(locked512){throw new Error("sha512 is locked")}__sha512=func};Object.freeze(sha256);const _0n$5=BigInt(0);const _1n$5=BigInt(1);const _2n$3=BigInt(2);const u8a=a=>a instanceof Uint8Array;const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,"0"));function bytesToHex(bytes){if(!u8a(bytes))throw new Error("Uint8Array expected");let hex="";for(let i=0;i<bytes.length;i++){hex+=hexes[bytes[i]]}return hex}function numberToHexUnpadded(num){const hex=num.toString(16);return hex.length&1?`0${hex}`:hex}function hexToNumber(hex){if(typeof hex!=="string")throw new Error("hex string expected, got "+typeof hex);return BigInt(hex===""?"0":`0x${hex}`)}function hexToBytes(hex){if(typeof hex!=="string")throw new Error("hex string expected, got "+typeof hex);const len=hex.length;if(len%2)throw new Error("padded hex string expected, got unpadded hex of length "+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=i*2;const hexByte=hex.slice(j,j+2);const byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error("Invalid byte sequence");array[i]=byte}return array}function bytesToNumberBE(bytes){return hexToNumber(bytesToHex(bytes))}function bytesToNumberLE(bytes){if(!u8a(bytes))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(len*2,"0"))}function numberToBytesLE(n,len){return numberToBytesBE(n,len).reverse()}function numberToVarBytesBE(n){return hexToBytes(numberToHexUnpadded(n))}function ensureBytes(title,hex,expectedLength){let res;if(typeof hex==="string"){try{res=hexToBytes(hex)}catch(e){throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`)}}else if(u8a(hex)){res=Uint8Array.from(hex)}else{throw new Error(`${title} must be hex string or Uint8Array`)}const len=res.length;if(typeof expectedLength==="number"&&len!==expectedLength)throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);return res}function concatBytes(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a(a))throw new Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r}function equalBytes(b1,b2){if(b1.length!==b2.length)return false;for(let i=0;i<b1.length;i++)if(b1[i]!==b2[i])return false;return true}function utf8ToBytes(str){if(typeof str!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function bitLen(n){let len;for(len=0;n>_0n$5;n>>=_1n$5,len+=1);return len}function bitGet(n,pos){return n>>BigInt(pos)&_1n$5}const bitSet=(n,pos,value)=>{return n|(value?_1n$5:_0n$5)<<BigInt(pos)};const bitMask=n=>(_2n$3<<BigInt(n-1))-_1n$5;const u8n=data=>new Uint8Array(data);const u8fr=arr=>Uint8Array.from(arr);function createHmacDrbg(hashLen,qByteLen,hmacFn){if(typeof hashLen!=="number"||hashLen<2)throw new Error("hashLen must be a number");if(typeof qByteLen!=="number"||qByteLen<2)throw new Error("qByteLen must be a number");if(typeof hmacFn!=="function")throw new Error("hmacFn must be a function");let v=u8n(hashLen);let k=u8n(hashLen);let i=0;const reset=()=>{v.fill(1);k.fill(0);i=0};const h=(...b)=>hmacFn(k,v,...b);const reseed=(seed=u8n())=>{k=h(u8fr([0]),seed);v=h();if(seed.length===0)return;k=h(u8fr([1]),seed);v=h()};const gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let len=0;const out=[];while(len<qByteLen){v=h();const sl=v.slice();out.push(sl);len+=v.length}return concatBytes(...out)};const genUntil=(seed,pred)=>{reset();reseed(seed);let res=undefined;while(!(res=pred(gen())))reseed();reset();return res};return genUntil}const validatorFns={bigint:val=>typeof val==="bigint",function:val=>typeof val==="function",boolean:val=>typeof val==="boolean",string:val=>typeof val==="string",stringOrUint8Array:val=>typeof val==="string"||val instanceof Uint8Array,isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>typeof val==="function"&&Number.isSafeInteger(val.outputLen)};function validateObject(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if(typeof checkVal!=="function")throw new Error(`Invalid validator "${type}", expected function`);const val=object[fieldName];if(isOptional&&val===undefined)return;if(!checkVal(val,object)){throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)}};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,false);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,true);return object}var ut=Object.freeze({__proto__:null,bitGet:bitGet,bitLen:bitLen,bitMask:bitMask,bitSet:bitSet,bytesToHex:bytesToHex,bytesToNumberBE:bytesToNumberBE,bytesToNumberLE:bytesToNumberLE,concatBytes:concatBytes,createHmacDrbg:createHmacDrbg,ensureBytes:ensureBytes,equalBytes:equalBytes,hexToBytes:hexToBytes,hexToNumber:hexToNumber,numberToBytesBE:numberToBytesBE,numberToBytesLE:numberToBytesLE,numberToHexUnpadded:numberToHexUnpadded,numberToVarBytesBE:numberToVarBytesBE,utf8ToBytes:utf8ToBytes,validateObject:validateObject});const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2),_3n$2=BigInt(3);const _4n=BigInt(4),_5n$1=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(a,b){const result=a%b;return result>=_0n$4?result:b+result}function pow(num,power,modulo){if(modulo<=_0n$4||power<_0n$4)throw new Error("Expected power/modulo > 0");if(modulo===_1n$4)return _0n$4;let res=_1n$4;while(power>_0n$4){if(power&_1n$4)res=res*num%modulo;num=num*num%modulo;power>>=_1n$4}return res}function pow2(x,power,modulo){let res=x;while(power-- >_0n$4){res*=res;res%=modulo}return res}function invert(number,modulo){if(number===_0n$4||modulo<=_0n$4){throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`)}let a=mod(number,modulo);let b=modulo;let x=_0n$4,u=_1n$4;while(a!==_0n$4){const q=b/a;const r=b%a;const m=x-u*q;b=a,a=r,x=u,u=m}const gcd=b;if(gcd!==_1n$4)throw new Error("invert: does not exist");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n$4)/_2n$2;let Q,S,Z;for(Q=P-_1n$4,S=0;Q%_2n$2===_0n$4;Q/=_2n$2,S++);for(Z=_2n$2;Z<P&&pow(Z,legendreC,P)!==P-_1n$4;Z++);if(S===1){const p1div4=(P+_1n$4)/_4n;return function tonelliFast(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}const Q1div2=(Q+_1n$4)/_2n$2;return function tonelliSlow(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error("Cannot find square root");let r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q);let x=Fp.pow(n,Q1div2);let b=Fp.pow(n,Q);while(!Fp.eql(b,Fp.ONE)){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r;m++){if(Fp.eql(t2,Fp.ONE))break;t2=Fp.sqr(t2)}const ge=Fp.pow(g,_1n$4<<BigInt(r-m-1));g=Fp.sqr(ge);x=Fp.mul(x,ge);b=Fp.mul(b,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n$2){const p1div4=(P+_1n$4)/_4n;return function sqrt3mod4(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}if(P%_8n===_5n$1){const c1=(P-_5n$1)/_8n;return function sqrt5mod8(Fp,n){const n2=Fp.mul(n,_2n$2);const v=Fp.pow(n2,c1);const nv=Fp.mul(n,v);const i=Fp.mul(Fp.mul(nv,_2n$2),v);const root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}return tonelliShanks(P)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(field){const initial={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"};const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]="function";return map},initial);return validateObject(field,opts)}function FpPow(f,num,power){if(power<_0n$4)throw new Error("Expected power > 0");if(power===_0n$4)return f.ONE;if(power===_1n$4)return num;let p=f.ONE;let d=num;while(power>_0n$4){if(power&_1n$4)p=f.mul(p,d);d=f.sqr(d);power>>=_1n$4}return p}function FpInvertBatch(f,nums){const tmp=new Array(nums.length);const lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);const inverted=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},inverted);return tmp}function nLength(n,nBitLength){const _nBitLength=nBitLength!==undefined?nBitLength:n.toString(2).length;const nByteLength=Math.ceil(_nBitLength/8);return{nBitLength:_nBitLength,nByteLength:nByteLength}}function Field(ORDER,bitLen,isLE=false,redef={}){if(ORDER<=_0n$4)throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error("Field lengths over 2048 bytes are not supported");const sqrtP=FpSqrt(ORDER);const f=Object.freeze({ORDER:ORDER,BITS:BITS,BYTES:BYTES,MASK:bitMask(BITS),ZERO:_0n$4,ONE:_1n$4,create:num=>mod(num,ORDER),isValid:num=>{if(typeof num!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n$4<=num&&num<ORDER},is0:num=>num===_0n$4,isOdd:num=>(num&_1n$4)===_1n$4,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?numberToBytesLE(num,BYTES):numberToBytesBE(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?bytesToNumberLE(bytes):bytesToNumberBE(bytes)}});return Object.freeze(f)}function getFieldBytesLength(fieldOrder){if(typeof fieldOrder!=="bigint")throw new Error("field order must be bigint");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}function mapHashToField(key,fieldOrder,isLE=false){const len=key.length;const fieldLen=getFieldBytesLength(fieldOrder);const minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);const num=isLE?bytesToNumberBE(key):bytesToNumberLE(key);const reduced=mod(num,fieldOrder-_1n$4)+_1n$4;return isLE?numberToBytesLE(reduced,fieldLen):numberToBytesBE(reduced,fieldLen)}const _0n$3=BigInt(0);const _1n$3=BigInt(1);function wNAF(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item};const opts=W=>{const windows=Math.ceil(bits/W)+1;const windowSize=2**(W-1);return{windows:windows,windowSize:windowSize}};return{constTimeNegate:constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO;let d=elm;while(n>_0n$3){if(n&_1n$3)p=p.add(d);d=d.double();n>>=_1n$3}return p},precomputeWindow(elm,W){const{windows,windowSize}=opts(W);const points=[];let p=elm;let base=p;for(let window=0;window<windows;window++){base=p;points.push(base);for(let i=1;i<windowSize;i++){base=base.add(p);points.push(base)}p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=opts(W);let p=c.ZERO;let f=c.BASE;const mask=BigInt(2**W-1);const maxNumber=2**W;const shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy;if(wbits>windowSize){wbits-=maxNumber;n+=_1n$3}const offset1=offset;const offset2=offset+Math.abs(wbits)-1;const cond1=window%2!==0;const cond2=wbits<0;if(wbits===0){f=f.add(constTimeNegate(cond1,precomputes[offset1]))}else{p=p.add(constTimeNegate(cond2,precomputes[offset2]))}}return{p:p,f:f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=precomputesMap.get(P);if(!comp){comp=this.precomputeWindow(P,W);if(W!==1){precomputesMap.set(P,transform(comp))}}return this.wNAF(W,comp,n)}}}function validateBasic(curve){validateField(curve.Fp);validateObject(curve,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"});return Object.freeze({...nLength(curve.n,curve.nBitLength),...curve,...{p:curve.Fp.ORDER}})}function validatePointOpts(curve){const opts=validateBasic(curve);validateObject(opts,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO)){throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0")}if(typeof endo!=="object"||typeof endo.beta!=="bigint"||typeof endo.splitScalar!=="function"){throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}}return Object.freeze({...opts})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;const DER={Err:class DERErr extends Error{constructor(m=""){super(m)}},_parseInt(data){const{Err:E}=DER;if(data.length<2||data[0]!==2)throw new E("Invalid signature integer tag");const len=data[1];const res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E("Invalid signature integer: wrong length");if(res[0]&128)throw new E("Invalid signature integer: negative");if(res[0]===0&&!(res[1]&128))throw new E("Invalid signature integer: unnecessary leading zero");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const{Err:E}=DER;const data=typeof hex==="string"?h2b(hex):hex;if(!(data instanceof Uint8Array))throw new Error("ui8a expected");let l=data.length;if(l<2||data[0]!=48)throw new E("Invalid signature tag");if(data[1]!==l-2)throw new E("Invalid signature: incorrect length");const{d:r,l:sBytes}=DER._parseInt(data.subarray(2));const{d:s,l:rBytesLeft}=DER._parseInt(sBytes);if(rBytesLeft.length)throw new E("Invalid signature: left bytes after parsing");return{r:r,s:s}},hexFromSig(sig){const slice=s=>Number.parseInt(s[0],16)&8?"00"+s:s;const h=num=>{const hex=num.toString(16);return hex.length&1?`0${hex}`:hex};const s=slice(h(sig.s));const r=slice(h(sig.r));const shl=s.length/2;const rhl=r.length/2;const sl=h(shl);const rl=h(rhl);return`30${h(rhl+shl+4)}02${rl}${r}02${sl}${s}`}};const _0n$2=BigInt(0),_1n$2=BigInt(1);BigInt(2);const _3n$1=BigInt(3);BigInt(4);function weierstrassPoints(opts){const CURVE=validatePointOpts(opts);const{Fp}=CURVE;const toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))});const fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}});function weierstrassEquation(x){const{a,b}=CURVE;const x2=Fp.sqr(x);const x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(num){return typeof num==="bigint"&&_0n$2<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&typeof key!=="bigint"){if(key instanceof Uint8Array)key=bytesToHex(key);if(typeof key!=="string"||!lengths.includes(key.length))throw new Error("Invalid key");key=key.padStart(nByteLength*2,"0")}let num;try{num=typeof key==="bigint"?key:bytesToNumberBE(ensureBytes("private key",key,nByteLength))}catch(error){throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)}if(wrapPrivateKey)num=mod(num,n);assertGE(num);return num}const pointPrecomputes=new Map;function assertPrjPoint(other){if(!(other instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(px,py,pz){this.px=px;this.py=py;this.pz=pz;if(px==null||!Fp.isValid(px))throw new Error("x required");if(py==null||!Fp.isValid(py))throw new Error("y required");if(pz==null||!Fp.isValid(pz))throw new Error("z required")}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error("invalid affine point");if(p instanceof Point)throw new Error("projective point not allowed");const is0=i=>Fp.eql(i,Fp.ZERO);if(is0(x)&&is0(y))return Point.ZERO;return new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map(p=>p.pz));return points.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes(ensureBytes("pointHex",hex)));P.assertValidity();return P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize;pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw new Error("bad point: ZERO")}const{x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error("bad point: x or y not FE");const left=Fp.sqr(y);const right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;const U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1));const U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE;const b3=Fp.mul(b,_3n$1);const{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;let t0=Fp.mul(X1,X1);let t1=Fp.mul(Y1,Y1);let t2=Fp.mul(Z1,Z1);let t3=Fp.mul(X1,Y1);t3=Fp.add(t3,t3);Z3=Fp.mul(X1,Z1);Z3=Fp.add(Z3,Z3);X3=Fp.mul(a,Z3);Y3=Fp.mul(b3,t2);Y3=Fp.add(X3,Y3);X3=Fp.sub(t1,Y3);Y3=Fp.add(t1,Y3);Y3=Fp.mul(X3,Y3);X3=Fp.mul(t3,X3);Z3=Fp.mul(b3,Z3);t2=Fp.mul(a,t2);t3=Fp.sub(t0,t2);t3=Fp.mul(a,t3);t3=Fp.add(t3,Z3);Z3=Fp.add(t0,t0);t0=Fp.add(Z3,t0);t0=Fp.add(t0,t2);t0=Fp.mul(t0,t3);Y3=Fp.add(Y3,t0);t2=Fp.mul(Y1,Z1);t2=Fp.add(t2,t2);t0=Fp.mul(t2,t3);X3=Fp.sub(X3,t0);Z3=Fp.mul(t2,t1);Z3=Fp.add(Z3,Z3);Z3=Fp.add(Z3,Z3);return new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a;const b3=Fp.mul(CURVE.b,_3n$1);let t0=Fp.mul(X1,X2);let t1=Fp.mul(Y1,Y2);let t2=Fp.mul(Z1,Z2);let t3=Fp.add(X1,Y1);let t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4);t4=Fp.add(t0,t1);t3=Fp.sub(t3,t4);t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);t4=Fp.mul(t4,t5);t5=Fp.add(t0,t2);t4=Fp.sub(t4,t5);t5=Fp.add(Y1,Z1);X3=Fp.add(Y2,Z2);t5=Fp.mul(t5,X3);X3=Fp.add(t1,t2);t5=Fp.sub(t5,X3);Z3=Fp.mul(a,t4);X3=Fp.mul(b3,t2);Z3=Fp.add(X3,Z3);X3=Fp.sub(t1,Z3);Z3=Fp.add(t1,Z3);Y3=Fp.mul(X3,Z3);t1=Fp.add(t0,t0);t1=Fp.add(t1,t0);t2=Fp.mul(a,t2);t4=Fp.mul(b3,t4);t1=Fp.add(t1,t2);t2=Fp.sub(t0,t2);t2=Fp.mul(a,t2);t4=Fp.add(t4,t2);t0=Fp.mul(t1,t4);Y3=Fp.add(Y3,t0);t0=Fp.mul(t5,t4);X3=Fp.mul(t3,X3);X3=Fp.sub(X3,t0);t0=Fp.mul(t3,t1);Z3=Fp.mul(t5,Z3);Z3=Fp.add(Z3,t0);return new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,comp=>{const toInv=Fp.invertBatch(comp.map(p=>p.pz));return comp.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)})}multiplyUnsafe(n){const I=Point.ZERO;if(n===_0n$2)return I;assertGE(n);if(n===_1n$2)return this;const{endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let k1p=I;let k2p=I;let d=this;while(k1>_0n$2||k2>_0n$2){if(k1&_1n$2)k1p=k1p.add(d);if(k2&_1n$2)k2p=k2p.add(d);d=d.double();k1>>=_1n$2;k2>>=_1n$2}if(k1neg)k1p=k1p.negate();if(k2neg)k2p=k2p.negate();k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);return k1p.add(k2p)}multiply(scalar){assertGE(scalar);let n=scalar;let point,fake;const{endo}=CURVE;if(endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1);let{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p);k2p=wnaf.constTimeNegate(k2neg,k2p);k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);point=k1p.add(k2p);fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n);point=p;fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE;const mul=(P,a)=>a===_0n$2||a===_1n$2||!P.equals(G)?P.multiplyUnsafe(a):P.multiply(a);const sum=mul(this,a).add(mul(Q,b));return sum.is0()?undefined:sum}toAffine(iz){const{px:x,py:y,pz:z}=this;const is0=this.is0();if(iz==null)iz=is0?Fp.ONE:Fp.inv(z);const ax=Fp.mul(x,iz);const ay=Fp.mul(y,iz);const zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error("invZ was invalid");return{x:ax,y:ay}}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n$2)return true;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;if(cofactor===_1n$2)return this;if(clearCofactor)return clearCofactor(Point,this);return this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=true){this.assertValidity();return toBytes(Point,this,isCompressed)}toHex(isCompressed=true){return bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE);Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength;const wnaf=wNAF(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE:CURVE,ProjectivePoint:Point,normPrivateKeyToScalar:normPrivateKeyToScalar,weierstrassEquation:weierstrassEquation,isWithinCurveOrder:isWithinCurveOrder}}function validateOpts(curve){const opts=validateBasic(curve);validateObject(opts,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"});return Object.freeze({lowS:true,...opts})}function weierstrass(curveDef){const CURVE=validateOpts(curveDef);const{Fp,n:CURVE_ORDER}=CURVE;const compressedLen=Fp.BYTES+1;const uncompressedLen=2*Fp.BYTES+1;function isValidFieldElement(num){return _0n$2<num&&num<Fp.ORDER}function modN(a){return mod(a,CURVE_ORDER)}function invN(a){return invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine();const x=Fp.toBytes(a.x);const cat=concatBytes;if(isCompressed){return cat(Uint8Array.from([point.hasEvenY()?2:3]),x)}else{return cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))}},fromBytes(bytes){const len=bytes.length;const head=bytes[0];const tail=bytes.subarray(1);if(len===compressedLen&&(head===2||head===3)){const x=bytesToNumberBE(tail);if(!isValidFieldElement(x))throw new Error("Point is not on curve");const y2=weierstrassEquation(x);let y=Fp.sqrt(y2);const isYOdd=(y&_1n$2)===_1n$2;const isHeadOdd=(head&1)===1;if(isHeadOdd!==isYOdd)y=Fp.neg(y);return{x:x,y:y}}else if(len===uncompressedLen&&head===4){const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}}else{throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)}}});const numToNByteStr=num=>bytesToHex(numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){const HALF=CURVE_ORDER>>_1n$2;return number>HALF}function normalizeS(s){return isBiggerThanHalfOrder(s)?modN(-s):s}const slcNum=(b,from,to)=>bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r;this.s=s;this.recovery=recovery;this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;hex=ensureBytes("compactSignature",hex,l*2);return new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=DER.toSig(ensureBytes("DER",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!isWithinCurveOrder(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this;const h=bits2int_modN(ensureBytes("msgHash",msgHash));if(rec==null||![0,1,2,3].includes(rec))throw new Error("recovery id invalid");const radj=rec===2||rec===3?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error("recovery id 2 or 3 invalid");const prefix=(rec&1)===0?"02":"03";const R=Point.fromHex(prefix+numToNByteStr(radj));const ir=invN(radj);const u1=modN(-h*ir);const u2=modN(s*ir);const Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error("point at infinify");Q.assertValidity();return Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{normPrivateKeyToScalar(privateKey);return true}catch(error){return false}},normPrivateKeyToScalar:normPrivateKeyToScalar,randomPrivateKey:()=>{const length=getMinHashLength(CURVE.n);return mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute(windowSize=8,point=Point.BASE){point._setWindowSize(windowSize);point.multiply(BigInt(3));return point}};function getPublicKey(privateKey,isCompressed=true){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)}function isProbPub(item){const arr=item instanceof Uint8Array;const str=typeof item==="string";const len=(arr||str)&&item.length;if(arr)return len===compressedLen||len===uncompressedLen;if(str)return len===2*compressedLen||len===2*uncompressedLen;if(item instanceof Point)return true;return false}function getSharedSecret(privateA,publicB,isCompressed=true){if(isProbPub(privateA))throw new Error("first arg must be private key");if(!isProbPub(publicB))throw new Error("second arg must be public key");const b=Point.fromHex(publicB);return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)}const bits2int=CURVE.bits2int||function(bytes){const num=bytesToNumberBE(bytes);const delta=bytes.length*8-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num};const bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))};const ORDER_MASK=bitMask(CURVE.nBitLength);function int2octets(num){if(typeof num!=="bigint")throw new Error("bigint expected");if(!(_0n$2<=num&&num<ORDER_MASK))throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);return numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if(["recovered","canonical"].some(k=>k in opts))throw new Error("sign() legacy options not supported");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;if(lowS==null)lowS=true;msgHash=ensureBytes("msgHash",msgHash);if(prehash)msgHash=ensureBytes("prehashed msgHash",hash(msgHash));const h1int=bits2int_modN(msgHash);const d=normPrivateKeyToScalar(privateKey);const seedArgs=[int2octets(d),int2octets(h1int)];if(ent!=null){const e=ent===true?randomBytes(Fp.BYTES):ent;seedArgs.push(ensureBytes("extraEntropy",e))}const seed=concatBytes(...seedArgs);const m=h1int;function k2sig(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k);const q=Point.BASE.multiply(k).toAffine();const r=modN(q.x);if(r===_0n$2)return;const s=modN(ik*modN(m+r*d));if(s===_0n$2)return;let recovery=(q.x===r?0:2)|Number(q.y&_1n$2);let normS=s;if(lowS&&isBiggerThanHalfOrder(s)){normS=normalizeS(s);recovery^=1}return new Signature(r,normS,recovery)}return{seed:seed,k2sig:k2sig}}const defaultSigOpts={lowS:CURVE.lowS,prehash:false};const defaultVerOpts={lowS:CURVE.lowS,prehash:false};function sign(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts);const C=CURVE;const drbg=createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac);return drbg(seed,k2sig)}Point.BASE._setWindowSize(8);function verify(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;msgHash=ensureBytes("msgHash",msgHash);publicKey=ensureBytes("publicKey",publicKey);if("strict"in opts)throw new Error("options.strict was renamed to lowS");const{lowS,prehash}=opts;let _sig=undefined;let P;try{if(typeof sg==="string"||sg instanceof Uint8Array){try{_sig=Signature.fromDER(sg)}catch(derError){if(!(derError instanceof DER.Err))throw derError;_sig=Signature.fromCompact(sg)}}else if(typeof sg==="object"&&typeof sg.r==="bigint"&&typeof sg.s==="bigint"){const{r,s}=sg;_sig=new Signature(r,s)}else{throw new Error("PARSE")}P=Point.fromHex(publicKey)}catch(error){if(error.message==="PARSE")throw new Error(`signature must be Signature instance, Uint8Array or hex string`);return false}if(lowS&&_sig.hasHighS())return false;if(prehash)msgHash=CURVE.hash(msgHash);const{r,s}=_sig;const h=bits2int_modN(msgHash);const is=invN(s);const u1=modN(h*is);const u2=modN(r*is);const R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();if(!R)return false;const v=modN(R.x);return v===r}return{CURVE:CURVE,getPublicKey:getPublicKey,getSharedSecret:getSharedSecret,sign:sign,verify:verify,ProjectivePoint:Point,Signature:Signature,utils:utils}}function getHash(hash){return{hash:hash,hmac:(key,...msgs)=>hmac(hash,key,concatBytes$1(...msgs)),randomBytes:randomBytes$2}}function createCurve(curveDef,defHash){const create=hash=>weierstrass({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create:create})}const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");const secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const _1n$1=BigInt(1);const _2n$1=BigInt(2);const divNearest=(a,b)=>(a+b/_2n$1)/b;function sqrtMod(y){const P=secp256k1P;const _3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22);const _23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88);const b2=y*y*y%P;const b3=b2*b2*y%P;const b6=pow2(b3,_3n,P)*b3%P;const b9=pow2(b6,_3n,P)*b3%P;const b11=pow2(b9,_2n$1,P)*b2%P;const b22=pow2(b11,_11n,P)*b11%P;const b44=pow2(b22,_22n,P)*b22%P;const b88=pow2(b44,_44n,P)*b44%P;const b176=pow2(b88,_88n,P)*b88%P;const b220=pow2(b176,_44n,P)*b44%P;const b223=pow2(b220,_3n,P)*b3%P;const t1=pow2(b223,_23n,P)*b22%P;const t2=pow2(t1,_6n,P)*b2%P;const root=pow2(t2,_2n$1,P);if(!Fp.eql(Fp.sqr(root),y))throw new Error("Cannot find square root");return root}const Fp=Field(secp256k1P,undefined,undefined,{sqrt:sqrtMod});const secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:true,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:k=>{const n=secp256k1N;const a1=BigInt("0x3086d221a7d46bcde86c90e49284eb15");const b1=-_1n$1*BigInt("0xe4437ed6010e88286f547fa90abfe4c3");const a2=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");const b2=a1;const POW_2_128=BigInt("0x100000000000000000000000000000000");const c1=divNearest(b2*k,n);const c2=divNearest(-b1*k,n);let k1=mod(k-c1*a1-c2*a2,n);let k2=mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128;const k2neg=k2>POW_2_128;if(k1neg)k1=n-k1;if(k2neg)k2=n-k2;if(k1>POW_2_128||k2>POW_2_128){throw new Error("splitScalar: Endomorphism failed, k="+k)}return{k1neg:k1neg,k1:k1,k2neg:k2neg,k2:k2}}}},sha256$1);const _0n$1=BigInt(0);const fe=x=>typeof x==="bigint"&&_0n$1<x&&x<secp256k1P;const ge=x=>typeof x==="bigint"&&_0n$1<x&&x<secp256k1N;const TAGGED_HASH_PREFIXES={};function taggedHash$1(tag,...messages){let tagP=TAGGED_HASH_PREFIXES[tag];if(tagP===undefined){const tagH=sha256$1(Uint8Array.from(tag,c=>c.charCodeAt(0)));tagP=concatBytes(tagH,tagH);TAGGED_HASH_PREFIXES[tag]=tagP}return sha256$1(concatBytes(tagP,...messages))}const pointToBytes=point=>point.toRawBytes(true).slice(1);const numTo32b=n=>numberToBytesBE(n,32);const modP=x=>mod(x,secp256k1P);const modN=x=>mod(x,secp256k1N);const Point=secp256k1.ProjectivePoint;const GmulAdd=(Q,a,b)=>Point.BASE.multiplyAndAddUnsafe(Q,a,b);function schnorrGetExtPubKey(priv){let d_=secp256k1.utils.normPrivateKeyToScalar(priv);let p=Point.fromPrivateKey(d_);const scalar=p.hasEvenY()?d_:modN(-d_);return{scalar:scalar,bytes:pointToBytes(p)}}function lift_x(x){if(!fe(x))throw new Error("bad x: need 0 < x < p");const xx=modP(x*x);const c=modP(xx*x+BigInt(7));let y=sqrtMod(c);if(y%_2n$1!==_0n$1)y=modP(-y);const p=new Point(x,y,_1n$1);p.assertValidity();return p}function challenge(...args){return modN(bytesToNumberBE(taggedHash$1("BIP0340/challenge",...args)))}function schnorrGetPublicKey(privateKey){return schnorrGetExtPubKey(privateKey).bytes}function schnorrSign(message,privateKey,auxRand=randomBytes$2(32)){const m=ensureBytes("message",message);const{bytes:px,scalar:d}=schnorrGetExtPubKey(privateKey);const a=ensureBytes("auxRand",auxRand,32);const t=numTo32b(d^bytesToNumberBE(taggedHash$1("BIP0340/aux",a)));const rand=taggedHash$1("BIP0340/nonce",t,px,m);const k_=modN(bytesToNumberBE(rand));if(k_===_0n$1)throw new Error("sign failed: k is zero");const{bytes:rx,scalar:k}=schnorrGetExtPubKey(k_);const e=challenge(rx,px,m);const sig=new Uint8Array(64);sig.set(rx,0);sig.set(numTo32b(modN(k+e*d)),32);if(!schnorrVerify(sig,m,px))throw new Error("sign: Invalid signature produced");return sig}function schnorrVerify(signature,message,publicKey){const sig=ensureBytes("signature",signature,64);const m=ensureBytes("message",message);const pub=ensureBytes("publicKey",publicKey,32);try{const P=lift_x(bytesToNumberBE(pub));const r=bytesToNumberBE(sig.subarray(0,32));if(!fe(r))return false;const s=bytesToNumberBE(sig.subarray(32,64));if(!ge(s))return false;const e=challenge(numTo32b(r),pointToBytes(P),m);const R=GmulAdd(P,s,modN(-e));if(!R||!R.hasEvenY()||R.toAffine().x!==r)return false;return true}catch(error){return false}}const schnorr=(()=>({getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x:lift_x,pointToBytes:pointToBytes,numberToBytesBE:numberToBytesBE,bytesToNumberBE:bytesToNumberBE,taggedHash:taggedHash$1,mod:mod}}))();const ZeroAddress="0x0000000000000000000000000000000000000000";const ZeroHash="0x0000000000000000000000000000000000000000000000000000000000000000";const N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const WeiPerEther=BigInt("1000000000000000000");const MaxUint256=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const MinInt256=BigInt("0x8000000000000000000000000000000000000000000000000000000000000000")*BigInt(-1);const MaxInt256=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const quaisymbol="";const MessagePrefix="Ethereum Signed Message:\n";var Shard;(function(Shard){Shard["Cyprus"]="0x0";Shard["Cyprus1"]="0x00";Shard["Cyprus2"]="0x01";Shard["Cyprus3"]="0x02";Shard["Paxos"]="0x1";Shard["Paxos1"]="0x10";Shard["Paxos2"]="0x11";Shard["Paxos3"]="0x12";Shard["Hydra"]="0x2";Shard["Hydra1"]="0x20";Shard["Hydra2"]="0x21";Shard["Hydra3"]="0x22";Shard["Prime"]="0x"})(Shard||(Shard={}));function shardFromBytes(shard){switch(shard){case"0x":return Shard.Prime;case"0x0":return Shard.Cyprus;case"0x1":return Shard.Paxos;case"0x2":return Shard.Hydra;case"0x00":return Shard.Cyprus1;case"0x01":return Shard.Cyprus2;case"0x02":return Shard.Cyprus3;case"0x10":return Shard.Paxos1;case"0x11":return Shard.Paxos2;case"0x12":return Shard.Paxos3;case"0x20":return Shard.Hydra1;case"0x21":return Shard.Hydra2;case"0x22":return Shard.Hydra3;default:throw new Error("Invalid shard")}}const ShardData=[...ZoneData,{name:"Cyprus",nickname:"cyprus",shard:"region-0",context:2,byte:"0x0"},{name:"Paxos",nickname:"paxos",shard:"region-1",context:2,byte:"0x1"},{name:"Hydra",nickname:"hydra",shard:"region-2",context:2,byte:"0x2"},{name:"Prime",nickname:"prime",shard:"prime",context:2,byte:"0x"}];function toShard(shard){return shardFromBytes(ShardData.find(it=>it.name==shard||it.byte==shard||it.nickname==shard||it.shard==shard)?.byte||"")}function fromShard(shard,key){return ShardData.find(it=>it.byte==shard)?.[key]||""}const BN_0$5=BigInt(0);const BN_1$2=BigInt(1);const BN_2=BigInt(2);const BN_27=BigInt(27);const BN_28=BigInt(28);const BN_35=BigInt(35);const _guard$6={};function toUint256(value){return zeroPadValue(toBeArray(value),32)}class Signature{#r;#s;#v;#networkV;get r(){return this.#r}set r(value){assertArgument(dataLength(value)===32,"invalid r","value",value);this.#r=hexlify(value)}get s(){return this.#s}set s(_value){assertArgument(dataLength(_value)===32,"invalid s","value",_value);const value=hexlify(_value);assertArgument(parseInt(value.substring(0,3))<8,"non-canonical s","value",value);this.#s=value}get v(){return this.#v}set v(value){const v=getNumber(value,"value");assertArgument(v===27||v===28,"invalid v","v",value);this.#v=v}get networkV(){return this.#networkV}get legacyChainId(){const v=this.networkV;if(v==null){return null}return Signature.getChainId(v)}get yParity(){return this.v===27?0:1}get yParityAndS(){const yParityAndS=getBytes(this.s);if(this.yParity){yParityAndS[0]|=128}return hexlify(yParityAndS)}get compactSerialized(){return concat([this.r,this.yParityAndS])}get serialized(){return concat([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(guard,r,s,v){assertPrivate(guard,_guard$6,"Signature");this.#r=r;this.#s=s;this.#v=v;this.#networkV=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const clone=new Signature(_guard$6,this.r,this.s,this.v);if(this.networkV){clone.#networkV=this.networkV}return clone}toJSON(){const networkV=this.networkV;return{_type:"signature",networkV:networkV!=null?networkV.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId(v){const bv=getBigInt(v,"v");if(bv==BN_27||bv==BN_28){return BN_0$5}assertArgument(bv>=BN_35,"invalid EIP-155 v","v",v);return(bv-BN_35)/BN_2}static getChainIdV(chainId,v){return getBigInt(chainId)*BN_2+BigInt(35+v-27)}static getNormalizedV(v){const bv=getBigInt(v);if(bv===BN_0$5||bv===BN_27){return 27}if(bv===BN_1$2||bv===BN_28){return 28}assertArgument(bv>=BN_35,"invalid v","v",v);return bv&BN_1$2?27:28}static from(sig){function assertError(check,message){assertArgument(check,message,"signature",sig)}if(sig==null){return new Signature(_guard$6,ZeroHash,ZeroHash,27)}if(typeof sig==="string"){const bytes=getBytes(sig,"signature");if(bytes.length===64){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);const v=s[0]&128?28:27;s[0]&=127;return new Signature(_guard$6,r,hexlify(s),v)}if(bytes.length===65){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);assertError((s[0]&128)===0,"non-canonical s");const v=Signature.getNormalizedV(bytes[64]);return new Signature(_guard$6,r,hexlify(s),v)}assertError(false,"invalid raw signature length")}if(sig instanceof Signature){return sig.clone()}const _r=sig.r;assertError(_r!=null,"missing r");const r=toUint256(_r);const s=function(s,yParityAndS){if(s!=null){return toUint256(s)}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");const bytes=getBytes(yParityAndS);bytes[0]&=127;return hexlify(bytes)}assertError(false,"missing s")}(sig.s,sig.yParityAndS);assertError((getBytes(s)[0]&128)==0,"non-canonical s");const{networkV,v}=function(_v,yParityAndS,yParity){if(_v!=null){const v=getBigInt(_v);return{networkV:v>=BN_35?v:undefined,v:Signature.getNormalizedV(v)}}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");return{v:getBytes(yParityAndS)[0]&128?28:27}}if(yParity!=null){switch(yParity){case 0:return{v:27};case 1:return{v:28}}assertError(false,"invalid yParity")}assertError(false,"missing v")}(sig.v,sig.yParityAndS,sig.yParity);const result=new Signature(_guard$6,r,s,v);if(networkV){result.#networkV=networkV}assertError(!("yParity"in sig&&sig.yParity!==result.yParity),"yParity mismatch");assertError(!("yParityAndS"in sig&&sig.yParityAndS!==result.yParityAndS),"yParityAndS mismatch");return result}}class SigningKey{#privateKey;constructor(privateKey){assertArgument(dataLength(privateKey)===32,"invalid private key","privateKey","[REDACTED]");this.#privateKey=hexlify(privateKey)}get privateKey(){return this.#privateKey}get publicKey(){return SigningKey.computePublicKey(this.#privateKey)}get compressedPublicKey(){return SigningKey.computePublicKey(this.#privateKey,true)}sign(digest){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const sig=secp256k1.sign(getBytesCopy(digest),getBytesCopy(this.#privateKey),{lowS:true});return Signature.from({r:toBeHex("0x"+sig.r.toString(16),32),s:toBeHex("0x"+sig.s.toString(16),32),v:sig.recovery?28:27})}computeSharedSecret(other){const pubKey=SigningKey.computePublicKey(other);return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey),getBytes(pubKey),false))}static computePublicKey(key,compressed){let bytes=getBytes(key,"key");if(bytes.length===32){const pubKey=secp256k1.getPublicKey(bytes,!!compressed);return hexlify(pubKey)}if(bytes.length===64){const pub=new Uint8Array(65);pub[0]=4;pub.set(bytes,1);bytes=pub}const point=secp256k1.ProjectivePoint.fromHex(bytes);return hexlify(point.toRawBytes(compressed))}static recoverPublicKey(digest,signature){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const sig=Signature.from(signature);let secpSig=secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r,sig.s])));secpSig=secpSig.addRecoveryBit(sig.yParity);const pubKey=secpSig.recoverPublicKey(getBytesCopy(digest));assertArgument(pubKey!=null,"invalid signautre for digest","signature",signature);return"0x"+pubKey.toHex(false)}static addPoints(p0,p1,compressed){const pub0=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));const pub1=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));return"0x"+pub0.add(pub1).toHex(!!compressed)}}const _0n=BigInt(0);const _1n=BigInt(1);const _2n=BigInt(2);const _3n=BigInt(3);const _5n=BigInt(5);const _7n=BigInt(7);const _64n=BigInt(64);const _64mask=BigInt("0xFFFFFFFFFFFFFFFF");const CURVE={b:BigInt(7),P:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"),n:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")};function read32b(bytes){if(bytes.length!==32)throw new Error(`Expected 32-bytes, not ${bytes.length}`);const view=new DataView(bytes.buffer,bytes.byteOffset,bytes.length);let b=view.getBigUint64(0);for(let offs=8;offs<bytes.length;offs+=8){b<<=_64n;b+=view.getBigUint64(offs)}return b}function write32b(num,dest=new Uint8Array(32)){const view=new DataView(dest.buffer,dest.byteOffset,dest.length);for(let offs=24;offs>=0;offs-=8){view.setBigUint64(offs,num&_64mask);num>>=_64n}return dest}function readScalar(bytes){const a=read32b(bytes);if(a>=CURVE.n)throw new Error("Expected value mod n");return a}function readSecret(bytes){const a=readScalar(bytes);if(a===0n)throw new Error("Expected non-zero");return a}function secp256k1Right(x){const x2=x*x%CURVE.P;const x3=x2*x%CURVE.P;return(x3+CURVE.b)%CURVE.P}function jacobiSymbol(a){if(a===_0n)return 0;let p=CURVE.P;let sign=1;for(;;){let and3;for(and3=a&_3n;and3===_0n;a>>=_2n,and3=a&_3n);if(and3===_2n){a>>=_1n;const pand7=p&_7n;if(pand7===_3n||pand7===_5n)sign=-sign}if(a===_1n)break;if((_3n&a)===_3n&&(_3n&p)===_3n)sign=-sign;[a,p]=[p%a,a]}return sign>0?1:-1}function isPoint(p){if(p.length<33)return false;const t=p[0];if(p.length===33){return(t===2||t===3)&&isXOnlyPoint(p.subarray(1))}if(t!==4||p.length!==65)return false;const x=read32b(p.subarray(1,33));if(x===_0n)return false;if(x>=CURVE.P)return false;const y=read32b(p.subarray(33));if(y===_0n)return false;if(y>=CURVE.P)return false;const left=y*y%CURVE.P;const right=secp256k1Right(x);return left===right}function isXOnlyPoint(p){if(p.length!==32)return false;const x=read32b(p);if(x===_0n)return false;if(x>=CURVE.P)return false;const y2=secp256k1Right(x);return jacobiSymbol(y2)===1}function scalarAdd(a,b){const aN=readScalar(a);const bN=readScalar(b);const sum=(aN+bN)%CURVE.n;return write32b(sum)}function scalarMultiply(a,b){const aN=readScalar(a);const bN=readScalar(b);const product=aN*bN%CURVE.n;return write32b(product)}function scalarNegate(a){const aN=readScalar(a);const negated=aN===_0n?_0n:CURVE.n-aN;return write32b(negated)}function scalarMod(a){const aN=read32b(a);const remainder=aN%CURVE.n;return write32b(remainder)}function isScalar(t){try{readScalar(t);return true}catch{return false}}function isSecret(s){try{readSecret(s);return true}catch{return false}}function pointNegate(p){const even=hasEvenY(p);const negated=Uint8Array.from(p);if(p.length===33){negated[0]=even?3:2}else if(p.length===65){const y=read32b(p.subarray(33));if(y>=CURVE.P)throw new Error("Expected Y coordinate mod P");const minusY=y===_0n?_0n:CURVE.P-y;write32b(minusY,negated.subarray(33))}return negated}function pointX(p){if(p.length===32)return p;hasEvenY(p);return p.slice(1,33)}function hasEvenY(p){if(p.length===33){if(p[0]===2)return true;else if(p[0]===3)return false;else throw new Error("Wrong first byte to be a point")}if(p.length===65){if(p[0]!==4)throw new Error("Wrong first byte to be point");return p[64]%2===0}throw new Error("Wrong length to be a point")}function pointMultiplyUnsafe(p,a,compress){try{const product=secp256k1.ProjectivePoint.fromHex(p).multiplyAndAddUnsafe(secp256k1.ProjectivePoint.ZERO,BigInt(`0x${Buffer.from(a).toString("hex")}`),BigInt(1));if(!product)return null;return product.toRawBytes(compress)}catch{return null}}function pointMultiplyAndAddUnsafe(p1,a,p2,compress){try{const p2p=secp256k1.ProjectivePoint.fromHex(p2);const p=secp256k1.ProjectivePoint.fromHex(p1).multiplyAndAddUnsafe(p2p,BigInt(`0x${Buffer.from(a).toString("hex")}`),BigInt(1));if(!p)return null;return p.toRawBytes(compress)}catch{return null}}function pointAdd(a,b,compress){try{return secp256k1.ProjectivePoint.fromHex(a).add(secp256k1.ProjectivePoint.fromHex(b)).toRawBytes(compress)}catch{return null}}function pointAddTweak(p,tweak,compress){try{const P=secp256k1.ProjectivePoint.fromHex(p);const t=readSecret(tweak);const Q=secp256k1.ProjectivePoint.BASE.multiplyAndAddUnsafe(P,t,1n);if(!Q)throw new Error("Tweaked point at infinity");return Q.toRawBytes(compress)}catch{return null}}function pointCompress(p,compress=true){return secp256k1.ProjectivePoint.fromHex(p).toRawBytes(compress)}function liftX(p){try{return secp256k1.ProjectivePoint.fromHex(p).toRawBytes(false)}catch{return null}}function getPublicKey(s,compress){try{return secp256k1.getPublicKey(s,compress)}catch{return null}}function taggedHash(tag,...messages){return schnorr.utils.taggedHash(tag,...messages)}function sha256Hash(...messages){const h=sha256$1.create();for(const message of messages)h.update(message);return h.digest()}const musigCrypto={read32b:read32b,write32b:write32b,readScalar:readScalar,readSecret:readSecret,secp256k1Right:secp256k1Right,jacobiSymbol:jacobiSymbol,isPoint:isPoint,isXOnlyPoint:isXOnlyPoint,scalarAdd:scalarAdd,scalarMultiply:scalarMultiply,scalarNegate:scalarNegate,scalarMod:scalarMod,isScalar:isScalar,isSecret:isSecret,pointNegate:pointNegate,pointX:pointX,hasEvenY:hasEvenY,pointMultiplyUnsafe:pointMultiplyUnsafe,pointMultiplyAndAddUnsafe:pointMultiplyAndAddUnsafe,pointAdd:pointAdd,pointAddTweak:pointAddTweak,pointCompress:pointCompress,liftX:liftX,getPublicKey:getPublicKey,taggedHash:taggedHash,sha256:sha256Hash};function lock(){computeHmac.lock();keccak256.lock();pbkdf2.lock();randomBytes.lock();ripemd160.lock();scrypt.lock();scryptSync.lock();sha256.lock();sha512.lock();randomBytes.lock()}function formatMixedCaseChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}function getAddress(address){assertArgument(typeof address==="string","invalid address","address",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith("0x")){address="0x"+address}const result=formatMixedCaseChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,"invalid address checksum","address",address);return result}assertArgument(false,"invalid address string format","address",address)}function getContractAddress(from,nonce,data){const nonceBytes=zeroPadValue(toBeHex(toBigInt(nonce)),8);return getAddress(dataSlice(keccak256(concat([getAddress(from),nonceBytes,stripZerosLeft(data)])),12))}function computeAddress(key){let pubkey;if(typeof key==="string"){pubkey=SigningKey.computePublicKey(key,false)}else{pubkey=key.publicKey}return getAddress(keccak256("0x"+pubkey.substring(4)).substring(26))}function recoverAddress(digest,signature){return computeAddress(SigningKey.recoverPublicKey(digest,signature))}function isAddressable(value){return value&&typeof value.getAddress==="function"}function isAddress(value){try{getAddress(value);return true}catch(error){}return false}async function checkAddress(target,promise){const result=await promise;if(result==null||result==="0x0000000000000000000000000000000000000000"){assertArgument(false,"invalid AddressLike value; did not resolve to a value address","target",target)}return result}function resolveAddress(target){if(typeof target==="string"){if(target.match(/^0x[0-9a-f]{40}$/i)){return target}}else if(isAddressable(target)){return checkAddress(target,target.getAddress())}else if(target&&typeof target.then==="function"){return checkAddress(target,target)}assertArgument(false,"unsupported addressable value","target",target)}function validateAddress(address){assertArgument(typeof address==="string","address must be string","address",address);assertArgument(Boolean(address.match(/^(0x)?[0-9a-fA-F]{40}$/)),"invalid address string format","address",address);assertArgument(formatMixedCaseChecksumAddress(address)===address,"invalid address checksum","address",address)}function isQiAddress(address){const secondByte=address.substring(4,6);const binaryString=parseInt(secondByte,16).toString(2).padStart(8,"0");const isUTXO=binaryString[0]==="1";return isUTXO}function isQuaiAddress(address){return!isQiAddress(address)}function getZoneForAddress(address){try{return toZone(address.slice(0,4))}catch(error){return null}}function getAddressDetails(address){const isQiLedger=(parseInt(address.substring(4,5),16)&1)===Ledger.Qi;return{zone:toZone(address.substring(0,4)),ledger:isQiLedger?Ledger.Qi:Ledger.Quai}}function getTxType(from,to){if(from===null||to===null)return 0;const senderAddressIsQi=isQiAddress(from);const recipientAddressIsQi=isQiAddress(to);switch(true){case senderAddressIsQi&&recipientAddressIsQi:return 2;case senderAddressIsQi&&!recipientAddressIsQi:return 1;default:return 0}}function getNodeLocationFromZone(zone){const zoneId=zone.slice(2);if(zoneId.length>2){throw new Error(`Invalid zone: ${zone}`)}else if(zoneId.length===0){return[]}return zoneId.split("").map(Number)}function getZoneFromNodeLocation(location){if(location.length>2){throw new Error("Invalid location")}return toZone(`0x${location.join("")}`)}const WordSize=32;const Padding=new Uint8Array(WordSize);const passProperties$1=["then"];const _guard$5={};function throwError(name,error){const wrapped=new Error(`deferred error during ABI decoding triggered accessing ${name}`);wrapped.error=error;throw wrapped}class Result extends Array{#names;constructor(...args){const guard=args[0];let items=args[1];let names=(args[2]||[]).slice();let wrap=true;if(guard!==_guard$5){items=args;names=[];wrap=false}super(items.length);items.forEach((item,index)=>{this[index]=item});const nameCounts=names.reduce((accum,name)=>{if(typeof name==="string"){accum.set(name,(accum.get(name)||0)+1)}return accum},new Map);this.#names=Object.freeze(items.map((item,index)=>{const name=names[index];if(name!=null&&nameCounts.get(name)===1){return name}return null}));if(!wrap){return}Object.freeze(this);return new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop==="string"){if(prop.match(/^[0-9]+$/)){const index=getNumber(prop,"%index");if(index<0||index>=this.length){throw new RangeError("out of result range")}const item=target[index];if(item instanceof Error){throwError(`index ${index}`,item)}return item}if(passProperties$1.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}const value=target[prop];if(value instanceof Function){return function(...args){return value.apply(this===receiver?target:this,args)}}else if(!(prop in target)){return target.getValue.apply(this===receiver?target:this,[prop])}}return Reflect.get(target,prop,receiver)}})}toArray(){const result=[];this.forEach((item,index)=>{if(item instanceof Error){throwError(`index ${index}`,item)}result.push(item)});return result}toObject(){return this.#names.reduce((accum,name,index)=>{assert$1(name!=null,"value at index ${ index } unnamed","UNSUPPORTED_OPERATION",{operation:"toObject()"});if(!(name in accum)){accum[name]=this.getValue(name)}return accum},{})}slice(start,end){if(start==null){start=0}if(start<0){start+=this.length;if(start<0){start=0}}if(end==null){end=this.length}if(end<0){end+=this.length;if(end<0){end=0}}if(end>this.length){end=this.length}const result=[],names=[];for(let i=start;i<end;i++){result.push(this[i]);names.push(this.#names[i])}return new Result(_guard$5,result,names)}filter(callback,thisArg){const result=[],names=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}if(callback.call(thisArg,item,i,this)){result.push(item);names.push(this.#names[i])}}return new Result(_guard$5,result,names)}map(callback,thisArg){const result=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}result.push(callback.call(thisArg,item,i,this))}return result}getValue(name){const index=this.#names.indexOf(name);if(index===-1){return undefined}const value=this[index];if(value instanceof Error){throwError(`property ${JSON.stringify(name)}`,value.error)}return value}static fromItems(items,keys){return new Result(_guard$5,items,keys)}}function checkResultErrors(result){const errors=[];const checkErrors=function(path,object){if(!Array.isArray(object)){return}for(const key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};checkErrors([],result);return errors}function getValue$1(value){let bytes=toBeArray(value);assert$1(bytes.length<=WordSize,"value out-of-bounds","BUFFER_OVERRUN",{buffer:bytes,length:WordSize,offset:bytes.length});if(bytes.length!==WordSize){bytes=getBytesCopy(concat([Padding.slice(bytes.length%WordSize),bytes]))}return bytes}class Coder{name;type;localName;dynamic;constructor(name,type,localName,dynamic){defineProperties(this,{name:name,type:type,localName:localName,dynamic:dynamic},{name:"string",type:"string",localName:"string",dynamic:"boolean"})}_throwError(message,value){assertArgument(false,message,this.localName,value)}}class Writer{#data;#dataLength;constructor(){this.#data=[];this.#dataLength=0}get data(){return concat(this.#data)}get length(){return this.#dataLength}#writeData(data){this.#data.push(data);this.#dataLength+=data.length;return data.length}appendWriter(writer){return this.#writeData(getBytesCopy(writer.data))}writeBytes(value){let bytes=getBytesCopy(value);const paddingOffset=bytes.length%WordSize;if(paddingOffset){bytes=getBytesCopy(concat([bytes,Padding.slice(paddingOffset)]))}return this.#writeData(bytes)}writeValue(value){return this.#writeData(getValue$1(value))}writeUpdatableValue(){const offset=this.#data.length;this.#data.push(Padding);this.#dataLength+=WordSize;return value=>{this.#data[offset]=getValue$1(value)}}}class Reader{allowLoose;#data;#offset;#bytesRead;#parent;#maxInflation;constructor(data,allowLoose,maxInflation){defineProperties(this,{allowLoose:!!allowLoose});this.#data=getBytesCopy(data);this.#bytesRead=0;this.#parent=null;this.#maxInflation=maxInflation!=null?maxInflation:1024;this.#offset=0}get data(){return hexlify(this.#data)}get dataLength(){return this.#data.length}get consumed(){return this.#offset}get bytes(){return new Uint8Array(this.#data)}#incrementBytesRead(count){if(this.#parent){return this.#parent.#incrementBytesRead(count)}this.#bytesRead+=count;assert$1(this.#maxInflation<1||this.#bytesRead<=this.#maxInflation*this.dataLength,`compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`,"BUFFER_OVERRUN",{buffer:getBytesCopy(this.#data),offset:this.#offset,length:count,info:{bytesRead:this.#bytesRead,dataLength:this.dataLength}})}#peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/WordSize)*WordSize;if(this.#offset+alignedLength>this.#data.length){if(this.allowLoose&&loose&&this.#offset+length<=this.#data.length){alignedLength=length}else{assert$1(false,"data out-of-bounds","BUFFER_OVERRUN",{buffer:getBytesCopy(this.#data),length:this.#data.length,offset:this.#offset+alignedLength})}}return this.#data.slice(this.#offset,this.#offset+alignedLength)}subReader(offset){const reader=new Reader(this.#data.slice(this.#offset+offset),this.allowLoose,this.#maxInflation);reader.#parent=this;return reader}readBytes(length,loose){const bytes=this.#peekBytes(0,length,!!loose);this.#incrementBytesRead(length);this.#offset+=bytes.length;return bytes.slice(0,length)}readValue(){return toBigInt(this.readBytes(WordSize))}readIndex(){return toNumber(this.readBytes(WordSize))}}function getCreateAddress(tx){const from=getAddress(tx.from);const nonce=getBigInt(tx.nonce,"tx.nonce");const nonceBytes=bigEndianNonce(nonce);const fromBytes=getBytes(from);const codeBytes=tx.data?getBytes(tx.data):new Uint8Array;const concatenated=new Uint8Array([...fromBytes,...nonceBytes,...codeBytes]);const hash=keccak256(concatenated);return getAddress(dataSlice(hash,12))}function getCreate2Address(_from,_salt,_initCodeHash){const from=getAddress(_from);const salt=getBytes(_salt,"salt");const initCodeHash=getBytes(_initCodeHash,"initCodeHash");assertArgument(salt.length===32,"salt must be 32 bytes","salt",_salt);assertArgument(initCodeHash.length===32,"initCodeHash must be 32 bytes","initCodeHash",_initCodeHash);return getAddress(dataSlice(keccak256(concat(["0xff",from,salt,initCodeHash])),12))}function bigEndianNonce(nonce){const buffer=new ArrayBuffer(8);const view=new DataView(buffer);view.setBigUint64(0,nonce,false);return new Uint8Array(buffer)}const _guard$4={};function n(value,width){let signed=false;if(width<0){signed=true;width*=-1}return new Typed(_guard$4,`${signed?"":"u"}int${width}`,value,{signed:signed,width:width})}function b(value,size){return new Typed(_guard$4,`bytes${size?size:""}`,value,{size:size})}const _typedSymbol=Symbol.for("_quais_typed");class Typed{type;value;#options;_typedSymbol;constructor(guard,type,value,options){if(options==null){options=null}assertPrivate(_guard$4,guard,"Typed");defineProperties(this,{_typedSymbol:_typedSymbol,type:type,value:value});this.#options=options;this.format()}format(){if(this.type==="array"){throw new Error("")}else if(this.type==="dynamicArray"){throw new Error("")}else if(this.type==="tuple"){return`tuple(${this.value.map(v=>v.format()).join(",")})`}return this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return this.type==="string"}get tupleName(){if(this.type!=="tuple"){throw TypeError("not a tuple")}return this.#options}get arrayLength(){if(this.type!=="array"){throw TypeError("not an array")}if(this.#options===true){return-1}if(this.#options===false){return this.value.length}return null}static from(type,value){return new Typed(_guard$4,type,value)}static uint8(v){return n(v,8)}static uint16(v){return n(v,16)}static uint24(v){return n(v,24)}static uint32(v){return n(v,32)}static uint40(v){return n(v,40)}static uint48(v){return n(v,48)}static uint56(v){return n(v,56)}static uint64(v){return n(v,64)}static uint72(v){return n(v,72)}static uint80(v){return n(v,80)}static uint88(v){return n(v,88)}static uint96(v){return n(v,96)}static uint104(v){return n(v,104)}static uint112(v){return n(v,112)}static uint120(v){return n(v,120)}static uint128(v){return n(v,128)}static uint136(v){return n(v,136)}static uint144(v){return n(v,144)}static uint152(v){return n(v,152)}static uint160(v){return n(v,160)}static uint168(v){return n(v,168)}static uint176(v){return n(v,176)}static uint184(v){return n(v,184)}static uint192(v){return n(v,192)}static uint200(v){return n(v,200)}static uint208(v){return n(v,208)}static uint216(v){return n(v,216)}static uint224(v){return n(v,224)}static uint232(v){return n(v,232)}static uint240(v){return n(v,240)}static uint248(v){return n(v,248)}static uint256(v){return n(v,256)}static uint(v){return n(v,256)}static int8(v){return n(v,-8)}static int16(v){return n(v,-16)}static int24(v){return n(v,-24)}static int32(v){return n(v,-32)}static int40(v){return n(v,-40)}static int48(v){return n(v,-48)}static int56(v){return n(v,-56)}static int64(v){return n(v,-64)}static int72(v){return n(v,-72)}static int80(v){return n(v,-80)}static int88(v){return n(v,-88)}static int96(v){return n(v,-96)}static int104(v){return n(v,-104)}static int112(v){return n(v,-112)}static int120(v){return n(v,-120)}static int128(v){return n(v,-128)}static int136(v){return n(v,-136)}static int144(v){return n(v,-144)}static int152(v){return n(v,-152)}static int160(v){return n(v,-160)}static int168(v){return n(v,-168)}static int176(v){return n(v,-176)}static int184(v){return n(v,-184)}static int192(v){return n(v,-192)}static int200(v){return n(v,-200)}static int208(v){return n(v,-208)}static int216(v){return n(v,-216)}static int224(v){return n(v,-224)}static int232(v){return n(v,-232)}static int240(v){return n(v,-240)}static int248(v){return n(v,-248)}static int256(v){return n(v,-256)}static int(v){return n(v,-256)}static bytes1(v){return b(v,1)}static bytes2(v){return b(v,2)}static bytes3(v){return b(v,3)}static bytes4(v){return b(v,4)}static bytes5(v){return b(v,5)}static bytes6(v){return b(v,6)}static bytes7(v){return b(v,7)}static bytes8(v){return b(v,8)}static bytes9(v){return b(v,9)}static bytes10(v){return b(v,10)}static bytes11(v){return b(v,11)}static bytes12(v){return b(v,12)}static bytes13(v){return b(v,13)}static bytes14(v){return b(v,14)}static bytes15(v){return b(v,15)}static bytes16(v){return b(v,16)}static bytes17(v){return b(v,17)}static bytes18(v){return b(v,18)}static bytes19(v){return b(v,19)}static bytes20(v){return b(v,20)}static bytes21(v){return b(v,21)}static bytes22(v){return b(v,22)}static bytes23(v){return b(v,23)}static bytes24(v){return b(v,24)}static bytes25(v){return b(v,25)}static bytes26(v){return b(v,26)}static bytes27(v){return b(v,27)}static bytes28(v){return b(v,28)}static bytes29(v){return b(v,29)}static bytes30(v){return b(v,30)}static bytes31(v){return b(v,31)}static bytes32(v){return b(v,32)}static address(v){return new Typed(_guard$4,"address",v)}static bool(v){return new Typed(_guard$4,"bool",!!v)}static bytes(v){return new Typed(_guard$4,"bytes",v)}static string(v){return new Typed(_guard$4,"string",v)}static array(v,dynamic){throw new Error("not implemented yet")}static tuple(v,name){throw new Error("not implemented yet")}static overrides(v){return new Typed(_guard$4,"overrides",Object.assign({},v))}static isTyped(value){return value&&typeof value==="object"&&"_typedSymbol"in value&&value._typedSymbol===_typedSymbol}static dereference(value,type){if(Typed.isTyped(value)){if(value.type!==type){throw new Error(`invalid type: expected ${type}, got ${value.type}`)}return value.value}return value}}class AddressCoder extends Coder{constructor(localName){super("address","address",localName,false)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(writer,_value){let value=Typed.dereference(_value,"string");try{value=getAddress(value)}catch(error){return this._throwError(error.message,_value)}return writer.writeValue(value)}decode(reader){return getAddress(toBeHex(reader.readValue(),20))}}class AnonymousCoder extends Coder{coder;constructor(coder){super(coder.name,coder.type,"_",coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}function pack(writer,coders,values){let arrayValues=[];if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values==="object"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;assert$1(name,"cannot encode object for signature with missing names","INVALID_ARGUMENT",{argument:"values",info:{coder:coder},value:values});assert$1(!unique[name],"cannot encode object for signature with duplicate names","INVALID_ARGUMENT",{argument:"values",info:{coder:coder},value:values});unique[name]=true;return values[name]})}else{assertArgument(false,"invalid tuple value","tuple",values)}assertArgument(coders.length===arrayValues.length,"types/value length mismatch","tuple",values);let staticWriter=new Writer;let dynamicWriter=new Writer;let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let keys=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readIndex();let offsetReader=baseReader.subReader(offset);try{value=coder.decode(offsetReader)}catch(error){if(isError(error,"BUFFER_OVERRUN")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(isError(error,"BUFFER_OVERRUN")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value==undefined){throw new Error("investigate")}values.push(value);keys.push(coder.localName||null)});return Result.fromItems(values,keys)}class ArrayCoder extends Coder{coder;length;constructor(coder,length,localName){const type=coder.type+"["+(length>=0?length:"")+"]";const dynamic=length===-1||coder.dynamic;super("array",type,localName,dynamic);defineProperties(this,{coder:coder,length:length})}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,_value){const value=Typed.dereference(_value,"array");if(!Array.isArray(value)){this._throwError("expected array value",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}assertArgumentCount(value.length,count,"coder array"+(this.localName?" "+this.localName:""));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readIndex();assert$1(count*WordSize<=reader.dataLength,"insufficient data length","BUFFER_OVERRUN",{buffer:reader.bytes,offset:count*WordSize,length:reader.dataLength})}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return unpack(reader,coders)}}class BooleanCoder extends Coder{constructor(localName){super("bool","bool",localName,false)}defaultValue(){return false}encode(writer,_value){const value=Typed.dereference(_value,"bool");return writer.writeValue(value?1:0)}decode(reader){return!!reader.readValue()}}class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return"0x"}encode(writer,value){value=getBytesCopy(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readIndex(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super("bytes",localName)}decode(reader){return hexlify(super.decode(reader))}}class FixedBytesCoder extends Coder{size;constructor(size,localName){let name="bytes"+String(size);super(name,name,localName,false);defineProperties(this,{size:size},{size:"number"})}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+this.size*2)}encode(writer,_value){let data=getBytesCopy(Typed.dereference(_value,this.type));if(data.length!==this.size){this._throwError("incorrect data length",_value)}return writer.writeBytes(data)}decode(reader){return hexlify(reader.readBytes(this.size))}}const Empty=new Uint8Array([]);class NullCoder extends Coder{constructor(localName){super("null","",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError("not null",value)}return writer.writeBytes(Empty)}decode(reader){reader.readBytes(0);return null}}const BN_0$4=BigInt(0);const BN_1$1=BigInt(1);const BN_MAX_UINT256$1=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");class NumberCoder extends Coder{size;signed;constructor(size,signed,localName){const name=(signed?"int":"uint")+size*8;super(name,name,localName,false);defineProperties(this,{size:size,signed:signed},{size:"number",signed:"boolean"})}defaultValue(){return 0}encode(writer,_value){let value=getBigInt(Typed.dereference(_value,this.type));let maxUintValue=mask(BN_MAX_UINT256$1,WordSize*8);if(this.signed){let bounds=mask(maxUintValue,this.size*8-1);if(value>bounds||value<-(bounds+BN_1$1)){this._throwError("value out-of-bounds",_value)}value=toTwos(value,8*WordSize)}else if(value<BN_0$4||value>mask(maxUintValue,this.size*8)){this._throwError("value out-of-bounds",_value)}return writer.writeValue(value)}decode(reader){let value=mask(reader.readValue(),this.size*8);if(this.signed){value=fromTwos(value,this.size*8)}return value}}class StringCoder extends DynamicBytesCoder{constructor(localName){super("string",localName)}defaultValue(){return""}encode(writer,_value){return super.encode(writer,toUtf8Bytes(Typed.dereference(_value,"string")))}decode(reader){return toUtf8String(super.decode(reader))}}class TupleCoder extends Coder{coders;constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type="tuple("+types.join(",")+")";super("tuple",type,localName,dynamic);defineProperties(this,{coders:Object.freeze(coders.slice())})}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,_value){const value=Typed.dereference(_value,"tuple");return pack(writer,this.coders,value)}decode(reader){return unpack(reader,this.coders)}}function id(value){return keccak256(toUtf8Bytes(value))}function hashMessage(message){if(typeof message==="string"){message=toUtf8Bytes(message)}return keccak256(concat([toUtf8Bytes(MessagePrefix),toUtf8Bytes(String(message.length)),message]))}function verifyMessage(message,sig){const digest=hashMessage(message);return recoverAddress(digest,sig)}const regexBytes=new RegExp("^bytes([0-9]+)$");const regexNumber=new RegExp("^(u?int)([0-9]*)$");const regexArray=new RegExp("^(.*)\\[([0-9]*)\\]$");function _pack(type,value,isArray){switch(type){case"address":if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(getAddress(value));case"string":return toUtf8Bytes(value);case"bytes":return getBytes(value);case"bool":value=value?"0x01":"0x00";if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(value)}let match=type.match(regexNumber);if(match){const signed=match[1]==="int";let size=parseInt(match[2]||"256");assertArgument((!match[2]||match[2]===String(size))&&size%8===0&&size!==0&&size<=256,"invalid number type","type",type);if(isArray){size=256}if(signed){value=toTwos(value,size)}return getBytes(zeroPadValue(toBeArray(value),size/8))}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);assertArgument(String(size)===match[1]&&size!==0&&size<=32,"invalid bytes type","type",type);assertArgument(dataLength(value)===size,`invalid value for ${type}`,"value",value);if(isArray){return getBytes(zeroPadBytes(value,32))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));assertArgument(count===value.length,`invalid array length for ${type}`,"value",value);const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return getBytes(concat(result))}assertArgument(false,"invalid type","type",type)}function solidityPacked(types,values){assertArgument(types.length===values.length,"wrong number of values; expected ${ types.length }","values",values);const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function solidityPackedKeccak256(types,values){return keccak256(solidityPacked(types,values))}function solidityPackedSha256(types,values){return sha256(solidityPacked(types,values))}const padding=new Uint8Array(32);padding.fill(0);const BN__1=BigInt(-1);const BN_0$3=BigInt(0);const BN_1=BigInt(1);const BN_MAX_UINT256=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function hexPadRight(value){const bytes=getBytes(value);const padOffset=bytes.length%32;if(padOffset){return concat([bytes,padding.slice(padOffset)])}return hexlify(bytes)}const hexTrue=toBeHex(BN_1,32);const hexFalse=toBeHex(BN_0$3,32);const domainFieldTypes={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"};const domainFieldNames=["name","version","chainId","verifyingContract","salt"];function checkString(key){return function(value){assertArgument(typeof value==="string",`invalid domain value for ${JSON.stringify(key)}`,`domain.${key}`,value);return value}}const domainChecks={name:checkString("name"),version:checkString("version"),chainId:function(_value){const value=getBigInt(_value,"domain.chainId");assertArgument(value>=0,"invalid chain ID","domain.chainId",_value);if(Number.isSafeInteger(value)){return Number(value)}return toQuantity(value)},verifyingContract:function(value){try{return getAddress(value)}catch(error){}assertArgument(false,`invalid domain value "verifyingContract"`,"domain.verifyingContract",value)},salt:function(value){const bytes=getBytes(value,"domain.salt");assertArgument(bytes.length===32,`invalid domain value "salt"`,"domain.salt",value);return hexlify(bytes)}};function getBaseEncoder(type){{const match=type.match(/^(u?)int(\d*)$/);if(match){const signed=match[1]==="";const width=parseInt(match[2]||"256");assertArgument(width%8===0&&width!==0&&width<=256&&(match[2]==null||match[2]===String(width)),"invalid numeric width","type",type);const boundsUpper=mask(BN_MAX_UINT256,signed?width-1:width);const boundsLower=signed?(boundsUpper+BN_1)*BN__1:BN_0$3;return function(_value){const value=getBigInt(_value,"value");assertArgument(value>=boundsLower&&value<=boundsUpper,`value out-of-bounds for ${type}`,"value",value);return toBeHex(signed?toTwos(value,256):value,32)}}}{const match=type.match(/^bytes(\d+)$/);if(match){const width=parseInt(match[1]);assertArgument(width!==0&&width<=32&&match[1]===String(width),"invalid bytes width","type",type);return function(value){const bytes=getBytes(value);assertArgument(bytes.length===width,`invalid length for ${type}`,"value",value);return hexPadRight(value)}}}switch(type){case"address":return function(value){return zeroPadValue(getAddress(value),32)};case"bool":return function(value){return!value?hexFalse:hexTrue};case"bytes":return function(value){return keccak256(value)};case"string":return function(value){return id(value)}}return null}function encodeType(name,fields){return`${name}(${fields.map(({name,type})=>type+" "+name).join(",")})`}class TypedDataEncoder{primaryType;#types;get types(){return JSON.parse(this.#types)}#fullTypes;#encoderCache;constructor(types){this.#types=JSON.stringify(types);this.#fullTypes=new Map;this.#encoderCache=new Map;const links=new Map;const parents=new Map;const subtypes=new Map;Object.keys(types).forEach(type=>{links.set(type,new Set);parents.set(type,[]);subtypes.set(type,new Set)});for(const name in types){const uniqueNames=new Set;for(const field of types[name]){assertArgument(!uniqueNames.has(field.name),`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`,"types",types);uniqueNames.add(field.name);const baseType=field.type.match(/^([^\x5b]*)(\x5b|$)/)[1]||null;assertArgument(baseType!==name,`circular type reference to ${JSON.stringify(baseType)}`,"types",types);const encoder=getBaseEncoder(baseType);if(encoder){continue}assertArgument(parents.has(baseType),`unknown type ${JSON.stringify(baseType)}`,"types",types);parents.get(baseType).push(name);links.get(name).add(baseType)}}const primaryTypes=Array.from(parents.keys()).filter(n=>parents.get(n).length===0);assertArgument(primaryTypes.length!==0,"missing primary type","types",types);assertArgument(primaryTypes.length===1,`ambiguous primary types or unused types: ${primaryTypes.map(t=>JSON.stringify(t)).join(", ")}`,"types",types);defineProperties(this,{primaryType:primaryTypes[0]});function checkCircular(type,found){assertArgument(!found.has(type),`circular type reference to ${JSON.stringify(type)}`,"types",types);found.add(type);for(const child of links.get(type)){if(!parents.has(child)){continue}checkCircular(child,found);for(const subtype of found){subtypes.get(subtype).add(child)}}found.delete(type)}checkCircular(this.primaryType,new Set);for(const[name,set]of subtypes){const st=Array.from(set);st.sort();this.#fullTypes.set(name,encodeType(name,types[name])+st.map(t=>encodeType(t,types[t])).join(""))}}getEncoder(type){let encoder=this.#encoderCache.get(type);if(!encoder){encoder=this.#getEncoder(type);this.#encoderCache.set(type,encoder)}return encoder}#getEncoder(type){{const encoder=getBaseEncoder(type);if(encoder){return encoder}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){const subtype=match[1];const subEncoder=this.getEncoder(subtype);return value=>{assertArgument(!match[3]||parseInt(match[3])===value.length,`array length mismatch; expected length ${parseInt(match[3])}`,"value",value);let result=value.map(subEncoder);if(this.#fullTypes.has(subtype)){result=result.map(keccak256)}return keccak256(concat(result))}}const fields=this.types[type];if(fields){const encodedType=id(this.#fullTypes.get(type));return value=>{const values=fields.map(({name,type})=>{const result=this.getEncoder(type)(value[name]);if(this.#fullTypes.has(type)){return keccak256(result)}return result});values.unshift(encodedType);return concat(values)}}assertArgument(false,`unknown type: ${type}`,"type",type)}encodeType(name){const result=this.#fullTypes.get(name);assertArgument(result,`unknown type: ${JSON.stringify(name)}`,"name",name);return result}encodeData(type,value){return this.getEncoder(type)(value)}hashStruct(name,value){return keccak256(this.encodeData(name,value))}encode(value){return this.encodeData(this.primaryType,value)}hash(value){return this.hashStruct(this.primaryType,value)}_visit(type,value,callback){{const encoder=getBaseEncoder(type);if(encoder){return callback(type,value)}}const match=type.match(/^(.*)(\x5b(\d*)\x5d)$/);if(match){assertArgument(!match[3]||parseInt(match[3])===value.length,`array length mismatch; expected length ${parseInt(match[3])}`,"value",value);return value.map(v=>this._visit(match[1],v,callback))}const fields=this.types[type];if(fields){return fields.reduce((accum,{name,type})=>{accum[name]=this._visit(type,value[name],callback);return accum},{})}assertArgument(false,`unknown type: ${type}`,"type",type)}visit(value,callback){return this._visit(this.primaryType,value,callback)}static from(types){return new TypedDataEncoder(types)}static getPrimaryType(types){return TypedDataEncoder.from(types).primaryType}static hashStruct(name,types,value){return TypedDataEncoder.from(types).hashStruct(name,value)}static hashDomain(domain){const domainFields=[];for(const name in domain){if(domain[name]==null){continue}const type=domainFieldTypes[name];assertArgument(type,`invalid typed-data domain key: ${JSON.stringify(name)}`,"domain",domain);domainFields.push({name:name,type:type})}domainFields.sort((a,b)=>{return domainFieldNames.indexOf(a.name)-domainFieldNames.indexOf(b.name)});return TypedDataEncoder.hashStruct("EIP712Domain",{EIP712Domain:domainFields},domain)}static encode(domain,types,value){return concat(["0x1901",TypedDataEncoder.hashDomain(domain),TypedDataEncoder.from(types).hash(value)])}static hash(domain,types,value){return keccak256(TypedDataEncoder.encode(domain,types,value))}static getPayload(domain,types,value){TypedDataEncoder.hashDomain(domain);const domainValues={};const domainTypes=[];domainFieldNames.forEach(name=>{const value=domain[name];if(value==null){return}domainValues[name]=domainChecks[name](value);domainTypes.push({name:name,type:domainFieldTypes[name]})});const encoder=TypedDataEncoder.from(types);const typesWithDomain=Object.assign({},types);assertArgument(typesWithDomain.EIP712Domain==null,"types must not contain EIP712Domain type","types.EIP712Domain",types);typesWithDomain.EIP712Domain=domainTypes;encoder.encode(value);return{types:typesWithDomain,domain:domainValues,primaryType:encoder.primaryType,message:encoder.visit(value,(type,value)=>{if(type.match(/^bytes(\d*)/)){return hexlify(getBytes(value))}if(type.match(/^u?int/)){return getBigInt(value).toString()}switch(type){case"address":return value.toLowerCase();case"bool":return!!value;case"string":assertArgument(typeof value==="string","invalid string","value",value);return value}assertArgument(false,"unsupported type","type",type)})}}}function verifyTypedData(domain,types,value,signature){return recoverAddress(TypedDataEncoder.hash(domain,types,value),signature)}function setify(items){const result=new Set;items.forEach(k=>result.add(k));return Object.freeze(result)}const _kwVisibDeploy="external public payable";const KwVisibDeploy=setify(_kwVisibDeploy.split(" "));const _kwVisib="constant external internal payable private public pure view";const KwVisib=setify(_kwVisib.split(" "));const _kwTypes="constructor error event fallback function receive struct";const KwTypes=setify(_kwTypes.split(" "));const _kwModifiers="calldata memory storage payable indexed";const KwModifiers=setify(_kwModifiers.split(" "));const _kwOther="tuple returns";const _keywords=[_kwTypes,_kwModifiers,_kwOther,_kwVisib].join(" ");const Keywords=setify(_keywords.split(" "));const SimpleTokens={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"};const regexWhitespacePrefix=new RegExp("^(\\s*)");const regexNumberPrefix=new RegExp("^([0-9]+)");const regexIdPrefix=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");const regexId=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");const regexType=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");class TokenString{#offset;#tokens;get offset(){return this.#offset}get length(){return this.#tokens.length-this.#offset}constructor(tokens){this.#offset=0;this.#tokens=tokens.slice()}clone(){return new TokenString(this.#tokens)}reset(){this.#offset=0}#subTokenString(from=0,to=0){return new TokenString(this.#tokens.slice(from,to).map(t=>{return Object.freeze(Object.assign({},t,{match:t.match-from,linkBack:t.linkBack-from,linkNext:t.linkNext-from}))}))}popKeyword(allowed){const top=this.peek();if(top.type!=="KEYWORD"||!allowed.has(top.text)){throw new Error(`expected keyword ${top.text}`)}return this.pop().text}popType(type){if(this.peek().type!==type){throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`)}return this.pop().text}popParen(){const top=this.peek();if(top.type!=="OPEN_PAREN"){throw new Error("bad start")}const result=this.#subTokenString(this.#offset+1,top.match+1);this.#offset=top.match+1;return result}popParams(){const top=this.peek();if(top.type!=="OPEN_PAREN"){throw new Error("bad start")}const result=[];while(this.#offset<top.match-1){const link=this.peek().linkNext;result.push(this.#subTokenString(this.#offset+1,link));this.#offset=link}this.#offset=top.match+1;return result}peek(){if(this.#offset>=this.#tokens.length){throw new Error("out-of-bounds")}return this.#tokens[this.#offset]}peekKeyword(allowed){const top=this.peekType("KEYWORD");return top!=null&&allowed.has(top)?top:null}peekType(type){if(this.length===0){return null}const top=this.peek();return top.type===type?top.text:null}pop(){const result=this.peek();this.#offset++;return result}toString(){const tokens=[];for(let i=this.#offset;i<this.#tokens.length;i++){const token=this.#tokens[i];tokens.push(`${token.type}:${token.text}`)}return`<TokenString ${tokens.join(" ")}>`}}function lex(text){const tokens=[];const throwError=message=>{const token=offset<text.length?JSON.stringify(text[offset]):"$EOI";throw new Error(`invalid token ${token} at ${offset}: ${message}`)};const brackets=[];const commas=[];let offset=0;while(offset<text.length){let cur=text.substring(offset);let match=cur.match(regexWhitespacePrefix);if(match){offset+=match[1].length;cur=text.substring(offset)}const token={depth:brackets.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:offset,value:-1};tokens.push(token);const type=SimpleTokens[cur[0]]||"";if(type){token.type=type;token.text=cur[0];offset++;if(type==="OPEN_PAREN"){brackets.push(tokens.length-1);commas.push(tokens.length-1)}else if(type=="CLOSE_PAREN"){if(brackets.length===0){throwError("no matching open bracket")}token.match=brackets.pop();tokens[token.match].match=tokens.length-1;token.depth--;token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1}else if(type==="COMMA"){token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1;commas.push(tokens.length-1)}else if(type==="OPEN_BRACKET"){token.type="BRACKET"}else if(type==="CLOSE_BRACKET"){let suffix=tokens.pop().text;if(tokens.length>0&&tokens[tokens.length-1].type==="NUMBER"){const value=tokens.pop().text;suffix=value+suffix;tokens[tokens.length-1].value=getNumber(value)}if(tokens.length===0||tokens[tokens.length-1].type!=="BRACKET"){throw new Error("missing opening bracket")}tokens[tokens.length-1].text+=suffix}continue}match=cur.match(regexIdPrefix);if(match){token.text=match[1];offset+=token.text.length;if(Keywords.has(token.text)){token.type="KEYWORD";continue}if(token.text.match(regexType)){token.type="TYPE";continue}token.type="ID";continue}match=cur.match(regexNumberPrefix);if(match){token.text=match[1];token.type="NUMBER";offset+=token.text.length;continue}throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`)}return new TokenString(tokens.map(t=>Object.freeze(t)))}function allowSingle(set,allowed){const included=[];for(const key in allowed.keys()){if(set.has(key)){included.push(key)}}if(included.length>1){throw new Error(`conflicting types: ${included.join(", ")}`)}}function consumeName(type,tokens){if(tokens.peekKeyword(KwTypes)){const keyword=tokens.pop().text;if(keyword!==type){throw new Error(`expected ${type}, got ${keyword}`)}}return tokens.popType("ID")}function consumeKeywords(tokens,allowed){const keywords=new Set;while(true){const keyword=tokens.peekType("KEYWORD");if(keyword==null||allowed&&!allowed.has(keyword)){break}tokens.pop();if(keywords.has(keyword)){throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`)}keywords.add(keyword)}return Object.freeze(keywords)}function consumeMutability(tokens){const modifiers=consumeKeywords(tokens,KwVisib);allowSingle(modifiers,setify("constant payable nonpayable".split(" ")));allowSingle(modifiers,setify("pure view payable nonpayable".split(" ")));if(modifiers.has("view")){return"view"}if(modifiers.has("pure")){return"pure"}if(modifiers.has("payable")){return"payable"}if(modifiers.has("nonpayable")){return"nonpayable"}if(modifiers.has("constant")){return"view"}return"nonpayable"}function consumeParams(tokens,allowIndexed){return tokens.popParams().map(t=>ParamType.from(t,allowIndexed))}function consumeGas(tokens){if(tokens.peekType("AT")){tokens.pop();if(tokens.peekType("NUMBER")){return getBigInt(tokens.pop().text)}throw new Error("invalid gas")}return null}function consumeEoi(tokens){if(tokens.length){throw new Error(`unexpected tokens: ${tokens.toString()}`)}}const regexArrayType=new RegExp(/^(.*)\[([0-9]*)\]$/);function verifyBasicType(type){const match=type.match(regexType);assertArgument(match,"invalid type","type",type);if(type==="uint"){return"uint256"}if(type==="int"){return"int256"}if(match[2]){const length=parseInt(match[2]);assertArgument(length!==0&&length<=32,"invalid bytes length","type",type)}else if(match[3]){const size=parseInt(match[3]);assertArgument(size!==0&&size<=256&&size%8===0,"invalid numeric width","type",type)}return type}const _guard$3={};const internal$1=Symbol.for("_quais_internal");const ParamTypeInternal="_ParamTypeInternal";const ErrorFragmentInternal="_ErrorInternal";const EventFragmentInternal="_EventInternal";const ConstructorFragmentInternal="_ConstructorInternal";const FallbackFragmentInternal="_FallbackInternal";const FunctionFragmentInternal="_FunctionInternal";const StructFragmentInternal="_StructInternal";class ParamType{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(guard,name,type,baseType,indexed,components,arrayLength,arrayChildren){assertPrivate(guard,_guard$3,"ParamType");Object.defineProperty(this,internal$1,{value:ParamTypeInternal});if(components){components=Object.freeze(components.slice())}if(baseType==="array"){if(arrayLength==null||arrayChildren==null){throw new Error("")}}else if(arrayLength!=null||arrayChildren!=null){throw new Error("")}if(baseType==="tuple"){if(components==null){throw new Error("")}}else if(components!=null){throw new Error("")}defineProperties(this,{name:name,type:type,baseType:baseType,indexed:indexed,components:components,arrayLength:arrayLength,arrayChildren:arrayChildren})}format(format){if(format==null){format="sighash"}if(format==="json"){const name=this.name||"";if(this.isArray()){const result=JSON.parse(this.arrayChildren.format("json"));result.name=name;result.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`;return JSON.stringify(result)}const result={type:this.baseType==="tuple"?"tuple":this.type,name:name};if(typeof this.indexed==="boolean"){result.indexed=this.indexed}if(this.isTuple()){result.components=this.components.map(c=>JSON.parse(c.format(format)))}return JSON.stringify(result)}let result="";if(this.isArray()){result+=this.arrayChildren.format(format);result+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`}else{if(this.isTuple()){result+="("+this.components.map(comp=>comp.format(format)).join(format==="full"?", ":",")+")"}else{result+=this.type}}if(format!=="sighash"){if(this.indexed===true){result+=" indexed"}if(format==="full"&&this.name){result+=" "+this.name}}return result}isArray(){return this.baseType==="array"}isTuple(){return this.baseType==="tuple"}isIndexable(){return this.indexed!=null}walk(value,process){if(this.isArray()){if(!Array.isArray(value)){throw new Error("invalid array value")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error("array is wrong length")}const _this=this;return value.map(v=>_this.arrayChildren.walk(v,process))}if(this.isTuple()){if(!Array.isArray(value)){throw new Error("invalid tuple value")}if(value.length!==this.components.length){throw new Error("array is wrong length")}const _this=this;return value.map((v,i)=>_this.components[i].walk(v,process))}return process(this.type,value)}#walkAsync(promises,value,process,setValue){if(this.isArray()){if(!Array.isArray(value)){throw new Error("invalid array value")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error("array is wrong length")}const childType=this.arrayChildren;const result=value.slice();result.forEach((value,index)=>{childType.#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}if(this.isTuple()){const components=this.components;let result;if(Array.isArray(value)){result=value.slice()}else{if(value==null||typeof value!=="object"){throw new Error("invalid tuple value")}result=components.map(param=>{if(!param.name){throw new Error("cannot use object value with unnamed components")}if(!(param.name in value)){throw new Error(`missing value for component ${param.name}`)}return value[param.name]})}if(result.length!==this.components.length){throw new Error("array is wrong length")}result.forEach((value,index)=>{components[index].#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}const result=process(this.type,value);if(result.then){promises.push(async function(){setValue(await result)}())}else{setValue(result)}}async walkAsync(value,process){const promises=[];const result=[value];this.#walkAsync(promises,value,process,value=>{result[0]=value});if(promises.length){await Promise.all(promises)}return result[0]}static from(obj,allowIndexed){if(ParamType.isParamType(obj)){return obj}if(typeof obj==="string"){try{return ParamType.from(lex(obj),allowIndexed)}catch(error){assertArgument(false,"invalid param type","obj",obj)}}else if(obj instanceof TokenString){let type="",baseType="";let comps=null;if(consumeKeywords(obj,setify(["tuple"])).has("tuple")||obj.peekType("OPEN_PAREN")){baseType="tuple";comps=obj.popParams().map(t=>ParamType.from(t));type=`tuple(${comps.map(c=>c.format()).join(",")})`}else{type=verifyBasicType(obj.popType("TYPE"));baseType=type}let arrayChildren=null;let arrayLength=null;while(obj.length&&obj.peekType("BRACKET")){const bracket=obj.pop();arrayChildren=new ParamType(_guard$3,"",type,baseType,null,comps,arrayLength,arrayChildren);arrayLength=bracket.value;type+=bracket.text;baseType="array";comps=null}let indexed=null;const keywords=consumeKeywords(obj,KwModifiers);if(keywords.has("indexed")){if(!allowIndexed){throw new Error("")}indexed=true}const name=obj.peekType("ID")?obj.pop().text:"";if(obj.length){throw new Error("leftover tokens")}return new ParamType(_guard$3,name,type,baseType,indexed,comps,arrayLength,arrayChildren)}const name=obj.name;assertArgument(!name||typeof name==="string"&&name.match(regexId),"invalid name","obj.name",name);let indexed=obj.indexed;if(indexed!=null){assertArgument(allowIndexed,"parameter cannot be indexed","obj.indexed",obj.indexed);indexed=!!indexed}let type=obj.type;const arrayMatch=type.match(regexArrayType);if(arrayMatch){const arrayLength=parseInt(arrayMatch[2]||"-1");const arrayChildren=ParamType.from({type:arrayMatch[1],components:obj.components});return new ParamType(_guard$3,name||"",type,"array",indexed,null,arrayLength,arrayChildren)}if(type==="tuple"||type.startsWith("tuple(")||type.startsWith("(")){const comps=obj.components!=null?obj.components.map(c=>ParamType.from(c)):null;const tuple=new ParamType(_guard$3,name||"",type,"tuple",indexed,comps,null,null);return tuple}type=verifyBasicType(obj.type);return new ParamType(_guard$3,name||"",type,type,indexed,null,null,null)}static isParamType(value){return value&&value[internal$1]===ParamTypeInternal}}class Fragment{type;inputs;constructor(guard,type,inputs){assertPrivate(guard,_guard$3,"Fragment");inputs=Object.freeze(inputs.slice());defineProperties(this,{type:type,inputs:inputs})}static from(obj){if(typeof obj==="string"){try{Fragment.from(JSON.parse(obj))}catch(e){}return Fragment.from(lex(obj))}if(obj instanceof TokenString){const type=obj.peekKeyword(KwTypes);switch(type){case"constructor":return ConstructorFragment.from(obj);case"error":return ErrorFragment.from(obj);case"event":return EventFragment.from(obj);case"fallback":case"receive":return FallbackFragment.from(obj);case"function":return FunctionFragment.from(obj);case"struct":return StructFragment.from(obj)}}else if(typeof obj==="object"){switch(obj.type){case"constructor":return ConstructorFragment.from(obj);case"error":return ErrorFragment.from(obj);case"event":return EventFragment.from(obj);case"fallback":case"receive":return FallbackFragment.from(obj);case"function":return FunctionFragment.from(obj);case"struct":return StructFragment.from(obj)}assert$1(false,`unsupported type: ${obj.type}`,"UNSUPPORTED_OPERATION",{operation:"Fragment.from"})}assertArgument(false,"unsupported frgament object","obj",obj)}static isConstructor(value){return ConstructorFragment.isFragment(value)}static isError(value){return ErrorFragment.isFragment(value)}static isEvent(value){return EventFragment.isFragment(value)}static isFunction(value){return FunctionFragment.isFragment(value)}static isStruct(value){return StructFragment.isFragment(value)}}class NamedFragment extends Fragment{name;constructor(guard,type,name,inputs){super(guard,type,inputs);assertArgument(typeof name==="string"&&name.match(regexId),"invalid identifier","name",name);inputs=Object.freeze(inputs.slice());defineProperties(this,{name:name})}}function joinParams(format,params){return"("+params.map(p=>p.format(format)).join(format==="full"?", ":",")+")"}class ErrorFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,"error",name,inputs);Object.defineProperty(this,internal$1,{value:ErrorFragmentInternal})}get selector(){return id(this.format("sighash")).substring(0,10)}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"error",name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}const result=[];if(format!=="sighash"){result.push("error")}result.push(this.name+joinParams(format,this.inputs));return result.join(" ")}static from(obj){if(ErrorFragment.isFragment(obj)){return obj}if(typeof obj==="string"){return ErrorFragment.from(lex(obj))}else if(obj instanceof TokenString){const name=consumeName("error",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new ErrorFragment(_guard$3,name,inputs)}return new ErrorFragment(_guard$3,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===ErrorFragmentInternal}}class EventFragment extends NamedFragment{anonymous;constructor(guard,name,inputs,anonymous){super(guard,"event",name,inputs);Object.defineProperty(this,internal$1,{value:EventFragmentInternal});defineProperties(this,{anonymous:anonymous})}get topicHash(){return id(this.format("sighash"))}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[];if(format!=="sighash"){result.push("event")}result.push(this.name+joinParams(format,this.inputs));if(format!=="sighash"&&this.anonymous){result.push("anonymous")}return result.join(" ")}static getTopicHash(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new EventFragment(_guard$3,name,params,false);return fragment.topicHash}static from(obj){if(EventFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return EventFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid event fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("event",obj);const inputs=consumeParams(obj,true);const anonymous=!!consumeKeywords(obj,setify(["anonymous"])).has("anonymous");consumeEoi(obj);return new EventFragment(_guard$3,name,inputs,anonymous)}return new EventFragment(_guard$3,obj.name,obj.inputs?obj.inputs.map(p=>ParamType.from(p,true)):[],!!obj.anonymous)}static isFragment(value){return value&&value[internal$1]===EventFragmentInternal}}class ConstructorFragment extends Fragment{payable;gas;constructor(guard,type,inputs,payable,gas){super(guard,type,inputs);Object.defineProperty(this,internal$1,{value:ConstructorFragmentInternal});defineProperties(this,{payable:payable,gas:gas})}format(format){assert$1(format!=null&&format!=="sighash","cannot format a constructor for sighash","UNSUPPORTED_OPERATION",{operation:"format(sighash)"});if(format==="json"){return JSON.stringify({type:"constructor",stateMutability:this.payable?"payable":"undefined",payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[`constructor${joinParams(format,this.inputs)}`];if(this.payable){result.push("payable")}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}return result.join(" ")}static from(obj){if(ConstructorFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return ConstructorFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid constuctor fragment","obj",obj)}}else if(obj instanceof TokenString){consumeKeywords(obj,setify(["constructor"]));const inputs=consumeParams(obj);const payable=!!consumeKeywords(obj,KwVisibDeploy).has("payable");const gas=consumeGas(obj);consumeEoi(obj);return new ConstructorFragment(_guard$3,"constructor",inputs,payable,gas)}return new ConstructorFragment(_guard$3,"constructor",obj.inputs?obj.inputs.map(ParamType.from):[],!!obj.payable,obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===ConstructorFragmentInternal}}class FallbackFragment extends Fragment{payable;constructor(guard,inputs,payable){super(guard,"fallback",inputs);Object.defineProperty(this,internal$1,{value:FallbackFragmentInternal});defineProperties(this,{payable:payable})}format(format){const type=this.inputs.length===0?"receive":"fallback";if(format==="json"){const stateMutability=this.payable?"payable":"nonpayable";return JSON.stringify({type:type,stateMutability:stateMutability})}return`${type}()${this.payable?" payable":""}`}static from(obj){if(FallbackFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return FallbackFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid fallback fragment","obj",obj)}}else if(obj instanceof TokenString){const errorObj=obj.toString();const topIsValid=obj.peekKeyword(setify(["fallback","receive"]));assertArgument(topIsValid,"type must be fallback or receive","obj",errorObj);const type=obj.popKeyword(setify(["fallback","receive"]));if(type==="receive"){const inputs=consumeParams(obj);assertArgument(inputs.length===0,`receive cannot have arguments`,"obj.inputs",inputs);consumeKeywords(obj,setify(["payable"]));consumeEoi(obj);return new FallbackFragment(_guard$3,[],true)}let inputs=consumeParams(obj);if(inputs.length){assertArgument(inputs.length===1&&inputs[0].type==="bytes","invalid fallback inputs","obj.inputs",inputs.map(i=>i.format("minimal")).join(", "))}else{inputs=[ParamType.from("bytes")]}const mutability=consumeMutability(obj);assertArgument(mutability==="nonpayable"||mutability==="payable","fallback cannot be constants","obj.stateMutability",mutability);if(consumeKeywords(obj,setify(["returns"])).has("returns")){const outputs=consumeParams(obj);assertArgument(outputs.length===1&&outputs[0].type==="bytes","invalid fallback outputs","obj.outputs",outputs.map(i=>i.format("minimal")).join(", "))}consumeEoi(obj);return new FallbackFragment(_guard$3,inputs,mutability==="payable")}if(obj.type==="receive"){return new FallbackFragment(_guard$3,[],true)}if(obj.type==="fallback"){const inputs=[ParamType.from("bytes")];const payable=obj.stateMutability==="payable";return new FallbackFragment(_guard$3,inputs,payable)}assertArgument(false,"invalid fallback description","obj",obj)}static isFragment(value){return value&&value[internal$1]===FallbackFragmentInternal}}class FunctionFragment extends NamedFragment{constant;outputs;stateMutability;payable;gas;constructor(guard,name,stateMutability,inputs,outputs,gas){super(guard,"function",name,inputs);Object.defineProperty(this,internal$1,{value:FunctionFragmentInternal});outputs=Object.freeze(outputs.slice());const constant=stateMutability==="view"||stateMutability==="pure";const payable=stateMutability==="payable";defineProperties(this,{constant:constant,gas:gas,outputs:outputs,payable:payable,stateMutability:stateMutability})}get selector(){return id(this.format("sighash")).substring(0,10)}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format))),outputs:this.outputs.map(o=>JSON.parse(o.format(format)))})}const result=[];if(format!=="sighash"){result.push("function")}result.push(this.name+joinParams(format,this.inputs));if(format!=="sighash"){if(this.stateMutability!=="nonpayable"){result.push(this.stateMutability)}if(this.outputs&&this.outputs.length){result.push("returns");result.push(joinParams(format,this.outputs))}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}}return result.join(" ")}static getSelector(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new FunctionFragment(_guard$3,name,"view",params,[],null);return fragment.selector}static from(obj){if(FunctionFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return FunctionFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid function fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("function",obj);const inputs=consumeParams(obj);const mutability=consumeMutability(obj);let outputs=[];if(consumeKeywords(obj,setify(["returns"])).has("returns")){outputs=consumeParams(obj)}const gas=consumeGas(obj);consumeEoi(obj);return new FunctionFragment(_guard$3,name,mutability,inputs,outputs,gas)}let stateMutability=obj.stateMutability;if(stateMutability==null){stateMutability="payable";if(typeof obj.constant==="boolean"){stateMutability="view";if(!obj.constant){stateMutability="payable";if(typeof obj.payable==="boolean"&&!obj.payable){stateMutability="nonpayable"}}}else if(typeof obj.payable==="boolean"&&!obj.payable){stateMutability="nonpayable"}}return new FunctionFragment(_guard$3,obj.name,stateMutability,obj.inputs?obj.inputs.map(ParamType.from):[],obj.outputs?obj.outputs.map(ParamType.from):[],obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===FunctionFragmentInternal}}class StructFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,"struct",name,inputs);Object.defineProperty(this,internal$1,{value:StructFragmentInternal})}format(){throw new Error("@TODO")}static from(obj){if(typeof obj==="string"){try{return StructFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid struct fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("struct",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new StructFragment(_guard$3,name,inputs)}return new StructFragment(_guard$3,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===StructFragmentInternal}}const PanicReasons$1=new Map;PanicReasons$1.set(0,"GENERIC_PANIC");PanicReasons$1.set(1,"ASSERT_FALSE");PanicReasons$1.set(17,"OVERFLOW");PanicReasons$1.set(18,"DIVIDE_BY_ZERO");PanicReasons$1.set(33,"ENUM_RANGE_ERROR");PanicReasons$1.set(34,"BAD_STORAGE_DATA");PanicReasons$1.set(49,"STACK_UNDERFLOW");PanicReasons$1.set(50,"ARRAY_RANGE_ERROR");PanicReasons$1.set(65,"OUT_OF_MEMORY");PanicReasons$1.set(81,"UNINITIALIZED_FUNCTION_CALL");const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);let defaultCoder=null;let defaultMaxInflation=1024;function getBuiltinCallException(action,tx,data,abiCoder){let message="missing revert data";let reason=null;const invocation=null;let revert=null;if(data){message="execution reverted";const bytes=getBytes(data);data=hexlify(data);if(bytes.length===0){message+=" (no data present; likely require(false) occurred";reason="require(false)"}else if(bytes.length%32!==4){message+=" (could not decode reason; invalid data length)"}else if(hexlify(bytes.slice(0,4))==="0x08c379a0"){try{reason=abiCoder.decode(["string"],bytes.slice(4))[0];revert={signature:"Error(string)",name:"Error",args:[reason]};message+=`: ${JSON.stringify(reason)}`}catch(error){message+=" (could not decode reason; invalid string data)"}}else if(hexlify(bytes.slice(0,4))==="0x4e487b71"){try{const code=Number(abiCoder.decode(["uint256"],bytes.slice(4))[0]);revert={signature:"Panic(uint256)",name:"Panic",args:[code]};reason=`Panic due to ${PanicReasons$1.get(code)||"UNKNOWN"}(${code})`;message+=`: ${reason}`}catch(error){message+=" (could not decode panic code)"}}else{message+=" (unknown custom error)"}}const transaction={to:tx.to?getAddress(tx.to):null,data:tx.data||"0x"};if(tx.from){transaction.from=getAddress(tx.from)}return makeError(message,"CALL_EXCEPTION",{action:action,data:data,reason:reason,transaction:transaction,invocation:invocation,revert:revert})}class AbiCoder{#getCoder(param){if(param.isArray()){return new ArrayCoder(this.#getCoder(param.arrayChildren),param.arrayLength,param.name)}if(param.isTuple()){return new TupleCoder(param.components.map(c=>this.#getCoder(c)),param.name)}switch(param.baseType){case"address":return new AddressCoder(param.name);case"bool":return new BooleanCoder(param.name);case"string":return new StringCoder(param.name);case"bytes":return new BytesCoder(param.name);case"":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){const size=parseInt(match[2]||"256");assertArgument(size!==0&&size<=256&&size%8===0,"invalid "+match[1]+" bit length","param",param);return new NumberCoder(size/8,match[1]==="int",param.name)}match=param.type.match(paramTypeBytes);if(match){const size=parseInt(match[1]);assertArgument(size!==0&&size<=32,"invalid bytes length","param",param);return new FixedBytesCoder(size,param.name)}assertArgument(false,"invalid type","type",param.type)}getDefaultValue(types){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.defaultValue()}encode(types,values){assertArgumentCount(values.length,types.length,"types/values length mismatch");const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");const writer=new Writer;coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.decode(new Reader(data,loose,defaultMaxInflation))}static _setDefaultMaxInflation(value){assertArgument(typeof value==="number"&&Number.isInteger(value),"invalid defaultMaxInflation factor","value",value);defaultMaxInflation=value}static defaultAbiCoder(){if(defaultCoder==null){defaultCoder=new AbiCoder}return defaultCoder}static getBuiltinCallException(action,tx,data){return getBuiltinCallException(action,tx,data,AbiCoder.defaultAbiCoder())}}class LogDescription{fragment;name;signature;topic;args;constructor(fragment,topic,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,signature:signature,topic:topic,args:args})}}class TransactionDescription{fragment;name;args;signature;selector;value;constructor(fragment,selector,args,value){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector,value:value})}}class ErrorDescription{fragment;name;args;signature;selector;constructor(fragment,selector,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector})}}class Indexed{hash;_isIndexed;static isIndexed(value){return!!(value&&value._isIndexed)}constructor(hash){defineProperties(this,{hash:hash,_isIndexed:true})}}const PanicReasons={0:"generic panic",1:"assert(false)",17:"arithmetic overflow",18:"division or modulo by zero",33:"enum overflow",34:"invalid encoded storage byte array accessed",49:"out-of-bounds array access; popping on an empty array",50:"out-of-bounds access of an array or bytesN",65:"out of memory",81:"uninitialized function"};const BuiltinErrors={"0x08c379a0":{signature:"Error(string)",name:"Error",inputs:["string"],reason:message=>{return`reverted with reason string ${JSON.stringify(message)}`}},"0x4e487b71":{signature:"Panic(uint256)",name:"Panic",inputs:["uint256"],reason:code=>{let reason="unknown panic code";if(code>=0&&code<=255&&PanicReasons[code.toString()]){reason=PanicReasons[code.toString()]}return`reverted with panic code 0x${code.toString(16)} (${reason})`}}};class Interface{fragments;deploy;fallback;receive;#errors;#events;#functions;#abiCoder;constructor(fragments){let abi=[];if(typeof fragments==="string"){abi=JSON.parse(fragments)}else{abi=fragments}this.#functions=new Map;this.#errors=new Map;this.#events=new Map;const frags=[];for(const a of abi){try{frags.push(Fragment.from(a))}catch(error){console.log("Error parsing ABI fragment",error)}}defineProperties(this,{fragments:Object.freeze(frags)});let fallback=null;let receive=false;this.#abiCoder=this.getAbiCoder();this.fragments.forEach((fragment,index)=>{let bucket;switch(fragment.type){case"constructor":if(this.deploy){console.log("duplicate definition - constructor");return}defineProperties(this,{deploy:fragment});return;case"fallback":if(fragment.inputs.length===0){receive=true}else{assertArgument(!fallback||fragment.payable!==fallback.payable,"conflicting fallback fragments",`fragments[${index}]`,fragment);fallback=fragment;receive=fallback.payable}return;case"function":bucket=this.#functions;break;case"event":bucket=this.#events;break;case"error":bucket=this.#errors;break;default:return}const signature=fragment.format();if(bucket.has(signature)){return}bucket.set(signature,fragment)});if(!this.deploy){defineProperties(this,{deploy:ConstructorFragment.from("constructor()")})}defineProperties(this,{fallback:fallback,receive:receive})}format(minimal){const format=minimal?"minimal":"full";const abi=this.fragments.map(f=>f.format(format));return abi}formatJson(){const abi=this.fragments.map(f=>f.format("json"));return JSON.stringify(abi.map(j=>JSON.parse(j)))}getAbiCoder(){return AbiCoder.defaultAbiCoder()}#getFunction(key,values,forceUnique){if(isHexString(key)){const selector=key.toLowerCase();for(const fragment of this.#functions.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#functions){if(name.split("(")[0]===key){matching.push(fragment)}}if(values){const lastValue=values.length>0?values[values.length-1]:null;let valueLength=values.length;let allowOptions=true;if(Typed.isTyped(lastValue)&&lastValue.type==="overrides"){allowOptions=false;valueLength--}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs.length;if(inputs!==valueLength&&(!allowOptions||inputs!==valueLength-1)){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(j>=inputs.length){if(values[j].type==="overrides"){continue}matching.splice(i,1);break}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===1&&values&&values.length!==matching[0].inputs.length){const lastArg=values[values.length-1];if(lastArg==null||Array.isArray(lastArg)||typeof lastArg!=="object"){matching.splice(0,1)}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous function description (i.e. matches ${matchStr})`,"key",key)}return matching[0]}const result=this.#functions.get(FunctionFragment.from(key).format());if(result){return result}return null}getFunctionName(key){const fragment=this.#getFunction(key,null,false);assertArgument(fragment,"no matching function","key",key);return fragment.name}hasFunction(key){return!!this.#getFunction(key,null,false)}getFunction(key,values){return this.#getFunction(key,values||null,true)}forEachFunction(callback){const names=Array.from(this.#functions.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#functions.get(name),i)}}#getEvent(key,values,forceUnique){if(isHexString(key)){const eventTopic=key.toLowerCase();for(const fragment of this.#events.values()){if(eventTopic===fragment.topicHash){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#events){if(name.split("(")[0]===key){matching.push(fragment)}}if(values){for(let i=matching.length-1;i>=0;i--){if(matching[i].inputs.length<values.length){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous event description (i.e. matches ${matchStr})`,"key",key)}return matching[0]}const result=this.#events.get(EventFragment.from(key).format());if(result){return result}return null}getEventName(key){const fragment=this.#getEvent(key,null,false);assertArgument(fragment,"no matching event","key",key);return fragment.name}hasEvent(key){return!!this.#getEvent(key,null,false)}getEvent(key,values){return this.#getEvent(key,values||null,true)}forEachEvent(callback){const names=Array.from(this.#events.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#events.get(name),i)}}getError(key,values){if(isHexString(key)){const selector=key.toLowerCase();if(BuiltinErrors[selector]){return ErrorFragment.from(BuiltinErrors[selector].signature)}for(const fragment of this.#errors.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#errors){if(name.split("(")[0]===key){matching.push(fragment)}}if(matching.length===0){if(key==="Error"){return ErrorFragment.from("error Error(string)")}if(key==="Panic"){return ErrorFragment.from("error Panic(uint256)")}return null}else if(matching.length>1){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous error description (i.e. ${matchStr})`,"name",key)}return matching[0]}key=ErrorFragment.from(key).format();if(key==="Error(string)"){return ErrorFragment.from("error Error(string)")}if(key==="Panic(uint256)"){return ErrorFragment.from("error Panic(uint256)")}const result=this.#errors.get(key);if(result){return result}return null}forEachError(callback){const names=Array.from(this.#errors.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#errors.get(name),i)}}_decodeParams(params,data){return this.#abiCoder.decode(params,data)}_encodeParams(params,values){return this.#abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeErrorResult(fragment,data){if(typeof fragment==="string"){const f=this.getError(fragment);assertArgument(f,"unknown error","fragment",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match error ${fragment.name}.`,"data",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeErrorResult(fragment,values){if(typeof fragment==="string"){const f=this.getError(fragment);assertArgument(f,"unknown error","fragment",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionData(fragment,data){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match function ${fragment.name}.`,"data",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeFunctionData(fragment,values){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionResult(fragment,data){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}let message="invalid length for result data";const bytes=getBytesCopy(data);if(bytes.length%32===0){try{return this.#abiCoder.decode(fragment.outputs,bytes)}catch(error){message="could not decode result data"}}assert$1(false,message,"BAD_DATA",{value:hexlify(bytes),info:{method:fragment.name,signature:fragment.format()}})}makeError(_data,tx){const data=getBytes(_data,"data");const error=AbiCoder.getBuiltinCallException("call",tx,data);const customPrefix="execution reverted (unknown custom error)";if(error.message.startsWith(customPrefix)){const selector=hexlify(data.slice(0,4));const ef=this.getError(selector);if(ef){try{const args=this.#abiCoder.decode(ef.inputs,data.slice(4));error.revert={name:ef.name,signature:ef.format(),args:args};error.reason=error.revert.signature;error.message=`execution reverted: ${error.reason}`}catch(e){error.message=`execution reverted (coult not decode custom error)`}}}const parsed=this.parseTransaction(tx);if(parsed){error.invocation={method:parsed.name,signature:parsed.signature,args:parsed.args}}return error}encodeFunctionResult(fragment,values){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}return hexlify(this.#abiCoder.encode(fragment.outputs,values||[]))}encodeFilterTopics(fragment,values){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}assert$1(values.length<=fragment.inputs.length,`too many arguments for ${fragment.format()}`,"UNEXPECTED_ARGUMENT",{count:values.length,expectedCount:fragment.inputs.length});const topics=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}const encodeTopic=(param,value)=>{if(param.type==="string"){return id(value)}else if(param.type==="bytes"){return keccak256(hexlify(value))}if(param.type==="bool"&&typeof value==="boolean"){value=value?"0x01":"0x00"}else if(param.type.match(/^u?int/)){value=toBeHex(value)}else if(param.type.match(/^bytes/)){value=zeroPadBytes(value,32)}else if(param.type==="address"){this.#abiCoder.encode(["address"],[value])}return zeroPadValue(hexlify(value),32)};values.forEach((value,index)=>{const param=fragment.inputs[index];if(!param.indexed){assertArgument(value==null,"cannot filter non-indexed parameters; must be null","contract."+param.name,value);return}if(value==null){topics.push(null)}else if(param.baseType==="array"||param.baseType==="tuple"){assertArgument(false,"filtering with tuples or arrays not supported","contract."+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(fragment,values){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}const topics=[];const dataTypes=[];const dataValues=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}assertArgument(values.length===fragment.inputs.length,"event arguments/values mismatch","values",values);fragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type==="string"){topics.push(id(value))}else if(param.type==="bytes"){topics.push(keccak256(value))}else if(param.baseType==="tuple"||param.baseType==="array"){throw new Error("not implemented")}else{topics.push(this.#abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this.#abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(fragment,data,topics){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}if(topics!=null&&!fragment.anonymous){const eventTopic=fragment.topicHash;assertArgument(isHexString(topics[0],32)&&topics[0].toLowerCase()===eventTopic,"fragment/topic mismatch","topics[0]",topics[0]);topics=topics.slice(1)}const indexed=[];const nonIndexed=[];const dynamic=[];fragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type==="string"||param.type==="bytes"||param.baseType==="tuple"||param.baseType==="array"){indexed.push(ParamType.from({type:"bytes32",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});const resultIndexed=topics!=null?this.#abiCoder.decode(indexed,concat(topics)):null;const resultNonIndexed=this.#abiCoder.decode(nonIndexed,data,true);const values=[];const keys=[];let nonIndexedIndex=0,indexedIndex=0;fragment.inputs.forEach((param,index)=>{let value=null;if(param.indexed){if(resultIndexed==null){value=new Indexed(null)}else if(dynamic[index]){value=new Indexed(resultIndexed[indexedIndex++])}else{try{value=resultIndexed[indexedIndex++]}catch(error){value=error}}}else{try{value=resultNonIndexed[nonIndexedIndex++]}catch(error){value=error}}values.push(value);keys.push(param.name||null)});return Result.fromItems(values,keys)}parseTransaction(tx){const data=getBytes(tx.data,"tx.data");const value=getBigInt(tx.value!=null?tx.value:0,"tx.value");const fragment=this.getFunction(hexlify(data.slice(0,4)));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,data.slice(4));return new TransactionDescription(fragment,fragment.selector,args,value)}parseCallResult(data){throw new Error("@TODO")}parseLog(log){const fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription(fragment,fragment.topicHash,this.decodeEventLog(fragment,log.data,log.topics))}parseError(data){const hexData=hexlify(data);const fragment=this.getError(dataSlice(hexData,0,4));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,dataSlice(hexData,4));return new ErrorDescription(fragment,fragment.selector,args)}static from(value){if(value instanceof Interface){return value}if(typeof value==="string"){return new Interface(JSON.parse(value))}if(typeof value.format==="function"){return new Interface(value.format("json"))}return new Interface(value)}}function accessSetify(addr,storageKeys){validateAddress(addr);return{address:getAddress(addr),storageKeys:storageKeys.map((storageKey,index)=>{assertArgument(isHexString(storageKey,32),"invalid slot",`storageKeys[${index}]`,storageKey);return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){assertArgument(set.length===2,"invalid slot set",`value[${index}]`,set);return accessSetify(formatMixedCaseChecksumAddress(set[0]),set[1])}assertArgument(set!=null&&typeof set==="object","invalid address-slot set","value",value);return accessSetify(formatMixedCaseChecksumAddress(set.address),set.storageKeys)})}assertArgument(value!=null&&typeof value==="object","invalid access list","value",value);const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}class AbstractTransaction{_type;_signature;_chainId;get type(){return this._type}set type(value){switch(value){case null:this._type=null;break;case 0:case"standard":this._type=0;break;case 2:case"utxo":this._type=2;break;default:assertArgument(false,"unsupported transaction type","type",value)}}get typeName(){switch(this.type){case 0:return"standard";case 1:return"external";case 2:return"utxo"}return null}get chainId(){return this._chainId}set chainId(value){this._chainId=getBigInt(value)}get signature(){return this._signature||null}set signature(value){if(typeof value==="string"){this._signature=value}else{this._signature=value==null?null:Signature.from(value)}}constructor(){this._type=null;this._chainId=BigInt(0);this._signature=null}get digest(){return keccak256(this.unsignedSerialized)}isSigned(){return this.signature!=null}get serialized(){assert$1(this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});return encodeProtoTransaction(this.toProtobuf(true))}get unsignedSerialized(){return encodeProtoTransaction(this.toProtobuf(false))}inferType(){return this.inferTypes().pop()}get isExternal(){return this.destZone!==undefined&&this.originZone!==this.destZone}}const denominations=[BigInt(1),BigInt(5),BigInt(10),BigInt(50),BigInt(100),BigInt(500),BigInt(1e3),BigInt(5e3),BigInt(1e4),BigInt(2e4),BigInt(1e5),BigInt(1e6),BigInt(1e7),BigInt(1e8),BigInt(1e9)];function isValidDenominationIndex(index){return index>=0&&index<denominations.length}function denominate(value,maxDenomination){if(value<=BigInt(0)){throw new Error("Value must be greater than 0")}const result=[];let remainingValue=BigInt(value);let maxDenominationIndex;if(maxDenomination!=null){maxDenominationIndex=denominations.findIndex(d=>d===maxDenomination);if(maxDenominationIndex===-1){throw new Error("Invalid maximum denomination")}}else{maxDenominationIndex=denominations.length-1}for(let i=maxDenominationIndex;i>=0;i--){const denomination=denominations[i];while(remainingValue>=denomination){result.push(denomination);remainingValue-=BigInt(denomination)}}if(remainingValue>0){throw new Error("Unable to match the value with available denominations")}return result}class UTXO{#txhash;#index;#address;#denomination;#lock;get txhash(){return this.#txhash}set txhash(value){this.#txhash=value}get index(){return this.#index}set index(value){this.#index=value}get address(){return this.#address||""}set address(value){validateAddress(value);this.#address=value}get denomination(){return this.#denomination}set denomination(value){if(value==null){this.#denomination=null;return}if(!isValidDenominationIndex(value)){throw new Error("Invalid denomination value")}this.#denomination=value}get lock(){return this.#lock}set lock(value){this.#lock=value}constructor(){this.#txhash=null;this.#index=null;this.#address=null;this.#denomination=null;this.#lock=null}toJSON(){return{txhash:this.txhash,index:this.index,address:this.address,denomination:this.denomination}}static from(utxo){if(utxo===null){return new UTXO}const result=utxo instanceof UTXO?utxo:new UTXO;if(utxo.txhash!=null){result.txhash=utxo.txhash}if(utxo.index!=null){result.index=utxo.index}if(utxo.address!=null&&utxo.address!==""){result.address=utxo.address}if(utxo.denomination!=null){result.denomination=utxo.denomination}return result}}class AbstractCoinSelector{availableUTXOs;totalInputValue=BigInt(0);spendOutputs=[];changeOutputs=[];selectedUTXOs=[];target=null;constructor(availableUTXOs=[]){this.availableUTXOs=availableUTXOs.map(utxo=>{this._validateUTXO(utxo);return utxo});this.spendOutputs=[];this.changeOutputs=[]}_validateUTXO(utxo){if(utxo.address==null){throw new Error("UTXO address is required")}if(utxo.denomination==null){throw new Error("UTXO denomination is required")}if(utxo.txhash==null){throw new Error("UTXO txhash is required")}if(utxo.index==null){throw new Error("UTXO index is required")}}validateUTXOs(){if(this.availableUTXOs.length===0){throw new Error("No UTXOs available")}}sortUTXOsByDenomination(utxos,direction){if(direction==="asc"){return[...utxos].sort((a,b)=>{const diff=BigInt(a.denomination!==null?denominations[a.denomination]:0)-BigInt(b.denomination!==null?denominations[b.denomination]:0);return diff>BigInt(0)?1:diff<BigInt(0)?-1:0})}return[...utxos].sort((a,b)=>{const diff=BigInt(b.denomination!==null?denominations[b.denomination]:0)-BigInt(a.denomination!==null?denominations[a.denomination]:0);return diff>BigInt(0)?1:diff<BigInt(0)?-1:0})}}class FewestCoinSelector extends AbstractCoinSelector{performSelection(config){const{target=BigInt(0),fee=BigInt(0)}=config;if(target<=BigInt(0)){throw new Error("Target amount must be greater than 0")}if(fee<BigInt(0)){throw new Error("Fee amount cannot be negative")}this.validateUTXOs();this.target=target;const totalRequired=BigInt(target)+BigInt(fee);this.selectedUTXOs=[];this.totalInputValue=BigInt(0);const sortedUTXOs=this.sortUTXOsByDenomination(this.availableUTXOs,"asc");const singleUTXO=sortedUTXOs.find(utxo=>BigInt(denominations[utxo.denomination])>=totalRequired);if(singleUTXO){this.selectedUTXOs.push(singleUTXO);this.totalInputValue=BigInt(denominations[singleUTXO.denomination])}else{this.selectedUTXOs=this.findMinimalUTXOSet(sortedUTXOs,totalRequired);if(this.selectedUTXOs.length===0){throw new Error("Insufficient funds")}this.totalInputValue=this.selectedUTXOs.reduce((sum,utxo)=>sum+BigInt(denominations[utxo.denomination]),BigInt(0))}const changeAmount=this.totalInputValue-BigInt(target)-BigInt(fee);this.spendOutputs=this.createSpendOutputs(target);this.changeOutputs=this.createChangeOutputs(changeAmount);const totalOutputValue=this.calculateTotalOutputValue();if(totalOutputValue>this.totalInputValue){throw new Error("Total output value exceeds total input value")}return{inputs:this.selectedUTXOs,spendOutputs:this.spendOutputs,changeOutputs:this.changeOutputs}}findMinimalUTXOSet(sortedUTXOs,totalRequired){const singleUTXO=sortedUTXOs.find(utxo=>BigInt(denominations[utxo.denomination])>=totalRequired);if(singleUTXO){return[singleUTXO]}const utxos=[...sortedUTXOs].reverse();let totalValue=BigInt(0);const selectedUTXOs=[];for(const utxo of utxos){if(totalValue>=totalRequired){break}selectedUTXOs.push(utxo);totalValue+=BigInt(denominations[utxo.denomination])}if(totalValue>=totalRequired){return selectedUTXOs}else{return[]}}createSpendOutputs(amount){const maxInputDenomination=this.getMaxInputDenomination();const spendDenominations=denominate(amount,maxInputDenomination);return spendDenominations.map(denominationValue=>{const utxo=new UTXO;utxo.denomination=denominations.indexOf(denominationValue);return utxo})}createChangeOutputs(change){if(change<=BigInt(0)){return[]}const maxInputDenomination=this.getMaxInputDenomination();const changeDenominations=denominate(change,maxInputDenomination);return changeDenominations.map(denominationValue=>{const utxo=new UTXO;utxo.denomination=denominations.indexOf(denominationValue);return utxo})}calculateTotalOutputValue(){const spendValue=this.spendOutputs.reduce((sum,output)=>sum+BigInt(denominations[output.denomination]),BigInt(0));const changeValue=this.changeOutputs.reduce((sum,output)=>sum+BigInt(denominations[output.denomination]),BigInt(0));return spendValue+changeValue}getMaxInputDenomination(){const inputs=[...this.selectedUTXOs];return this.getMaxDenomination(inputs)}getMaxOutputDenomination(){const outputs=[...this.spendOutputs,...this.changeOutputs];return this.getMaxDenomination(outputs)}getMaxDenomination(utxos){return utxos.reduce((max,utxo)=>{const denomValue=BigInt(denominations[utxo.denomination]);return denomValue>max?denomValue:max},BigInt(0))}increaseFee(additionalFeeNeeded){let remainingFee=BigInt(additionalFeeNeeded);const totalChange=this.changeOutputs.reduce((sum,output)=>BigInt(sum)+BigInt(denominations[output.denomination]),BigInt(0));if(totalChange>=remainingFee){this.adjustChangeOutputs(totalChange-remainingFee);return{inputs:this.selectedUTXOs,spendOutputs:this.spendOutputs,changeOutputs:this.changeOutputs}}remainingFee-=BigInt(totalChange);this.changeOutputs=[];const unusedUTXOs=this.availableUTXOs.filter(utxo=>!this.selectedUTXOs.includes(utxo));const sortedUTXOs=this.sortUTXOsByDenomination(unusedUTXOs,"asc");for(const utxo of sortedUTXOs){this.selectedUTXOs.push(utxo);this.totalInputValue+=BigInt(denominations[utxo.denomination]);remainingFee-=BigInt(denominations[utxo.denomination]);if(remainingFee<=BigInt(0)){if(remainingFee<BigInt(0)){const change=BigInt(this.totalInputValue)-BigInt(this.target)-BigInt(additionalFeeNeeded);this.adjustChangeOutputs(change)}}}return{inputs:this.selectedUTXOs,spendOutputs:this.spendOutputs,changeOutputs:this.changeOutputs}}decreaseFee(feeReduction){let excessValue=feeReduction;const sortedInputs=this.sortUTXOsByDenomination(this.selectedUTXOs,"desc");const inputsToRemove=[];for(const input of sortedInputs){const inputValue=BigInt(denominations[input.denomination]);if(excessValue>=inputValue&&this.totalInputValue-inputValue>=this.target){inputsToRemove.push(input);excessValue-=BigInt(inputValue);this.totalInputValue-=BigInt(inputValue)}if(excessValue===BigInt(0))break}this.selectedUTXOs=this.selectedUTXOs.filter(utxo=>!inputsToRemove.includes(utxo));if(excessValue>BigInt(0)){this.adjustChangeOutputs(excessValue)}return{inputs:this.selectedUTXOs,spendOutputs:this.spendOutputs,changeOutputs:this.changeOutputs}}adjustChangeOutputs(changeAmount){if(changeAmount<=BigInt(0)){this.changeOutputs=[];return}this.changeOutputs=this.createChangeOutputs(changeAmount)}}class AggregateCoinSelector extends AbstractCoinSelector{performSelection(config){const{includeLocked=false,fee=BigInt(0),maxDenomination=6}=config;this.validateUTXOs();const eligibleUTXOs=includeLocked?this.availableUTXOs:this.availableUTXOs.filter(utxo=>utxo.lock===null||utxo.lock===0);this.totalInputValue=eligibleUTXOs.reduce((sum,utxo)=>sum+BigInt(denominations[utxo.denomination]),BigInt(0));const smallDenominationsUTXOs=eligibleUTXOs.filter(utxo=>utxo.denomination<maxDenomination);if(smallDenominationsUTXOs.length===0){throw new Error("No eligible UTXOs available for aggregation")}const bigDenominationUTXOs=eligibleUTXOs.filter(utxo=>utxo.denomination>=maxDenomination);const totalInputValueAboveMaxDenomination=bigDenominationUTXOs.reduce((sum,utxo)=>sum+BigInt(denominations[utxo.denomination]),BigInt(0));const totalInputValueBelowMaxDenomination=this.totalInputValue-totalInputValueAboveMaxDenomination;const valueToAggregate=totalInputValueAboveMaxDenomination>=fee?totalInputValueBelowMaxDenomination:totalInputValueBelowMaxDenomination-(fee-totalInputValueAboveMaxDenomination);if(valueToAggregate<=BigInt(0)){throw new Error("Insufficient funds to cover fee")}this.spendOutputs=this.createOptimalDenominations(valueToAggregate);const inputsToAggregate=this.getInputsToAggregate(smallDenominationsUTXOs,valueToAggregate);const feeInputs=this.getInputsForFee(inputsToAggregate,eligibleUTXOs,fee);const feeInputsValue=feeInputs.reduce((sum,utxo)=>sum+BigInt(denominations[utxo.denomination]),BigInt(0));if(feeInputsValue>fee){const difference=feeInputsValue-fee;const additionalOutputs=this.createOptimalDenominations(difference);this.spendOutputs.push(...additionalOutputs)}this.selectedUTXOs=[...feeInputs,...inputsToAggregate];if(this.spendOutputs.length>=inputsToAggregate.length){throw new Error("Aggregation would not reduce number of UTXOs")}this.changeOutputs=[];return{inputs:this.selectedUTXOs,spendOutputs:this.spendOutputs,changeOutputs:this.changeOutputs}}createOptimalDenominations(value){const outputs=[];let remaining=value;for(let i=denominations.length-1;i>=0&&remaining>BigInt(0);i--){const denomination=denominations[i];while(remaining>=denomination){const output=new UTXO;output.denomination=i;outputs.push(output);remaining-=denomination}}if(remaining>BigInt(0)){throw new Error("Unable to create optimal denominations")}return outputs}getInputsForFee(inputsToAggregate,eligibleUTXOs,fee){const eligiblefeeInputs=eligibleUTXOs.filter(utxo=>!inputsToAggregate.some(input=>input.txhash===utxo.txhash&&input.index===utxo.index));const sortedUTXOs=this.sortUTXOsByDenomination(eligiblefeeInputs,"asc");let sum=BigInt(0);const feeInputs=[];for(const utxo of sortedUTXOs){sum+=BigInt(denominations[utxo.denomination]);feeInputs.push(utxo);if(sum>=fee){return feeInputs}}throw new Error("Unable to find inputs to cover fee")}getInputsToAggregate(smallDenominationsUTXOs,valueToAggregate){const sortedUTXOs=this.sortUTXOsByDenomination(smallDenominationsUTXOs,"asc");const inputsToAggregate=[];for(const utxo of sortedUTXOs){inputsToAggregate.push(utxo);if(inputsToAggregate.reduce((sum,utxo)=>sum+BigInt(denominations[utxo.denomination]),BigInt(0))===valueToAggregate){return inputsToAggregate}}throw new Error("Unable to find inputs to aggregate")}}const BN_0$2=BigInt(0);function allowNull(format,nullValue){return function(value){if(value==null){return nullValue}return format(value)}}function arrayOf(format){return array=>{if(!Array.isArray(array)){throw new Error("not an array")}return array.map(i=>format(i))}}function object(format,altNames){return value=>{const result={};for(const key in format){let srcKey=key;if(altNames&&key in altNames&&!(srcKey in value)){for(const altKey of altNames[key]){if(altKey in value){srcKey=altKey;break}}}try{const nv=format[key](value[srcKey]);if(nv!==undefined){result[key]=nv}}catch(error){const message=error instanceof Error?error.message:"not-an-error";assert$1(false,`invalid value for value.${key} (${message})`,"BAD_DATA",{value:value})}}return result}}function formatBoolean(value){switch(value){case true:case"true":return true;case false:case"false":return false}assertArgument(false,`invalid boolean; ${JSON.stringify(value)}`,"value",value)}function formatData(value){assertArgument(isHexString(value),"invalid data","value",value);return value}function formatHash(value){assertArgument(isHexString(value,32),"invalid hash","value",value);return value}function handleNumber(_value,param){if(_value==="0x"){return 0}return getNumber(_value,param)}function formatNumber(_value,name){const value=getBigInt(_value,"value");const result=toBeArray(value);assertArgument(result.length<=32,`value too large`,`tx.${name}`,value);return result}const _formatLog=object({address:getAddress,blockHash:formatHash,blockNumber:getNumber,data:formatData,index:getNumber,removed:allowNull(formatBoolean,false),topics:arrayOf(formatHash),transactionHash:formatHash,transactionIndex:getNumber},{index:["logIndex"]});function formatLog(value){return _formatLog(value)}const _formatHeader=object({baseFeePerGas:getBigInt,efficiencyScore:getBigInt,etxEligibleSlices:formatHash,etxSetRoot:formatHash,evmRoot:formatHash,expansionNumber:getNumber,etxRollupRoot:formatHash,outboundEtxsRoot:formatHash,extraData:formatData,gasLimit:getBigInt,gasUsed:getBigInt,interlinkRootHash:formatHash,manifestHash:arrayOf(formatHash),number:arrayOf(getNumber),parentDeltaEntropy:arrayOf(getBigInt),parentEntropy:arrayOf(getBigInt),parentHash:arrayOf(formatHash),parentUncledDeltaEntropy:arrayOf(getBigInt),primeTerminusHash:formatHash,quaiStateSize:getBigInt,receiptsRoot:formatHash,uncleHash:formatHash,size:getBigInt,stateLimit:getBigInt,stateUsed:getBigInt,thresholdCount:getBigInt,transactionsRoot:formatHash,uncledEntropy:getBigInt,utxoRoot:formatHash,secondaryCoinbase:allowNull(getAddress),exchangeRate:getBigInt,quaiToQi:getBigInt,qiToQuai:getBigInt});const _formatUncle=object({primaryCoinbase:allowNull(getAddress),difficulty:getNumber,headerHash:formatHash,location:formatData,mixHash:formatHash,nonce:formatData,number:getNumber,parentHash:formatHash,primeTerminusNumber:getNumber,timestamp:getNumber,txHash:formatHash,lock:getNumber});const _formatBlock=object({outboundEtxs:arrayOf(tx=>{if(typeof tx==="string"){return formatHash(tx)}return formatExternalTransactionResponse(tx)}),hash:formatHash,header:_formatHeader,interlinkHashes:arrayOf(formatHash),size:getBigInt,subManifest:arrayOf(formatData),totalEntropy:getBigInt,transactions:arrayOf(tx=>{if(typeof tx==="string"){return formatHash(tx)}return formatTransactionResponse(tx)}),uncles:arrayOf(_formatUncle),woHeader:_formatUncle,workShares:allowNull(arrayOf(_formatUncle),[])});function formatBlock(value){const result=_formatBlock(value);result.transactions=value.transactions.map(tx=>{if(typeof tx==="string"){return tx}if("originatingTxHash"in tx){return formatExternalTransactionResponse(tx)}return formatTransactionResponse(tx)});result.outboundEtxs=value.outboundEtxs.map(tx=>{if(typeof tx==="string"){return tx}return formatExternalTransactionResponse(tx)});return result}const _formatReceiptLog=object({transactionIndex:getNumber,blockNumber:getNumber,transactionHash:formatHash,address:getAddress,topics:arrayOf(formatHash),data:formatData,index:getNumber,blockHash:formatHash},{index:["logIndex"]});function formatReceiptLog(value){return _formatReceiptLog(value)}const _formatEtx=object({type:allowNull(getNumber,0),nonce:allowNull(getNumber),gasPrice:allowNull(getBigInt),minerTip:allowNull(getBigInt),gas:allowNull(getBigInt),value:allowNull(getBigInt,BN_0$2),input:allowNull(formatData),to:allowNull(getAddress,null),accessList:allowNull(accessListify,null),from:getAddress,originatingTxHash:formatHash,etxIndex:getNumber,chainId:allowNull(getBigInt,null),etxType:getNumber,hash:formatHash},{from:["from"]});function formatEtx(value){return _formatEtx(value)}const _formatTransactionReceipt=object({to:allowNull(getAddress,null),from:allowNull(getAddress,null),contractAddress:allowNull(getAddress,null),index:getNumber,gasUsed:getBigInt,logsBloom:allowNull(formatData),blockHash:formatHash,hash:formatHash,logs:arrayOf(formatReceiptLog),blockNumber:getNumber,cumulativeGasUsed:getBigInt,effectiveGasPrice:allowNull(getBigInt),status:allowNull(getNumber),type:allowNull(getNumber,0),outboundEtxs:value=>value?arrayOf(formatEtx)(value):value,originatingTxHash:allowNull(formatHash),etxType:allowNull(getNumber)},{hash:["transactionHash"],index:["transactionIndex"]});function formatTransactionReceipt(value){const result=_formatTransactionReceipt(value);return result}function formatTransactionResponse(value){const transactionType=parseInt(value.type,16);switch(transactionType){case 0:return formatQuaiTransactionResponse(value);case 1:return formatExternalTransactionResponse(value);case 2:return formatQiTransactionResponse(value);default:throw new Error("Unknown transaction type")}}function formatExternalTransactionResponse(value){const result=object({hash:formatHash,type:value=>{if(value==="0x"||value==null){return 0}return parseInt(value,16)},accessList:allowNull(accessListify,null),blockHash:allowNull(formatHash,null),blockNumber:allowNull(value=>value?parseInt(value,16):null,null),index:allowNull(value=>value?BigInt(value):null,null),from:allowNull(getAddress,null),minerTip:allowNull(value=>value?BigInt(value):null),gasPrice:allowNull(value=>value?BigInt(value):null),gasLimit:allowNull(value=>value?BigInt(value):null,null),to:allowNull(getAddress,null),value:allowNull(value=>value?BigInt(value):null,null),nonce:allowNull(value=>value?parseInt(value,10):null,null),creates:allowNull(getAddress,null),chainId:allowNull(value=>value?BigInt(value):null,null),originatingTxHash:allowNull(formatHash,null),etxIndex:allowNull(value=>value?parseInt(value,10):null,null),etxType:allowNull(value=>value,null),data:value=>value},{data:["input"],gasLimit:["gas"],index:["transactionIndex"]})(value);if(result.blockHash&&getBigInt(result.blockHash)===BN_0$2){result.blockHash=null}return result}function formatQuaiTransactionResponse(value){const result=object({hash:formatHash,type:value=>{if(value==="0x"||value==null){return 0}return parseInt(value,16)},accessList:allowNull(accessListify,null),blockHash:allowNull(formatHash,null),blockNumber:allowNull(value=>value?parseInt(value,16):null,null),index:allowNull(value=>value?BigInt(value):null,null),from:allowNull(getAddress,null),minerTip:allowNull(value=>value?BigInt(value):null),gasPrice:allowNull(value=>value?BigInt(value):null),gasLimit:allowNull(value=>value?BigInt(value):null,null),to:allowNull(getAddress,null),value:allowNull(value=>value?BigInt(value):null,null),nonce:allowNull(value=>value?parseInt(value,10):null,null),creates:allowNull(getAddress,null),chainId:allowNull(value=>value?BigInt(value):null,null),etxType:allowNull(value=>parseInt(value,16),null),data:value=>value},{data:["input"],gasLimit:["gas"],index:["transactionIndex"]})(value);if(value.accessList==null){result.accessList=[]}if(value.signature){result.signature=Signature.from(value.signature);if(result.chainId==null){const chainId=result.signature.legacyChainId;if(chainId!=null){result.chainId=chainId}}}if(result.blockHash&&getBigInt(result.blockHash)===BN_0$2){result.blockHash=null}return result}function formatQiTransactionResponse(value){return object({hash:formatHash,type:value=>{if(value==="0x"||value==null){return 0}return parseInt(value,16)},blockHash:allowNull(formatHash,null),blockNumber:allowNull(value=>value?parseInt(value,16):null,null),chainId:allowNull(value=>value?BigInt(value):null,null),signature:value=>value,txInputs:allowNull(formatTxInputs,[]),txOutputs:allowNull(formatTxOutputs,[])},{index:["transactionIndex"],signature:["utxoSignature"],txInputs:["inputs"],txOutputs:["outputs"]})(value)}const formatTxInputs=value=>{return value?.map(_formatTxInput)};const _formatTxInput=value=>{return{txhash:formatHash(value.previousOutPoint.txHash),index:getNumber(value.previousOutPoint.index),pubkey:hexlify(value.pubKey)}};const formatTxOutputs=value=>{return value?.map(_formatTxOutput)};const _formatTxOutput=value=>{return{denomination:getNumber(value.denomination),lock:getNumber(value.lock),address:getAddress(value.address)}};const _formatOutpoint=object({denomination:value=>getNumber(value),index:value=>getNumber(value),lock:value=>getNumber(value),txhash:formatHash},{txhash:["txHash"]});function formatOutpoints(outpoints){return outpoints.map(_formatOutpoint)}function formatOutpointDeltas(deltas){const result={};for(const[address,delta]of Object.entries(deltas)){const created=[];const deleted=[];for(const[txHash,outputs]of Object.entries(delta.created)){outputs.forEach(output=>{created.push({txHash:txHash,index:output.index,denomination:output.denomination,lock:output.lock})})}for(const[txHash,outputs]of Object.entries(delta.deleted)){outputs.forEach(output=>{deleted.push({txHash:txHash,index:output.index,denomination:output.denomination,lock:output.lock})})}result[address]={created:formatOutpoints(created),deleted:formatOutpoints(deleted)}}return result}class QiTransaction extends AbstractTransaction{#txInputs;#txOutputs;get txInputs(){return(this.#txInputs??[]).map(entry=>({...entry}))}set txInputs(value){if(!Array.isArray(value)){throw new Error("txInputs must be an array")}this.#txInputs=value.map(entry=>({...entry}))}get txOutputs(){return(this.#txOutputs??[]).map(output=>({...output}))}set txOutputs(value){if(!Array.isArray(value)){throw new Error("txOutputs must be an array")}this.#txOutputs=value.map(output=>({...output}))}get hash(){if(this.signature==null){return null}if(this.txInputs.length<1||this.txOutputs.length<1){throw new Error("Transaction must have at least one input and one output")}const senderAddr=computeAddress(this.txInputs[0].pubkey||"");if(!this.destZone||!this.originZone){throw new Error(`Invalid zones: origin ${this.originZone} ->  destination ${this.destZone} (address: ${senderAddr})`)}const isSameLedger=isQiAddress(senderAddr)===isQiAddress(hexlify(this.txOutputs[0].address)||"");if(this.isExternal&&!isSameLedger){throw new Error("Cross-zone & cross-ledger transactions are not supported")}const hexString=this.serialized.startsWith("0x")?this.serialized.substring(2):this.serialized;const dataBuffer=Buffer.from(hexString,"hex");const hashHex=keccak256(dataBuffer);const hashBuffer=Buffer.from(hashHex.substring(2),"hex");const prevTxHash=this.txInputs[0].txhash;const prevTxHashBytes=getBytes(prevTxHash);const origin=prevTxHashBytes[2];hashBuffer[0]=origin;hashBuffer[1]|=128;hashBuffer[2]=origin;hashBuffer[3]|=128;return"0x"+hashBuffer.toString("hex")}get originZone(){const senderAddr=computeAddress(this.txInputs[0].pubkey||"");const zone=getZoneForAddress(senderAddr);return zone??undefined}get destZone(){const zone=getZoneForAddress(this.txOutputs[0].address);return zone??undefined}constructor(){super();this.#txInputs=[];this.#txOutputs=[]}inferTypes(){const types=[];if(this.type!=null){types.push(this.type)}else{types.push(2)}types.sort();return types}clone(){return QiTransaction.from(this)}toJSON(){const s=v=>{if(v==null){return null}return v.toString()};return{type:this.type,chainId:s(this.chainId),signature:this.signature?this.signature:null,hash:this.hash,txInputs:this.txInputs,txOutputs:this.txOutputs}}toProtobuf(includeSignature=true){const protoTx={type:this.type||2,chain_id:formatNumber(this.chainId||0,"chainId"),tx_ins:{tx_ins:this.txInputs.map(input=>({previous_out_point:{hash:{value:getBytes(input.txhash)},index:input.index},pub_key:getBytes(input.pubkey)}))},tx_outs:{tx_outs:this.txOutputs.map(output=>({address:getBytes(output.address),denomination:output.denomination,lock:new Uint8Array}))}};if(this.signature&&includeSignature){protoTx.signature=getBytes(this.signature)}return protoTx}static from(tx){if(typeof tx==="string"){const decodedProtoTx=decodeProtoTransaction(getBytes(tx));return QiTransaction.fromProto(decodedProtoTx)}const result=new QiTransaction;if(tx.type!=null){result.type=tx.type}if(tx.chainId!=null){result.chainId=tx.chainId}if(tx.signature!=null&&tx.signature!==""){result.signature=tx.signature}if(tx.txInputs!=null){result.txInputs=tx.txInputs}if(tx.txOutputs!=null){result.txOutputs=tx.txOutputs}if(tx.hash!=null){assertArgument(result.isSigned(),"unsigned transaction cannot define hash","tx",tx)}return result}static fromProto(protoTx){const tx=new QiTransaction;tx.type=protoTx.type;tx.chainId=toBigInt(protoTx.chain_id);tx.txInputs=protoTx.tx_ins?.tx_ins.map(input=>({txhash:hexlify(input.previous_out_point.hash.value),index:input.previous_out_point.index,pubkey:hexlify(input.pub_key)}))??[];tx.txOutputs=protoTx.tx_outs?.tx_outs.map(output=>({address:hexlify(output.address),denomination:output.denomination,lock:output.lock?hexlify(output.lock):""}))??[];if(protoTx.signature){tx.signature=hexlify(protoTx.signature)}return tx}}function _parseSignature(fields){let yParity;try{yParity=handleNumber(fields[0],"yParity");if(yParity!==0&&yParity!==1){throw new Error("bad yParity")}}catch(error){assertArgument(false,"invalid yParity","yParity",fields[0])}const r=zeroPadValue(fields[1],32);const s=zeroPadValue(fields[2],32);return Signature.from({r:r,s:s,yParity:yParity})}class QuaiTransaction extends AbstractTransaction{#to;#data;#nonce;#gasLimit;#gasPrice;#minerTip;#value;#accessList;from;get to(){return this.#to}set to(value){if(value!==null)validateAddress(value);this.#to=value}get hash(){if(this.signature==null)return null;if(!this.originZone){throw new Error("Invalid Zone for from address")}if(!this.from){throw new Error("Missing from address")}const isSameLedger=!this.to||isQuaiAddress(this.from)===isQuaiAddress(this.to);if(this.isExternal&&!isSameLedger){throw new Error("Cross-zone & cross-ledger transactions are not supported")}const hexString=this.serialized.startsWith("0x")?this.serialized.substring(2):this.serialized;const dataBuffer=Buffer.from(hexString,"hex");const hashHex=keccak256(dataBuffer);const hashBuffer=Buffer.from(hashHex.substring(2),"hex");const origin=this.originZone?parseInt(this.originZone.slice(2),16):0;hashBuffer[0]=origin;hashBuffer[1]&=127;hashBuffer[2]=origin;hashBuffer[3]&=127;return"0x"+hashBuffer.toString("hex")}get originZone(){const zone=this.from?getZoneForAddress(this.from):undefined;return zone??undefined}get destZone(){const zone=this.to!==null?getZoneForAddress(this.to||""):undefined;return zone??undefined}get nonce(){return this.#nonce}set nonce(value){this.#nonce=getNumber(value,"value")}get gasLimit(){return this.#gasLimit}set gasLimit(value){this.#gasLimit=getBigInt(value)}get minerTip(){const value=this.#minerTip;if(value==null){return null}return value}set minerTip(value){this.#minerTip=value==null?null:getBigInt(value,"minerTip")}get gasPrice(){const value=this.#gasPrice;if(value==null){return null}return value}set gasPrice(value){this.#gasPrice=value==null?null:getBigInt(value,"gasPrice")}get data(){return this.#data}set data(value){this.#data=hexlify(value)}get value(){return this.#value}set value(value){this.#value=getBigInt(value,"value")}get accessList(){const value=this.#accessList||null;if(value==null){return null}return value}set accessList(value){this.#accessList=value==null?null:accessListify(value)}constructor(from){super();this.#to=null;this.#nonce=0;this.#gasLimit=BigInt(0);this.#gasPrice=null;this.#minerTip=null;this.#gasPrice=null;this.#data="0x";this.#value=BigInt(0);this.#accessList=null;this.from=from}inferTypes(){if(this.gasPrice!=null&&this.minerTip!=null){assert$1(this.gasPrice>=this.minerTip,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this})}assert$1(this.type!==0&&this.type!==1,"transaction type cannot have externalGasLimit, externalGasTip, externalGasPrice, externalData, or externalAccessList","BAD_DATA",{value:this});const types=[];if(this.type!=null){types.push(this.type)}else{types.push(0)}types.sort();return types}clone(){return QuaiTransaction.from(this)}toJSON(){const s=v=>{if(v==null){return null}return v.toString()};return{type:this.type,to:this.to,from:this.from,data:this.data,nonce:this.nonce,gasLimit:s(this.gasLimit),gasPrice:s(this.gasPrice),minerTip:s(this.minerTip),value:s(this.value),chainId:s(this.chainId),signature:this.signature?this.signature.toJSON():null,hash:this.hash,accessList:this.accessList}}toProtobuf(includeSignature=true){const protoTx={type:this.type||0,chain_id:formatNumber(this.chainId||0,"chainId"),nonce:this.nonce||0,miner_tip:formatNumber(this.minerTip||0,"minerTip"),gas_price:formatNumber(this.gasPrice||0,"gasPrice"),gas:Number(this.gasLimit||0),to:this.to!=null?getBytes(this.to):null,value:formatNumber(this.value||0,"value"),data:getBytes(this.data||"0x"),access_list:{access_tuples:this.accessList?.map(it=>{return{address:getBytes(it.address),storage_key:it.storageKeys.map(key=>{return{value:getBytes(key)}})}})||[]}};if(this.signature&&includeSignature){protoTx.v=formatNumber(this.signature.yParity,"yParity");protoTx.r=toBeArray(this.signature.r);protoTx.s=toBeArray(this.signature.s)}return protoTx}static from(tx){if(typeof tx==="string"){const decodedProtoTx=decodeProtoTransaction(getBytes(tx));return QuaiTransaction.fromProto(decodedProtoTx)}const result=new QuaiTransaction(tx.from);if(tx.type!=null){result.type=tx.type}if(tx.to!=null){validateAddress(tx.to);result.to=tx.to}if(tx.nonce!=null){result.nonce=tx.nonce}if(tx.gasLimit!=null){result.gasLimit=tx.gasLimit}if(tx.minerTip!=null){result.minerTip=tx.minerTip}if(tx.gasPrice!=null){result.gasPrice=tx.gasPrice}if(tx.data!=null&&tx.data!==""){result.data=tx.data}if(tx.value!=null){result.value=tx.value}if(tx.chainId!=null){result.chainId=tx.chainId}if(tx.signature!=null){result.signature=Signature.from(tx.signature)}if(tx.accessList!=null){result.accessList=tx.accessList}if(tx.hash!=null){assertArgument(result.isSigned(),"unsigned transaction cannot define hash","tx",tx)}if(tx.from!=null){assertArgument(isQuaiAddress(tx.from),"from address must be a Quai address","tx.from",tx.from);assertArgument((result.from||"").toLowerCase()===(tx.from||"").toLowerCase(),"from mismatch","tx",tx);result.from=tx.from}return result}static fromProto(protoTx){let signature=null;let address="";delete protoTx.etx_sender;delete protoTx.etx_index;delete protoTx.work_nonce;delete protoTx.etx_type;const protoTxCopy=deepCopyProtoTransaction(protoTx);if(protoTx.v&&protoTx.r&&protoTx.s){if(protoTx.r.reduce((acc,val)=>acc+=val,0)==0){throw new Error("Proto decoding only supported for signed transactions")}const signatureFields=[hexlify(protoTx.v),hexlify(protoTx.r),hexlify(protoTx.s)];signature=_parseSignature(signatureFields);delete protoTxCopy.v;delete protoTxCopy.r;delete protoTxCopy.s;delete protoTxCopy.signature;address=recoverAddress(keccak256(encodeProtoTransaction(protoTxCopy)),signature)}const tx=new QuaiTransaction(address);if(signature){tx.signature=signature}if(protoTx.to!==null){const toAddr=hexlify(protoTx.to);tx.to=getAddress(toAddr)}tx.type=protoTx.type;tx.chainId=toBigInt(protoTx.chain_id);tx.nonce=Number(protoTx.nonce);tx.minerTip=toBigInt(protoTx.miner_tip);tx.gasPrice=toBigInt(protoTx.gas_price);tx.gasLimit=toBigInt(protoTx.gas);tx.value=protoTx.value!==null?toBigInt(protoTx.value):BigInt(0);tx.data=hexlify(protoTx.data);tx.accessList=protoTx.access_list.access_tuples.map(tuple=>({address:formatMixedCaseChecksumAddress(hexlify(tuple.address)),storageKeys:tuple.storage_key.map(key=>hexlify(key.value))}));return tx}}function deepCopyProtoTransaction(proto){if(proto==null)return proto;const copy={type:proto.type,chain_id:new Uint8Array(proto.chain_id),nonce:proto.nonce};if(proto.to)copy.to=new Uint8Array(proto.to);if(proto.value)copy.value=new Uint8Array(proto.value);if(proto.data)copy.data=new Uint8Array(proto.data);if(proto.gas_price)copy.gas_price=new Uint8Array(proto.gas_price);if(proto.miner_tip)copy.miner_tip=new Uint8Array(proto.miner_tip);if(proto.v)copy.v=new Uint8Array(proto.v);if(proto.r)copy.r=new Uint8Array(proto.r);if(proto.s)copy.s=new Uint8Array(proto.s);if(proto.signature)copy.signature=new Uint8Array(proto.signature);if(proto.etx_sender)copy.etx_sender=new Uint8Array(proto.etx_sender);if(proto.gas!==undefined)copy.gas=proto.gas;if(proto.etx_index!==undefined)copy.etx_index=proto.etx_index;if(proto.work_nonce!==undefined)copy.work_nonce=proto.work_nonce;if(proto.etx_type!==undefined)copy.etx_type=proto.etx_type;if(proto.access_list){copy.access_list={access_tuples:proto.access_list.access_tuples.map(tuple=>({address:new Uint8Array(tuple.address),storage_key:tuple.storage_key.map(key=>({value:new Uint8Array(key.value)}))}))}}return copy}const BN_0$1=BigInt(0);function getValue(value){if(value==null){return null}return value}function toJson(value){if(value==null){return null}return value.toString()}class FeeData{gasPrice;minerTip;constructor(gasPrice,minerTip){defineProperties(this,{gasPrice:getValue(gasPrice),minerTip:getValue(minerTip)})}toJSON(){const{gasPrice,minerTip}=this;return{_type:"FeeData",gasPrice:toJson(gasPrice),minerTip:toJson(minerTip)}}}function addressFromTransactionRequest(tx){if("from"in tx&&!!tx.from){if(tx.from!==ZeroAddress){return tx.from}}if("to"in tx&&!!tx.to){if(tx.to!==ZeroAddress){return tx.to}}if("txInputs"in tx&&!!tx.txInputs){const inputs=tx.txInputs;return computeAddress(inputs[0].pubkey)}if("txIn"in tx&&!!tx.txIn){const inputs=tx.txIn;return computeAddress(inputs[0].pubkey)}throw new Error("Unable to determine address from transaction inputs, from or to field")}function copyRequest(req){const result={};if("to"in req&&req.to){result.to=req.to}if("from"in req&&req.from){result.from=req.from}if("data"in req&&req.data){result.data=hexlify(req.data)}const bigIntKeys="chainId,gasLimit,gasPrice,minerTip,value".split(/,/);for(const key of bigIntKeys){if(!(key in req)||req[key]==null){continue}result[key]=getBigInt(req[key],`request.${key}`)}const numberKeys="type,nonce".split(/,/);for(const key of numberKeys){if(!(key in req)||req[key]==null){continue}result[key]=getNumber(req[key],`request.${key}`)}if("accessList"in req&&req.accessList){result.accessList=accessListify(req.accessList)}if("blockTag"in req){result.blockTag=req.blockTag}if("customData"in req){result.customData=req.customData}if("txInputs"in req&&req.txInputs){result.txInputs=req.txInputs.map(entry=>({...entry}))}if("txOutputs"in req&&req.txOutputs){result.txOutputs=req.txOutputs.map(entry=>({...entry}))}return result}class BlockHeader{baseFeePerGas;efficiencyScore;etxEligibleSlices;etxSetRoot;evmRoot;expansionNumber;etxRollupRoot;outboundEtxsRoot;extraData;gasLimit;gasUsed;interlinkRootHash;manifestHash;number;parentDeltaEntropy;parentEntropy;parentHash;parentUncledDeltaEntropy;primeTerminusHash;quaiStateSize;receiptsRoot;uncleHash;size;stateLimit;stateUsed;thresholdCount;transactionsRoot;uncledEntropy;utxoRoot;exchangeRate;quaiToQi;qiToQuai;secondaryCoinbase;constructor(params){this.baseFeePerGas=params.baseFeePerGas;this.efficiencyScore=params.efficiencyScore;this.etxEligibleSlices=params.etxEligibleSlices;this.etxSetRoot=params.etxSetRoot;this.evmRoot=params.evmRoot;this.expansionNumber=params.expansionNumber;this.etxRollupRoot=params.etxRollupRoot;this.outboundEtxsRoot=params.outboundEtxsRoot;this.extraData=params.extraData;this.gasLimit=params.gasLimit;this.gasUsed=params.gasUsed;this.interlinkRootHash=params.interlinkRootHash;this.manifestHash=params.manifestHash;this.number=params.number;this.parentDeltaEntropy=params.parentDeltaEntropy;this.parentEntropy=params.parentEntropy;this.parentHash=params.parentHash;this.parentUncledDeltaEntropy=params.parentUncledDeltaEntropy;this.primeTerminusHash=params.primeTerminusHash;this.quaiStateSize=params.quaiStateSize;this.receiptsRoot=params.receiptsRoot;this.uncleHash=params.uncleHash;this.size=params.size;this.stateLimit=params.stateLimit;this.stateUsed=params.stateUsed;this.thresholdCount=params.thresholdCount;this.transactionsRoot=params.transactionsRoot;this.uncledEntropy=params.uncledEntropy;this.utxoRoot=params.utxoRoot;this.exchangeRate=params.exchangeRate;this.quaiToQi=params.quaiToQi;this.qiToQuai=params.qiToQuai;this.secondaryCoinbase=params.secondaryCoinbase}toJSON(){return{...this}}}class Uncle{primaryCoinbase;difficulty;headerHash;location;mixHash;nonce;number;parentHash;timestamp;txHash;lock;constructor(params){this.primaryCoinbase=params.primaryCoinbase;this.difficulty=params.difficulty;this.headerHash=params.headerHash;this.location=params.location;this.mixHash=params.mixHash;this.nonce=params.nonce;this.number=params.number;this.parentHash=params.parentHash;this.timestamp=params.timestamp;this.txHash=params.txHash;this.lock=params.lock}toJSON(){return{primaryCoinbase:this.primaryCoinbase,difficulty:this.difficulty,headerHash:this.headerHash,location:this.location,mixHash:this.mixHash,nonce:this.nonce,number:this.number,parentHash:this.parentHash,timestamp:this.timestamp,txHash:this.txHash,lock:this.lock}}}class Block{#outboundEtxs;hash;header;interlinkHashes;size;subManifest;totalEntropy;#transactions;uncles;woHeader;workShares;provider;constructor(block,provider){this.#transactions=block.transactions.map(tx=>{if(typeof tx==="string"){return tx}if("originatingTxHash"in tx){return new ExternalTransactionResponse(tx,provider)}if("from"in tx){return new QuaiTransactionResponse(tx,provider)}return new QiTransactionResponse(tx,provider)});this.#outboundEtxs=block.outboundEtxs.map(tx=>{if(typeof tx!=="string"){return new ExternalTransactionResponse(tx,provider)}return tx});this.hash=block.hash;this.header=new BlockHeader(block.header);this.interlinkHashes=block.interlinkHashes;this.size=block.size;this.subManifest=block.subManifest;this.totalEntropy=block.totalEntropy;this.uncles=block.uncles.map(uncle=>{if(typeof uncle==="string"){return uncle}return new Uncle(uncle)});this.woHeader=new Uncle(block.woHeader);this.workShares=block.workShares.map(workShare=>{if(typeof workShare==="string"){return workShare}return new Uncle(workShare)});this.provider=provider}get transactions(){return this.#transactions.map(tx=>{if(typeof tx==="string"){return tx}return tx.hash})}get outboundEtxs(){return this.#outboundEtxs.map(tx=>{if(typeof tx==="string"){return tx}return tx.hash})}get prefetchedTransactions(){const txs=this.#transactions.slice();if(txs.length===0){return[]}assert$1(typeof txs[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"});return txs}get prefetchedExtTransactions(){const txs=this.#outboundEtxs.slice();if(txs.length===0){return[]}assert$1(typeof txs[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"});return txs}toJSON(){const{hash,header,interlinkHashes,size,subManifest,totalEntropy,uncles,woHeader,workShares}=this;const transactions=this.transactions;const outboundEtxs=this.outboundEtxs;return{outboundEtxs:outboundEtxs,hash:hash,header:header.toJSON(),interlinkHashes:interlinkHashes,transactions:transactions,size:size,subManifest:subManifest,totalEntropy:totalEntropy,uncles:uncles.map(uncle=>{if(typeof uncle==="string"){return uncle}return uncle.toJSON()}),woHeader:woHeader.toJSON(),workShares:workShares.map(workShare=>{if(typeof workShare==="string"){return workShare}return workShare.toJSON()})}}[Symbol.iterator](){let index=0;const txs=this.transactions;return{next:()=>{if(index<this.length){return{value:txs[index++],done:false}}return{value:undefined,done:true}}}}get length(){return this.#transactions.length}get date(){const timestampHex=this.woHeader.timestamp;if(!timestampHex){return null}const timestamp=parseInt(timestampHex,16);return new Date(timestamp*1e3)}async getTransaction(indexOrHash){let tx=undefined;if(typeof indexOrHash==="number"){tx=this.#transactions[indexOrHash]}else{const hash=indexOrHash.toLowerCase();for(const v of this.#transactions){if(typeof v==="string"){if(v!==hash){continue}tx=v;break}else{if(v.hash===hash){continue}tx=v;break}}}if(tx==null){throw new Error("no such tx")}if(typeof tx==="string"){return await this.provider.getTransaction(tx)}else{return tx}}async getExtTransaction(indexOrHash){let tx=undefined;if(typeof indexOrHash==="number"){tx=this.#outboundEtxs[indexOrHash]}else{const hash=indexOrHash.toLowerCase();for(const v of this.#outboundEtxs){if(typeof v==="string"){if(v!==hash){continue}tx=v;break}else{if(v.hash===hash){continue}tx=v;break}}}if(tx==null){throw new Error("no such tx")}if(typeof tx==="string"){throw new Error("External Transaction isn't prefetched")}else{return tx}}getPrefetchedTransaction(indexOrHash){const txs=this.prefetchedTransactions;if(typeof indexOrHash==="number"){return txs[indexOrHash]}indexOrHash=indexOrHash.toLowerCase();for(const tx of txs){if(tx.hash===indexOrHash){return tx}}assertArgument(false,"no matching transaction","indexOrHash",indexOrHash)}isMined(){return!!this.hash}orphanedEvent(){if(!this.isMined()||!this.woHeader.number){throw new Error("")}return createOrphanedBlockFilter({hash:this.hash,number:this.woHeader.number})}}class Log{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(log,provider){this.provider=provider;const topics=Object.freeze(log.topics.slice());defineProperties(this,{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,removed:log.removed,address:log.address,data:log.data,topics:topics,index:log.index,transactionIndex:log.transactionIndex})}toJSON(){const{address,blockHash,blockNumber,data,index,removed,topics,transactionHash,transactionIndex}=this;return{_type:"log",address:address,blockHash:blockHash,blockNumber:blockNumber,data:data,index:index,removed:removed,topics:topics,transactionHash:transactionHash,transactionIndex:transactionIndex}}async getBlock(shard){const block=await this.provider.getBlock(shard,this.blockHash);assert$1(!!block,"failed to find transaction","UNKNOWN_ERROR",{});return block}async getTransaction(){const tx=await this.provider.getTransaction(this.transactionHash);assert$1(!!tx,"failed to find transaction","UNKNOWN_ERROR",{});return tx}async getTransactionReceipt(){const receipt=await this.provider.getTransactionReceipt(this.transactionHash);assert$1(!!receipt,"failed to find transaction receipt","UNKNOWN_ERROR",{});return receipt}removedEvent(){return createRemovedLogFilter(this)}}function zoneFromHash(hash){return toZone(hash.slice(0,4))}class TransactionReceipt{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;cumulativeGasUsed;gasPrice;type;status;#logs;outboundEtxs=[];etxType;originatingTxHash;constructor(tx,provider){this.#logs=Object.freeze(Array.isArray(tx.logs)?tx.logs.map(log=>new Log(log,provider)):[]);let gasPrice=BN_0$1;if(tx.effectiveGasPrice!=null){gasPrice=tx.effectiveGasPrice}else if(tx.gasPrice!=null){gasPrice=tx.gasPrice}const outboundEtxs=tx.outboundEtxs?tx.outboundEtxs.map(etx=>{const safeConvert=(value,name)=>{try{if(value!=null){return BigInt(value)}return null}catch(error){console.error(`Conversion to BigInt failed for ${name}: ${value}, error: ${error}`);return null}};return{type:etx.type,nonce:etx.nonce,gasPrice:safeConvert(etx.gasPrice,"gasPrice"),minerTip:safeConvert(etx.minerTip,"minerTip"),gas:safeConvert(etx.gas,"gas"),value:safeConvert(etx.value,"value"),input:etx.input,to:etx.to,accessList:etx.accessList,chainId:safeConvert(etx.chainId,"chainId"),from:etx.from,hash:etx.hash,originatingTxHash:etx.originatingTxHash,etxIndex:etx.etxIndex}}):[];defineProperties(this,{provider:provider,to:tx.to,from:tx.from,contractAddress:tx.contractAddress,hash:tx.hash,index:tx.index,blockHash:tx.blockHash,blockNumber:tx.blockNumber,logsBloom:tx.logsBloom,gasUsed:tx.gasUsed,cumulativeGasUsed:tx.cumulativeGasUsed,gasPrice:gasPrice,outboundEtxs:outboundEtxs,type:tx.type,status:tx.status,etxType:tx.etxType,originatingTxHash:tx.originatingTxHash})}get logs(){return this.#logs}toJSON(){const{to,from,contractAddress,hash,index,blockHash,blockNumber,logsBloom,logs,status,outboundEtxs}=this;return{_type:"TransactionReceipt",blockHash:blockHash,blockNumber:blockNumber,contractAddress:contractAddress,cumulativeGasUsed:toJson(this.cumulativeGasUsed),from:from,gasPrice:toJson(this.gasPrice),gasUsed:toJson(this.gasUsed),hash:hash,index:index,logs:logs,logsBloom:logsBloom,status:status,to:to,outboundEtxs:outboundEtxs??[]}}get length(){return this.logs.length}[Symbol.iterator](){let index=0;return{next:()=>{if(index<this.length){return{value:this.logs[index++],done:false}}return{value:undefined,done:true}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(shard){const block=await this.provider.getBlock(shard,this.blockHash);if(block==null){throw new Error("TODO")}return block}async getTransaction(){const tx=await this.provider.getTransaction(this.hash);if(tx==null){throw new Error("TODO")}return tx}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){const zone=zoneFromHash(this.hash);return await this.provider.getBlockNumber(toShard(zone))-this.blockNumber+1}removedEvent(){return createRemovedTransactionFilter(this)}reorderedEvent(other){assert$1(!other||other.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"});return createReorderedTransactionFilter(this,other)}}class ExternalTransactionResponse{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;data;value;chainId;signature;accessList;etxType;originatingTxHash;sender;etxIndex;startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.from=tx.from;this.to=tx.to||null;this.gasLimit=tx.gasLimit;this.nonce=tx.nonce;this.data=tx.data;this.value=tx.value;this.chainId=tx.chainId;this.signature=tx.signature;this.accessList=tx.accessList!=null?tx.accessList:null;this.startBlock=-1;this.originatingTxHash=tx.originatingTxHash!=null?tx.originatingTxHash:null;this.etxType=tx.etxType!=null?tx.etxType:null;this.etxIndex=tx.etxIndex}toJSON(){const{blockNumber,blockHash,index,hash,type,to,from,nonce,data,signature,accessList,etxType,originatingTxHash,etxIndex}=this;const result={_type:"TransactionReceipt",accessList:accessList,blockNumber:blockNumber,blockHash:blockHash,chainId:toJson(this.chainId),data:data,from:from,gasLimit:toJson(this.gasLimit),hash:hash,nonce:nonce,signature:signature,to:to,index:index,type:type,etxType:etxType,originatingTxHash:originatingTxHash,etxIndex:etxIndex,value:toJson(this.value)};return result}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,"invalid startBlock","startBlock",startBlock);const tx=new ExternalTransactionResponse(this,this.provider);tx.startBlock=startBlock;return tx}}class QuaiTransactionResponse{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;minerTip;gasPrice;data;value;chainId;signature;accessList;etxType;sender;originatingTxHash;startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.from=tx.from;this.to=tx.to||null;this.gasLimit=tx.gasLimit;this.nonce=tx.nonce;this.data=tx.data;this.value=tx.value;this.minerTip=tx.minerTip!=null?tx.minerTip:null;this.gasPrice=tx.gasPrice!=null?tx.gasPrice:null;this.chainId=tx.chainId;this.signature=tx.signature;this.accessList=tx.accessList!=null?tx.accessList:null;this.startBlock=-1;this.etxType=tx.etxType!=null?tx.etxType:null}toJSON(){const{blockNumber,blockHash,index,hash,type,to,from,nonce,data,signature,accessList}=this;const result={_type:"TransactionReceipt",accessList:accessList,blockNumber:blockNumber,blockHash:blockHash,chainId:toJson(this.chainId),data:data,from:from,gasLimit:toJson(this.gasLimit),hash:hash,gasPrice:toJson(this.gasPrice),minerTip:toJson(this.minerTip),nonce:nonce,signature:signature,to:to,index:index,type:type,value:toJson(this.value)};return result}async getBlock(shard){let blockNumber=this.blockNumber;if(blockNumber==null){const tx=await this.getTransaction();if(tx){blockNumber=tx.blockNumber}}if(blockNumber==null){return null}const block=this.provider.getBlock(shard,blockNumber);if(block==null){throw new Error("TODO")}return block}async getTransaction(){const transaction=this.provider.getTransaction(this.hash);if(transaction instanceof QuaiTransactionResponse){return transaction}else{return null}}async confirmations(){const zone=zoneFromHash(this.hash);if(this.blockNumber==null){const{tx,blockNumber}=await resolveProperties({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber(toShard(zone))});if(tx==null||tx.blockNumber==null){return 0}return blockNumber-tx.blockNumber+1}const blockNumber=await this.provider.getBlockNumber(toShard(zone));return blockNumber-this.blockNumber+1}async wait(_confirms,_timeout){const confirms=_confirms==null?1:_confirms;const timeout=_timeout==null?0:_timeout;let startBlock=this.startBlock;let nextScan=-1;let stopScanning=startBlock===-1?true:false;const zone=zoneFromHash(this.hash);const checkReplacement=async()=>{if(stopScanning){return null}const{blockNumber,nonce}=await resolveProperties({blockNumber:this.provider.getBlockNumber(toShard(zone)),nonce:this.provider.getTransactionCount(this.from)});if(nonce<this.nonce){startBlock=blockNumber;return}if(stopScanning){return null}const mined=await this.getTransaction();if(mined&&mined.blockNumber!=null){return}if(nextScan===-1){nextScan=startBlock-3;if(nextScan<this.startBlock){nextScan=this.startBlock}}while(nextScan<=blockNumber){if(stopScanning){return null}const block=await this.provider.getBlock(toShard(zone),nextScan,true);if(block==null){return}for(const hash of block){if(hash===this.hash){return}}for(let i=0;i<block.length;i++){const tx=await block.getTransaction(i);if("from"in tx&&tx.from===this.from&&tx.nonce===this.nonce){if(stopScanning){return null}const receipt=await this.provider.getTransactionReceipt(tx.hash);if(receipt==null){return}if(blockNumber-receipt.blockNumber+1<confirms){return}let reason="replaced";if(tx.data===this.data&&tx.to===this.to&&tx.value===this.value){reason="repriced"}else if(tx.data==="0x"&&tx.from===tx.to&&tx.value===BN_0$1){reason="cancelled"}assert$1(false,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:reason==="replaced"||reason==="cancelled",reason:reason,replacement:tx.replaceableTransaction(startBlock),hash:tx.hash,receipt:receipt})}}nextScan++}return};const checkReceipt=receipt=>{if(receipt==null||receipt.status!==0){return receipt}assert$1(false,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:receipt.to,from:receipt.from,data:""},receipt:receipt})};const receipt=await this.provider.getTransactionReceipt(this.hash);if(confirms===0){return checkReceipt(receipt)}if(receipt){if(await receipt.confirmations()>=confirms){return checkReceipt(receipt)}}else{await checkReplacement();if(confirms===0){return null}}const waiter=new Promise((resolve,reject)=>{const cancellers=[];const cancel=()=>{cancellers.forEach(c=>c())};cancellers.push(()=>{stopScanning=true});if(timeout>0){const timer=setTimeout(()=>{cancel();reject(makeError("wait for transaction timeout","TIMEOUT"))},timeout);cancellers.push(()=>{clearTimeout(timer)})}const txListener=async receipt=>{if(await receipt.confirmations()>=confirms){cancel();try{resolve(checkReceipt(receipt))}catch(error){reject(error)}}};cancellers.push(()=>{this.provider.off(this.hash,txListener)});this.provider.on(this.hash,txListener);if(startBlock>=0){const replaceListener=async()=>{try{await checkReplacement()}catch(error){if(isError(error,"TRANSACTION_REPLACED")){cancel();reject(error);return}}if(!stopScanning){this.provider.once("block",replaceListener,zone)}};cancellers.push(()=>{this.provider.off("block",replaceListener,zone)});this.provider.once("block",replaceListener,zone)}});return await waiter}isMined(){return this.blockHash!=null}removedEvent(){assert$1(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createRemovedTransactionFilter(this)}reorderedEvent(other){assert$1(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});assert$1(!other||other.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createReorderedTransactionFilter(this,other)}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,"invalid startBlock","startBlock",startBlock);const tx=new QuaiTransactionResponse(this,this.provider);tx.startBlock=startBlock;return tx}}class QiTransactionResponse{provider;blockNumber;blockHash;index;hash;type;chainId;signature;txInputs;txOutputs;startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.chainId=tx.chainId;this.signature=tx.signature;this.startBlock=-1;this.txInputs=tx.txInputs;this.txOutputs=tx.txOutputs}toJSON(){const{blockNumber,blockHash,index,hash,type,signature,txInputs,txOutputs}=this;const result={_type:"TransactionReceipt",blockNumber:blockNumber,blockHash:blockHash,chainId:toJson(this.chainId),hash:hash,signature:signature,index:index,type:type,txInputs:JSON.parse(JSON.stringify(txInputs)),txOutputs:JSON.parse(JSON.stringify(txOutputs))};return result}async getBlock(shard){let blockNumber=this.blockNumber;if(blockNumber==null){const tx=await this.getTransaction();if(tx){blockNumber=tx.blockNumber}}if(blockNumber==null){return null}const block=this.provider.getBlock(shard,blockNumber);if(block==null){throw new Error("TODO")}return block}async getTransaction(){const transaction=this.provider.getTransaction(this.hash);if(transaction instanceof QiTransactionResponse){return transaction}else{return null}}async confirmations(){const zone=zoneFromHash(this.hash);if(this.blockNumber==null){const{tx,blockNumber}=await resolveProperties({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber(toShard(zone))});if(tx==null||tx.blockNumber==null||tx.blockHash==null){return 0}return blockNumber-tx.blockNumber+1}const blockNumber=await this.provider.getBlockNumber(toShard(zone));return blockNumber-this.blockNumber+1}async wait(_confirms,_timeout){const confirms=_confirms==null?1:_confirms;const timeout=_timeout==null?0:_timeout;const tx=await this.provider.getTransaction(this.hash);if(confirms===0&&tx?.blockHash!=null){return tx}const waiter=new Promise((resolve,reject)=>{const cancellers=[];const cancel=()=>{cancellers.forEach(c=>c())};if(timeout>0){const timer=setTimeout(()=>{cancel();reject(makeError("wait for transaction timeout","TIMEOUT"))},timeout);cancellers.push(()=>{clearTimeout(timer)})}const txListener=async tx=>{if(await tx.confirmations()>=confirms){cancel();try{resolve(tx)}catch(error){reject(error)}}};cancellers.push(()=>{this.provider.off(this.hash,txListener)});this.provider.on(this.hash,txListener)});return await waiter}isMined(){return this.blockHash!=null}removedEvent(){assert$1(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createRemovedTransactionFilter(this)}reorderedEvent(other){assert$1(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});assert$1(!other||other.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createReorderedTransactionFilter(this,other)}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,"invalid startBlock","startBlock",startBlock);const tx=new QiTransactionResponse(this,this.provider);tx.startBlock=startBlock;return tx}}function createOrphanedBlockFilter(block){return{orphan:"drop-block",hash:block.hash,number:block.number}}function createReorderedTransactionFilter(tx,other){return{orphan:"reorder-transaction",tx:tx,other:other}}function createRemovedTransactionFilter(tx){return{orphan:"drop-transaction",tx:tx}}function createRemovedLogFilter(log){return{orphan:"drop-log",log:{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,address:log.address,data:log.data,topics:Object.freeze(log.topics.slice()),index:log.index}}}function getZoneFromEventFilter(filter){let zone=null;if(filter.nodeLocation){zone=getZoneFromNodeLocation(filter.nodeLocation)}else if(filter.address){let address;if(Array.isArray(filter.address)){address=filter.address[0]}else{address=filter.address}const addressZone=getZoneForAddress(address);if(addressZone){zone=toZone(addressZone)}else{return null}}return zone}class EventLog extends Log{interface;fragment;args;constructor(log,iface,fragment){super(log,log.provider);const args=iface.decodeEventLog(fragment,log.data,log.topics);defineProperties(this,{args:args,fragment:fragment,interface:iface})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class UndecodedEventLog extends Log{error;constructor(log,error){super(log,log.provider);defineProperties(this,{error:error})}}class ContractTransactionReceipt extends TransactionReceipt{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}get logs(){return super.logs.map(log=>{const fragment=log.topics.length?this.#iface.getEvent(log.topics[0]):null;if(fragment){try{return new EventLog(log,this.#iface,fragment)}catch(error){return new UndecodedEventLog(log,error)}}return log})}}class ContractTransactionResponse extends QuaiTransactionResponse{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}async wait(confirms){const receipt=await super.wait(confirms);if(receipt==null){return null}return new ContractTransactionReceipt(this.#iface,this.provider,receipt)}}class ContractUnknownEventPayload extends EventPayload{log;constructor(contract,listener,filter,log){super(contract,listener,filter);defineProperties(this,{log:log})}async getBlock(shard){return await this.log.getBlock(shard)}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}class ContractEventPayload extends ContractUnknownEventPayload{constructor(contract,listener,filter,fragment,_log){super(contract,listener,filter,new EventLog(_log,contract.interface,fragment));const args=contract.interface.decodeEventLog(fragment,this.log.data,this.log.topics);defineProperties(this,{args:args,fragment:fragment})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}const BN_0=BigInt(0);function canCall(value){return value&&typeof value.call==="function"}function canEstimate(value){return value&&typeof value.estimateGas==="function"}function canSend(value){return value&&typeof value.sendTransaction==="function"}class PreparedTopicFilter{#filter;fragment;constructor(contract,fragment,args){defineProperties(this,{fragment:fragment});if(fragment.inputs.length<args.length){throw new Error("too many arguments")}this.#filter=async function(){const resolvedArgs=await Promise.all(fragment.inputs.map((param,index)=>{const arg=args[index];if(arg==null){return null}return param.walkAsync(args[index],(type,value)=>{if(type==="address"){if(Array.isArray(value)){return Promise.all(value.map(v=>resolveAddress(v)))}return resolveAddress(value)}return value})}));return contract.interface.encodeFilterTopics(fragment,resolvedArgs)}()}getTopicFilter(){return this.#filter}}function getRunner(value,feature){if(value==null){return null}if(typeof value[feature]==="function"){return value}if(value.provider&&typeof value.provider[feature]==="function"){return value.provider}return null}function getProvider(value){if(value==null){return null}return value.provider||null}async function copyOverrides(arg,allowed){const _overrides=Typed.dereference(arg,"overrides");assertArgument(typeof _overrides==="object","invalid overrides parameter","overrides",arg);const overrides=copyRequest(_overrides);assertArgument(!("to"in overrides)||overrides.to==null||(allowed||[]).indexOf("to")>=0,"cannot override to","overrides.to",overrides);assertArgument(!("data"in overrides)||overrides.data==null||(allowed||[]).indexOf("data")>=0,"cannot override data","overrides.data",overrides);if("from"in overrides&&overrides.from){overrides.from=await overrides.from}return overrides}async function resolveArgs(_runner,inputs,args){return await Promise.all(inputs.map((param,index)=>{return param.walkAsync(args[index],(type,value)=>{value=Typed.dereference(value,type);if(type==="address"){return resolveAddress(value)}return value})}))}function buildWrappedFallback(contract){const populateTransaction=async function(overrides){const tx=await copyOverrides(overrides,["data"]);tx.to=await contract.getAddress();validateAddress(tx.to);if(tx.from){tx.from=await resolveAddress(tx.from);validateAddress(tx.from)}const iface=contract.interface;const noValue=getBigInt(tx.value||BN_0,"overrides.value")===BN_0;const noData=(tx.data||"0x")==="0x";if(iface.fallback&&!iface.fallback.payable&&iface.receive&&!noData&&!noValue){assertArgument(false,"cannot send data to receive or send value to non-payable fallback","overrides",overrides)}assertArgument(iface.fallback||noData,"cannot send data to receive-only contract","overrides.data",tx.data);const payable=iface.receive||iface.fallback&&iface.fallback.payable;assertArgument(payable||noValue,"cannot send value to non-payable fallback","overrides.value",tx.value);assertArgument(iface.fallback||noData,"cannot send data to receive-only contract","overrides.data",tx.data);return tx};const staticCall=async function(overrides){const runner=getRunner(contract.runner,"call");assert$1(canCall(runner),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const tx=await populateTransaction(overrides);try{return await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}};const send=async function(overrides){const runner=contract.runner;assert$1(canSend(runner),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const tx=await runner.sendTransaction(await populateTransaction(overrides));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(overrides){const runner=getRunner(contract.runner,"estimateGas");assert$1(canEstimate(runner),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"});return await runner.estimateGas(await populateTransaction(overrides))};const method=async overrides=>{return await send(overrides)};defineProperties(method,{_contract:contract,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall});return method}function buildWrappedMethod(contract,key){const getFragment=function(...args){const fragment=contract.interface.getFunction(key,args);assert$1(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key,args:args}});return fragment};const populateTransaction=async function(...args){const fragment=getFragment(...args);let overrides;if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop());const resolvedArgs=await resolveArgs(contract.runner,fragment.inputs,args);return Object.assign({},overrides,await resolveProperties({to:contract.getAddress(),data:contract.interface.encodeFunctionData(fragment,resolvedArgs)}))}if(fragment.inputs.length!==args.length){throw new Error("internal error: fragment inputs doesn't match arguments; should not happen")}const resolvedArgs=await resolveArgs(contract.runner,fragment.inputs,args);return await resolveProperties({to:contract.getAddress(),from:args.pop()?.from,data:contract.interface.encodeFunctionData(fragment,resolvedArgs)})};const staticCall=async function(...args){const result=await staticCallResult(...args);if(result.length===1){return result[0]}return result};const send=async function(...args){const runner=contract.runner;assert$1(canSend(runner),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const pop=await populateTransaction(...args);if(!pop.from&&"address"in runner&&typeof runner.address==="string"){pop.from=await resolveAddress(runner.address)}const tx=await runner.sendTransaction(await pop);const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(...args){const runner=getRunner(contract.runner,"estimateGas");assert$1(canEstimate(runner),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"});return await runner.estimateGas(await populateTransaction(...args))};const staticCallResult=async function(...args){const runner=getRunner(contract.runner,"call");assert$1(canCall(runner),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const tx=await populateTransaction(...args);if(!tx.from&&"address"in runner&&typeof runner.address==="string"){tx.from=await resolveAddress(runner.address)}let result="0x";try{result=await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}const fragment=getFragment(...args);return contract.interface.decodeFunctionResult(fragment,result)};const method=async(...args)=>{const fragment=getFragment(...args);if(fragment.constant){return await staticCall(...args)}return await send(...args)};defineProperties(method,{name:contract.interface.getFunctionName(key),_contract:contract,_key:key,getFragment:getFragment,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall,staticCallResult:staticCallResult});Object.defineProperty(method,"fragment",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getFunction(key);assert$1(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key}});return fragment}});return method}function buildWrappedEvent(contract,key){const getFragment=function(...args){const fragment=contract.interface.getEvent(key,args);assert$1(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key,args:args}});return fragment};const method=function(...args){return new PreparedTopicFilter(contract,getFragment(...args),args)};defineProperties(method,{name:contract.interface.getEventName(key),_contract:contract,_key:key,getFragment:getFragment});Object.defineProperty(method,"fragment",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getEvent(key);assert$1(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key}});return fragment}});return method}const internal=Symbol.for("_quaisInternal_contract");const internalValues=new WeakMap;function setInternal(contract,values){internalValues.set(contract[internal],values)}function getInternal(contract){return internalValues.get(contract[internal])}function isDeferred(value){return value&&typeof value==="object"&&"getTopicFilter"in value&&typeof value.getTopicFilter==="function"&&value.fragment}async function getSubInfo(contract,event){let topics;let fragment=null;if(Array.isArray(event)){const topicHashify=function(name){if(isHexString(name,32)){return name}const fragment=contract.interface.getEvent(name);assertArgument(fragment,"unknown fragment","name",name);return fragment.topicHash};topics=event.map(e=>{if(e==null){return null}if(Array.isArray(e)){return e.map(topicHashify)}return topicHashify(e)})}else if(event==="*"){topics=[null]}else if(typeof event==="string"){if(isHexString(event,32)){topics=[event]}else{fragment=contract.interface.getEvent(event);assertArgument(fragment,"unknown fragment","event",event);topics=[fragment.topicHash]}}else if(isDeferred(event)){topics=await event.getTopicFilter()}else if(event&&"fragment"in event){fragment=event.fragment;topics=[fragment.topicHash]}else{assertArgument(false,"unknown event name","event",event)}topics=topics.map(t=>{if(t==null){return null}if(Array.isArray(t)){const items=Array.from(new Set(t.map(t=>t.toLowerCase())).values());if(items.length===1){return items[0]}items.sort();return items}return t.toLowerCase()});const tag=topics.map(t=>{if(t==null){return"null"}if(Array.isArray(t)){return t.join("|")}return t}).join("&");return{fragment:fragment,tag:tag,topics:topics}}async function hasSub(contract,event){const{subs}=getInternal(contract);return subs.get((await getSubInfo(contract,event)).tag)||null}async function getSub(contract,operation,event){const provider=getProvider(contract.runner);assert$1(provider,"contract runner does not support subscribing","UNSUPPORTED_OPERATION",{operation:operation});const{fragment,tag,topics}=await getSubInfo(contract,event);const{addr,subs}=getInternal(contract);let sub=subs.get(tag);if(!sub){const address=addr?addr:contract;const filter={address:address,topics:topics};const listener=log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=contract.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){const _foundFragment=foundFragment;const args=fragment?contract.interface.decodeEventLog(fragment,log.data,log.topics):[];emit(contract,event,args,listener=>{return new ContractEventPayload(contract,listener,event,_foundFragment,log)})}else{emit(contract,event,[],listener=>{return new ContractUnknownEventPayload(contract,listener,event,log)})}};const zone=getZoneForAddress(await resolveAddress(address));let starting=[];const start=()=>{if(starting.length){return}starting.push(provider.on(filter,listener,zone))};const stop=async()=>{if(starting.length==0){return}const started=starting;starting=[];await Promise.all(started);provider.off(filter,listener,zone)};sub={tag:tag,listeners:[],start:start,stop:stop};subs.set(tag,sub)}return sub}let lastEmit=Promise.resolve();async function _emit(contract,event,args,payloadFunc){await lastEmit;const sub=await hasSub(contract,event);if(!sub){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const passArgs=Array.from(args);if(payloadFunc){passArgs.push(payloadFunc(once?null:listener))}try{listener.call(contract,...passArgs)}catch(error){}return!once});if(sub.listeners.length===0){sub.stop();getInternal(contract).subs.delete(sub.tag)}return count>0}async function emit(contract,event,args,payloadFunc){try{await lastEmit}catch(error){}const resultPromise=_emit(contract,event,args,payloadFunc);lastEmit=resultPromise;return await resultPromise}const passProperties=["then"];class BaseContract{target;interface;runner;filters;[internal];fallback;constructor(target,abi,runner,_deployTx){assertArgument(typeof target==="string"||isAddressable(target),"invalid value for Contract target","target",target);if(runner==null){runner=null}const iface=Interface.from(abi);defineProperties(this,{target:target,runner:runner,interface:iface});Object.defineProperty(this,internal,{value:{}});let addrPromise;let addr=null;let deployTx=null;if(_deployTx){const provider=getProvider(runner);deployTx=new ContractTransactionResponse(this.interface,provider,_deployTx)}const subs=new Map;if(typeof target==="string"){addr=target;addrPromise=Promise.resolve(target)}else{addrPromise=target.getAddress().then(addr=>{if(addr==null){throw new Error("TODO")}getInternal(this).addr=addr;return addr})}setInternal(this,{addrPromise:addrPromise,addr:addr,deployTx:deployTx,subs:subs});const filters=new Proxy({},{get:(target,prop,receiver)=>{if(typeof prop==="symbol"||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return this.getEvent(prop)}catch(error){if(!isError(error,"INVALID_ARGUMENT")||error.argument!=="key"){throw error}}return undefined},has:(target,prop)=>{if(passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return Reflect.has(target,prop)||this.interface.hasEvent(String(prop))}});defineProperties(this,{filters:filters});defineProperties(this,{fallback:iface.receive||iface.fallback?buildWrappedFallback(this):null});return new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop==="symbol"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return target.getFunction(prop)}catch(error){if(!isError(error,"INVALID_ARGUMENT")||error.argument!=="key"){throw error}}return undefined},has:(target,prop)=>{if(typeof prop==="symbol"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return target.interface.hasFunction(prop)}})}connect(runner){return new BaseContract(this.target,this.interface,runner)}attach(target){return new BaseContract(target,this.interface,this.runner)}async getAddress(){return await getInternal(this).addrPromise}async getDeployedCode(){const provider=getProvider(this.runner);assert$1(provider,"runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"getDeployedCode"});const code=await provider.getCode(await this.getAddress());if(code==="0x"){return null}return code}async waitForDeployment(){const deployTx=this.deploymentTransaction();if(deployTx){await deployTx.wait();return this}const code=await this.getDeployedCode();if(code!=null){return this}const provider=getProvider(this.runner);assert$1(provider!=null,"contract runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"waitForDeployment"});return new Promise((resolve,reject)=>{const checkCode=async()=>{try{const code=await this.getDeployedCode();if(code!=null){return resolve(this)}provider.once("block",checkCode)}catch(error){reject(error)}};checkCode()})}deploymentTransaction(){return getInternal(this).deployTx}getFunction(key){if(typeof key!=="string"){key=key.format()}const func=buildWrappedMethod(this,key);return func}getEvent(key){if(typeof key!=="string"){key=key.format()}return buildWrappedEvent(this,key)}async queryTransaction(hash){throw new Error("@TODO")}async queryFilter(event,fromBlock,toBlock){if(fromBlock==null){fromBlock=0}if(toBlock==null){toBlock="latest"}const{addr,addrPromise}=getInternal(this);const address=addr?addr:await addrPromise;const{fragment,topics}=await getSubInfo(this,event);const zone=getZoneForAddress(address);const filter={address:address,topics:topics,fromBlock:fromBlock,toBlock:toBlock,nodeLocation:getNodeLocationFromZone(zone)};const provider=getProvider(this.runner);assert$1(provider,"contract runner does not have a provider","UNSUPPORTED_OPERATION",{operation:"queryFilter"});return(await provider.getLogs(filter)).map(log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=this.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){try{return new EventLog(log,this.interface,foundFragment)}catch(error){return new UndecodedEventLog(log,error)}}return new Log(log,provider)})}async on(event,listener){const sub=await getSub(this,"on",event);sub.listeners.push({listener:listener,once:false});sub.start();return this}async once(event,listener){const sub=await getSub(this,"once",event);sub.listeners.push({listener:listener,once:true});sub.start();return this}async emit(event,...args){return await emit(this,event,args,null)}async listenerCount(event){if(event){const sub=await hasSub(this,event);if(!sub){return 0}return sub.listeners.length}const{subs}=getInternal(this);let total=0;for(const{listeners}of subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}const{subs}=getInternal(this);let result=[];for(const{listeners}of subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await hasSub(this,event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(listener==null||sub.listeners.length===0){sub.stop();getInternal(this).subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return this}sub.stop();getInternal(this).subs.delete(sub.tag)}else{const{subs}=getInternal(this);for(const{tag,stop}of subs.values()){stop();subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return await this.off(event,listener)}static buildClass(abi){class CustomContract extends BaseContract{constructor(address,runner=null){super(address,abi,runner)}}return CustomContract}static from(target,abi,runner){if(runner==null){runner=null}const contract=new this(target,abi,runner);return contract}}function _ContractBase(){return BaseContract}class Contract extends _ContractBase(){}function checkProvider(signer,operation){if(signer.provider){return signer.provider}assert$1(false,"missing provider","UNSUPPORTED_OPERATION",{operation:operation})}async function populate(signer,tx){const pop=copyRequest(tx);if(pop.to!=null){pop.to=resolveAddress(pop.to);validateAddress(pop.to)}if(pop.from!=null){const from=pop.from;pop.from=await Promise.all([signer.getAddress(),resolveAddress(from)]).then(([address,from])=>{assertArgument(address.toLowerCase()===from.toLowerCase(),"transaction from mismatch","tx.from",from);return address})}else{pop.from=await signer.getAddress()}validateAddress(pop.from);return await resolveProperties(pop)}class AbstractSigner{provider;constructor(provider){defineProperties(this,{provider:provider||null})}_getAddress(address){return resolveAddress(address)}async zoneFromAddress(_address){const address=this._getAddress(_address);return toZone((await address).slice(0,4))}async getNonce(blockTag){return checkProvider(this,"getTransactionCount").getTransactionCount(await this.getAddress(),blockTag)}async populateCall(tx){const pop=await populate(this,tx);return pop}async populateQuaiTransaction(tx){const provider=checkProvider(this,"populateTransaction");const zone=await this.zoneFromAddress(tx.from);const pop=await populate(this,tx);if(pop.type==null){pop.type=getTxType(pop.from??null,pop.to??null)}if(pop.nonce==null||pop.nonce===0){pop.nonce=await this.getNonce("pending")}const network=await this.provider.getNetwork();if(pop.chainId!=null&&pop.chainId!==0n){const chainId=getBigInt(pop.chainId);assertArgument(chainId===network.chainId,"transaction chainId mismatch","tx.chainId",zone)}else{pop.chainId=network.chainId}const baseTx={chainId:pop.chainId,type:pop.type,from:pop.from,nonce:pop.nonce};if(pop.to)baseTx.to=pop.to;if(pop.data)baseTx.data=pop.data;if(pop.value)baseTx.value=pop.value;if(pop.gasLimit==null||pop.gasLimit===0n){if(pop.type==0){pop.gasLimit=await this.estimateGas(baseTx)}else{baseTx.to="0x0000000000000000000000000000000000000000";pop.gasLimit=getBigInt(2*Number(await this.estimateGas(baseTx)));baseTx.to=pop.to}}if(pop.gasPrice==null||pop.minerTip==null){const feeData=await provider.getFeeData(zone,true);if(pop.gasPrice==null){pop.gasPrice=feeData.gasPrice}if(pop.minerTip==null){pop.minerTip=feeData.minerTip||10n}}if(pop.data){if(tx.accessList){pop.accessList=tx.accessList}else{pop.accessList=await this.createAccessList(baseTx)}}return await resolveProperties(pop)}async estimateGas(tx){return checkProvider(this,"estimateGas").estimateGas(await this.populateCall(tx))}async createAccessList(tx){return checkProvider(this,"createAccessList").createAccessList(await this.populateCall(tx))}async call(tx){return checkProvider(this,"call").call(await this.populateCall(tx))}async sendTransaction(tx){const provider=checkProvider(this,"sendTransaction");const zone=await this.zoneFromAddress(addressFromTransactionRequest(tx));const pop=await this.populateQuaiTransaction(tx);const txObj=QuaiTransaction.from(pop);const sender=await this.getAddress();const signedTx=await this.signTransaction(txObj);return await provider.broadcastTransaction(zone,signedTx,sender)}}class VoidSigner extends AbstractSigner{address;constructor(address,provider){super(provider);defineProperties(this,{address:address})}async getAddress(){return this.address}connect(provider){return new VoidSigner(this.address,provider)}#throwUnsupported(suffix,operation){assert$1(false,`VoidSigner cannot sign ${suffix}`,"UNSUPPORTED_OPERATION",{operation:operation})}async signTransaction(tx){this.#throwUnsupported("transactions","signTransaction")}async signMessage(message){this.#throwUnsupported("messages","signMessage")}async signTypedData(domain,types,value){this.#throwUnsupported("typed-data","signTypedData")}}class BaseWallet extends AbstractSigner{#address;#signingKey;constructor(privateKey,provider){super(provider);assertArgument(privateKey&&typeof privateKey.sign==="function","invalid private key","privateKey","[ REDACTED ]");this.#signingKey=privateKey;this.#address=computeAddress(this.signingKey.publicKey)}get address(){return this.#address}get signingKey(){return this.#signingKey}get privateKey(){return this.signingKey.privateKey}async getAddress(_zone){return this.#address}connect(provider){return new BaseWallet(this.#signingKey,provider)}async signTransaction(tx){const{to,from}=await resolveProperties({to:tx.to?resolveAddress(tx.to):undefined,from:tx.from?resolveAddress(tx.from):undefined});if(to!==undefined){validateAddress(to);tx.to=to}if(from!==undefined){assertArgument(getAddress(from)===this.#address,"transaction from address mismatch","tx.from",from)}else{tx.from=this.#address}const btx=QuaiTransaction.from(tx);const digest=keccak256(btx.unsignedSerialized);btx.signature=this.signingKey.sign(digest);return btx.serialized}async signMessage(message){return this.signMessageSync(message)}signMessageSync(message){return this.signingKey.sign(hashMessage(message)).serialized}async signTypedData(domain,types,value){return this.signingKey.sign(TypedDataEncoder.hash(domain,types,value)).serialized}}const subsChrs=" !#$%&'()*+,-./<=>?@[]^_`{|}~";const Word=/^[a-z]*$/i;function unfold(words,sep){let initial=97;return words.reduce((accum,word)=>{if(word===sep){initial++}else if(word.match(Word)){accum.push(String.fromCharCode(initial)+word)}else{initial=97;accum.push(word)}return accum},[])}function decode(data,subs){for(let i=subsChrs.length-1;i>=0;i--){data=data.split(subsChrs[i]).join(subs.substring(2*i,2*i+2))}const clumps=[];const leftover=data.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(all,item,semi,word)=>{if(semi){for(let i=parseInt(semi);i>=0;i--){clumps.push(";")}}else{clumps.push(item.toLowerCase())}return""});if(leftover){throw new Error(`leftovers: ${JSON.stringify(leftover)}`)}return unfold(unfold(clumps,";"),":")}function decodeOwl(data){assertArgument(data[0]==="0","unsupported auwl data","data",data);return decode(data.substring(1+2*subsChrs.length),data.substring(1,1+2*subsChrs.length))}class Wordlist{locale;constructor(locale){defineProperties(this,{locale:locale})}split(phrase){return phrase.toLowerCase().split(/\s+/g)}join(words){return words.join(" ")}}class WordlistOwl extends Wordlist{#data;#checksum;constructor(locale,data,checksum){super(locale);this.#data=data;this.#checksum=checksum;this.#words=null}get _data(){return this.#data}_decodeWords(){return decodeOwl(this.#data)}#words;#loadWords(){if(this.#words==null){const words=this._decodeWords();const checksum=id(words.join("\n")+"\n");if(checksum!==this.#checksum){throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`)}this.#words=words}return this.#words}getWord(index){const words=this.#loadWords();assertArgument(index>=0&&index<words.length,`invalid word index: ${index}`,"index",index);return words[index]}getWordIndex(word){return this.#loadWords().indexOf(word)}}const words$1="0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";const checksum$2="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";let wordlist$1=null;class LangEn extends WordlistOwl{constructor(){super("en",words$1,checksum$2)}static wordlist(){if(wordlist$1==null){wordlist$1=new LangEn}return wordlist$1}}function getUpperMask(bits){return(1<<bits)-1<<8-bits&255}function getLowerMask(bits){return(1<<bits)-1&255}function mnemonicToEntropy(mnemonic,wordlist){assertNormalize("NFKD");if(wordlist==null){wordlist=LangEn.wordlist()}const words=wordlist.split(mnemonic);assertArgument(words.length%3===0&&words.length>=12&&words.length<=24,"invalid mnemonic length","mnemonic","[ REDACTED ]");const entropy=new Uint8Array(Math.ceil(11*words.length/8));let offset=0;for(let i=0;i<words.length;i++){const index=wordlist.getWordIndex(words[i].normalize("NFKD"));assertArgument(index>=0,`invalid mnemonic word at index ${i}`,"mnemonic","[ REDACTED ]");for(let bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8}offset++}}const entropyBits=32*words.length/3;const checksumBits=words.length/3;const checksumMask=getUpperMask(checksumBits);const checksum=getBytes(sha256(entropy.slice(0,entropyBits/8)))[0]&checksumMask;assertArgument(checksum===(entropy[entropy.length-1]&checksumMask),"invalid mnemonic checksum","mnemonic","[ REDACTED ]");return hexlify(entropy.slice(0,entropyBits/8))}function entropyToMnemonic(entropy,wordlist){assertArgument(entropy.length%4===0&&entropy.length>=16&&entropy.length<=32,"invalid entropy size","entropy","[ REDACTED ]");if(wordlist==null){wordlist=LangEn.wordlist()}const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++){if(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;indices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3}}const checksumBits=entropy.length/4;const checksum=parseInt(sha256(entropy).substring(2,4),16)&getUpperMask(checksumBits);indices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(index=>wordlist.getWord(index)))}const _guard$2={};class Mnemonic{phrase;password;wordlist;entropy;constructor(guard,entropy,phrase,password,wordlist){if(password==null){password=""}if(wordlist==null){wordlist=LangEn.wordlist()}assertPrivate(guard,_guard$2,"Mnemonic");defineProperties(this,{phrase:phrase,password:password,wordlist:wordlist,entropy:entropy})}computeSeed(){const salt=toUtf8Bytes("mnemonic"+this.password,"NFKD");return pbkdf2(toUtf8Bytes(this.phrase,"NFKD"),salt,2048,64,"sha512")}static fromPhrase(phrase,password,wordlist){if(wordlist==null){wordlist=LangEn.wordlist()}if(password==null){password=""}const entropy=mnemonicToEntropy(phrase,wordlist);phrase=entropyToMnemonic(getBytes(entropy),wordlist);return new Mnemonic(_guard$2,entropy,phrase,password,wordlist)}static fromEntropy(_entropy,password,wordlist){if(wordlist==null){wordlist=LangEn.wordlist()}if(password==null){password=""}const entropy=getBytes(_entropy,"entropy");const phrase=entropyToMnemonic(entropy,wordlist);return new Mnemonic(_guard$2,hexlify(entropy),phrase,password,wordlist)}static entropyToPhrase(_entropy,wordlist){const entropy=getBytes(_entropy,"entropy");return entropyToMnemonic(entropy,wordlist)}static phraseToEntropy(phrase,wordlist){return mnemonicToEntropy(phrase,wordlist)}static isValidMnemonic(phrase,wordlist){try{mnemonicToEntropy(phrase,wordlist);return true}catch(error){}return false}}var __classPrivateFieldGet$1=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var __classPrivateFieldSet$1=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var _AES_key,_AES_Kd,_AES_Ke;const numberOfRounds={16:10,24:12,32:14};const rcon=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145];const S=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];const Si=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];const T1=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986];const T2=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766];const T3=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126];const T4=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436];const T5=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890];const T6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935];const T7=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600];const T8=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480];const U1=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795];const U2=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855];const U3=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150];const U4=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function convertToInt32(bytes){const result=[];for(let i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3])}return result}class AES{get key(){return __classPrivateFieldGet$1(this,_AES_key,"f").slice()}constructor(key){_AES_key.set(this,void 0);_AES_Kd.set(this,void 0);_AES_Ke.set(this,void 0);if(!(this instanceof AES)){throw Error("AES must be instanitated with `new`")}__classPrivateFieldSet$1(this,_AES_key,new Uint8Array(key),"f");const rounds=numberOfRounds[this.key.length];if(rounds==null){throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)")}__classPrivateFieldSet$1(this,_AES_Ke,[],"f");__classPrivateFieldSet$1(this,_AES_Kd,[],"f");for(let i=0;i<=rounds;i++){__classPrivateFieldGet$1(this,_AES_Ke,"f").push([0,0,0,0]);__classPrivateFieldGet$1(this,_AES_Kd,"f").push([0,0,0,0])}const roundKeyCount=(rounds+1)*4;const KC=this.key.length/4;const tk=convertToInt32(this.key);let index;for(let i=0;i<KC;i++){index=i>>2;__classPrivateFieldGet$1(this,_AES_Ke,"f")[index][i%4]=tk[i];__classPrivateFieldGet$1(this,_AES_Kd,"f")[rounds-index][i%4]=tk[i]}let rconpointer=0;let t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&255]<<24^S[tt>>8&255]<<16^S[tt&255]<<8^S[tt>>24&255]^rcon[rconpointer]<<24;rconpointer+=1;if(KC!=8){for(let i=1;i<KC;i++){tk[i]^=tk[i-1]}}else{for(let i=1;i<KC/2;i++){tk[i]^=tk[i-1]}tt=tk[KC/2-1];tk[KC/2]^=S[tt&255]^S[tt>>8&255]<<8^S[tt>>16&255]<<16^S[tt>>24&255]<<24;for(let i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1]}}let i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;__classPrivateFieldGet$1(this,_AES_Ke,"f")[r][c]=tk[i];__classPrivateFieldGet$1(this,_AES_Kd,"f")[rounds-r][c]=tk[i++];t++}}for(let r=1;r<rounds;r++){for(let c=0;c<4;c++){tt=__classPrivateFieldGet$1(this,_AES_Kd,"f")[r][c];__classPrivateFieldGet$1(this,_AES_Kd,"f")[r][c]=U1[tt>>24&255]^U2[tt>>16&255]^U3[tt>>8&255]^U4[tt&255]}}}encrypt(plaintext){if(plaintext.length!=16){throw new TypeError("invalid plaintext size (must be 16 bytes)")}const rounds=__classPrivateFieldGet$1(this,_AES_Ke,"f").length-1;const a=[0,0,0,0];let t=convertToInt32(plaintext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$1(this,_AES_Ke,"f")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T1[t[i]>>24&255]^T2[t[(i+1)%4]>>16&255]^T3[t[(i+2)%4]>>8&255]^T4[t[(i+3)%4]&255]^__classPrivateFieldGet$1(this,_AES_Ke,"f")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$1(this,_AES_Ke,"f")[rounds][i];result[4*i]=(S[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(S[t[(i+1)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(S[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(S[t[(i+3)%4]&255]^tt)&255}return result}decrypt(ciphertext){if(ciphertext.length!=16){throw new TypeError("invalid ciphertext size (must be 16 bytes)")}const rounds=__classPrivateFieldGet$1(this,_AES_Kd,"f").length-1;const a=[0,0,0,0];let t=convertToInt32(ciphertext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$1(this,_AES_Kd,"f")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T5[t[i]>>24&255]^T6[t[(i+3)%4]>>16&255]^T7[t[(i+2)%4]>>8&255]^T8[t[(i+1)%4]&255]^__classPrivateFieldGet$1(this,_AES_Kd,"f")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$1(this,_AES_Kd,"f")[rounds][i];result[4*i]=(Si[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(Si[t[(i+3)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(Si[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(Si[t[(i+1)%4]&255]^tt)&255}return result}}_AES_key=new WeakMap,_AES_Kd=new WeakMap,_AES_Ke=new WeakMap;class ModeOfOperation{constructor(name,key,cls){if(cls&&!(this instanceof cls)){throw new Error(`${name} must be instantiated with "new"`)}Object.defineProperties(this,{aes:{enumerable:true,value:new AES(key)},name:{enumerable:true,value:name}})}}var __classPrivateFieldSet=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var _CTR_remaining,_CTR_remainingIndex,_CTR_counter;class CTR extends ModeOfOperation{constructor(key,initialValue){super("CTR",key,CTR);_CTR_remaining.set(this,void 0);_CTR_remainingIndex.set(this,void 0);_CTR_counter.set(this,void 0);__classPrivateFieldSet(this,_CTR_counter,new Uint8Array(16),"f");__classPrivateFieldGet(this,_CTR_counter,"f").fill(0);__classPrivateFieldSet(this,_CTR_remaining,__classPrivateFieldGet(this,_CTR_counter,"f"),"f");__classPrivateFieldSet(this,_CTR_remainingIndex,16,"f");if(initialValue==null){initialValue=1}if(typeof initialValue==="number"){this.setCounterValue(initialValue)}else{this.setCounterBytes(initialValue)}}get counter(){return new Uint8Array(__classPrivateFieldGet(this,_CTR_counter,"f"))}setCounterValue(value){if(!Number.isInteger(value)||value<0||value>Number.MAX_SAFE_INTEGER){throw new TypeError("invalid counter initial integer value")}for(let index=15;index>=0;--index){__classPrivateFieldGet(this,_CTR_counter,"f")[index]=value%256;value=Math.floor(value/256)}}setCounterBytes(value){if(value.length!==16){throw new TypeError("invalid counter initial Uint8Array value length")}__classPrivateFieldGet(this,_CTR_counter,"f").set(value)}increment(){for(let i=15;i>=0;i--){if(__classPrivateFieldGet(this,_CTR_counter,"f")[i]===255){__classPrivateFieldGet(this,_CTR_counter,"f")[i]=0}else{__classPrivateFieldGet(this,_CTR_counter,"f")[i]++;break}}}encrypt(plaintext){var _a,_b;const crypttext=new Uint8Array(plaintext);for(let i=0;i<crypttext.length;i++){if(__classPrivateFieldGet(this,_CTR_remainingIndex,"f")===16){__classPrivateFieldSet(this,_CTR_remaining,this.aes.encrypt(__classPrivateFieldGet(this,_CTR_counter,"f")),"f");__classPrivateFieldSet(this,_CTR_remainingIndex,0,"f");this.increment()}crypttext[i]^=__classPrivateFieldGet(this,_CTR_remaining,"f")[__classPrivateFieldSet(this,_CTR_remainingIndex,(_b=__classPrivateFieldGet(this,_CTR_remainingIndex,"f"),_a=_b++,_b),"f"),_a]}return crypttext}decrypt(ciphertext){return this.encrypt(ciphertext)}}_CTR_remaining=new WeakMap,_CTR_remainingIndex=new WeakMap,_CTR_counter=new WeakMap;function looseArrayify(hexString){if(typeof hexString==="string"&&!hexString.startsWith("0x")){hexString="0x"+hexString}return getBytesCopy(hexString)}function getPassword(password){if(typeof password==="string"){return toUtf8Bytes(password,"NFKC")}return getBytesCopy(password)}function spelunk(object,_path){const match=_path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);assertArgument(match!=null,"invalid path","path",_path);const path=match[1];const type=match[3];const reqd=match[4]==="!";let cur=object;for(const comp of path.toLowerCase().split(".")){if(Array.isArray(cur)){if(!comp.match(/^[0-9]+$/)){break}cur=cur[parseInt(comp)]}else if(typeof cur==="object"){let found=null;for(const key in cur){if(key.toLowerCase()===comp){found=cur[key];break}}cur=found}else{cur=null}if(cur==null){break}}assertArgument(!reqd||cur!=null,"missing required value","path",path);if(type&&cur!=null){if(type==="int"){if(typeof cur==="string"&&cur.match(/^-?[0-9]+$/)){return parseInt(cur)}else if(Number.isSafeInteger(cur)){return cur}}if(type==="number"){if(typeof cur==="string"&&cur.match(/^-?[0-9.]*$/)){return parseFloat(cur)}}if(type==="data"){if(typeof cur==="string"){return looseArrayify(cur)}}if(type==="array"&&Array.isArray(cur)){return cur}if(type===typeof cur){return cur}assertArgument(false,`wrong type found for ${type} `,"path",path)}return cur}BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");function zpad$1(value,length){const isHex=typeof value==="string"&&value.startsWith("0x");if(isHex){let hexValue=value.substring(2);while(hexValue.length<length*2){hexValue="0"+hexValue}return"0x"+hexValue}let result=String(value);while(result.length<length){result="0"+result}return result}const defaultPath="m/44'/994'/0'/0/0";function isKeystoreJson(json){try{const data=JSON.parse(json);const version=data.version!=null?parseInt(data.version):0;if(version===3){return true}}catch(error){}return false}function decrypt(data,key,ciphertext){const cipher=spelunk(data,"crypto.cipher:string");if(cipher==="aes-128-ctr"){const iv=spelunk(data,"crypto.cipherparams.iv:data!");const aesCtr=new CTR(key,iv);return hexlify(aesCtr.decrypt(ciphertext))}assert$1(false,"unsupported cipher","UNSUPPORTED_OPERATION",{operation:"decrypt"})}function getAccount(data,_key){const key=getBytes(_key);const ciphertext=spelunk(data,"crypto.ciphertext:data!");const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);assertArgument(computedMAC===spelunk(data,"crypto.mac:string!").toLowerCase(),"incorrect password","password","[ REDACTED ]");const privateKey=decrypt(data,key.slice(0,16),ciphertext);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(!check.startsWith("0x")){check="0x"+check}assertArgument(getAddress(check)===address,"keystore address/privateKey mismatch","address",data.address)}const account={address:address,privateKey:privateKey};const version=spelunk(data,"x-quais.version:string");if(version==="0.1"){const mnemonicKey=key.slice(32,64);const mnemonicCiphertext=spelunk(data,"x-quais.mnemonicCiphertext:data!");const mnemonicIv=spelunk(data,"x-quais.mnemonicCounter:data!");const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);account.mnemonic={path:spelunk(data,"x-quais.path:string")||defaultPath,locale:spelunk(data,"x-quais.locale:string")||"en",entropy:hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))}}return account}function getDecryptKdfParams(data){const kdf=spelunk(data,"crypto.kdf:string");if(kdf&&typeof kdf==="string"){if(kdf.toLowerCase()==="scrypt"){const salt=spelunk(data,"crypto.kdfparams.salt:data!");const N=spelunk(data,"crypto.kdfparams.n:int!");const r=spelunk(data,"crypto.kdfparams.r:int!");const p=spelunk(data,"crypto.kdfparams.p:int!");assertArgument(N>0&&(N&N-1)===0,"invalid kdf.N","kdf.N",N);assertArgument(r>0&&p>0,"invalid kdf","kdf",kdf);const dkLen=spelunk(data,"crypto.kdfparams.dklen:int!");assertArgument(dkLen===32,"invalid kdf.dklen","kdf.dflen",dkLen);return{name:"scrypt",salt:salt,N:N,r:r,p:p,dkLen:64}}else if(kdf.toLowerCase()==="pbkdf2"){const salt=spelunk(data,"crypto.kdfparams.salt:data!");const prf=spelunk(data,"crypto.kdfparams.prf:string!");const algorithm=prf.split("-").pop();assertArgument(algorithm==="sha256"||algorithm==="sha512","invalid kdf.pdf","kdf.pdf",prf);const count=spelunk(data,"crypto.kdfparams.c:int!");const dkLen=spelunk(data,"crypto.kdfparams.dklen:int!");assertArgument(dkLen===32,"invalid kdf.dklen","kdf.dklen",dkLen);return{name:"pbkdf2",salt:salt,count:count,dkLen:dkLen,algorithm:algorithm}}}assertArgument(false,"unsupported key-derivation function","kdf",kdf)}function decryptKeystoreJsonSync(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name==="pbkdf2"){const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);return getAccount(data,key)}assert$1(params.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:params});const{salt,N,r,p,dkLen}=params;const key=scryptSync(password,salt,N,r,p,dkLen);return getAccount(data,key)}function stall$1(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}async function decryptKeystoreJson(json,_password,progress){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name==="pbkdf2"){if(progress){progress(0);await stall$1(0)}const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);if(progress){progress(1);await stall$1(0)}return getAccount(data,key)}assert$1(params.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:params});const{salt,N,r,p,dkLen}=params;const key=await scrypt(password,salt,N,r,p,dkLen,progress);return getAccount(data,key)}function getEncryptKdfParams(options){const salt=options.salt!=null?getBytes(options.salt,"options.salt"):randomBytes(32);let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}assertArgument(typeof N==="number"&&N>0&&Number.isSafeInteger(N)&&(BigInt(N)&BigInt(N-1))===BigInt(0),"invalid scrypt N parameter","options.N",N);assertArgument(typeof r==="number"&&r>0&&Number.isSafeInteger(r),"invalid scrypt r parameter","options.r",r);assertArgument(typeof p==="number"&&p>0&&Number.isSafeInteger(p),"invalid scrypt p parameter","options.p",p);return{name:"scrypt",dkLen:32,salt:salt,N:N,r:r,p:p}}function _encryptKeystore(key,kdf,account,options){const privateKey=getBytes(account.privateKey,"privateKey");const iv=options.iv!=null?getBytes(options.iv,"options.iv"):randomBytes(16);assertArgument(iv.length===16,"invalid options.iv length","options.iv",options.iv);const uuidRandom=options.uuid!=null?getBytes(options.uuid,"options.uuid"):randomBytes(16);assertArgument(uuidRandom.length===16,"invalid options.uuid length","options.uuid",options.iv);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const aesCtr=new CTR(derivedKey,iv);const ciphertext=getBytes(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:"scrypt",kdfparams:{salt:hexlify(kdf.salt).substring(2),n:kdf.N,dklen:32,p:kdf.p,r:kdf.r},mac:mac.substring(2)}};if(account.mnemonic){const client=options.client!=null?options.client:`quais/${version}`;const path=account.mnemonic.path||defaultPath;const locale=account.mnemonic.locale||"en";const mnemonicKey=key.slice(32,64);const entropy=getBytes(account.mnemonic.entropy,"account.mnemonic.entropy");const mnemonicIv=randomBytes(16);const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);const mnemonicCiphertext=getBytes(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+"-"+zpad$1(now.getUTCMonth()+1,2)+"-"+zpad$1(now.getUTCDate(),2)+"T"+zpad$1(now.getUTCHours(),2)+"-"+zpad$1(now.getUTCMinutes(),2)+"-"+zpad$1(now.getUTCSeconds(),2)+".0Z";const gethFilename="UTC--"+timestamp+"--"+data.address;data["x-quais"]={client:client,gethFilename:gethFilename,path:path,locale:locale,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),version:"0.1"}}return JSON.stringify(data)}function encryptKeystoreJsonSync(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=scryptSync(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64);return _encryptKeystore(getBytes(key),kdf,account,options)}async function encryptKeystoreJson(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=await scrypt(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64,options.progressCallback);return _encryptKeystore(getBytes(key),kdf,account,options)}const MasterSecret=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]);const HardenedBit=2147483648;const N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const Nibbles="0123456789abcdef";function zpad(value,length){let result="";while(value){result=Nibbles[value%16]+result;value=Math.trunc(value/16)}while(result.length<length*2){result="0"+result}return"0x"+result}function encodeBase58Check(_value){const value=getBytes(_value);const check=dataSlice(sha256(sha256(value)),0,4);const bytes=concat([value,check]);return encodeBase58(bytes)}const _guard$1={};function ser_I(index,chainCode,publicKey,privateKey){const data=new Uint8Array(37);if(index&HardenedBit){assert$1(privateKey!=null,"cannot derive child of neutered node","UNSUPPORTED_OPERATION",{operation:"deriveChild"});data.set(getBytes(privateKey),1)}else{data.set(getBytes(publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=getBytes(computeHmac("sha512",chainCode,data));return{IL:I.slice(0,32),IR:I.slice(32)}}function derivePath(node,path){const components=path.split("/");assertArgument(components.length>0,"invalid path","path",path);if(components[0]==="m"){assertArgument(node.depth===0,`cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`,"path",path);components.shift()}let result=node;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));assertArgument(index<HardenedBit,"invalid path index",`path[${i}]`,component);result=result.deriveChild(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);assertArgument(index<HardenedBit,"invalid path index",`path[${i}]`,component);result=result.deriveChild(index)}else{assertArgument(false,"invalid path component",`path[${i}]`,component)}}return result}class HDNodeWallet extends BaseWallet{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(guard,signingKey,parentFingerprint,chainCode,path,index,depth,mnemonic,provider){super(signingKey,provider);assertPrivate(guard,_guard$1,"HDNodeWallet");defineProperties(this,{publicKey:signingKey.compressedPublicKey});const fingerprint=dataSlice(ripemd160(sha256(this.publicKey)),0,4);defineProperties(this,{parentFingerprint:parentFingerprint,fingerprint:fingerprint,chainCode:chainCode,path:path,index:index,depth:depth});defineProperties(this,{mnemonic:mnemonic})}connect(provider){return new HDNodeWallet(_guard$1,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,provider)}#account(){const account={address:this.address,privateKey:this.privateKey};const m=this.mnemonic;if(this.path&&m&&m.wordlist.locale==="en"&&m.password===""){account.mnemonic={path:this.path,locale:"en",entropy:m.entropy}}return account}async encrypt(password,progressCallback){return await encryptKeystoreJson(this.#account(),password,{progressCallback:progressCallback})}encryptSync(password){return encryptKeystoreJsonSync(this.#account(),password)}get extendedKey(){assert$1(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"});return encodeBase58Check(concat(["0x0488ADE4",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,concat(["0x00",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new HDNodeVoidWallet(_guard$1,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(_index){const index=getNumber(_index,"index");assertArgument(index<=4294967295,"invalid index","index",index);let path=this.path;if(path){path+="/"+(index&~HardenedBit);if(index&HardenedBit){path+="'"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,this.privateKey);const ki=new SigningKey(toBeHex((toBigInt(IL)+BigInt(this.privateKey))%N,32));return new HDNodeWallet(_guard$1,ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.mnemonic,this.provider)}derivePath(path){return derivePath(this,path)}static#fromSeed(_seed,mnemonic){assertArgument(isBytesLike(_seed),"invalid seed","seed","[REDACTED]");const seed=getBytes(_seed,"seed");assertArgument(seed.length>=16&&seed.length<=64,"invalid seed","seed","[REDACTED]");const I=getBytes(computeHmac("sha512",MasterSecret,seed));const signingKey=new SigningKey(hexlify(I.slice(0,32)));return new HDNodeWallet(_guard$1,signingKey,"0x00000000",hexlify(I.slice(32)),"m",0,0,mnemonic,null)}static fromExtendedKey(extendedKey){const bytes=toBeArray(decodeBase58(extendedKey));assertArgument(bytes.length===82||encodeBase58Check(bytes.slice(0,78))===extendedKey,"invalid extended key","extendedKey","[ REDACTED ]");const depth=bytes[4];const parentFingerprint=hexlify(bytes.slice(5,9));const index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16);const chainCode=hexlify(bytes.slice(13,45));const key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case"0x0488b21e":case"0x043587cf":{const publicKey=hexlify(key);return new HDNodeVoidWallet(_guard$1,computeAddress(publicKey),publicKey,parentFingerprint,chainCode,null,index,depth,null)}case"0x0488ade4":case"0x04358394 ":if(key[0]!==0){break}return new HDNodeWallet(_guard$1,new SigningKey(key.slice(1)),parentFingerprint,chainCode,null,index,depth,null,null)}assertArgument(false,"invalid extended key prefix","extendedKey","[ REDACTED ]")}static createRandom(path,password,wordlist){if(password==null){password=""}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromEntropy(randomBytes(16),password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromMnemonic(mnemonic,path){return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromPhrase(phrase,path,password,wordlist){if(password==null){password=""}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromPhrase(phrase,password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromSeed(seed){return HDNodeWallet.#fromSeed(seed,null)}}class HDNodeVoidWallet extends VoidSigner{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(guard,address,publicKey,parentFingerprint,chainCode,path,index,depth,provider){super(address,provider);assertPrivate(guard,_guard$1,"HDNodeVoidWallet");defineProperties(this,{publicKey:publicKey});const fingerprint=dataSlice(ripemd160(sha256(publicKey)),0,4);defineProperties(this,{publicKey:publicKey,fingerprint:fingerprint,parentFingerprint:parentFingerprint,chainCode:chainCode,path:path,index:index,depth:depth})}connect(provider){return new HDNodeVoidWallet(_guard$1,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,provider)}get extendedKey(){assert$1(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"});return encodeBase58Check(concat(["0x0488B21E",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(_index){const index=getNumber(_index,"index");assertArgument(index<=4294967295,"invalid index","index",index);let path=this.path;if(path){path+="/"+(index&~HardenedBit);if(index&HardenedBit){path+="'"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,null);const Ki=SigningKey.addPoints(IL,this.publicKey,true);const address=computeAddress(Ki);return new HDNodeVoidWallet(_guard$1,address,Ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.provider)}derivePath(path){return derivePath(this,path)}}const HARDENED_OFFSET=2**31;const MAX_ADDRESS_DERIVATION_ATTEMPTS=1e7;const _guard={};class AbstractHDWallet{static _version=1;static _coinType;_addresses=new Map;_root;provider;constructor(guard,root,provider){assertPrivate(guard,_guard,"AbstractHDWallet");this._root=root;this.provider=provider}static parentPath(coinType){return`m/44'/${coinType}'`}coinType(){return this.constructor._coinType}get xPub(){return this._root.extendedKey}isValidAddressForZone(address,zone){const addressZone=getZoneForAddress(address);if(!addressZone){return false}const isCorrectShard=addressZone===zone;const isCorrectLedger=this.coinType()===969?isQiAddress(address):!isQiAddress(address);return isCorrectShard&&isCorrectLedger}_getChangeNode(account,change){const changeIndex=change?1:0;return this._root.deriveChild(account+HARDENED_OFFSET).deriveChild(changeIndex)}_getAddressNode(account,change,addressIndex){return this._getChangeNode(account,change).deriveChild(addressIndex)}deriveNextAddressNode(account,startingIndex,zone,isChange=false){const changeNode=this._getChangeNode(account,isChange);let addrIndex=startingIndex;let addressNode;for(let attempts=0;attempts<MAX_ADDRESS_DERIVATION_ATTEMPTS;attempts++){addressNode=changeNode.deriveChild(addrIndex++);if(this.isValidAddressForZone(addressNode.address,zone)){return addressNode}}throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`)}static createInstance(mnemonic){const coinType=this._coinType;const root=HDNodeWallet.fromMnemonic(mnemonic,this.parentPath(coinType));return new this(_guard,root)}static fromMnemonic(mnemonic){return this.createInstance(mnemonic)}static createRandom(password,wordlist){if(password==null){password=""}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromEntropy(randomBytes(16),password,wordlist);return this.createInstance(mnemonic)}static fromPhrase(phrase,password,wordlist){if(password==null){password=""}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromPhrase(phrase,password,wordlist);return this.createInstance(mnemonic)}connect(provider){this.provider=provider}validateZone(zone){if(!Object.values(Zone).includes(zone)){throw new Error(`Invalid zone: ${zone}`)}}serialize(){return{version:this.constructor._version,phrase:this._root.mnemonic.phrase,coinType:this.coinType()}}static async deserialize(_serialized){throw new Error("deserialize method must be implemented in the subclass")}validateAddressInfo(info){this.validateBaseAddressInfo(info);this.validateAddressDerivation(info);this.validateExtendedProperties(info)}validateBaseAddressInfo(info){if(!/^(0x)?[0-9a-fA-F]{40}$/.test(info.address)){throw new Error(`Invalid NeuteredAddressInfo: address must be a 40-character hexadecimal string prefixed with 0x: ${info.address}`)}if(!/^0x[0-9a-fA-F]{66}$/.test(info.pubKey)){throw new Error(`Invalid NeuteredAddressInfo: pubKey must be a 66-character hexadecimal string prefixed with 0x: ${info.pubKey}`)}if(!Number.isInteger(info.account)||info.account<0){throw new Error(`Invalid NeuteredAddressInfo: account must be a non-negative integer: ${info.account}`)}if(!Number.isInteger(info.index)||info.index<0){throw new Error(`Invalid NeuteredAddressInfo: index must be a non-negative integer: ${info.index}`)}if(!Object.values(Zone).includes(info.zone)){throw new Error(`Invalid NeuteredAddressInfo: zone '${info.zone}' is not a valid Zone`)}}validateExtendedProperties(_info){}static validateSerializedWallet(serialized){if(serialized.version!==this._version){throw new Error(`Invalid version ${serialized.version} for wallet (expected ${this._version})`)}if(serialized.coinType!==this._coinType){throw new Error(`Invalid coinType ${serialized.coinType} for wallet (expected ${this._coinType})`)}}}class QuaiHDWallet extends AbstractHDWallet{static _version=1;static _coinType=994;constructor(guard,root,provider){super(guard,root,provider)}async signTransaction(tx){const from=await resolveAddress(tx.from);const fromNode=this._getHDNodeForAddress(from);const signedTx=await fromNode.signTransaction(tx);return signedTx}async sendTransaction(tx){if(!this.provider){throw new Error("Provider is not set")}const from=await resolveAddress(tx.from);const fromNode=this._getHDNodeForAddress(from);const fromNodeConnected=fromNode.connect(this.provider);return await fromNodeConnected.sendTransaction(tx)}async signMessage(address,message){const addrNode=this._getHDNodeForAddress(address);return await addrNode.signMessage(message)}serialize(){const hdwalletSerialized=super.serialize();return{...hdwalletSerialized,addresses:Array.from(this._addresses.values())}}validateAddressDerivation(info){const addressNode=this._getAddressNode(info.account,false,info.index);if(addressNode.address!==info.address){throw new Error(`Address mismatch: derived ${addressNode.address} but got ${info.address}`)}if(addressNode.publicKey!==info.pubKey){throw new Error(`Public key mismatch: derived ${addressNode.publicKey} but got ${info.pubKey}`)}const zone=getZoneForAddress(addressNode.address);if(!zone||zone!==info.zone){throw new Error(`Zone mismatch: derived ${zone} but got ${info.zone}`)}if(!isQuaiAddress(addressNode.address)){throw new Error(`Address ${addressNode.address} is not a valid Quai address`)}}static async deserialize(serialized){super.validateSerializedWallet(serialized);const mnemonic=Mnemonic.fromPhrase(serialized.phrase);const path=this.parentPath(serialized.coinType);const root=HDNodeWallet.fromMnemonic(mnemonic,path);const wallet=new this(_guard,root);for(const addressInfo of serialized.addresses){wallet.validateAddressInfo(addressInfo);if(!wallet._addresses.has(addressInfo.address)){wallet._addresses.set(addressInfo.address,addressInfo)}}return wallet}async signTypedData(address,domain,types,value){const addrNode=this._getHDNodeForAddress(address);return addrNode.signTypedData(domain,types,value)}addAddress(account,addressIndex){if(account<0||addressIndex<0){throw new Error("Account and address index must be non-negative integers")}return this._addAddress(account,addressIndex)}_addAddress(account,addressIndex){this._addresses.forEach(addressInfo=>{if(addressInfo.index===addressIndex){throw new Error(`Address for index ${addressIndex} already exists`)}});const addressNode=this._getAddressNode(account,false,addressIndex);const zone=getZoneForAddress(addressNode.address);if(!zone){throw new Error(`Failed to derive a valid address zone for the index ${addressIndex}`)}if(!isQuaiAddress(addressNode.address)){throw new Error(`Address ${addressNode.address} is not a valid Quai address`)}return this._createAndStoreNeuteredAddressInfo(addressNode,account,zone)}async getNextAddress(account,zone){return Promise.resolve(this._getNextAddress(account,zone))}getNextAddressSync(account,zone){return this._getNextAddress(account,zone)}_getNextAddress(accountIndex,zone){this.validateZone(zone);const lastIndex=this._findLastUsedIndex(Array.from(this._addresses.values()),accountIndex,zone);const addressNode=this.deriveNextAddressNode(accountIndex,lastIndex+1,zone,false);return this._createAndStoreNeuteredAddressInfo(addressNode,accountIndex,zone)}_createAndStoreNeuteredAddressInfo(addressNode,account,zone){const neuteredAddressInfo={pubKey:addressNode.publicKey,address:addressNode.address,account:account,index:addressNode.index,zone:zone};this._addresses.set(neuteredAddressInfo.address,neuteredAddressInfo);return neuteredAddressInfo}getAddressInfo(address){const addressInfo=this._addresses.get(address);if(!addressInfo){return null}return addressInfo}getPrivateKey(address){const hdNode=this._getHDNodeForAddress(address);return hdNode.privateKey}_getHDNodeForAddress(addr){const addressInfo=this._addresses.get(addr);if(!addressInfo){throw new Error(`Address ${addr} is not known to this wallet`)}return this._getAddressNode(addressInfo.account,false,addressInfo.index)}getAddressesForZone(zone){this.validateZone(zone);const addresses=this._addresses.values();return Array.from(addresses).filter(addressInfo=>addressInfo.zone===zone)}getAddressesForAccount(account){const addresses=this._addresses.values();return Array.from(addresses).filter(addressInfo=>addressInfo.account===account)}_findLastUsedIndex(addresses,account,zone){const filteredAddresses=addresses?.filter(addressInfo=>addressInfo.account===account&&addressInfo.zone===zone);return filteredAddresses?.reduce((maxIndex,addressInfo)=>Math.max(maxIndex,addressInfo.index),-1)||-1}}class Wallet extends BaseWallet{constructor(key,provider){if(typeof key==="string"&&!key.startsWith("0x")){key="0x"+key}const signingKey=typeof key==="string"?new SigningKey(key):key;super(signingKey,provider)}connect(provider){return new Wallet(this.signingKey,provider)}async encrypt(password,progressCallback){const account={address:this.address,privateKey:this.privateKey};return await encryptKeystoreJson(account,password,{progressCallback:progressCallback})}encryptSync(password){const account={address:this.address,privateKey:this.privateKey};return encryptKeystoreJsonSync(account,password)}static#fromAccount(account){assertArgument(account,"invalid JSON wallet","json","[ REDACTED ]");const wallet=new Wallet(account.privateKey);assertArgument(wallet.address===account.address,"address/privateKey mismatch","json","[ REDACTED ]");return wallet}static async fromEncryptedJson(json,password,progress){let account;if(isKeystoreJson(json)){account=await decryptKeystoreJson(json,password,progress);return Wallet.#fromAccount(account)}throw new Error("invalid JSON wallet")}static fromEncryptedJsonSync(json,password){let account=null;if(isKeystoreJson(json)){account=decryptKeystoreJsonSync(json,password)}else{assertArgument(false,"invalid JSON wallet","json","[ REDACTED ]")}return Wallet.#fromAccount(account)}}const TAGS={challenge:"BIP0340/challenge",keyagg_list:"KeyAgg list",keyagg_coef:"KeyAgg coefficient",musig_aux:"MuSig/aux",musig_nonce:"MuSig/nonce",musig_deterministic_nonce:"MuSig/deterministic/nonce",musig_noncecoef:"MuSig/noncecoef"};function compare32b(a,b){if(a.length!==32||b.length!==32)throw new Error("Invalid array");const aD=new DataView(a.buffer,a.byteOffset,a.length);const bD=new DataView(b.buffer,b.byteOffset,b.length);for(let i=0;i<8;i++){const cmp=aD.getUint32(i*4)-bD.getUint32(i*4);if(cmp!==0)return cmp}return 0}function compare33b(a,b){if(a.length!==33||b.length!==33)throw new Error("Invalid array");const cmp=a[0]-b[0];if(cmp!==0)return cmp;return compare32b(a.subarray(1),b.subarray(1))}const makeSessionId=typeof self==="object"&&(self.crypto||self.msCrypto)?()=>(self.crypto||self.msCrypto).getRandomValues(new Uint8Array(32)):()=>require("crypto").randomBytes(32);const _keyAggCache=new WeakMap;const _coefCache=new WeakMap;const _nonceCache=new WeakMap;const _sessionCache=new WeakMap;function MuSigFactory(ecc){const CPOINT_INF=new Uint8Array(33);const SCALAR_0=new Uint8Array(32);const SCALAR_1=new Uint8Array(32);SCALAR_1[31]=1;ecc.scalarNegate(SCALAR_1);function keyAggCoeff(publicKeys,publicKey){let coefCache=_coefCache.get(publicKeys);if(coefCache===undefined){coefCache=new Map;_coefCache.set(publicKeys,coefCache)}let coefficient=coefCache.get(publicKey);if(coefficient)return coefficient;coefficient=SCALAR_1;let secondPublicKey;let publicKeyHash;let keyAggCache=_keyAggCache.get(publicKeys);if(keyAggCache===undefined){const pkIdx2=publicKeys.findIndex(pk=>compare33b(pk,publicKeys[0])!==0);secondPublicKey=publicKeys[pkIdx2];publicKeyHash=ecc.taggedHash(TAGS.keyagg_list,...publicKeys);keyAggCache={publicKeyHash:publicKeyHash,secondPublicKey:secondPublicKey};_keyAggCache.set(publicKeys,keyAggCache)}else{({publicKeyHash,secondPublicKey}=keyAggCache)}if(secondPublicKey===undefined||compare33b(publicKey,secondPublicKey)!==0)coefficient=ecc.taggedHash(TAGS.keyagg_coef,publicKeyHash,publicKey);coefCache.set(publicKey,coefficient);return coefficient}function addTweak(ctx,t){const tweak="tweak"in t?t:{tweak:t};if(!ecc.isScalar(tweak.tweak))throw new TypeError("Expected tweak to be a valid scalar with curve order");let{gacc,tacc}=ctx;let aggPublicKey=ctx.aggPublicKey;if(!ecc.hasEvenY(aggPublicKey)&&tweak.xOnly){gacc=ecc.scalarNegate(gacc);tacc=ecc.scalarNegate(tacc);aggPublicKey=ecc.pointNegate(aggPublicKey)}aggPublicKey=ecc.pointAddTweak(aggPublicKey,tweak.tweak,false);if(aggPublicKey===null)throw new Error("Unexpected point at infinity during tweaking");tacc=ecc.scalarAdd(tweak.tweak,tacc);return{aggPublicKey:aggPublicKey,gacc:gacc,tacc:tacc}}function keyAgg(publicKeys,...tweaks){checkArgs({publicKeys:publicKeys});const multipliedPublicKeys=publicKeys.map(publicKey=>{const coefficient=keyAggCoeff(publicKeys,publicKey);let multipliedPublicKey;if(compare32b(coefficient,SCALAR_1)===0){multipliedPublicKey=publicKey}else{multipliedPublicKey=ecc.pointMultiplyUnsafe(publicKey,coefficient,false)}if(multipliedPublicKey===null)throw new Error("Point at infinity during aggregation");return multipliedPublicKey});const aggPublicKey=multipliedPublicKeys.reduce((a,b)=>{const next=ecc.pointAdd(a,b,false);if(next===null)throw new Error("Point at infinity during aggregation");return next});return tweaks.reduce((ctx,tweak)=>addTweak(ctx,tweak),{aggPublicKey:aggPublicKey,gacc:SCALAR_1,tacc:SCALAR_0})}function getSessionValues(sessionKey){const sessionValues=_sessionCache.get(sessionKey);if(!sessionValues)throw new Error("Invalid session key, please call `startSigningSession`");return sessionValues}function nonceAgg(publicNonces){checkArgs({publicNonces:publicNonces});const aggNonces=[publicNonces[0].subarray(0,33),publicNonces[0].subarray(33)];for(let i=1;i<publicNonces.length;i++){if(aggNonces[0]!==null)aggNonces[0]=ecc.pointAdd(aggNonces[0],publicNonces[i].subarray(0,33),false);if(aggNonces[1]!==null)aggNonces[1]=ecc.pointAdd(aggNonces[1],publicNonces[i].subarray(33),false)}const aggNonce=new Uint8Array(66);if(aggNonces[0]!==null)aggNonce.set(ecc.pointCompress(aggNonces[0]),0);if(aggNonces[1]!==null)aggNonce.set(ecc.pointCompress(aggNonces[1]),33);return aggNonce}function startSigningSessionInner(aggNonce,msg,publicKeys,ctx){const pubKeyX=ecc.pointX(ctx.aggPublicKey);const coefficient=ecc.taggedHash(TAGS.musig_noncecoef,aggNonce,pubKeyX,msg);const aggNonces=[aggNonce.subarray(0,33),aggNonce.subarray(33)];let r=null;if(compare33b(aggNonces[1],CPOINT_INF)!==0&&compare33b(aggNonces[0],CPOINT_INF)!==0){r=ecc.pointMultiplyAndAddUnsafe(aggNonces[1],coefficient,aggNonces[0],false)}else if(compare33b(aggNonces[0],CPOINT_INF)!==0){r=ecc.pointCompress(aggNonces[0],false)}else if(compare33b(aggNonces[1],CPOINT_INF)!==0){r=ecc.pointMultiplyUnsafe(aggNonces[1],coefficient,false)}if(r===null)r=ecc.getPublicKey(SCALAR_1,false);if(r===null)throw new Error("Failed to get G");const challenge=ecc.scalarMod(ecc.taggedHash(TAGS.challenge,ecc.pointX(r),pubKeyX,msg));const key={publicKey:ctx.aggPublicKey,aggNonce:aggNonce,msg:msg};_sessionCache.set(key,{...ctx,coefficient:coefficient,challenge:challenge,finalNonce:r,publicKeys:publicKeys});return key}function partialVerifyInner({sig,publicKey,publicNonces,sessionKey}){const{aggPublicKey,gacc,challenge,coefficient,finalNonce,publicKeys}=getSessionValues(sessionKey);const rePrime=ecc.pointMultiplyAndAddUnsafe(publicNonces[1],coefficient,publicNonces[0],false);if(rePrime===null)throw new Error("Unexpected public nonce at infinity");const re=ecc.hasEvenY(finalNonce)?rePrime:ecc.pointNegate(rePrime);const a=keyAggCoeff(publicKeys,publicKey);const g=ecc.hasEvenY(aggPublicKey)?gacc:ecc.scalarNegate(gacc);const ea=ecc.scalarMultiply(challenge,a);const eag=ecc.scalarMultiply(ea,g);const ver=ecc.pointMultiplyAndAddUnsafe(publicKey,eag,re,true);if(ver===null)throw new Error("Unexpected verification point at infinity");const sG=ecc.getPublicKey(sig,true);if(sG===null)throw new Error("Unexpected signature point at infinity");return compare33b(ver,sG)===0}function partialSignInner({secretKey,publicKey,secretNonces,sessionKey}){const{aggPublicKey,gacc,challenge,coefficient,finalNonce,publicKeys}=getSessionValues(sessionKey);const[k1,k2]=secretNonces.map(k=>ecc.hasEvenY(finalNonce)?k:ecc.scalarNegate(k));const a=keyAggCoeff(publicKeys,publicKey);const g=ecc.hasEvenY(aggPublicKey)?gacc:ecc.scalarNegate(gacc);const d=ecc.scalarMultiply(g,secretKey);const bk2=ecc.scalarMultiply(coefficient,k2);const k1bk2=ecc.scalarAdd(k1,bk2);const ea=ecc.scalarMultiply(challenge,a);const ead=ecc.scalarMultiply(ea,d);const sig=ecc.scalarAdd(k1bk2,ead);return sig}function partialSign({secretKey,publicNonce,sessionKey,verify=true}){checkArgs({publicNonce:publicNonce,secretKey:secretKey});const secretNonce=_nonceCache.get(publicNonce);if(secretNonce===undefined)throw new Error("No secret nonce found for specified public nonce");_nonceCache.delete(publicNonce);const publicKey=ecc.getPublicKey(secretKey,true);if(publicKey===null)throw new Error("Invalid secret key, no corresponding public key");if(compare33b(publicKey,secretNonce.subarray(64))!==0)throw new Error("Secret nonce pubkey mismatch");const secretNonces=[secretNonce.subarray(0,32),secretNonce.subarray(32,64)];const sig=partialSignInner({secretKey:secretKey,publicKey:publicKey,secretNonces:secretNonces,sessionKey:sessionKey});if(verify){const publicNonces=[publicNonce.subarray(0,33),publicNonce.subarray(33)];const valid=partialVerifyInner({sig:sig,publicKey:publicKey,publicNonces:publicNonces,sessionKey:sessionKey});if(!valid)throw new Error("Partial signature failed verification")}return sig}function deterministicSign({secretKey,aggOtherNonce,publicKeys,tweaks=[],msg,rand,verify=true,nonceOnly=false}){checkArgs({rand:rand,secretKey:secretKey,aggOtherNonce:aggOtherNonce});const publicKey=ecc.getPublicKey(secretKey,true);if(publicKey===null)throw new Error("Secret key has no corresponding public key");let secretKeyPrime;if(rand!==undefined){secretKeyPrime=ecc.taggedHash(TAGS.musig_aux,rand);for(let i=0;i<32;i++){secretKeyPrime[i]=secretKeyPrime[i]^secretKey[i]}}else{secretKeyPrime=secretKey}const ctx=keyAgg(publicKeys,...tweaks);const aggPublicKey=ecc.pointX(ctx.aggPublicKey);const mLength=new Uint8Array(8);new DataView(mLength.buffer).setBigUint64(0,BigInt(msg.length));const secretNonce=new Uint8Array(97);const publicNonce=new Uint8Array(66);for(let i=0;i<2;i++){const kH=ecc.taggedHash(TAGS.musig_deterministic_nonce,...[secretKeyPrime,aggOtherNonce,aggPublicKey,mLength,msg,Uint8Array.of(i)]);const k=ecc.scalarMod(kH);if(compare32b(SCALAR_0,k)===0)throw new Error("0 secret nonce");const pub=ecc.getPublicKey(k,true);if(pub===null)throw new Error("Secret nonce has no corresponding public nonce");secretNonce.set(k,i*32);publicNonce.set(pub,i*33)}secretNonce.set(publicKey,64);if(nonceOnly)return{publicNonce:publicNonce};_nonceCache.set(publicNonce,secretNonce);const aggNonce=nonceAgg([aggOtherNonce,publicNonce]);const sessionKey=startSigningSessionInner(aggNonce,msg,publicKeys,ctx);const sig=partialSign({secretKey:secretKey,publicNonce:publicNonce,sessionKey:sessionKey,verify:verify});return{sig:sig,sessionKey:sessionKey,publicNonce:publicNonce}}const pubKeyArgs=["publicKey","publicKeys"];const scalarArgs=["tweak","sig","sigs","tacc","gacc"];const otherArgs32b=["xOnlyPublicKey","rand","sessionId"];const args32b=["secretKey",...scalarArgs,...otherArgs32b];const pubNonceArgs=["publicNonce","publicNonces","aggNonce","aggOtherNonce","finalNonce"];const argLengths=new Map;args32b.forEach(a=>argLengths.set(a,32));pubKeyArgs.forEach(a=>argLengths.set(a,33));pubNonceArgs.forEach(a=>argLengths.set(a,66));argLengths.set("secretNonce",97);argLengths.set("aggPublicKey",65);const scalarNames=new Set;scalarArgs.forEach(n=>scalarNames.add(n));function checkArgs(args){for(let[name,values]of Object.entries(args)){if(values===undefined)continue;values=Array.isArray(values)?values:[values];if(values.length===0)throw new TypeError(`0-length ${name}s not supported`);for(const value of values){if(argLengths.get(name)!==value.length)throw new TypeError(`Invalid ${name} length (${value.length})`);if(name==="secretKey"){if(!ecc.isSecret(value))throw new TypeError(`Invalid secretKey`)}else if(name==="secretNonce"){for(let i=0;i<64;i+=32)if(!ecc.isSecret(value.subarray(i,i+32)))throw new TypeError(`Invalid secretNonce`)}else if(scalarNames.has(name)){for(let i=0;i<value.length;i+=32)if(!ecc.isScalar(value.subarray(i,i+32)))throw new TypeError(`Invalid ${name}`)}}}}return{getXOnlyPubkey:ctx=>{if("aggPublicKey"in ctx)return ecc.pointX(ctx.aggPublicKey);return ecc.pointX(getSessionValues(ctx).aggPublicKey)},getPlainPubkey:ctx=>{if("aggPublicKey"in ctx)return ecc.pointCompress(ctx.aggPublicKey);return ecc.pointCompress(getSessionValues(ctx).aggPublicKey)},keySort:publicKeys=>{checkArgs({publicKeys:publicKeys});return[...publicKeys].sort((a,b)=>compare33b(a,b))},keyAgg:keyAgg,addTweaks:(ctx,...tweaks)=>{checkArgs(ctx);return tweaks.reduce((c,tweak)=>addTweak(c,tweak),ctx)},nonceGen:({sessionId=makeSessionId(),secretKey,publicKey,xOnlyPublicKey,msg,extraInput})=>{if(extraInput!==undefined&&extraInput.length>Math.pow(2,32)-1)throw new TypeError("extraInput is limited to 2^32-1 bytes");checkArgs({sessionId:sessionId,secretKey:secretKey,publicKey:publicKey,xOnlyPublicKey:xOnlyPublicKey});let rand;if(secretKey!==undefined){rand=ecc.taggedHash(TAGS.musig_aux,sessionId);for(let i=0;i<32;i++){rand[i]=rand[i]^secretKey[i]}}else{rand=sessionId}if(xOnlyPublicKey===undefined)xOnlyPublicKey=new Uint8Array;const mPrefixed=[Uint8Array.of(0)];if(msg!==undefined){mPrefixed[0][0]=1;mPrefixed.push(new Uint8Array(8));new DataView(mPrefixed[1].buffer).setBigUint64(0,BigInt(msg.length));mPrefixed.push(msg)}if(extraInput===undefined)extraInput=new Uint8Array;const eLength=new Uint8Array(4);new DataView(eLength.buffer).setUint32(0,extraInput.length);const secretNonce=new Uint8Array(97);const publicNonce=new Uint8Array(66);for(let i=0;i<2;i++){const kH=ecc.taggedHash(TAGS.musig_nonce,rand,Uint8Array.of(publicKey.length),publicKey,Uint8Array.of(xOnlyPublicKey.length),xOnlyPublicKey,...mPrefixed,eLength,extraInput,Uint8Array.of(i));const k=ecc.scalarMod(kH);if(compare32b(SCALAR_0,k)===0)throw new Error("0 secret nonce");const pub=ecc.getPublicKey(k,true);if(pub===null)throw new Error("Secret nonce has no corresponding public nonce");secretNonce.set(k,i*32);publicNonce.set(pub,i*33)}secretNonce.set(publicKey,64);_nonceCache.set(publicNonce,secretNonce);return publicNonce},addExternalNonce:(publicNonce,secretNonce)=>{checkArgs({publicNonce:publicNonce,secretNonce:secretNonce});_nonceCache.set(publicNonce,secretNonce)},deterministicNonceGen:args=>deterministicSign({...args,nonceOnly:true}),deterministicSign:deterministicSign,nonceAgg:nonceAgg,startSigningSession:(aggNonce,msg,publicKeys,...tweaks)=>{checkArgs({aggNonce:aggNonce});const ctx=keyAgg(publicKeys,...tweaks);return startSigningSessionInner(aggNonce,msg,publicKeys,ctx)},partialSign:partialSign,partialVerify:({sig,publicKey,publicNonce,sessionKey})=>{checkArgs({sig:sig,publicKey:publicKey,publicNonce:publicNonce});const publicNonces=[publicNonce.subarray(0,33),publicNonce.subarray(33)];const valid=partialVerifyInner({sig:sig,publicKey:publicKey,publicNonces:publicNonces,sessionKey:sessionKey});return valid},signAgg:(sigs,sessionKey)=>{checkArgs({sigs:sigs});const{aggPublicKey,tacc,challenge,finalNonce}=getSessionValues(sessionKey);let sPart=ecc.scalarMultiply(challenge,tacc);if(!ecc.hasEvenY(aggPublicKey)){sPart=ecc.scalarNegate(sPart)}const aggS=sigs.reduce((a,b)=>ecc.scalarAdd(a,b),sPart);const sig=new Uint8Array(64);sig.set(ecc.pointX(finalNonce),0);sig.set(aggS,32);return sig}}}function isBytes(a){return a instanceof Uint8Array||a!=null&&typeof a==="object"&&a.constructor.name==="Uint8Array"}function chain(...args){const id=a=>a;const wrap=(a,b)=>c=>a(b(c));const encode=args.map(x=>x.encode).reduceRight(wrap,id);const decode=args.map(x=>x.decode).reduce(wrap,id);return{encode:encode,decode:decode}}function alphabet(alphabet){return{encode:digits=>{if(!Array.isArray(digits)||digits.length&&typeof digits[0]!=="number")throw new Error("alphabet.encode input should be an array of numbers");return digits.map(i=>{if(i<0||i>=alphabet.length)throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);return alphabet[i]})},decode:input=>{if(!Array.isArray(input)||input.length&&typeof input[0]!=="string")throw new Error("alphabet.decode input should be array of strings");return input.map(letter=>{if(typeof letter!=="string")throw new Error(`alphabet.decode: not string element=${letter}`);const index=alphabet.indexOf(letter);if(index===-1)throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);return index})}}}function join(separator=""){if(typeof separator!=="string")throw new Error("join separator should be string");return{encode:from=>{if(!Array.isArray(from)||from.length&&typeof from[0]!=="string")throw new Error("join.encode input should be array of strings");for(let i of from)if(typeof i!=="string")throw new Error(`join.encode: non-string input=${i}`);return from.join(separator)},decode:to=>{if(typeof to!=="string")throw new Error("join.decode input should be string");return to.split(separator)}}}function convertRadix(data,from,to){if(from<2)throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);if(to<2)throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);if(!Array.isArray(data))throw new Error("convertRadix: data should be array");if(!data.length)return[];let pos=0;const res=[];const digits=Array.from(data);digits.forEach(d=>{if(d<0||d>=from)throw new Error(`Wrong integer: ${d}`)});while(true){let carry=0;let done=true;for(let i=pos;i<digits.length;i++){const digit=digits[i];const digitBase=from*carry+digit;if(!Number.isSafeInteger(digitBase)||from*carry/from!==carry||digitBase-digit!==from*carry){throw new Error("convertRadix: carry overflow")}carry=digitBase%to;const rounded=Math.floor(digitBase/to);digits[i]=rounded;if(!Number.isSafeInteger(rounded)||rounded*to+carry!==digitBase)throw new Error("convertRadix: carry overflow");if(!done)continue;else if(!rounded)pos=i;else done=false}res.push(carry);if(done)break}for(let i=0;i<data.length-1&&data[i]===0;i++)res.push(0);return res.reverse()}function radix(num){return{encode:bytes=>{if(!isBytes(bytes))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(bytes),2**8,num)},decode:digits=>{if(!Array.isArray(digits)||digits.length&&typeof digits[0]!=="number")throw new Error("radix.decode input should be array of numbers");return Uint8Array.from(convertRadix(digits,num,2**8))}}}function checksum$1(len,fn){if(typeof fn!=="function")throw new Error("checksum fn should be function");return{encode(data){if(!isBytes(data))throw new Error("checksum.encode: input should be Uint8Array");const checksum=fn(data).slice(0,len);const res=new Uint8Array(data.length+len);res.set(data);res.set(checksum,data.length);return res},decode(data){if(!isBytes(data))throw new Error("checksum.decode: input should be Uint8Array");const payload=data.slice(0,-len);const newChecksum=fn(payload).slice(0,len);const oldChecksum=data.slice(-len);for(let i=0;i<len;i++)if(newChecksum[i]!==oldChecksum[i])throw new Error("Invalid checksum");return payload}}}const genBase58=abc=>chain(radix(58),alphabet(abc),join(""));const base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");const createBase58check=sha256=>chain(checksum$1(4,data=>sha256(sha256(data))),base58);const base58check=createBase58check;const bs58check=base58check(sha256$1);function hash160(buffer){return ripemd160$1(sha256$1(buffer))}function hmacSHA512(key,data){return hmac(sha512$1,key,data)}const PC_VERSION=71;class PaymentCodePublic{ecc;bip32;buf;root;hasPrivKeys;constructor(ecc,bip32,buf){this.ecc=ecc;this.bip32=bip32;this.hasPrivKeys=false;if(buf.length!==80)throw new Error("Invalid buffer length");if(buf[0]!==1)throw new Error("Only payment codes version 1 are supported");this.buf=buf;this.root=bip32.fromPublicKey(this.pubKey,this.chainCode)}get features(){return this.buf.subarray(1,2)}get pubKey(){return this.buf.subarray(2,2+33)}get chainCode(){return this.buf.subarray(35,35+32)}get paymentCode(){return this.buf}toBase58(){const version=new Uint8Array([PC_VERSION]);const buf=new Uint8Array(version.length+this.buf.length);buf.set(version);buf.set(this.buf,version.length);return bs58check.encode(buf)}derive(index){return this.root.derive(index)}getNotificationPublicKey(){return getBytes(this.derive(0).publicKey)}derivePublicKeyFromSharedSecret(B,S){const Sx=S.subarray(1,33);const s=sha256$1(Sx);if(!this.ecc.isPrivate(s))throw new Error("Invalid shared secret");const P=this.ecc.pointAddScalar(B,s,true);if(!P)throw new Error("Unable to derive public key");return P}derivePaymentPublicKey(paymentCode,idx){const a=paymentCode.getNotificationPrivateKey();if(!this.ecc.isPrivate(a))throw new Error("Received invalid private key");const B=this.derive(idx).publicKey;const S=this.ecc.pointMultiply(B,a);if(!S)throw new Error("Unable to compute secret point");return this.derivePublicKeyFromSharedSecret(B,S)}getAddressFromPubkey(pubKey){return computeAddress(hexlify(pubKey))}getPaymentAddress(paymentCode,idx){const pubkey=this.derivePaymentPublicKey(paymentCode,idx);return this.getAddressFromPubkey(pubkey)}}class PaymentCodePrivate extends PaymentCodePublic{constructor(root,ecc,bip32,buf){super(ecc,bip32,buf);this.root=root;this.hasPrivKeys=true}derivePaymentPublicKey(paymentCode,idx){const A=paymentCode.getNotificationPublicKey();if(!this.ecc.isPoint(A))throw new Error("Received invalid public key");const b_node=this.derive(idx);if(!b_node.privateKey)throw new Error("Unable to derive node with private key");const b=getBytes(b_node.privateKey);const B=getBytes(b_node.publicKey);const S=this.ecc.pointMultiply(A,b);if(!S)throw new Error("Unable to compute resulting point");return this.derivePublicKeyFromSharedSecret(B,S)}getPaymentAddress(paymentCode,idx){const pubKey=this.derivePaymentPublicKey(paymentCode,idx);return this.getAddressFromPubkey(pubKey)}derivePaymentPrivateKey(paymentCodePublic,idx){const A=paymentCodePublic.getNotificationPublicKey();if(!this.ecc.isPoint(A))throw new Error("Argument is not a valid public key");const b_node=this.derive(idx);if(!b_node.privateKey)throw new Error("Unable to derive node without private key");const b=getBytes(b_node.privateKey);const S=this.ecc.pointMultiply(A,b);if(!S)throw new Error("Unable to compute resulting point");const Sx=S.subarray(1,33);const s=sha256$1(Sx);if(!this.ecc.isPrivate(s))throw new Error("Invalid shared secret");const paymentPrivateKey=this.ecc.privateAdd(b,s);if(!paymentPrivateKey)throw new Error("Unable to compute payment private key");return paymentPrivateKey}getNotificationPrivateKey(){const child=this.derive(0);return child.privateKey}}function validatePaymentCode(paymentCode){const VERSION_BYTE=71;const FEATURE_BYTE=0;try{const decoded=bs58check.decode(paymentCode);if(decoded.length!==81){return false}if(decoded[0]!==VERSION_BYTE){return false}const paymentCodeBytes=decoded.slice(1);if(paymentCodeBytes[0]!==1){return false}if(paymentCodeBytes[1]!==FEATURE_BYTE){return false}if(paymentCodeBytes[2]!==2&&paymentCodeBytes[2]!==3){return false}const pubKey=paymentCodeBytes.slice(2,35);try{secp256k1.ProjectivePoint.fromHex(Buffer.from(pubKey).toString("hex")).assertValidity()}catch(error){return false}if(!paymentCodeBytes.slice(67).every(byte=>byte===0)){return false}return true}catch(error){return false}}function areUint8ArraysEqual(a,b){if(a===b){return true}if(a.length!==b.length){return false}for(let index=0;index<a.length;index++){if(a[index]!==b[index]){return false}}return true}const h=hex=>hexToBytes$1(hex);function testEcc(ecc){assert(ecc.isPoint(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));assert(!ecc.isPoint(h("030000000000000000000000000000000000000000000000000000000000000005")));assert(ecc.isPrivate(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));assert(ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));assert(!ecc.isPrivate(h("0000000000000000000000000000000000000000000000000000000000000000")));assert(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")));assert(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")));assert(areUint8ArraysEqual(ecc.pointFromScalar(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")),h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")));if(ecc.xOnlyPointAddTweak){assert(ecc.xOnlyPointAddTweak(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))===null);let xOnlyRes=ecc.xOnlyPointAddTweak(h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));assert(areUint8ArraysEqual(xOnlyRes.xOnlyPubkey,h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"))&&xOnlyRes.parity===1);xOnlyRes=ecc.xOnlyPointAddTweak(h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"))}assert(areUint8ArraysEqual(ecc.pointAddScalar(h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),h("0000000000000000000000000000000000000000000000000000000000000003")),h("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")));assert(areUint8ArraysEqual(ecc.privateAdd(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),h("0000000000000000000000000000000000000000000000000000000000000002")),h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));if(ecc.privateNegate){assert(areUint8ArraysEqual(ecc.privateNegate(h("0000000000000000000000000000000000000000000000000000000000000001")),h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));assert(areUint8ArraysEqual(ecc.privateNegate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")),h("0000000000000000000000000000000000000000000000000000000000000003")));assert(areUint8ArraysEqual(ecc.privateNegate(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")),h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")))}assert(areUint8ArraysEqual(ecc.sign(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));assert(ecc.verify(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));if(ecc.signSchnorr){assert(areUint8ArraysEqual(ecc.signSchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")),h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")))}if(ecc.verifySchnorr){assert(ecc.verifySchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")))}}function assert(bool){if(!bool)throw new Error("ecc library invalid")}function BIP32Factory(ecc){testEcc(ecc);const BITCOIN={bip32:{public:76067358,private:76066276},wif:128};const HIGHEST_BIT=2147483648;function toXOnly(pubKey){return pubKey.length===32?pubKey:pubKey.subarray(1,33)}class Bip32Signer{__D;__Q;lowR;constructor({__D,__Q}){this.__D=__D;this.__Q=__Q;this.lowR=false}get publicKey(){if(this.__Q===undefined)this.__Q=ecc.pointFromScalar(this.__D,true);return this.__Q}get privateKey(){return this.__D}sign(hash,lowR){if(!this.privateKey)throw new Error("Missing private key");if(lowR===undefined)lowR=this.lowR;if(lowR===false){return ecc.sign(hash,this.privateKey)}else{let sig=ecc.sign(hash,this.privateKey);const extraData=new Uint8Array(32);const extraDataView=new DataView(extraData.buffer);let counter=0;while(sig[0]>127){counter++;extraDataView.setUint32(0,counter,true);sig=ecc.sign(hash,this.privateKey,extraData)}return sig}}signSchnorr(hash){if(!this.privateKey)throw new Error("Missing private key");if(!ecc.signSchnorr)throw new Error("signSchnorr not supported by ecc library");return ecc.signSchnorr(hash,this.privateKey)}verify(hash,signature){return ecc.verify(hash,this.publicKey,signature)}verifySchnorr(hash,signature){if(!ecc.verifySchnorr)throw new Error("verifySchnorr not supported by ecc library");return ecc.verifySchnorr(hash,this.publicKey.subarray(1,33),signature)}}class BIP32 extends Bip32Signer{chainCode;network;__DEPTH;__INDEX;__PARENT_FINGERPRINT;constructor({__D,__Q,chainCode,network,__DEPTH=0,__INDEX=0,__PARENT_FINGERPRINT=0}){super({__D:__D,__Q:__Q});this.chainCode=chainCode;this.network=network;this.__DEPTH=__DEPTH;this.__INDEX=__INDEX;this.__PARENT_FINGERPRINT=__PARENT_FINGERPRINT}get depth(){return this.__DEPTH}get index(){return this.__INDEX}get parentFingerprint(){return this.__PARENT_FINGERPRINT}get identifier(){return hash160(this.publicKey)}get fingerprint(){return this.identifier.subarray(0,4)}get compressed(){return true}isNeutered(){return this.__D===undefined}neutered(){return fromPublicKeyLocal(this.publicKey,this.chainCode,this.network,this.depth,this.index,this.parentFingerprint)}toBase58(){const network=this.network;const version=!this.isNeutered()?network.bip32.private:network.bip32.public;const buffer=new Uint8Array(78);const bufferView=new DataView(buffer.buffer);bufferView.setUint32(0,version,false);bufferView.setUint8(4,this.depth);bufferView.setUint32(5,this.parentFingerprint,false);bufferView.setUint32(9,this.index,false);buffer.set(this.chainCode,13);if(!this.isNeutered()){bufferView.setUint8(45,0);buffer.set(this.privateKey,46)}else{buffer.set(this.publicKey,45)}return bs58check.encode(buffer)}derive(index){const isHardened=index>=HIGHEST_BIT;const data=new Uint8Array(37);const dataView=new DataView(data.buffer);if(isHardened){if(this.isNeutered())throw new TypeError("Missing private key for hardened child key");data[0]=0;data.set(this.privateKey,1);dataView.setUint32(33,index,false)}else{data.set(this.publicKey,0);dataView.setUint32(33,index,false)}const I=hmacSHA512(this.chainCode,data);const IL=I.slice(0,32);const IR=I.slice(32);if(!ecc.isPrivate(IL))return this.derive(index+1);let hd;if(!this.isNeutered()){const ki=ecc.privateAdd(this.privateKey,IL);if(ki==null)return this.derive(index+1);hd=fromPrivateKeyLocal(ki,IR,this.network,this.depth+1,index,new DataView(this.fingerprint.buffer).getUint32(0,false))}else{const Ki=ecc.pointAddScalar(this.publicKey,IL,true);if(Ki===null)return this.derive(index+1);hd=fromPublicKeyLocal(Ki,IR,this.network,this.depth+1,index,new DataView(this.fingerprint.buffer).getUint32(0,false))}return hd}deriveHardened(index){return this.derive(index+HIGHEST_BIT)}derivePath(path){let splitPath=path.split("/");if(splitPath[0]==="m"){if(this.parentFingerprint)throw new TypeError("Expected master, got child");splitPath=splitPath.slice(1)}return splitPath.reduce((prevHd,indexStr)=>{let index;if(indexStr.slice(-1)===`'`){index=parseInt(indexStr.slice(0,-1),10);return prevHd.deriveHardened(index)}else{index=parseInt(indexStr,10);return prevHd.derive(index)}},this)}tweak(t){if(this.privateKey)return this.tweakFromPrivateKey(t);return this.tweakFromPublicKey(t)}tweakFromPublicKey(t){const xOnlyPubKey=toXOnly(this.publicKey);if(!ecc.xOnlyPointAddTweak)throw new Error("xOnlyPointAddTweak not supported by ecc library");const tweakedPublicKey=ecc.xOnlyPointAddTweak(xOnlyPubKey,t);if(!tweakedPublicKey||tweakedPublicKey.xOnlyPubkey===null)throw new Error("Cannot tweak public key!");const parityByte=Uint8Array.from([tweakedPublicKey.parity===0?2:3]);const tweakedPublicKeyCompresed=new Uint8Array(tweakedPublicKey.xOnlyPubkey.length+1);tweakedPublicKeyCompresed.set(parityByte);tweakedPublicKeyCompresed.set(tweakedPublicKey.xOnlyPubkey,1);return new Bip32Signer({__Q:tweakedPublicKeyCompresed})}tweakFromPrivateKey(t){const hasOddY=this.publicKey[0]===3||this.publicKey[0]===4&&(this.publicKey[64]&1)===1;const privateKey=(()=>{if(!hasOddY)return this.privateKey;else if(!ecc.privateNegate)throw new Error("privateNegate not supported by ecc library");else return ecc.privateNegate(this.privateKey)})();const tweakedPrivateKey=ecc.privateAdd(privateKey,t);if(!tweakedPrivateKey)throw new Error("Invalid tweaked private key!");return new Bip32Signer({__D:tweakedPrivateKey})}}function fromBase58(inString,network){const buffer=bs58check.decode(inString);const bufferView=new DataView(buffer.buffer);if(buffer.length!==78)throw new TypeError("Invalid buffer length");network=network||BITCOIN;const version=bufferView.getUint32(0,false);if(version!==network.bip32.private&&version!==network.bip32.public)throw new TypeError("Invalid network version");const depth=buffer[4];const parentFingerprint=bufferView.getUint32(5,false);if(depth===0){if(parentFingerprint!==0)throw new TypeError("Invalid parent fingerprint")}const index=bufferView.getUint32(9,false);if(depth===0&&index!==0)throw new TypeError("Invalid index");const chainCode=buffer.subarray(13,45);let hd;if(version===network.bip32.private){if(bufferView.getUint8(45)!==0)throw new TypeError("Invalid private key");const k=buffer.subarray(46,78);hd=fromPrivateKeyLocal(k,chainCode,network,depth,index,parentFingerprint)}else{const X=buffer.subarray(45,78);hd=fromPublicKeyLocal(X,chainCode,network,depth,index,parentFingerprint)}return hd}function fromPrivateKey(privateKey,chainCode,network){return fromPrivateKeyLocal(privateKey,chainCode,network||BITCOIN,0,0,0)}function fromPrivateKeyLocal(privateKey,chainCode,network,depth,index,parentFingerprint){network=network||BITCOIN;if(!ecc.isPrivate(privateKey))throw new TypeError("Private key not in range [1, n)");return new BIP32({__D:privateKey,chainCode:chainCode,network:network,__DEPTH:depth,__INDEX:index,__PARENT_FINGERPRINT:parentFingerprint})}function fromPublicKey(publicKey,chainCode,network){return fromPublicKeyLocal(publicKey,chainCode,network||BITCOIN,0,0,0)}function fromPublicKeyLocal(publicKey,chainCode,network,depth,index,parentFingerprint){network=network||BITCOIN;if(!ecc.isPoint(publicKey))throw new TypeError("Point is not on the curve");return new BIP32({__Q:publicKey,chainCode:chainCode,network:network,__DEPTH:depth,__INDEX:index,__PARENT_FINGERPRINT:parentFingerprint})}function fromSeed(seed,network){if(seed.length<16)throw new TypeError("Seed should be at least 128 bits");if(seed.length>64)throw new TypeError("Seed should be at most 512 bits");network=network||BITCOIN;const encoder=new TextEncoder;const I=hmacSHA512(encoder.encode("Bitcoin seed"),seed);const IL=I.slice(0,32);const IR=I.slice(32);return fromPrivateKey(IL,IR,network)}return{fromSeed:fromSeed,fromBase58:fromBase58,fromPublicKey:fromPublicKey,fromPrivateKey:fromPrivateKey}}class HDNodeBIP32Adapter{hdNodeWallet;constructor(hdNodeWallet){this.hdNodeWallet=hdNodeWallet}get chainCode(){return getBytes(this.hdNodeWallet.chainCode)}get network(){throw"Not implemented"}get depth(){return this.hdNodeWallet.depth}get index(){return this.hdNodeWallet.index}get parentFingerprint(){return parseInt(this.hdNodeWallet.parentFingerprint)}get privateKey(){return getBytes(this.hdNodeWallet.privateKey)}get identifier(){throw"Not implemented"}get fingerprint(){throw"Not implemented"}isNeutered(){throw"Not implemented"}neutered(){throw"Not implemented"}toBase58(){throw"Not implemented"}derive(index){const derivedNode=this.hdNodeWallet.deriveChild(index);return new HDNodeBIP32Adapter(derivedNode)}deriveHardened(index){throw"Not implemented"}derivePath(path){const derivedNode=this.hdNodeWallet.derivePath(path);return new HDNodeBIP32Adapter(derivedNode)}tweak(t){throw"Not implemented"}get publicKey(){return getBytes(this.hdNodeWallet.publicKey)}get lowR(){throw"Not implemented"}sign(hash){const sig=this.hdNodeWallet.signingKey.sign(hash);return getBytes(sig.serialized)}verify(hash,signature){throw"Not implemented"}signSchnorr(hash){throw"Not implemented"}verifySchnorr(hash,signature){throw"Not implemented"}}class ConversionCoinSelector extends FewestCoinSelector{createSpendOutputs(amount){const spendDenominations=denominate(amount);return spendDenominations.map(denominationValue=>{const utxo=new UTXO;utxo.denomination=denominations.indexOf(denominationValue);return utxo})}}var AddressStatus;(function(AddressStatus){AddressStatus["USED"]="USED";AddressStatus["UNUSED"]="UNUSED";AddressStatus["ATTEMPTED_USE"]="ATTEMPTED_USE";AddressStatus["UNKNOWN"]="UNKNOWN"})(AddressStatus||(AddressStatus={}));class QiHDWallet extends AbstractHDWallet{static _version=1;static _GAP_LIMIT=5;static _coinType=969;static PRIVATE_KEYS_PATH="privateKeys";_addressesMap=new Map;_availableOutpoints=new Map;_addressUseChecker;_paymentCodeSendAddressMap=new Map;constructor(guard,root,provider){super(guard,root,provider);this._addressesMap.set("BIP44:external",[]);this._addressesMap.set("BIP44:change",[]);this._addressesMap.set(QiHDWallet.PRIVATE_KEYS_PATH,[])}get openChannels(){return Array.from(this._addressesMap.keys()).filter(key=>!key.startsWith("BIP44:")&&key!==QiHDWallet.PRIVATE_KEYS_PATH)}setAddressUseChecker(checker){this._addressUseChecker=checker}_findLastUsedIndex(addresses,account,zone){if(!addresses)return-1;return addresses.filter(addressInfo=>addressInfo.account===account&&addressInfo.zone===zone).reduce((maxIndex,addressInfo)=>Math.max(maxIndex,addressInfo.index),-1)||-1}_getNextQiAddress(account,zone,isChange){const derivationPath=isChange?"BIP44:change":"BIP44:external";const addresses=this._addressesMap.get(derivationPath)||[];const lastIndex=this._findLastUsedIndex(addresses,account,zone);const addressNode=this.deriveNextAddressNode(account,lastIndex+1,zone,isChange);const newAddressInfo=this._createAndStoreQiAddressInfo(addressNode,account,zone,isChange);const privateKeysArray=this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH)||[];const existingPrivateKeyIndex=privateKeysArray.findIndex(info=>info.address===newAddressInfo.address);if(existingPrivateKeyIndex!==-1){const pkAddressInfo=privateKeysArray[existingPrivateKeyIndex];newAddressInfo.status=pkAddressInfo.status;newAddressInfo.lastSyncedBlock=pkAddressInfo.lastSyncedBlock;privateKeysArray.splice(existingPrivateKeyIndex,1);this._addressesMap.set(QiHDWallet.PRIVATE_KEYS_PATH,privateKeysArray)}return newAddressInfo}_createAndStoreQiAddressInfo(addressNode,account,zone,isChange){const derivationPath=isChange?"BIP44:change":"BIP44:external";const qiAddressInfo={zone:zone,account:account,derivationPath:derivationPath,address:addressNode.address,pubKey:addressNode.publicKey,index:addressNode.index,change:isChange,status:AddressStatus.UNKNOWN,lastSyncedBlock:null};this._addressesMap.get(derivationPath).push(qiAddressInfo);return qiAddressInfo}async getNextAddress(account,zone){return Promise.resolve(this.getNextAddressSync(account,zone))}getNextAddressSync(account,zone){return this._getNextQiAddress(account,zone,false)}async getNextChangeAddress(account,zone){return Promise.resolve(this.getNextChangeAddressSync(account,zone))}getNextChangeAddressSync(account,zone){return this._getNextQiAddress(account,zone,true)}importOutpoints(outpoints){this.validateOutpointInfo(outpoints);for(const outpoint of outpoints){const key=`${outpoint.outpoint.txhash}:${outpoint.outpoint.index}`;if(!this._availableOutpoints.has(key)){this._availableOutpoints.set(key,outpoint)}}}getOutpoints(zone){this.validateZone(zone);return Array.from(this._availableOutpoints.values()).filter(outpoint=>outpoint.zone===zone)}async signTransaction(tx){const txobj=QiTransaction.from(tx);if(!txobj.txInputs||txobj.txInputs.length==0||!txobj.txOutputs)throw new Error("Invalid UTXO transaction, missing inputs or outputs");const hash=getBytes(keccak256(txobj.unsignedSerialized));let signature;if(txobj.txInputs.length===1){signature=this.createSchnorrSignature(txobj.txInputs[0],hash)}else{signature=this.createMuSigSignature(txobj,hash)}txobj.signature=signature;return txobj.serialized}locateAddressInfo(address){for(const[,addressInfos]of this._addressesMap.entries()){const addressInfo=addressInfos.find(info=>info.address===address);if(addressInfo){return addressInfo}}return null}async getBalanceForZone(zone,blockNumber,useAvailableOutpoints=false){if(!this.provider)throw new Error("Provider is not set");this.validateZone(zone);if(!blockNumber&&useAvailableOutpoints){blockNumber=await this.provider.getBlockNumber(toShard(zone))}return await this.getSpendableBalanceForZone(zone,blockNumber,useAvailableOutpoints)+await this.getLockedBalanceForZone(zone,blockNumber,useAvailableOutpoints)}async getSpendableBalanceForZone(zone,blockNumber,useAvailableOutpoints=false){if(!this.provider)throw new Error("Provider is not set");this.validateZone(zone);if(useAvailableOutpoints){if(!blockNumber){blockNumber=await this.provider.getBlockNumber(toShard(zone))}return this._calculateAvailableOutpointSpendableBalanceForZone(zone,blockNumber)}return this._fetchSpendableBalanceForZone(zone)}async getLockedBalanceForZone(zone,blockNumber,useAvailableOutpoints=false){if(!this.provider)throw new Error("Provider is not set");this.validateZone(zone);if(useAvailableOutpoints){if(!blockNumber){blockNumber=await this.provider.getBlockNumber(toShard(zone))}return this._calculateAvailableOutpointLockedBalanceForZone(zone,blockNumber)}return this._fetchLockedBalanceForZone(zone)}async _fetchSpendableBalanceForZone(zone){const balanceMethod=async address=>this.provider?.getBalance(address,"latest")||BigInt(0);return this._fetchBalanceForZone(zone,balanceMethod)}async _fetchLockedBalanceForZone(zone){const balanceMethod=async address=>this.provider?.getLockedBalance(address)||BigInt(0);return this._fetchBalanceForZone(zone,balanceMethod)}async _fetchBalanceForZone(zone,balanceMethod){const allAddresses=Array.from(this._addressesMap.values()).flat().filter(address=>address.zone===zone);const allBalances=await Promise.all(allAddresses.map(address=>balanceMethod(address.address)??BigInt(0)));return allBalances.reduce((total,balance)=>BigInt(total)+BigInt(balance),BigInt(0))}async _calculateAvailableOutpointSpendableBalanceForZone(zone,blockNumber){return this.getOutpoints(zone).filter(utxo=>utxo.outpoint.lock===0||utxo.outpoint.lock<blockNumber).reduce((total,utxo)=>{const denominationValue=denominations[utxo.outpoint.denomination];return total+denominationValue},BigInt(0))}async _calculateAvailableOutpointLockedBalanceForZone(zone,blockNumber){return this.getOutpoints(zone).filter(utxo=>utxo.outpoint.lock!==0&&blockNumber<utxo.outpoint.lock).reduce((total,utxo)=>{const denominationValue=denominations[utxo.outpoint.denomination];return total+denominationValue},BigInt(0))}outpointsToUTXOs(zone){return this.getOutpoints(zone).map(outpointInfo=>{const utxo=new UTXO;utxo.txhash=outpointInfo.outpoint.txhash;utxo.index=outpointInfo.outpoint.index;utxo.address=outpointInfo.address;utxo.denomination=outpointInfo.outpoint.denomination;utxo.lock=outpointInfo.outpoint.lock??null;return utxo})}async convertToQuai(destinationAddress,amount){const zone=getZoneForAddress(destinationAddress);if(!zone){throw new Error(`Invalid zone for Quai address: ${destinationAddress}`)}if(isQiAddress(destinationAddress)){throw new Error(`Invalid Quai address: ${destinationAddress}`)}if(amount<=0){throw new Error("Amount must be greater than 0")}const getDestinationAddresses=async count=>{return Array(count).fill(destinationAddress)};return this.prepareAndSendTransaction(amount,zone,getDestinationAddresses,utxos=>new ConversionCoinSelector(utxos))}async sendTransaction(recipientPaymentCode,amount,originZone,destinationZone){if(!validatePaymentCode(recipientPaymentCode)){throw new Error("Invalid payment code")}if(amount<=0){throw new Error("Amount must be greater than 0")}this.validateZone(originZone);this.validateZone(destinationZone);const getDestinationAddresses=async count=>{const addresses=[];while(addresses.length<count){const address=this.getNextSendAddress(recipientPaymentCode,destinationZone).address;const{isUsed}=await this.checkAddressUse(address);if(!isUsed){addresses.push(address)}}return addresses};return this.prepareAndSendTransaction(amount,originZone,getDestinationAddresses,utxos=>new FewestCoinSelector(utxos))}async aggregate(zone){this.validateZone(zone);if(!this.provider){throw new Error("Provider is not set")}const zoneUTXOs=this.outpointsToUTXOs(zone);if(zoneUTXOs.length===0){throw new Error("No UTXOs available in zone.")}const aggregateCoinSelector=new AggregateCoinSelector(zoneUTXOs);const fee=BigInt(1e3);const selection=aggregateCoinSelector.performSelection({fee:fee,maxDenomination:6,includeLocked:false});const sendAddressesInfo=this._getUnusedBIP44Addresses(1,0,"BIP44:external",zone);const sendAddresses=sendAddressesInfo.map(addressInfo=>addressInfo.address);const changeAddresses=[];const inputPubKeys=selection.inputs.map(input=>{const addressInfo=this.locateAddressInfo(input.address);if(!addressInfo){throw new Error(`Could not locate address info for address: ${input.address}`)}return addressInfo.pubKey});const chainId=(await this.provider.getNetwork()).chainId;const tx=await this.prepareTransaction(selection,inputPubKeys,sendAddresses,changeAddresses,Number(chainId));const signedTx=await this.signTransaction(tx);return this.provider.broadcastTransaction(zone,signedTx)}async prepareAndSendTransaction(amount,originZone,getDestinationAddresses,coinSelectorCreator){if(!this.provider){throw new Error("Provider is not set")}const currentBlock=await this.provider.getBlock(toShard(originZone),"latest");const balance=await this.getSpendableBalanceForZone(originZone,currentBlock?.woHeader.number,true);if(balance<amount){throw new Error(`Insufficient balance in the originating zone: want ${Number(amount)/1e3} Qi got ${balance} Qi`)}const zoneUTXOs=this.outpointsToUTXOs(originZone);if(zoneUTXOs.length===0){throw new Error("No Qi available in zone.")}const unlockedUTXOs=zoneUTXOs.filter(utxo=>utxo.lock===0||utxo.lock<currentBlock?.woHeader.number);if(unlockedUTXOs.length===0){throw new Error("Insufficient spendable balance in zone.")}const coinSelector=coinSelectorCreator(unlockedUTXOs);const spendTarget=amount;let selection=coinSelector.performSelection({target:spendTarget});const sendAddresses=await getDestinationAddresses(selection.spendOutputs.length);const getChangeAddressesForOutputs=async count=>{const currentChangeAddresses=this._addressesMap.get("BIP44:change")||[];const outputChangeAddresses=[];for(let i=0;i<currentChangeAddresses.length;i++){if(currentChangeAddresses[i].status===AddressStatus.UNUSED){outputChangeAddresses.push(currentChangeAddresses[i])}if(outputChangeAddresses.length===count)break}const remainingAddressesNeeded=count-outputChangeAddresses.length;if(remainingAddressesNeeded>0){outputChangeAddresses.push(...Array(remainingAddressesNeeded).fill(0).map(()=>this.getNextChangeAddressSync(0,originZone)))}const mergedChangeAddresses=[...outputChangeAddresses.map(address=>({...address,status:AddressStatus.ATTEMPTED_USE})),...currentChangeAddresses];const sortedAndFilteredChangeAddresses=mergedChangeAddresses.filter((address,index,self)=>self.findIndex(t=>t.address===address.address)===index).sort((a,b)=>a.index-b.index);this._addressesMap.set("BIP44:change",sortedAndFilteredChangeAddresses);return outputChangeAddresses.map(address=>address.address)};const changeAddresses=await getChangeAddressesForOutputs(selection.changeOutputs.length);let inputPubKeys=selection.inputs.map(input=>this.locateAddressInfo(input.address)?.pubKey);if(inputPubKeys.some(pubkey=>!pubkey)){throw new Error("Missing public key for input address")}let attempts=0;const MAX_FEE_ESTIMATION_ATTEMPTS=5;while(attempts<MAX_FEE_ESTIMATION_ATTEMPTS){const feeEstimationTx=this.prepareFeeEstimationTransaction(selection,inputPubKeys.map(pubkey=>pubkey),sendAddresses,changeAddresses);const estimatedFee=await this.provider.estimateFeeForQi(feeEstimationTx);selection=coinSelector.performSelection({target:spendTarget,fee:estimatedFee*3n});const changeAddressesNeeded=selection.changeOutputs.length-changeAddresses.length;if(changeAddressesNeeded>0){const newChangeAddresses=await getChangeAddressesForOutputs(changeAddressesNeeded);changeAddresses.push(...newChangeAddresses)}else if(changeAddressesNeeded<0){const addressesToSetToUnused=changeAddresses.slice(changeAddressesNeeded);const changeAddressesMap=this._addressesMap.get("BIP44:change");const updatedChangeAddressesMap=changeAddressesMap.map(a=>{if(addressesToSetToUnused.includes(a.address)){return{...a,status:AddressStatus.UNUSED}}return a});this._addressesMap.set("BIP44:change",updatedChangeAddressesMap)}const spendAddressesNeeded=selection.spendOutputs.length-sendAddresses.length;if(spendAddressesNeeded>0){const newSendAddresses=await getDestinationAddresses(spendAddressesNeeded);sendAddresses.push(...newSendAddresses)}else if(spendAddressesNeeded<0){sendAddresses.slice(spendAddressesNeeded)}inputPubKeys=selection.inputs.map(input=>this.locateAddressInfo(input.address)?.pubKey);const totalNewOutputsNeeded=Math.abs(changeAddressesNeeded)+Math.abs(spendAddressesNeeded);if(changeAddressesNeeded<=0&&spendAddressesNeeded<=0||totalNewOutputsNeeded<=5){break}attempts++}const chainId=(await this.provider.getNetwork()).chainId;const tx=await this.prepareTransaction(selection,inputPubKeys.map(pubkey=>pubkey),sendAddresses,changeAddresses,Number(chainId));const signedTx=await this.signTransaction(tx);return this.provider.broadcastTransaction(originZone,signedTx)}async prepareTransaction(selection,inputPubKeys,sendAddresses,changeAddresses,chainId){const tx=new QiTransaction;tx.txInputs=selection.inputs.map((input,index)=>({txhash:input.txhash,index:input.index,pubkey:inputPubKeys[index]}));const senderOutputs=selection.spendOutputs.map((output,index)=>({address:sendAddresses[index],denomination:output.denomination}));const changeOutputs=selection.changeOutputs.map((output,index)=>({address:changeAddresses[index],denomination:output.denomination}));tx.txOutputs=[...senderOutputs,...changeOutputs].map(output=>({address:output.address,denomination:output.denomination}));tx.chainId=chainId;return tx}prepareFeeEstimationTransaction(selection,inputPubKeys,sendAddresses,changeAddresses){const txIn=selection.inputs.map((input,index)=>({previousOutpoint:{txHash:input.txhash,index:toQuantity(input.index)},pubkey:inputPubKeys[index]}));const senderOutputs=selection.spendOutputs.map((output,index)=>({address:sendAddresses[index],denomination:output.denomination}));const changeOutputs=selection.changeOutputs.map((output,index)=>({address:changeAddresses[index],denomination:output.denomination}));const txOut=[...senderOutputs,...changeOutputs].map(output=>({address:output.address,denomination:toQuantity(output.denomination)}));return{txType:2,txIn:txIn,txOut:txOut}}_getUnusedBIP44Addresses(amount,account,path,zone){const addresses=this._addressesMap.get(path)||[];const unusedAddresses=addresses.filter(address=>address.status===AddressStatus.UNUSED&&address.account===account&&address.zone===zone);if(unusedAddresses.length>=amount){return unusedAddresses.slice(0,amount)}const remainingAddressesNeeded=amount-unusedAddresses.length;const isChange=path==="BIP44:change";const newAddresses=Array.from({length:remainingAddressesNeeded},()=>this._getNextQiAddress(account,zone,isChange));return[...unusedAddresses,...newAddresses]}createSchnorrSignature(input,hash){const privKey=this.getPrivateKeyForTxInput(input);const signature=schnorr.sign(hash,getBytes(privKey));return hexlify(signature)}createMuSigSignature(tx,hash){const musig=MuSigFactory(musigCrypto);const privKeys=tx.txInputs.map(input=>this.getPrivateKeyForTxInput(input));const pubKeys=privKeys.map(privKey=>musigCrypto.getPublicKey(getBytes(privKey),true)).filter(pubKey=>pubKey!==null);const nonces=pubKeys.map(pk=>musig.nonceGen({publicKey:getBytes(pk)}));const aggNonce=musig.nonceAgg(nonces);const signingSession=musig.startSigningSession(aggNonce,hash,pubKeys);const partialSignatures=privKeys.map((sk,index)=>musig.partialSign({secretKey:getBytes(sk||""),publicNonce:nonces[index],sessionKey:signingSession,verify:true}));const finalSignature=musig.signAgg(partialSignatures,signingSession);return hexlify(finalSignature)}getPrivateKeyForTxInput(input){if(!input.pubkey)throw new Error("Missing public key for input");const address=computeAddress(input.pubkey);return this.getPrivateKey(address)}getPrivateKey(address){const addressInfo=this.locateAddressInfo(address);if(!addressInfo){throw new Error(`Address not found: ${address}`)}if(isHexString(addressInfo.derivationPath,32)){return addressInfo.derivationPath}if(addressInfo.derivationPath==="BIP44:external"||addressInfo.derivationPath==="BIP44:change"){const addressNode=this._getAddressNode(addressInfo.account,addressInfo.change,addressInfo.index);return addressNode.privateKey}else{const pcAddressInfo=addressInfo;const account=pcAddressInfo.account;const index=pcAddressInfo.index;const counterpartyPaymentCode=pcAddressInfo.derivationPath;if(!counterpartyPaymentCode){throw new Error("Counterparty payment code not found for payment channel address")}const bip32=BIP32Factory(ecc);const buf=bs58check.decode(counterpartyPaymentCode);const version=buf[0];if(version!==PC_VERSION)throw new Error("Invalid payment code version");const counterpartyPCodePublic=new PaymentCodePublic(ecc,bip32,buf.slice(1));const paymentCodePrivate=this._getPaymentCodePrivate(account);const paymentPrivateKey=paymentCodePrivate.derivePaymentPrivateKey(counterpartyPCodePublic,index);return hexlify(paymentPrivateKey)}}async scan(zone,account=0){this.validateZone(zone);this._addressesMap=new Map(Array.from(this._addressesMap.entries()).map(([key,addresses])=>[key,addresses.map(addr=>({...addr,status:AddressStatus.UNKNOWN,lastSyncedBlock:null}))]));this._availableOutpoints.clear();this._paymentCodeSendAddressMap=new Map(Array.from(this._paymentCodeSendAddressMap.keys()).map(key=>[key,[]]));await this._scan(zone,account)}async sync(zone,account=0,onOutpointsCreated,onOutpointsDeleted){this.validateZone(zone);await this._scan(zone,account,onOutpointsCreated,onOutpointsDeleted)}async _scan(zone,account=0,onOutpointsCreated,onOutpointsDeleted){if(!this.provider)throw new Error("Provider not set");const derivationPaths=["BIP44:external","BIP44:change",...this.openChannels];const currentBlock=await this.provider.getBlock(toShard(zone),"latest");for(const path of derivationPaths){await this._scanDerivationPath(path,zone,account,currentBlock,false,onOutpointsCreated,onOutpointsDeleted);await new Promise(resolve=>setTimeout(resolve,0))}await this._scanDerivationPath(QiHDWallet.PRIVATE_KEYS_PATH,zone,account,currentBlock,true,onOutpointsCreated,onOutpointsDeleted)}async _scanDerivationPath(path,zone,account,currentBlock,skipGap=false,onOutpointsCreated,onOutpointsDeleted){const addresses=this._addressesMap.get(path)||[];const updatedAddresses=[];const createdOutpoints={};const deletedOutpoints={};const previouslySyncedAddresses=[];const unsyncedAddresses=[];for(const addr of addresses){if(addr.lastSyncedBlock!==null){previouslySyncedAddresses.push(addr)}else{unsyncedAddresses.push(addr)}}if(previouslySyncedAddresses.length>0){const addressesByLastSyncedTxHash={};for(const addr of previouslySyncedAddresses){if(addr.lastSyncedBlock?.hash){if(!addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash]){addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash]=[addr.address]}else{addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash].push(addr.address)}}}const deltasBatches=await Promise.all(Object.entries(addressesByLastSyncedTxHash).map(([txHash,addresses])=>this.provider.getOutpointDeltas(addresses,txHash)));const deltas={};for(const deltaBatch of deltasBatches){for(const[address,delta]of Object.entries(deltaBatch)){if(!deltas[address]){deltas[address]={created:delta.created,deleted:delta.deleted}}else{deltas[address].created.push(...delta.created);deltas[address].deleted.push(...delta.deleted)}}}for(const[address,delta]of Object.entries(deltas)){const addressInfo=addresses.find(a=>a.address===address);const updatedAddressInfo={...addressInfo,lastSyncedBlock:{hash:currentBlock.hash,number:currentBlock.woHeader.number}};if(delta.created&&delta.created.length>0){this.importOutpoints(delta.created.map(outpoint=>({outpoint:outpoint,address:address,zone:zone,account:account})));createdOutpoints[address]=delta.created;updatedAddressInfo.status=AddressStatus.USED}if(delta.deleted&&delta.deleted.length>0){for(const outpoint of delta.deleted){this._availableOutpoints.delete(`${outpoint.txhash}:${outpoint.index}`)}deletedOutpoints[address]=delta.deleted}updatedAddresses.push(updatedAddressInfo)}}let consecutiveUnusedCount=0;if(unsyncedAddresses.length>0){const checkAddressUsePromises=unsyncedAddresses.map(addr=>this.checkAddressUse(addr.address));const checkResults=await Promise.all(checkAddressUsePromises);for(let i=0;i<unsyncedAddresses.length;i++){const addr=unsyncedAddresses[i];const{isUsed,outpoints}=checkResults[i];addr.status=isUsed?AddressStatus.USED:AddressStatus.UNUSED;addr.lastSyncedBlock={hash:currentBlock.hash,number:currentBlock.woHeader.number};if(outpoints.length>0){this.importOutpoints(outpoints.map(outpoint=>({outpoint:outpoint,address:addr.address,zone:addr.zone,account:addr.account})));createdOutpoints[addr.address]=outpoints}if(addr.status===AddressStatus.USED){consecutiveUnusedCount=0}else{consecutiveUnusedCount++}updatedAddresses.push(addr);if(consecutiveUnusedCount>=QiHDWallet._GAP_LIMIT)break}}if(!skipGap){while(consecutiveUnusedCount<QiHDWallet._GAP_LIMIT){const isChange=path.endsWith(":change");const remainingGap=QiHDWallet._GAP_LIMIT-consecutiveUnusedCount;const newAddresses=[];for(let i=0;i<remainingGap;i++){const newAddrInfo=path.includes("BIP44")?this._getNextQiAddress(account,zone,isChange):this.getNextReceiveAddress(path,zone,account);newAddresses.push(newAddrInfo)}const checkAddressUsePromises=newAddresses.map(addr=>this.checkAddressUse(addr.address));const checkResults=await Promise.all(checkAddressUsePromises);for(let i=0;i<newAddresses.length;i++){const newAddrInfo=newAddresses[i];const{isUsed,outpoints}=checkResults[i];newAddrInfo.status=isUsed?AddressStatus.USED:AddressStatus.UNUSED;newAddrInfo.lastSyncedBlock={hash:currentBlock.hash,number:currentBlock.woHeader.number};if(outpoints.length>0){this.importOutpoints(outpoints.map(outpoint=>({outpoint:outpoint,address:newAddrInfo.address,zone:newAddrInfo.zone,account:newAddrInfo.account})));createdOutpoints[newAddrInfo.address]=outpoints}if(newAddrInfo.status===AddressStatus.USED){consecutiveUnusedCount=0}else{consecutiveUnusedCount++}addresses.push(newAddrInfo);if(consecutiveUnusedCount>=QiHDWallet._GAP_LIMIT){break}}await new Promise(resolve=>setTimeout(resolve,0))}}const uniqueAddressMap=new Map;addresses.forEach(addr=>{const updatedAddr=updatedAddresses.find(a=>a.address===addr.address);uniqueAddressMap.set(addr.address,updatedAddr||addr)});const updatedAddressesForMap=Array.from(uniqueAddressMap.values());this._addressesMap.set(path,updatedAddressesForMap);const executeCreatedOutpointsCallback=async()=>{if(onOutpointsCreated&&Object.keys(createdOutpoints).length>0){try{await onOutpointsCreated(createdOutpoints)}catch(error){console.error(`Error in onOutpointsCreated callback: ${error.message}`)}}};const executeDeletedOutpointsCallback=async()=>{if(onOutpointsDeleted&&Object.keys(deletedOutpoints).length>0){try{await onOutpointsDeleted(deletedOutpoints)}catch(error){console.error(`Error in onOutpointsDeleted callback: ${error.message}`)}}};await Promise.all([executeCreatedOutpointsCallback(),executeDeletedOutpointsCallback()])}async getOutpointsByAddress(address){try{return await this.provider.getOutpointsByAddress(address)}catch(error){throw new Error(`Failed to get outpoints for address: ${address} - error: ${error}`)}}async checkAddressUse(address){let isUsed=false;let outpoints=[];try{outpoints=await this.getOutpointsByAddress(address);if(outpoints.length>0){isUsed=true}else if(this._addressUseChecker!==undefined&&await this._addressUseChecker(address)){isUsed=true}}catch(error){throw new Error(`Failed to get outpoints for address: ${address} - error: ${error}`)}return{isUsed:isUsed,outpoints:outpoints}}getAddressesForZone(zone){this.validateZone(zone);return this._addressesMap.get("BIP44:external")?.filter(addressInfo=>addressInfo.zone===zone)||[]}getChangeAddressesForZone(zone){this.validateZone(zone);return this._addressesMap.get("BIP44:change")?.filter(addressInfo=>addressInfo.zone===zone)||[]}getGapAddressesForZone(zone){this.validateZone(zone);const gapAddresses=this._addressesMap.get("BIP44:external")||[];return gapAddresses.filter(addressInfo=>addressInfo.zone===zone&&addressInfo.status===AddressStatus.UNUSED)}getGapChangeAddressesForZone(zone){this.validateZone(zone);const gapChangeAddresses=this._addressesMap.get("BIP44:change")||[];return gapChangeAddresses.filter(addressInfo=>addressInfo.zone===zone&&addressInfo.status===AddressStatus.UNUSED)}getPaymentChannelAddressesForZone(paymentCode,zone){return this._addressesMap.get(paymentCode)?.filter(addressInfo=>addressInfo.zone===zone)||[]}getGapPaymentChannelAddressesForZone(paymentCode,zone){return this._addressesMap.get(paymentCode)?.filter(addressInfo=>addressInfo.status===AddressStatus.UNUSED&&addressInfo.zone===zone)||[]}async signMessage(address,message){const privKey=this.getPrivateKey(address);const messageBytes=typeof message==="string"?getBytes(toUtf8Bytes(message)):message;const digest=keccak256(messageBytes);const digestBytes=getBytes(digest);const signature=schnorr.sign(digestBytes,getBytes(privKey));return hexlify(signature)}serialize(){const hdwalletSerialized=super.serialize();return{...hdwalletSerialized,addresses:Array.from(this._addressesMap.values()).flatMap(addresses=>addresses),senderPaymentCodeInfo:Object.fromEntries(Array.from(this._paymentCodeSendAddressMap.entries()).map(([key,value])=>[key,Array.from(value)]))}}static async deserialize(serialized){super.validateSerializedWallet(serialized);const mnemonic=Mnemonic.fromPhrase(serialized.phrase);const path=this.parentPath(serialized.coinType);const root=HDNodeWallet.fromMnemonic(mnemonic,path);const wallet=new this(_guard,root);for(const addressInfo of serialized.addresses){let key=addressInfo.derivationPath;if(isHexString(key,32)){key=QiHDWallet.PRIVATE_KEYS_PATH}else if(key.includes("BIP44")){wallet.validateAddressInfo(addressInfo)}else{wallet.validateBaseAddressInfo(addressInfo);wallet.validateExtendedProperties(addressInfo)}const existingAddresses=wallet._addressesMap.get(key);if(!existingAddresses){wallet._addressesMap.set(key,[addressInfo])}else if(!existingAddresses.some(addr=>addr.address===addressInfo.address)){existingAddresses.push(addressInfo)}}for(const[paymentCode,paymentCodeInfoArray]of Object.entries(serialized.senderPaymentCodeInfo)){if(!validatePaymentCode(paymentCode)){throw new Error(`Invalid payment code: ${paymentCode}`)}for(const pcInfo of paymentCodeInfoArray){wallet.validateBaseAddressInfo(pcInfo);wallet.validateExtendedProperties(pcInfo)}wallet._paymentCodeSendAddressMap.set(paymentCode,paymentCodeInfoArray)}return wallet}validateAddressDerivation(info){const addressNode=this._getAddressNode(info.account,info.change,info.index);if(addressNode.address!==info.address){throw new Error(`Address mismatch: derived ${addressNode.address} but got ${info.address}`)}if(addressNode.publicKey!==info.pubKey){throw new Error(`Public key mismatch: derived ${addressNode.publicKey} but got ${info.pubKey}`)}const zone=getZoneForAddress(addressNode.address);if(!zone||zone!==info.zone){throw new Error(`Zone mismatch: derived ${zone} but got ${info.zone}`)}if(!isQiAddress(addressNode.address)){throw new Error(`Address ${addressNode.address} is not a valid Qi address`)}}validateExtendedProperties(info){if(!Object.values(AddressStatus).includes(info.status)){throw new Error(`Invalid status: ${info.status}`)}if(typeof info.derivationPath!=="string"||!info.derivationPath){throw new Error(`Invalid derivation path: ${info.derivationPath}`)}this.validateDerivationPath(info.derivationPath,info.change);if(info.lastSyncedBlock&&!isHexString(info.lastSyncedBlock.hash,32)){throw new Error(`Invalid last synced block hash: ${info.lastSyncedBlock.hash}`)}if(info.lastSyncedBlock&&(typeof info.lastSyncedBlock.number!=="number"||info.lastSyncedBlock.number<0)){throw new Error(`Invalid last synced block number: ${info.lastSyncedBlock.number}`)}}validateDerivationPath(path,isChange){if(path==="BIP44:external"||path==="BIP44:change"){const expectedPath=isChange?"BIP44:change":"BIP44:external";if(path!==expectedPath){throw new Error(`BIP44 path mismatch: address marked as ${isChange?"change":"external"} `+`but has path ${path}`)}return}if(path===QiHDWallet.PRIVATE_KEYS_PATH){if(isChange){throw new Error("Imported private key addresses cannot be change addresses")}return}if(!validatePaymentCode(path)){throw new Error(`Invalid derivation path: must be 'BIP44:external', 'BIP44:change', `+`'${QiHDWallet.PRIVATE_KEYS_PATH}', or a valid payment code. Got: ${path}`)}if(isChange){throw new Error("Payment code addresses cannot be change addresses")}}validateOutpointInfo(outpointInfo){outpointInfo.forEach(info=>{this.validateZone(info.zone);this.validateAddressAndAccount(info.address,info.account);if(info.outpoint.txhash==null||info.outpoint.index==null||info.outpoint.denomination==null){throw new Error(`Invalid Outpoint: ${JSON.stringify(info)} `)}})}validateAddressAndAccount(address,account){const addressInfo=this.locateAddressInfo(address);if(!addressInfo){throw new Error(`Address ${address} not found in wallet`)}if(account&&account!==addressInfo.account){throw new Error(`Address ${address} does not match account ${account}`)}}getPaymentCode(account=0){const privatePcode=this._getPaymentCodePrivate(account);return privatePcode.toBase58()}_getPaymentCodePrivate(account){const bip32=BIP32Factory(ecc);const accountNode=this._root.deriveChild(account+HARDENED_OFFSET);const pc=new Uint8Array(80);pc.set([1,0]);const pubKey=accountNode.publicKey;pc.set(getBytes(pubKey),2);const chainCode=accountNode.chainCode;pc.set(getBytes(chainCode),35);const adapter=new HDNodeBIP32Adapter(accountNode);return new PaymentCodePrivate(adapter,ecc,bip32,pc)}getNextSendAddress(receiverPaymentCode,zone,account=0){const bip32=BIP32Factory(ecc);const buf=bs58check.decode(receiverPaymentCode);const version=buf[0];if(version!==PC_VERSION)throw new Error("Invalid payment code version");const walletPCodePrivate=this._getPaymentCodePrivate(account);const receiverPCodePublic=new PaymentCodePublic(ecc,bip32,buf.slice(1));const paymentCodeInfoArray=this._paymentCodeSendAddressMap.get(receiverPaymentCode);const lastIndex=this._findLastUsedIndex(paymentCodeInfoArray,account,zone);let addrIndex=lastIndex+1;for(let attempts=0;attempts<MAX_ADDRESS_DERIVATION_ATTEMPTS;attempts++){const address=receiverPCodePublic.getPaymentAddress(walletPCodePrivate,addrIndex);if(this.isValidAddressForZone(address,zone)){const pubkey=receiverPCodePublic.derivePaymentPublicKey(walletPCodePrivate,addrIndex);const pcInfo={address:address,pubKey:hexlify(pubkey),index:addrIndex,account:account,zone:zone,change:false,status:AddressStatus.UNKNOWN,derivationPath:receiverPaymentCode,lastSyncedBlock:null};if(paymentCodeInfoArray){paymentCodeInfoArray.push(pcInfo)}else{this._paymentCodeSendAddressMap.set(receiverPaymentCode,[pcInfo])}return pcInfo}addrIndex++}throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`)}getNextReceiveAddress(senderPaymentCode,zone,account=0){const bip32=BIP32Factory(ecc);const buf=bs58check.decode(senderPaymentCode);const version=buf[0];if(version!==PC_VERSION)throw new Error("Invalid payment code version");const senderPCodePublic=new PaymentCodePublic(ecc,bip32,buf.slice(1));const walletPCodePrivate=this._getPaymentCodePrivate(account);const paymentCodeInfoArray=this._addressesMap.get(senderPaymentCode);const lastIndex=this._findLastUsedIndex(paymentCodeInfoArray,account,zone);let addrIndex=lastIndex+1;for(let attempts=0;attempts<MAX_ADDRESS_DERIVATION_ATTEMPTS;attempts++){const address=walletPCodePrivate.getPaymentAddress(senderPCodePublic,addrIndex);if(this.isValidAddressForZone(address,zone)){const pubkey=walletPCodePrivate.derivePaymentPublicKey(senderPCodePublic,addrIndex);const pcInfo={address:address,pubKey:hexlify(pubkey),index:addrIndex,account:account,zone:zone,change:false,status:AddressStatus.UNKNOWN,derivationPath:senderPaymentCode,lastSyncedBlock:null};if(paymentCodeInfoArray){paymentCodeInfoArray.push(pcInfo)}else{this._addressesMap.set(senderPaymentCode,[pcInfo])}return pcInfo}addrIndex++}throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`)}openChannel(paymentCode){if(!validatePaymentCode(paymentCode)){throw new Error(`Invalid payment code: ${paymentCode}`)}if(!this._addressesMap.has(paymentCode)){this._addressesMap.set(paymentCode,[])}if(!this._paymentCodeSendAddressMap.has(paymentCode)){this._paymentCodeSendAddressMap.set(paymentCode,[])}}channelIsOpen(paymentCode){return this._addressesMap.has(paymentCode)&&this._paymentCodeSendAddressMap.has(paymentCode)}getAddressInfo(address){const externalAddressInfo=this._addressesMap.get("BIP44:external")?.find(addr=>addr.address===address);if(!externalAddressInfo){return null}return externalAddressInfo}getChangeAddressInfo(address){const changeAddressInfo=this._addressesMap.get("BIP44:change")?.find(addr=>addr.address===address);if(!changeAddressInfo){return null}return changeAddressInfo}async importPrivateKey(privateKey){if(!isHexString(privateKey,32)){throw new Error(`Invalid private key format: must be 32-byte hex string (got ${privateKey})`)}const pubKey=SigningKey.computePublicKey(privateKey,true);const address=computeAddress(pubKey);const addressZone=getZoneForAddress(address);if(!addressZone){throw new Error(`Private key does not correspond to a valid address for any zone (got ${address})`)}if(!isQiAddress(address)){throw new Error(`Private key does not correspond to a valid Qi address (got ${address})`)}for(const[path,addresses]of this._addressesMap.entries()){if(addresses.some(info=>info.address===address)){throw new Error(`Address ${address} already exists in wallet under path ${path}`)}}const addressInfo={pubKey:pubKey,address:address,account:0,index:-1,change:false,zone:addressZone,status:AddressStatus.UNUSED,derivationPath:privateKey,lastSyncedBlock:null};this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH).push(addressInfo);return addressInfo}getImportedAddresses(zone){const importedAddresses=this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH)||[];if(zone!==undefined){this.validateZone(zone);return importedAddresses.filter(info=>info.zone===zone)}return[...importedAddresses]}addAddress(account,addressIndex){if(account<0||addressIndex<0){throw new Error("Account and address index must be non-negative integers")}return this._addAddress(account,addressIndex,false)}addChangeAddress(account,addressIndex){if(account<0||addressIndex<0){throw new Error("Account and address index must be non-negative integers")}return this._addAddress(account,addressIndex,true)}_addAddress(account,addressIndex,isChange){const derivationPath=isChange?"BIP44:change":"BIP44:external";const existingAddresses=this._addressesMap.get(derivationPath)||[];if(existingAddresses.some(info=>info.index===addressIndex)){throw new Error(`Address index ${addressIndex} already exists in wallet under path ${derivationPath}`)}const addressNode=this._getAddressNode(account,isChange,addressIndex);const zone=getZoneForAddress(addressNode.address);if(!zone){throw new Error(`Failed to derive a Qi valid address zone for the index ${addressIndex}`)}if(!isQiAddress(addressNode.address)){throw new Error(`Address ${addressNode.address} is not a valid Qi address`)}return this._createAndStoreQiAddressInfo(addressNode,account,zone,isChange)}getAddressesForAccount(account){const addresses=this._addressesMap.values();return Array.from(addresses).flat().filter(info=>info.account===account)}}const Networks=new Map;class Network{#name;#chainId;constructor(name,chainId){this.#name=name;this.#chainId=getBigInt(chainId)}toJSON(){return{name:this.name,chainId:String(this.chainId)}}get name(){return this.#name}set name(value){this.#name=value}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value,"chainId")}matches(other){if(other==null){return false}if(typeof other==="string"){try{return this.chainId===getBigInt(other)}catch(error){}return this.name===other}if(typeof other==="number"||typeof other==="bigint"){try{return this.chainId===getBigInt(other)}catch(error){}return false}if(typeof other==="object"){if(other.chainId!=null){try{return this.chainId===getBigInt(other.chainId)}catch(error){}return false}if(other.name!=null){return this.name===other.name}return false}return false}clone(){const clone=new Network(this.name,this.chainId);return clone}static from(network){if(network==null){return Network.from("mainnet")}if(typeof network==="number"){network=BigInt(network)}if(typeof network==="string"||typeof network==="bigint"){const networkFunc=Networks.get(network);if(networkFunc){return networkFunc()}if(typeof network==="bigint"){return new Network("unknown",network)}assertArgument(false,"unknown network","network",network)}if(typeof network.clone==="function"){const clone=network.clone();return clone}if(typeof network==="object"){assertArgument(typeof network.name==="string"&&typeof network.chainId==="number","invalid network object name or chainId","network",network);const custom=new Network(network.name,network.chainId);return custom}assertArgument(false,"invalid network","network",network)}static register(nameOrChainId,networkFunc){if(typeof nameOrChainId==="number"){nameOrChainId=BigInt(nameOrChainId)}const existing=Networks.get(nameOrChainId);if(existing){assertArgument(false,`conflicting network for ${JSON.stringify(existing.name)}`,"nameOrChainId",nameOrChainId)}Networks.set(nameOrChainId,networkFunc)}}function copy$2(obj){return JSON.parse(JSON.stringify(obj))}class PollingBlockSubscriber{#provider;#poller;#interval;#zone;#blockNumber;constructor(provider,zone){this.#provider=provider;this.#zone=zone;this.#poller=null;this.#interval=4e3;this.#blockNumber=-2}get pollingInterval(){return this.#interval}set pollingInterval(value){this.#interval=value}async#poll(){try{const blockNumber=await this.#provider.getBlockNumber(toShard(this.#zone));if(this.#blockNumber===-2){this.#blockNumber=blockNumber;return}if(blockNumber!==this.#blockNumber){for(let b=this.#blockNumber+1;b<=blockNumber;b++){if(this.#poller==null){return}await this.#provider.emit("block",this.#zone,b)}this.#blockNumber=blockNumber}}catch(error){}if(this.#poller==null){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval)}start(){if(this.#poller){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval);this.#poll()}stop(){if(!this.#poller){return}this.#provider._clearTimeout(this.#poller);this.#poller=null}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}class OnBlockSubscriber{#provider;#poll;#running;#zone;constructor(provider,zone){this.#provider=provider;this.#zone=zone;this.#running=false;this.#poll=blockNumber=>{this._poll(blockNumber,this.#provider)}}async _poll(blockNumber,provider){throw new Error("sub-classes must override this")}start(){if(this.#running){return}this.#running=true;this.#poll(-2);this.#provider.on("block",this.#poll,this.#zone)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off("block",this.#poll,this.#zone)}pause(dropWhilePaused){this.stop()}resume(){this.start()}}class PollingOrphanSubscriber extends OnBlockSubscriber{#filter;constructor(provider,filter,zone){super(provider,zone);this.#filter=copy$2(filter)}async _poll(blockNumber,provider){throw new Error("@TODO")}}class PollingTransactionSubscriber extends OnBlockSubscriber{#hash;constructor(provider,hash,zone){super(provider,zone);this.#hash=hash}async _poll(blockNumber,provider){const tx=await provider.getTransactionReceipt(this.#hash);if(tx){provider.emit(this.#hash,toZone(this.#hash.slice(0,4)),tx)}}}class PollingQiTransactionSubscriber extends OnBlockSubscriber{#hash;constructor(provider,hash,zone){super(provider,zone);this.#hash=hash}async _poll(blockNumber,provider){const tx=await provider.getTransaction(this.#hash);if(tx&&tx.isMined()){provider.emit(this.#hash,toZone(this.#hash.slice(0,4)),tx)}}}class PollingEventSubscriber{#provider;#filter;#poller;#running;#blockNumber;#zone;constructor(provider,filter){this.#provider=provider;this.#filter=copy$2(filter);this.#poller=this.#poll.bind(this);this.#running=false;this.#blockNumber=-2;const zone=getZoneFromEventFilter(this.#filter);if(zone){this.#zone=zone}else{throw new Error("Unable to determine zone for event filter")}}async#poll(blockNumber){if(this.#blockNumber===-2){return}const filter=copy$2(this.#filter);filter.fromBlock=this.#blockNumber+1;filter.toBlock=blockNumber;const logs=await this.#provider.getLogs(filter);if(logs.length===0){if(this.#blockNumber<blockNumber-60){this.#blockNumber=blockNumber-60}return}for(const log of logs){this.#provider.emit(this.#filter,getZoneFromNodeLocation(this.#filter.nodeLocation),log);this.#blockNumber=log.blockNumber}}start(){if(this.#running){return}this.#running=true;if(this.#blockNumber===-2){this.#provider.getBlockNumber(toShard(this.#zone)).then(blockNumber=>{this.#blockNumber=blockNumber})}this.#provider.on("block",this.#poller,this.#zone)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off("block",this.#poller,this.#zone)}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}function isPromise(value){return value&&typeof value.then==="function"}function getTag(prefix,value){return prefix+":"+JSON.stringify(value,(k,v)=>{if(v==null){return"null"}if(typeof v==="bigint"){return`bigint:${v.toString()}`}if(typeof v==="string"){return v.toLowerCase()}if(typeof v==="object"&&!Array.isArray(v)){const keys=Object.keys(v);keys.sort();return keys.reduce((accum,key)=>{accum[key]=v[key];return accum},{})}return v})}class UnmanagedSubscriber{name;constructor(name){defineProperties(this,{name:name})}start(){}stop(){}pause(dropWhilePaused){}resume(){}}function copy$1(value){return JSON.parse(JSON.stringify(value))}function concisify(items){items=Array.from(new Set(items).values());items.sort();return items}async function getSubscription(_event,zone){if(_event==null){throw new Error("invalid event")}if(Array.isArray(_event)){_event={topics:_event}}if(typeof _event==="string"){if(_event==="debug"){return{type:_event,tag:_event}}switch(_event){case"block":case"pending":if(!zone){throw new Error("zone is required for block and pending events")}return{type:"block",tag:_event,zone:zone};case"error":case"finalized":case"network":case"safe":{return{type:_event,tag:_event}}}}if(isHexString(_event,32)){const eventBytes=getBytes(_event);const ninthBit=(eventBytes[1]&128)===128;const hash=_event.toLowerCase();zone=toZone(hash.slice(0,4));if(ninthBit){return{type:"qiTransaction",tag:getTag("Tx",{hash:hash}),hash:hash,zone:zone}}else{return{type:"transaction",tag:getTag("tx",{hash:hash}),hash:hash,zone:zone}}}if(_event.orphan){const event=_event;if(!zone){const hash=event.hash||event.tx.hash||event.other?.hash||event.log.transactionHash||null;if(hash==null){throw new Error("orphan event must specify a hash")}zone=toZone(hash.slice(0,4))}return{type:"orphan",tag:getTag("orphan",event),filter:copy$1(event),zone:zone}}if(_event.type&&_event.address){const address=formatMixedCaseChecksumAddress(isHexString(_event.address)?_event.address:await resolveAddress(_event.address));const filter={type:_event.type,address:address};if(!zone){zone=toZone(address.slice(0,4))}return{filter:filter,tag:getTag("accesses",filter),type:"accesses",zone:zone}}else if(_event.topics||_event.address){const event=_event;const filter={topics:(event.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()})};if(event.nodeLocation){filter.nodeLocation=event.nodeLocation}if(event.address){const addresses=[];const promises=[];const addAddress=addr=>{if(isHexString(addr)){addresses.push(formatMixedCaseChecksumAddress(addr))}else{promises.push((async()=>{addresses.push(formatMixedCaseChecksumAddress(await resolveAddress(addr)))})())}};if(Array.isArray(event.address)){event.address.forEach(addAddress)}else{addAddress(event.address)}if(promises.length){await Promise.all(promises)}if(!zone){zone=toZone(addresses[0].slice(0,4))}filter.address=concisify(addresses.map(a=>a.toLowerCase()));if(!filter.nodeLocation){filter.nodeLocation=getNodeLocationFromZone(zone)}}else{if(!zone){throw new Error("zone is required for event")}}return{filter:filter,tag:getTag("event",filter),type:"event",zone:zone}}assertArgument(false,"unknown ProviderEvent","event",_event)}function getTime(){return(new Date).getTime()}const defaultOptions$1={cacheTimeout:250,pollingInterval:4e3,usePathing:true};class AbstractProvider{_urlMap;#connect;#subs;#pausedState;#destroyed;#networkPromise;#anyNetwork;#performCache;#lastBlockNumber;#nextTimer;#timers;#options;_initFailed;initResolvePromise;initRejectPromise;initPromise;attemptConnect;constructor(_network,options){this._initFailed=false;this.attemptConnect=true;this.#options=Object.assign({},defaultOptions$1,options||{});if(_network==="any"){this.#anyNetwork=true;this.#networkPromise=null}else if(_network){const network=Network.from(_network);this.#anyNetwork=false;this.#networkPromise=Promise.resolve(network);setTimeout(()=>{this.emit("network",undefined,network,null)},0)}else{this.#anyNetwork=false;this.#networkPromise=null}this.#lastBlockNumber=-1;this.#performCache=new Map;this.#subs=new Map;this.#pausedState=null;this.#destroyed=false;this.#nextTimer=1;this.#timers=new Map;this.#connect=[];this._urlMap=new Map;this.initResolvePromise=null;this.initRejectPromise=null;this.initPromise=new Promise((resolve,reject)=>{this.initResolvePromise=resolve;this.initRejectPromise=reject})}async initialize(urls){this.initPromise=new Promise((resolve,reject)=>{this.initResolvePromise=resolve;this.initRejectPromise=reject});try{const primeSuffix=this.#options.usePathing?`/${fromShard(Shard.Prime,"nickname")}`:":9001";if(urls instanceof FetchRequest){urls.url=urls.url.split(":")[0]+":"+urls.url.split(":")[1]+primeSuffix;this._urlMap.set(Shard.Prime,urls);this.#connect.push(urls);const shards=await this._waitGetRunningLocations(Shard.Prime,true);shards.forEach(shard=>{const port=9200+20*shard[0]+shard[1];const shardEnum=toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);const shardSuffix=this.#options.usePathing?`/${fromShard(shardEnum,"nickname")}`:`:${port}`;this._urlMap.set(shardEnum,new FetchRequest(urls.url.split(":")[0]+":"+urls.url.split(":")[1]+shardSuffix))});return}if(Array.isArray(urls)){for(const url of urls){const primeUrl=url.split(":")[0]+":"+url.split(":")[1]+primeSuffix;const primeConnect=new FetchRequest(primeUrl);this._urlMap.set(Shard.Prime,primeConnect);this.#connect.push(primeConnect);const shards=await this._waitGetRunningLocations(Shard.Prime,true);shards.forEach(shard=>{const port=9200+20*shard[0]+shard[1];const shardEnum=toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);const shardSuffix=this.#options.usePathing?`/${fromShard(shardEnum,"nickname")}`:`:${port}`;this._urlMap.set(toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`),new FetchRequest(url.split(":")[0]+":"+url.split(":")[1]+shardSuffix))})}}if(this.initResolvePromise)this.initResolvePromise()}catch(error){this._initFailed=true;console.log("Error initializing URL map:",error);if(this.initRejectPromise)this.initRejectPromise(error)}}get connect(){return this.#connect}async zoneFromAddress(_address){const address=this._getAddress(_address);return toZone((await address).slice(0,4))}shardFromHash(hash){return toShard(hash.slice(0,4))}zoneFromHash(hash){return toZone(hash.slice(0,4))}async getLatestQuaiRate(zone,amt){const blockNumber=await this.getBlockNumber(toShard(zone));return this.getQuaiRateAtBlock(zone,blockNumber,amt)}async getQuaiRateAtBlock(zone,blockTag,amt){let resolvedBlockTag=this._getBlockTag(toShard(zone),blockTag);if(typeof resolvedBlockTag!=="string"){resolvedBlockTag=await resolvedBlockTag}return getBigInt(await this.#perform({method:"getQuaiRateAtBlock",blockTag:resolvedBlockTag,amt:toQuantity(String(amt)),zone:zone}))}async getProtocolExpansionNumber(){return getNumber(await this.#perform({method:"getProtocolExpansionNumber"}))}async getActiveRegions(){const protocolExpansionNumber=await this.getProtocolExpansionNumber();const shards=[Shard.Cyprus];if(protocolExpansionNumber>=1){shards.push(Shard.Paxos)}if(protocolExpansionNumber>=3){shards.push(Shard.Hydra)}return shards.sort((a,b)=>a.localeCompare(b))}async getActiveZones(){const protocolExpansionNumber=await this.getProtocolExpansionNumber();const zones=[Zone.Cyprus1];if(protocolExpansionNumber>=1){zones.push(Zone.Cyprus2)}if(protocolExpansionNumber>=2){zones.push(Zone.Paxos1,Zone.Paxos2)}if(protocolExpansionNumber>=3){zones.push(Zone.Cyprus3,Zone.Paxos3,Zone.Hydra1,Zone.Hydra2,Zone.Hydra3)}return zones.sort((a,b)=>a.localeCompare(b))}async getLatestQiRate(zone,amt){const blockNumber=await this.getBlockNumber(toShard(zone));return this.getQiRateAtBlock(zone,blockNumber,amt)}async getQiRateAtBlock(zone,blockTag,amt){let resolvedBlockTag=this._getBlockTag(toShard(zone),blockTag);if(typeof resolvedBlockTag!=="string"){resolvedBlockTag=await resolvedBlockTag}return getBigInt(await this.#perform({method:"getQiRateAtBlock",blockTag:resolvedBlockTag,amt:toQuantity(String(amt)),zone:zone}))}get pollingInterval(){return this.#options.pollingInterval}get provider(){return this}async#perform(req){this.attemptConnect=true;const timeout=this.#options.cacheTimeout;if(timeout<0){return await this._perform(req)}const tag=getTag(req.method,req);let perform=this.#performCache.get(tag);if(!perform||tag.includes("pending")||tag.includes("latest")){perform=this._perform(req);this.#performCache.set(tag,perform);setTimeout(()=>{if(this.#performCache.get(tag)===perform){this.#performCache.delete(tag)}},timeout)}return await perform}_wrapBlock(value,network){return new Block(formatBlock(value),this)}_wrapLog(value,network){return new Log(formatLog(value),this)}_wrapTransactionReceipt(value,network){const formattedReceipt=formatTransactionReceipt(value);return new TransactionReceipt(formattedReceipt,this)}_wrapTransactionResponse(tx,network){try{const formattedTx=formatTransactionResponse(tx);if(tx.type==="0x0"||tx.type===0){return new QuaiTransactionResponse(formattedTx,this)}else if(tx.type==="0x1"||tx.type===1){return new ExternalTransactionResponse(formattedTx,this)}else if(tx.type==="0x2"||tx.type===2){return new QiTransactionResponse(formattedTx,this)}else{throw new Error(`Unknown transaction type: ${tx.type}`)}}catch(error){console.error("Error in _wrapTransactionResponse:",error);throw error}}_detectNetwork(){assert$1(false,"sub-classes must implement this","UNSUPPORTED_OPERATION",{operation:"_detectNetwork"})}async _perform(req){assert$1(false,`unsupported method: ${req.method}`,"UNSUPPORTED_OPERATION",{operation:req.method,info:req})}async getBlockNumber(shard){const blockNumber=getNumber(await this.#perform({method:"getBlockNumber",shard:shard}),"%response");if(this.#lastBlockNumber>=0){this.#lastBlockNumber=blockNumber}return blockNumber}_getAddress(address){return resolveAddress(address)}_getBlockTag(shard,blockTag){if(blockTag==null){return"latest"}switch(blockTag){case"earliest":return"0x0";case"finalized":case"latest":case"pending":case"safe":return blockTag}if(isHexString(blockTag)){if(isHexString(blockTag,32)){return blockTag}return toQuantity(blockTag)}if(typeof blockTag==="bigint"){blockTag=getNumber(blockTag,"blockTag")}if(typeof blockTag==="number"){if(blockTag>=0){return toQuantity(blockTag)}if(this.#lastBlockNumber>=0){return toQuantity(this.#lastBlockNumber+blockTag)}return this.getBlockNumber(shard).then(b=>toQuantity(b+blockTag))}assertArgument(false,"invalid blockTag","blockTag",blockTag)}_getFilter(filter){const topics=(filter.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()});const blockHash="blockHash"in filter?filter.blockHash:undefined;const resolve=(_address,fromBlock,toBlock,nodeLocation)=>{let address=undefined;switch(_address.length){case 0:break;case 1:address=_address[0];break;default:_address.sort();address=_address}if(blockHash){if(fromBlock!=null||toBlock!=null){throw new Error("invalid filter")}}const filter={};if(address){filter.address=address}if(topics.length){filter.topics=topics}if(fromBlock){filter.fromBlock=fromBlock}if(toBlock){filter.toBlock=toBlock}if(blockHash){filter.blockHash=blockHash}if(nodeLocation){filter.nodeLocation=nodeLocation}return filter};const address=[];if(filter.address){if(Array.isArray(filter.address)){for(const addr of filter.address){address.push(this._getAddress(addr))}}else{address.push(this._getAddress(filter.address))}}const zone=getZoneFromNodeLocation(filter.nodeLocation);let fromBlock=undefined;if("fromBlock"in filter){fromBlock=this._getBlockTag(toShard(zone),filter.fromBlock)}let toBlock=undefined;if("toBlock"in filter){toBlock=this._getBlockTag(toShard(zone),filter.toBlock)}let nodeLocation=undefined;if(filter.nodeLocation){nodeLocation=filter.nodeLocation}if(address.filter(a=>typeof a!=="string").length||fromBlock!=null&&typeof fromBlock!=="string"||toBlock!=null&&typeof toBlock!=="string"){return Promise.all([Promise.all(address),fromBlock,toBlock,nodeLocation]).then(result=>{return resolve(result[0],result[1],result[2],result[3])})}return resolve(address,fromBlock,toBlock,nodeLocation)}_getTransactionRequest(_request){const request=copyRequest(_request);const promises=[];["to","from","inputs","outputs"].forEach(key=>{if(request[key]==null){return}const addr=Array.isArray(request[key])?"address"in request[key][0]?request[key].map(it=>it.address):request[key].map(it=>computeAddress(it.pubkey)):resolveAddress(request[key]);if(isPromise(addr)){if(Array.isArray(addr)){for(let i=0;i<addr.length;i++){promises.push(async function(){request[key][i].address=await addr[i]}())}}else{promises.push(async function(){request[key]=await addr}())}}else{request[key]=addr}});if(request.blockTag!=null){const getBlockTag=async()=>{const zone=await this.zoneFromAddress(addressFromTransactionRequest(_request));const shard=toShard(zone);const blockTag=this._getBlockTag(shard,request.blockTag);if(isPromise(blockTag)){return await blockTag}return blockTag};promises.push(async function(){request.blockTag=await getBlockTag()}())}if(promises.length){return async function(){await Promise.all(promises);return request}()}return request}async getNetwork(){if(this.#networkPromise==null){const detectNetwork=(async()=>{try{const network=await this._detectNetwork();this.emit("network",undefined,network,null);return network}catch(error){if(this.#networkPromise===detectNetwork){this.#networkPromise=null}throw error}})();this.#networkPromise=detectNetwork;return(await detectNetwork).clone()}const networkPromise=this.#networkPromise;const[expected,actual]=await Promise.all([networkPromise,this._detectNetwork()]);if(expected.chainId!==actual.chainId){if(this.#anyNetwork){this.emit("network",undefined,actual,expected);if(this.#networkPromise===networkPromise){this.#networkPromise=Promise.resolve(actual)}}else{assert$1(false,`network changed: ${expected.chainId} => ${actual.chainId} `,"NETWORK_ERROR",{event:"changed"})}}return expected.clone()}async _waitGetRunningLocations(shard,now){let retries=0;let locations=[];while(true){try{if(this.attemptConnect){if(retries>5){retries=0}locations=await this._getRunningLocations(shard,now);break}else{await new Promise(resolve=>setTimeout(resolve,1e3))}}catch(error){retries++;if(retries>5){this.attemptConnect=false}await new Promise(resolve=>setTimeout(resolve,1e3))}}if(locations.length===0){throw new Error("could not get running locations")}return locations}async _getRunningLocations(shard,now){now=now?now:false;return await this.#perform(shard?{method:"getRunningLocations",shard:shard,now:now}:{method:"getRunningLocations",now:now})}async getRunningLocations(shard){return await this._getRunningLocations(shard)}async getProtocolTrieExpansionCount(shard){return await this.#perform({method:"getProtocolTrieExpansionCount",shard:shard})}async getFeeData(zone,txType=true){const getFeeDataFunc=async()=>{const{gasPrice,minerTip}=await resolveProperties({gasPrice:(async()=>{try{const value=await this.#perform({method:"getGasPrice",txType:txType,zone:zone});return getBigInt(value,"%response")}catch(error){console.log(error)}return null})(),minerTip:(async()=>{try{const value=txType?await this.#perform({method:"getMinerTip",zone:zone}):0;return getBigInt(value,"%response")}catch(error){}return null})()});if(gasPrice==null){throw new Error("could not determine gasPrice")}let baseMinerTip=null;baseMinerTip=minerTip!=null?minerTip:BigInt("1000000000");return new FeeData(gasPrice,baseMinerTip)};return await getFeeDataFunc()}async estimateGas(_tx){let tx=this._getTransactionRequest(_tx);if(isPromise(tx)){tx=await tx}const zone=await this.zoneFromAddress(addressFromTransactionRequest(tx));return getBigInt(await this.#perform({method:"estimateGas",transaction:tx,zone:zone}),"%response")*BigInt(2)}async estimateFeeForQi(_tx){const zone=await this.zoneFromAddress(addressFromTransactionRequest(_tx));return getBigInt(await this.#perform({method:"estimateFeeForQi",transaction:_tx,zone:zone}),"%response")}async createAccessList(_tx){let tx=this._getTransactionRequest(_tx);if(isPromise(tx)){tx=await tx}const zone=await this.zoneFromAddress(addressFromTransactionRequest(tx));return(await this.#perform({method:"createAccessList",transaction:tx,zone:zone})).accessList}async#call(tx,blockTag,attempt,zone){const transaction=copyRequest(tx);return hexlify(await this._perform({method:"call",transaction:transaction,blockTag:blockTag,zone:zone}))}async#checkNetwork(promise,shard){const{value}=await resolveProperties({network:this.getNetwork(),value:promise});return value}async call(_tx){const zone=await this.zoneFromAddress(addressFromTransactionRequest(_tx));const shard=toShard(zone);const{tx,blockTag}=await resolveProperties({tx:this._getTransactionRequest(_tx),blockTag:this._getBlockTag(shard,_tx.blockTag)});return await this.#checkNetwork(this.#call(tx,blockTag,-1,zone),shard)}async#getAccountValue(request,_address,_blockTag){let address=this._getAddress(_address);const zone=await this.zoneFromAddress(_address);const shard=toShard(zone);let blockTag=this._getBlockTag(shard,_blockTag);if(typeof address!=="string"||typeof blockTag!=="string"){[address,blockTag]=await Promise.all([address,blockTag])}return await this.#checkNetwork(this.#perform(Object.assign(request,{address:address,blockTag:blockTag,zone:zone})),shard)}async getBalance(address,blockTag){return getBigInt(await this.#getAccountValue({method:"getBalance"},address,blockTag),"%response")}async getLockedBalance(address){return getBigInt(await this.#getAccountValue({method:"getLockedBalance"},address),"%response")}async getOutpointsByAddress(address){return formatOutpoints(await this.#getAccountValue({method:"getOutpointsByAddress"},address,"latest"))}async getTransactionCount(address,blockTag){return getNumber(await this.#getAccountValue({method:"getTransactionCount"},address,blockTag),"%response")}async getCode(address,blockTag){return hexlify(await this.#getAccountValue({method:"getCode"},address,blockTag))}async getStorage(address,_position,blockTag){const position=getBigInt(_position,"position");return hexlify(await this.#getAccountValue({method:"getStorage",position:position},address,blockTag))}async getPendingHeader(){return await this.#perform({method:"getPendingHeader"})}async getTxPoolContent(zone){return await this.#perform({method:"getTxPoolContent",zone:zone})}async txPoolInspect(zone){return await this.#perform({method:"txPoolInspect",zone:zone})}async broadcastTransaction(zone,signedTx){const type=decodeProtoTransaction(getBytes(signedTx)).type;try{const{blockNumber,hash,network}=await resolveProperties({blockNumber:this.getBlockNumber(toShard(zone)),hash:this._perform({method:"broadcastTransaction",signedTransaction:signedTx,zone:zone}),network:this.getNetwork()});const tx=type==2?QiTransaction.from(signedTx):QuaiTransaction.from(signedTx);const txObj=tx.toJSON();this.#validateTransactionHash(tx.hash||"",hash);if(type==2){return new QiTransactionResponse(txObj,this)}const wrappedTx=this._wrapTransactionResponse(txObj,network);return wrappedTx.replaceableTransaction(blockNumber)}catch(error){console.error("Error in broadcastTransaction:",error);throw error}}#validateTransactionHash(computedHash,nodehash){if(computedHash!==nodehash){throw new Error(`Transaction hash mismatch: ${computedHash} !== ${nodehash}`)}}validateUrl(url){const urlPattern=/^(https?):\/\/[a-zA-Z0-9.-]+(:\d+)?$/;if(!urlPattern.test(url)){let errorMessage="Invalid URL: ";if(!/^https?:\/\//.test(url)){errorMessage+="URL must start with http:// or https://. "}if(url.endsWith("/")){errorMessage+="URL should not end with a /. "}if(/\/[^/]+/.test(url)){errorMessage+="URL should not contain a path, query string, or fragment. "}throw new Error(errorMessage.trim())}}async#getBlock(shard,block,includeTransactions){if(isHexString(block,32)){return await this.#perform({method:"getBlock",blockHash:block,includeTransactions:includeTransactions,shard:shard})}let blockTag=this._getBlockTag(shard,block);if(typeof blockTag!=="string"){blockTag=await blockTag}return await this.#perform({method:"getBlock",blockTag:blockTag,includeTransactions:includeTransactions,shard:shard})}async getBlock(shard,block,prefetchTxs){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#getBlock(shard,block,!!prefetchTxs)});if(params==null){return null}return this._wrapBlock(params,network)}async getTransaction(hash){const zone=toZone(this.shardFromHash(hash));const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getTransaction",hash:hash,zone:zone})});if(params==null){return null}return this._wrapTransactionResponse(params,network)}async getTransactionReceipt(hash){const zone=toZone(this.shardFromHash(hash));const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getTransactionReceipt",hash:hash,zone:zone})});if(params==null){return null}if(params.gasPrice==null&&params.effectiveGasPrice==null){const tx=await this.#perform({method:"getTransaction",hash:hash,zone:zone});if(tx==null){throw new Error("report this; could not find tx or effectiveGasPrice")}params.effectiveGasPrice=tx.gasPrice}return this._wrapTransactionReceipt(params,network)}async getTransactionResult(hash){const zone=toZone(this.shardFromHash(hash));const{result}=await resolveProperties({network:this.getNetwork(),result:this.#perform({method:"getTransactionResult",hash:hash,zone:zone})});if(result==null){return null}return hexlify(result)}async getOutpointDeltas(addresses,startHash,endHash){for(const addr of addresses){assertArgument(isQiAddress(addr),`Invalid Qi address: ${addr}`,"addresses",addresses)}assertArgument(isHexString(startHash,32),"invalid startHash","startHash",startHash);if(endHash){assertArgument(isHexString(endHash,32),"invalid endHash","endHash",endHash)}else{endHash="latest"}const zone=await this.zoneFromAddress(addresses[0]);const shard=toShard(zone);const[startBlock,endBlock]=await Promise.all([this.getBlock(shard,startHash),this.getBlock(shard,endHash)]);if(startBlock==null){throw new Error("Could not find start block")}if(endBlock==null){throw new Error("Could not find end block")}const startBlockNumber=getNumber(startBlock.woHeader.number,"startBlockNumber");const endBlockNumber=getNumber(endBlock.woHeader.number,"endBlockNumber");assertArgument(startBlockNumber<=endBlockNumber,"startBlockNumber must be less than or equal to endBlockNumber","startBlockNumber",startBlockNumber);const ranges=[];const endBlockNumbers=[];let currentStartBlockNumber=startBlockNumber;let currentStartHash=startHash;while(currentStartBlockNumber<=endBlockNumber){const currentEndBlockNumber=Math.min(currentStartBlockNumber+999,endBlockNumber);endBlockNumbers.push(currentEndBlockNumber);currentStartBlockNumber=currentEndBlockNumber+1}const endBlocksPromises=endBlockNumbers.map(blockNumber=>this.getBlock(shard,blockNumber));const endBlocks=await Promise.all(endBlocksPromises);currentStartBlockNumber=startBlockNumber;currentStartHash=startHash;for(let i=0;i<endBlocks.length;i++){const currentEndBlock=endBlocks[i];if(!currentEndBlock){throw new Error(`Could not find block for block number ${endBlockNumbers[i]}`)}const currentEndHash=currentEndBlock.hash;ranges.push({startHash:currentStartHash,endHash:currentEndHash});currentStartBlockNumber=endBlockNumbers[i]+1;currentStartHash=currentEndHash}const promises=ranges.map(range=>{return this.#perform({method:"getOutpointDeltasForAddressesInRange",addresses:addresses,startHash:range.startHash,endHash:range.endHash,zone:zone}).then(formatOutpointDeltas)});const deltasArray=await Promise.all(promises);const deltas={};for(const delta of deltasArray){for(const[address,data]of Object.entries(delta)){if(!deltas[address]){deltas[address]={created:[],deleted:[]}}deltas[address].created.push(...data.created);deltas[address].deleted.push(...data.deleted)}}return deltas}async getLogs(_filter){let filter=this._getFilter(_filter);if(isPromise(filter)){filter=await filter}const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getLogs",filter:filter,zone:getZoneFromNodeLocation(filter.nodeLocation)})});return params.map(p=>this._wrapLog(p,network))}_getProvider(chainId){assert$1(false,"provider cannot connect to target network","UNSUPPORTED_OPERATION",{operation:"_getProvider()"})}async waitForTransaction(hash,_confirms,timeout){const zone=this.zoneFromHash(hash);const confirms=_confirms!=null?_confirms:1;if(confirms===0){return this.getTransactionReceipt(hash)}return new Promise(async(resolve,reject)=>{let timer=null;const listener=async blockNumber=>{try{const receipt=await this.getTransactionReceipt(hash);if(receipt!=null){if(blockNumber-receipt.blockNumber+1>=confirms){resolve(receipt);if(timer){clearTimeout(timer);timer=null}return}}}catch(error){console.log("Error occured while waiting for transaction:",error)}this.once("block",listener,zone)};if(timeout!=null){timer=setTimeout(()=>{if(timer==null){return}timer=null;this.off("block",listener,zone);reject(makeError("timeout","TIMEOUT",{reason:"timeout"}))},timeout)}listener(await this.getBlockNumber(toShard(zone)))})}async waitForBlock(shard,blockTag){assert$1(false,"not implemented yet","NOT_IMPLEMENTED",{operation:"waitForBlock"})}_clearTimeout(timerId){const timer=this.#timers.get(timerId);if(!timer){return}if(timer.timer){clearTimeout(timer.timer)}this.#timers.delete(timerId)}_setTimeout(_func,timeout){if(timeout==null){timeout=0}const timerId=this.#nextTimer++;const func=()=>{this.#timers.delete(timerId);_func()};if(this.paused){this.#timers.set(timerId,{timer:null,func:func,time:timeout})}else{const timer=setTimeout(func,timeout);this.#timers.set(timerId,{timer:timer,func:func,time:getTime()})}return timerId}_forEachSubscriber(func){for(const sub of this.#subs.values()){func(sub.subscriber)}}_getSubscriber(sub){switch(sub.type){case"debug":case"error":case"network":return new UnmanagedSubscriber(sub.type);case"block":{const subscriber=new PollingBlockSubscriber(this,sub.zone);subscriber.pollingInterval=this.pollingInterval;return subscriber}case"event":return new PollingEventSubscriber(this,sub.filter);case"transaction":return new PollingTransactionSubscriber(this,sub.hash,sub.zone);case"qiTransaction":return new PollingQiTransactionSubscriber(this,sub.hash,sub.zone);case"orphan":return new PollingOrphanSubscriber(this,sub.filter,sub.zone)}throw new Error(`unsupported event: ${sub.type}`)}_recoverSubscriber(oldSub,newSub){for(const sub of this.#subs.values()){if(sub.subscriber===oldSub){if(sub.started){sub.subscriber.stop()}sub.subscriber=newSub;if(sub.started){newSub.start()}if(this.#pausedState!=null){newSub.pause(this.#pausedState)}break}}}async#hasSub(event,emitArgs,zone){let sub=await getSubscription(event,zone);if(sub.type==="event"&&emitArgs&&emitArgs.length>0&&emitArgs[0].removed===true){sub=await getSubscription({orphan:"drop-log",log:emitArgs[0]},zone)}return this.#subs.get(sub.tag)||null}async#getSub(event,zone){const subscription=await getSubscription(event,zone);const tag=subscription.tag;let sub=this.#subs.get(tag);if(!sub){const subscriber=this._getSubscriber(subscription);const addressableMap=new WeakMap;const nameMap=new Map;sub={subscriber:subscriber,tag:tag,addressableMap:addressableMap,nameMap:nameMap,started:false,listeners:[],zone:subscription.zone};this.#subs.set(tag,sub)}return sub}async startZoneSubscriptions(zone){for(const sub of Array.from(this.#subs.values())){if(sub.zone===zone){if(sub.started){await sub.subscriber.start()}}}}async on(event,listener,zone){const sub=await this.#getSub(event,zone);sub.listeners.push({listener:listener,once:false});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async once(event,listener,zone){const sub=await this.#getSub(event,zone);sub.listeners.push({listener:listener,once:true});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async emit(event,zone,...args){const sub=await this.#hasSub(event,args,zone);if(!sub||sub.listeners.length===0){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const payload=new EventPayload(this,once?null:listener,event);try{listener.call(this,...args,payload)}catch(error){}return!once});if(sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return count>0}async listenerCount(event){if(event){const sub=await this.#hasSub(event);if(!sub){return 0}return sub.listeners.length}let total=0;for(const{listeners}of this.#subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await this.#hasSub(event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}let result=[];for(const{listeners}of this.#subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener,zone){const sub=await this.#hasSub(event,[],zone);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(!listener||sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const{tag,started,subscriber}=await this.#getSub(event);if(started){subscriber.stop()}this.#subs.delete(tag)}else{for(const[tag,{started,subscriber}]of this.#subs){if(started){subscriber.stop()}this.#subs.delete(tag)}}return this}async addListener(event,listener,zone){return await this.on(event,listener,zone)}async removeListener(event,listener,zone){return this.off(event,listener,zone)}get destroyed(){return this.#destroyed}destroy(){this.removeAllListeners();for(const timerId of this.#timers.keys()){this._clearTimeout(timerId)}this.#destroyed=true}get paused(){return this.#pausedState!=null}set paused(pause){if(!!pause===this.paused){return}if(this.paused){this.resume()}else{this.pause(false)}}pause(dropWhilePaused){this.#lastBlockNumber=-1;if(this.#pausedState!=null){if(this.#pausedState==!!dropWhilePaused){return}assert$1(false,"cannot change pause type; resume first","UNSUPPORTED_OPERATION",{operation:"pause"})}this._forEachSubscriber(s=>s.pause(dropWhilePaused));this.#pausedState=!!dropWhilePaused;for(const timer of this.#timers.values()){if(timer.timer){clearTimeout(timer.timer)}timer.time=getTime()-timer.time}}resume(){if(this.#pausedState==null){return}this._forEachSubscriber(s=>s.resume());this.#pausedState=null;for(const timer of this.#timers.values()){let timeout=timer.time;if(timeout<0){timeout=0}timer.time=getTime();setTimeout(timer.func,timeout)}}}function copy(obj){return JSON.parse(JSON.stringify(obj))}class FilterIdSubscriber{#provider;#filterIdPromise;#poller;#running;#network;#hault;zone;constructor(provider,zone){this.#provider=provider;this.#filterIdPromise=null;this.#poller=this.#poll.bind(this);this.#running=false;this.#network=null;this.#hault=false;this.zone=zone}_subscribe(provider){throw new Error("subclasses must override this")}_emitResults(provider,result){throw new Error("subclasses must override this")}_recover(provider){throw new Error("subclasses must override this")}async#poll(blockNumber){try{if(this.#filterIdPromise==null){this.#filterIdPromise=this._subscribe(this.#provider)}let filterId=null;try{filterId=await this.#filterIdPromise}catch(error){if(!isError(error,"UNSUPPORTED_OPERATION")||error.operation!=="quai_newFilter"){throw error}}if(filterId==null){this.#filterIdPromise=null;this.#provider._recoverSubscriber(this,this._recover(this.#provider));return}const network=await this.#provider.getNetwork();if(!this.#network){this.#network=network}if(this.#network.chainId!==network.chainId){throw new Error("chain changed")}if(this.#hault){return}const result=await this.#provider.send("quai_getFilterChanges",[filterId]);await this._emitResults(this.#provider,result)}catch(error){console.log("@TODO",error)}this.#provider.once("block",this.#poller,this.zone)}#teardown(){const filterIdPromise=this.#filterIdPromise;if(filterIdPromise){this.#filterIdPromise=null;filterIdPromise.then(filterId=>{this.#provider.send("quai_uninstallFilter",[filterId])})}}start(){if(this.#running){return}this.#running=true;this.#poll(-2)}stop(){if(!this.#running){return}this.#running=false;this.#hault=true;this.#teardown();this.#provider.off("block",this.#poller,this.zone)}pause(dropWhilePaused){if(dropWhilePaused){this.#teardown()}this.#provider.off("block",this.#poller,this.zone)}resume(){this.start()}}class FilterIdEventSubscriber extends FilterIdSubscriber{#event;constructor(provider,filter){const zone=getZoneFromEventFilter(filter);if(zone==null){throw new Error("Unable to determine zone for event filter")}super(provider,zone);this.#event=copy(filter)}_recover(provider){return new PollingEventSubscriber(provider,this.#event)}async _subscribe(provider){const filterId=await provider.send("quai_newFilter",[this.#event]);return filterId}async _emitResults(provider,results){for(const result of results){provider.emit(this.#event,this.zone,provider._wrapLog(result,provider._network))}}}class FilterIdPendingSubscriber extends FilterIdSubscriber{async _subscribe(provider){return await provider.send("quai_newPendingTransactionFilter",[])}async _emitResults(provider,results){for(const result of results){provider.emit("pending",this.zone,result)}}}const Primitive="bigint,boolean,function,number,string,symbol".split(/,/g);function deepCopy(value){if(value==null||Primitive.indexOf(typeof value)>=0){return value}if(typeof value.getAddress==="function"){return value}if(Array.isArray(value)){return value.map(deepCopy)}if(typeof value==="object"){return Object.keys(value).reduce((accum,key)=>{accum[key]=value[key];return accum},{})}throw new Error(`should not happen: ${value} (${typeof value})`)}function stall(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}const defaultOptions={staticNetwork:null,batchStallTime:10,batchMaxSize:1<<20,batchMaxCount:100,cacheTimeout:250,usePathing:true};class JsonRpcSigner extends AbstractSigner{address;constructor(provider,address){super(provider);address=getAddress(address);defineProperties(this,{address:address})}connect(provider){assert$1(false,"cannot reconnect JsonRpcSigner","UNSUPPORTED_OPERATION",{operation:"signer.connect"})}async getAddress(){return this.address}async populateQuaiTransaction(tx){return await this.populateCall(tx)}async sendUncheckedTransaction(_tx){const tx=deepCopy(_tx);const promises=[];if("from"in tx){if(tx.from){const _from=tx.from;promises.push((async()=>{const from=await resolveAddress(_from);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),"from address mismatch","transaction",_tx);tx.from=from})())}else{tx.from=this.address}if(tx.gasLimit==null){promises.push((async()=>{tx.gasLimit=await this.provider.estimateGas({...tx,from:this.address})})())}if(tx.to!=null){const _to=tx.to;promises.push((async()=>{tx.to=await resolveAddress(_to)})())}}if(promises.length){await Promise.all(promises)}const hexTx=this.provider.getRpcTransaction(tx);return this.provider.send("quai_sendTransaction",[hexTx])}async sendTransaction(tx){const zone=await this.zoneFromAddress(addressFromTransactionRequest(tx));const blockNumber=await this.provider.getBlockNumber(toShard(zone));const hash=await this.sendUncheckedTransaction(tx);return await new Promise((resolve,reject)=>{const timeouts=[1e3,100];let invalids=0;const checkTx=async()=>{try{const tx=await this.provider.getTransaction(hash);if(tx!=null){resolve(tx.replaceableTransaction(blockNumber));return}}catch(error){if(isError(error,"CANCELLED")||isError(error,"BAD_DATA")||isError(error,"NETWORK_ERROR")||isError(error,"UNSUPPORTED_OPERATION")){if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;reject(error);return}if(isError(error,"INVALID_ARGUMENT")){invalids++;if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;if(invalids>10){reject(error);return}}this.provider.emit("error",zoneFromHash(hash),makeError("failed to fetch transation after sending (will try again)","UNKNOWN_ERROR",{error:error}))}this.provider._setTimeout(()=>{checkTx()},timeouts.pop()||4e3)};checkTx()})}async signTransaction(_tx){const tx=deepCopy(_tx);if("from"in tx){if(tx.from){const from=await resolveAddress(tx.from);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),"from address mismatch","transaction",_tx);tx.from=from}else{tx.from=this.address}}else{throw new Error("No QI signing implementation in provider-jsonrpc")}const hexTx=this.provider.getRpcTransaction(tx);return await this.provider.send("quai_signTransaction",[hexTx])}async signMessage(_message){const message=typeof _message==="string"?toUtf8Bytes(_message):_message;return await this.provider.send("personal_sign",[hexlify(message),this.address.toLowerCase()])}async signTypedData(domain,types,_value){const value=deepCopy(_value);return await this.provider.send("quai_signTypedData_v4",[this.address.toLowerCase(),JSON.stringify(TypedDataEncoder.getPayload(domain,types,value))])}async unlock(password){return this.provider.send("personal_unlockAccount",[this.address.toLowerCase(),password,null])}async _legacySignMessage(_message){const message=typeof _message==="string"?toUtf8Bytes(_message):_message;return await this.provider.send("quai_sign",[this.address.toLowerCase(),hexlify(message)])}}class JsonRpcApiProvider extends AbstractProvider{#options;#nextId;#payloads;#drainTimer;#notReady;#network;#pendingDetectNetwork;#scheduleDrain(){if(this.#drainTimer){return}const stallTime=this._getOption("batchMaxCount")===1?0:this._getOption("batchStallTime");this.#drainTimer=setTimeout(()=>{this.#drainTimer=null;const payloads=this.#payloads;this.#payloads=[];while(payloads.length){const batch=[payloads.shift()];while(payloads.length){if(batch.length===this.#options.batchMaxCount){break}batch.push(payloads.shift());const bytes=JSON.stringify(batch.map(p=>p.payload));if(bytes.length>this.#options.batchMaxSize){payloads.unshift(batch.pop());break}}(async()=>{const payloadMap=new Map;const nowPayloadMap=new Map;for(let i=0;i<batch.length;i++){if(batch[i].now){if(!nowPayloadMap.has(batch[i].shard)){if(batch[i].payload!=null){nowPayloadMap.set(batch[i].shard,[batch[i].payload])}}else{nowPayloadMap.get(batch[i].shard)?.push(batch[i].payload)}}else{if(!payloadMap.has(batch[i].shard)){if(batch[i].payload!=null){payloadMap.set(batch[i].shard,[batch[i].payload])}}else{payloadMap.get(batch[i].shard)?.push(batch[i].payload)}}}const rawResult=[];const processPayloads=async(key,value,now)=>{const payload=value.length===1?value[0]:value;const shard=key?toShard(key):Shard.Prime;const zone=shard.length<4?undefined:toZone(shard);this.emit("debug",zone,{action:"sendRpcPayload",payload:payload});rawResult.push(await this._send(payload,shard,now));this.emit("debug",zone,{action:"receiveRpcResult",payload:payload})};await Promise.all(Array.from(nowPayloadMap).map(async([key,value])=>{await processPayloads(key,value,true)}).concat(Array.from(payloadMap).map(async([key,value])=>{await processPayloads(key,value)})));const result=rawResult.flat();let lastZone;try{for(const{resolve,reject,payload,shard}of batch){if(this.destroyed){reject(makeError("provider destroyed; cancelled request","UNSUPPORTED_OPERATION",{operation:payload.method}));continue}if(shard){lastZone=shard.length<4?undefined:toZone(shard)}else{lastZone=undefined}const resp=result.filter(r=>r.id===payload.id)[0];if(resp==null){const error=makeError("missing response for request","BAD_DATA",{value:result,info:{payload:payload}});this.emit("error",lastZone,error);reject(error);continue}if("error"in resp){reject(this.getRpcError(payload,resp,shard));continue}resolve(resp.result)}}catch(error){this.emit("debug",lastZone,{action:"receiveRpcError",error:error});for(const{reject}of batch){reject(error)}}})()}},stallTime)}constructor(network,options){super(network,options);this.#nextId=1;this.#options=Object.assign({},defaultOptions,options||{});this.#payloads=[];this.#drainTimer=null;this.#network=null;this.#pendingDetectNetwork=null;{let resolve=null;const promise=new Promise(_resolve=>{resolve=_resolve});this.#notReady={promise:promise,resolve:resolve}}const staticNetwork=this._getOption("staticNetwork");if(typeof staticNetwork==="boolean"){assertArgument(!staticNetwork||network!=="any","staticNetwork cannot be used on special network 'any'","options",options);if(staticNetwork&&network!=null){this.#network=Network.from(network)}}else if(staticNetwork){assertArgument(network==null||staticNetwork.matches(network),"staticNetwork MUST match network object","options",options);this.#network=staticNetwork}}_getOption(key){return this.#options[key]}get _network(){assert$1(this.#network,"network is not available yet","NETWORK_ERROR");return this.#network}async _perform(req){if(req.method!=="getRunningLocations"){await this.initPromise}if(req.method==="call"||req.method==="estimateGas"){const tx=req.transaction;if(tx&&tx.type!=null&&getBigInt(tx.type)){if(tx.gasPrice==null&&tx.minerTip==null){const feeData=await this.getFeeData(req.zone,tx.type===1);if(feeData.gasPrice==null&&feeData.minerTip==null){req=Object.assign({},req,{transaction:Object.assign({},tx,{type:undefined})})}}}}const request=this.getRpcRequest(req);if(request!=null){const shard="shard"in req?req.shard:"zone"in req?toShard(req.zone):undefined;if(req.method==="getRunningLocations"){return await this.send(request.method,request.args,shard,req.now)}else{return await this.send(request.method,request.args,shard)}}return super._perform(req)}async _detectNetwork(){const network=this._getOption("staticNetwork");if(network){if(network===true){if(this.#network){return this.#network}}else{return network}}if(this.#pendingDetectNetwork){return await this.#pendingDetectNetwork}if(this.ready){this.#pendingDetectNetwork=(async()=>{try{const result=Network.from(getBigInt(await this.send("quai_chainId",[])));this.#pendingDetectNetwork=null;return result}catch(error){this.#pendingDetectNetwork=null;throw error}})();return await this.#pendingDetectNetwork}this.#pendingDetectNetwork=(async()=>{const payload={id:this.#nextId++,method:"quai_chainId",params:[],jsonrpc:"2.0"};this.emit("debug",undefined,{action:"sendRpcPayload",payload:payload});let result;try{result=(await this._send(payload))[0];this.#pendingDetectNetwork=null}catch(error){this.#pendingDetectNetwork=null;this.emit("debug",undefined,{action:"receiveRpcError",error:error});throw error}this.emit("debug",undefined,{action:"receiveRpcResult",result:result});if("result"in result){return Network.from(getBigInt(result.result))}throw this.getRpcError(payload,result)})();return await this.#pendingDetectNetwork}_start(){this.attemptConnect=true;if(this.#notReady==null||this.#notReady.resolve==null){return}this.#notReady.resolve();this.#notReady=null;(async()=>{let retries=0;const maxRetries=5;while(this.#network==null&&!this.destroyed&&retries<maxRetries){try{this.#network=await this._detectNetwork()}catch(error){if(this.destroyed){break}console.log("JsonRpcProvider failed to detect network and cannot start up; retrying (perhaps the URL is wrong or the node is not started)");this.emit("error",undefined,makeError("failed to bootstrap network detection","NETWORK_ERROR",{event:"initial-network-discovery",info:{error:error}}));await stall(1e3*Math.pow(2,retries));retries++}}if(retries>=maxRetries){console.log("JsonRpcProvider failed to detect network and cannot start up; retry limit reached");makeError("failed to bootstrap network detection","NETWORK_ERROR",{event:"initial-network-discovery",info:{retries:retries}})}this.#scheduleDrain()})()}async _waitUntilReady(){if(this._initFailed){console.log("init failed");throw new Error("Provider failed to initialize on creation. Run initialize or create a new provider.")}let keepAttempting=true;const setAttemptConnect=async()=>{while(keepAttempting){this.attemptConnect=true;await new Promise(resolve=>setTimeout(resolve,2e3))}};setAttemptConnect();try{await this.initPromise}finally{keepAttempting=false}}_getSubscriber(sub){if(sub.type==="pending"){return new FilterIdPendingSubscriber(this,sub.zone)}if(sub.type==="event"){return new FilterIdEventSubscriber(this,sub.filter)}if(sub.type==="orphan"&&sub.filter.orphan==="drop-log"){return new UnmanagedSubscriber("orphan")}return super._getSubscriber(sub)}get ready(){return this.#notReady==null}getRpcTransaction(tx){const result={};if("from"in tx||"to"in tx&&"data"in tx){["chainId","gasLimit","gasPrice","type","gasPrice","minerTip","nonce","value"].forEach(key=>{if(tx[key]==null){return}let dstKey=key;if(key==="gasLimit"){dstKey="gas"}result[dstKey]=toQuantity(getBigInt(tx[key],`tx.${key}`))});["from","to","data"].forEach(key=>{if(tx[key]==null){return}result[key]=hexlify(tx[key])});if("accessList"in tx&&tx.accessList){result["accessList"]=accessListify(tx.accessList)}}else{if(tx.txInputs!=null){result["txInputs"]=tx.txInputs.map(input=>({txhash:hexlify(input.txhash),index:toQuantity(getBigInt(input.index,`tx.txInputs.${input.index}`)),pubkey:hexlify(input.pubkey)}))}if(tx.txOutputs!=null){result["txOutputs"]=tx.txOutputs.map(output=>({address:hexlify(output.address),denomination:toQuantity(getBigInt(output.denomination,`tx.txOutputs.${output.denomination}`))}))}}return result}getRpcRequest(req){switch(req.method){case"chainId":return{method:"quai_chainId",args:[]};case"getBlockNumber":return{method:"quai_blockNumber",args:[]};case"getGasPrice":return{method:"quai_gasPrice",args:[]};case"getMinerTip":return{method:"quai_minerTip",args:[]};case"getPendingHeader":return{method:"quai_getPendingHeader",args:[]};case"getBalance":return{method:"quai_getBalance",args:[req.address,req.blockTag]};case"getLockedBalance":return{method:"quai_getLockedBalance",args:[req.address]};case"getOutpointsByAddress":return{method:"quai_getOutpointsByAddress",args:[req.address]};case"getTransactionCount":return{method:"quai_getTransactionCount",args:[req.address,req.blockTag]};case"getCode":return{method:"quai_getCode",args:[req.address,req.blockTag]};case"getStorage":return{method:"quai_getStorageAt",args:[req.address,"0x"+req.position.toString(16),req.blockTag]};case"broadcastTransaction":return{method:"quai_sendRawTransaction",args:[req.signedTransaction]};case"getBlock":if("blockTag"in req){return{method:"quai_getBlockByNumber",args:[req.blockTag,!!req.includeTransactions]}}else if("blockHash"in req){return{method:"quai_getBlockByHash",args:[req.blockHash,!!req.includeTransactions]}}break;case"getTransaction":return{method:"quai_getTransactionByHash",args:[req.hash]};case"getTransactionReceipt":return{method:"quai_getTransactionReceipt",args:[req.hash]};case"call":return{method:"quai_call",args:[this.getRpcTransaction(req.transaction),req.blockTag]};case"estimateGas":{return{method:"quai_estimateGas",args:[this.getRpcTransaction(req.transaction)]}}case"estimateFeeForQi":{return{method:"quai_estimateFeeForQi",args:[req.transaction]}}case"createAccessList":{return{method:"quai_createAccessList",args:[this.getRpcTransaction(req.transaction)]}}case"getRunningLocations":{return{method:"quai_listRunningChains",args:[]}}case"getProtocolTrieExpansionCount":{return{method:"quai_getProtocolExpansionNumber",args:[]}}case"getProtocolExpansionNumber":{return{method:"quai_getProtocolExpansionNumber",args:[]}}case"getQiRateAtBlock":{return{method:"quai_qiRateAtBlock",args:[req.blockTag,req.amt]}}case"getQuaiRateAtBlock":{return{method:"quai_quaiRateAtBlock",args:[req.blockTag,req.amt]}}case"getLogs":return{method:"quai_getLogs",args:[req.filter]};case"getTxPoolContent":return{method:"txpool_content",args:[]};case"txPoolInspect":return{method:"txpool_inspect",args:[]};case"getOutpointDeltasForAddressesInRange":return{method:"quai_getOutpointDeltasForAddressesInRange",args:[req.addresses,req.startHash,req.endHash]}}return null}getRpcError(payload,_error,shard){const{method}=payload;const{error}=_error;if(method==="quai_estimateGas"&&error.message){const msg=error.message;if(!msg.match(/revert/i)&&msg.match(/insufficient funds/i)){return makeError("insufficient funds","INSUFFICIENT_FUNDS",{transaction:payload.params[0],info:{payload:payload,error:error,shard:shard}})}}if(method==="quai_call"||method==="quai_estimateGas"){const result=spelunkData(error);const e=AbiCoder.getBuiltinCallException(method==="quai_call"?"call":"estimateGas",payload.params[0],result?result.data:null);e.info={error:error,payload:payload,shard:shard};return e}const message=JSON.stringify(spelunkMessage(error));if(method==="quai_getTransactionByHash"&&error.message&&error.message.match(/transaction not found/i)){return makeError("transaction not found","TRANSACTION_NOT_FOUND",{info:{payload:payload,error:error,shard:shard}})}if(typeof error.message==="string"&&error.message.match(/user denied|quais-user-denied/i)){const actionMap={quai_sign:"signMessage",personal_sign:"signMessage",quai_signTypedData_v4:"signTypedData",quai_signTransaction:"signTransaction",quai_sendTransaction:"sendTransaction",quai_requestAccounts:"requestAccess",wallet_requestAccounts:"requestAccess"};return makeError(`user rejected action`,"ACTION_REJECTED",{action:actionMap[method]||"unknown",reason:"rejected",info:{payload:payload,error:error,shard:shard}})}if(method==="quai_sendRawTransaction"||method==="quai_sendTransaction"){const transaction=payload.params[0];if(message.match(/insufficient funds|base fee exceeds gas limit/i)){return makeError("insufficient funds for intrinsic transaction cost","INSUFFICIENT_FUNDS",{transaction:transaction,info:{error:error,shard:shard}})}if(message.match(/nonce/i)&&message.match(/too low/i)){return makeError("nonce has already been used","NONCE_EXPIRED",{transaction:transaction,info:{error:error,shard:shard}})}if(message.match(/replacement transaction/i)&&message.match(/underpriced/i)){return makeError("replacement fee too low","REPLACEMENT_UNDERPRICED",{transaction:transaction,info:{error:error,shard:shard}})}if(message.match(/only replay-protected/i)){return makeError("legacy pre-eip-155 transactions not supported","UNSUPPORTED_OPERATION",{operation:method,info:{transaction:transaction,info:{error:error,shard:shard}}})}if(message.match(/already known/i)){return makeError("transaction already known","TRANSACTION_ALREADY_KNOWN",{info:{error:error,shard:shard}})}}let unsupported=!!message.match(/the method .* does not exist/i);if(!unsupported){if(error&&error.details&&error.details.startsWith("Unauthorized method:")){unsupported=true}}if(unsupported){return makeError("unsupported operation","UNSUPPORTED_OPERATION",{operation:payload.method,info:{error:error,payload:payload,shard:shard}})}if(message.match("Provider failed to initialize on creation. Run initialize or create a new provider.")){return makeError("Provider failed to initialize on creation. Run initUrlMap or create a new provider.","PROVIDER_FAILED_TO_INITIALIZE",{info:{payload:payload,error:error,shard:shard}})}return makeError("could not coalesce error","UNKNOWN_ERROR",{error:error,payload:payload,shard:shard})}send(method,params,shard,now){const continueSend=()=>{if(this.destroyed){return Promise.reject(makeError("provider destroyed; cancelled request","UNSUPPORTED_OPERATION",{operation:method}))}const id=this.#nextId++;const promise=new Promise((resolve,reject)=>{this.#payloads.push({resolve:resolve,reject:reject,payload:{method:method,params:params,id:id,jsonrpc:"2.0"},shard:shard,now:now})});this.#scheduleDrain();return promise};if(method!=="quai_listRunningChains"){return this.initPromise.then(()=>{return continueSend()})}else{return continueSend()}}async getSigner(address){if(address==null){address=0}const accountsPromise=this.send("quai_accounts",[]);if(typeof address==="number"){const accounts=await accountsPromise;if(address>=accounts.length){throw new Error("no such account")}return new JsonRpcSigner(this,accounts[address])}const{accounts}=await resolveProperties({network:this.getNetwork(),accounts:accountsPromise});address=getAddress(address);for(const account of accounts){if(getAddress(account)===address){return new JsonRpcSigner(this,address)}}throw new Error("invalid account")}async listAccounts(){const accounts=await this.send("quai_accounts",[]);return accounts.map(a=>new JsonRpcSigner(this,a))}destroy(){if(this.#drainTimer){clearTimeout(this.#drainTimer);this.#drainTimer=null}for(const{payload,reject}of this.#payloads){reject(makeError("provider destroyed; cancelled request","UNSUPPORTED_OPERATION",{operation:payload.method}))}this.#payloads=[];super.destroy()}}class JsonRpcProvider extends JsonRpcApiProvider{constructor(urls,network,options){if(urls==null){urls=["http://localhost:8545"]}super(network,options);if(Array.isArray(urls)){urls.forEach(url=>{this.validateUrl(url)});this.initialize(urls)}else if(typeof urls==="string"){this.validateUrl(urls);this.initialize([urls])}else{this.validateUrl(urls.url);this.initialize(urls.clone())}}_getSubscriber(sub){const subscriber=super._getSubscriber(sub);return subscriber}_getConnection(shard){if(this._initFailed){throw new Error("Provider failed to initialize on creation. Run initUrlMap or create a new provider.")}let connection;if(shard!==undefined){connection=this._urlMap.get(shard)??this.connect[this.connect.length-1].clone()}else{connection=this.connect[this.connect.length-1].clone()}return new FetchRequest(connection.url)}async send(method,params,shard,now){try{this._start();return await super.send(method,params,shard,now)}catch(error){return Promise.reject(error)}}async _send(payload,shard,now){if(this._initFailed){return[{id:Array.isArray(payload)?payload[0].id:payload.id,error:{code:-32e3,message:"Provider failed to initialize on creation. Run initialize or create a new provider."}}]}try{if(!now){await this._waitUntilReady()}}catch(error){return[{id:Array.isArray(payload)?payload[0].id:payload.id,error:{code:-32e3,message:"Provider failed to initialize on creation. Run initialize or create a new provider."}}]}try{const request=this._getConnection(shard);request.body=JSON.stringify(payload);request.setHeader("content-type","application/json");const response=await request.send();response.assertOk();let resp=response.bodyJson;if(!Array.isArray(resp)){resp=[resp]}return resp}catch(error){return[{id:Array.isArray(payload)?payload[0].id:payload.id,error:{code:-32e3,message:error instanceof Error?error.message:String(error)}}]}}}function spelunkData(value){if(value==null){return null}if(typeof value.message==="string"&&value.message.match(/revert/i)&&isHexString(value.data)){return{message:value.message,data:value.data}}if(typeof value==="object"){for(const key in value){const result=spelunkData(value[key]);if(result){return result}}return null}if(typeof value==="string"){try{return spelunkData(JSON.parse(value))}catch(error){}}return null}function _spelunkMessage(value,result){if(value==null){return}if(typeof value.message==="string"){result.push(value.message)}if(typeof value==="object"){for(const key in value){_spelunkMessage(value[key],result)}}if(typeof value==="string"){try{return _spelunkMessage(JSON.parse(value),result)}catch(error){}}}function spelunkMessage(value){const result=[];_spelunkMessage(value,result);return result}class ContractFactory{interface;bytecode;runner;constructor(abi,bytecode,runner){const iface=Interface.from(abi);if(bytecode instanceof Uint8Array){bytecode=hexlify(getBytes(bytecode))}else{if(typeof bytecode==="object"){bytecode=bytecode.object}if(!bytecode.startsWith("0x")){bytecode="0x"+bytecode}bytecode=hexlify(getBytes(bytecode))}defineProperties(this,{bytecode:bytecode,interface:iface,runner:runner||null})}attach(target){return new BaseContract(target,this.interface,this.runner)}async getDeployTransaction(...args){let overrides;const fragment=this.interface.deploy;if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop());const resolvedArgs=await resolveArgs(this.runner,fragment.inputs,args);const data=concat([this.bytecode,this.interface.encodeDeploy(resolvedArgs)]);return Object.assign({},overrides,{data:data})}if(fragment.inputs.length!==args.length){throw new Error("incorrect number of arguments to constructor")}const resolvedArgs=await resolveArgs(this.runner,fragment.inputs,args);const data=concat([this.bytecode,this.interface.encodeDeploy(resolvedArgs)]);const from=args.pop()?.from||undefined;return Object.assign({},from,{data:data})}async deploy(...args){const tx=await this.getDeployTransaction(...args);assert$1(this.runner&&typeof this.runner.sendTransaction==="function","factory runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});if(this.runner instanceof Wallet||this.runner instanceof JsonRpcSigner){validateAddress(this.runner.address);tx.from=this.runner.address}const grindedTx=await this.grindContractAddress(tx);grindedTx.accessList=await this.runner.createAccessList?.(grindedTx);const sentTx=await this.runner.sendTransaction(grindedTx);const address=getStatic(this.constructor,"getContractAddress")?.(tx);return new BaseContract(address,this.interface,this.runner,sentTx)}static getContractAddress(transaction){return getContractAddress(transaction.from,BigInt(transaction.nonce),transaction.data)}async grindContractAddress(tx){if(tx.nonce==null&&tx.from){tx.nonce=await this.runner?.provider?.getTransactionCount(tx.from)}const sender=String(tx.from);const toShard=getZoneForAddress(sender);let i=0;const startingData=tx.data;const salt=new Uint8Array(4);new DataView(salt.buffer).setUint32(0,Number(tx.nonce)&4294967295,false);while(i<1e4){tx.data=hexlify(concat([String(startingData),salt]));const contractAddress=getContractAddress(sender,BigInt(tx.nonce||0),tx.data||"");const contractShard=getZoneForAddress(contractAddress);const utxo=isQiAddress(contractAddress);if(contractShard===toShard&&!utxo){return tx}let saltValue=new DataView(salt.buffer).getUint32(0,false);saltValue++;new DataView(salt.buffer).setUint32(0,saltValue,false);i++}return tx}connect(runner){return new ContractFactory(this.interface,this.bytecode,runner)}static fromSolidity(output,runner){assertArgument(output!=null,"bad compiler output","output",output);if(typeof output==="string"){output=JSON.parse(output)}const abi=output.abi;let bytecode="";if(output.bytecode){bytecode=output.bytecode}else if(output.evm&&output.evm.bytecode){bytecode=output.evm.bytecode}return new this(abi,bytecode,runner)}}class BrowserProvider extends JsonRpcApiProvider{#request;constructor(ethereum,network){super(network,{batchMaxCount:1});if(this.initResolvePromise)this.initResolvePromise();this.#request=async(method,params,shard)=>{const payload={method:method,params:params,shard:shard};this.emit("debug",undefined,{action:"sendEip1193Request",payload:payload});try{const result=await ethereum.request(payload);this.emit("debug",undefined,{action:"receiveEip1193Result",result:result});return result}catch(e){const error=new Error(e.message);error.code=e.code;error.data=e.data;error.payload=payload;this.emit("debug",undefined,{action:"receiveEip1193Error",error:error});throw error}}}async hasSigner(address){if(address==null){address=0}const accounts=await this.send("quai_accounts",[]);if(typeof address==="number"){return accounts.length>address}address=address.toLowerCase();return accounts.filter(a=>a.toLowerCase()===address).length!==0}async send(method,params,shard){await this._start();return await super.send(method,params,shard)}async _send(payload,shard){assertArgument(!Array.isArray(payload),"EIP-1193 does not support batch request","payload",payload);try{const result=await this.#request(payload.method,payload.params||[],shard);return[{id:payload.id,result:result}]}catch(e){return[{id:payload.id,error:{code:e.code,data:e.data,message:e.message,shard:shard||undefined}}]}}getRpcError(payload,error){error=JSON.parse(JSON.stringify(error));switch(error.error.code||-1){case 4001:error.error.message=`quais-user-denied: ${error.error.message}`;break;case 4200:error.error.message=`quais-unsupported: ${error.error.message}`;break}return super.getRpcError(payload,error)}async getSigner(address){if(address==null){address=0}if(!await this.hasSigner(address)){try{await this.#request("quai_requestAccounts",[])}catch(error){const payload=error.payload;throw this.getRpcError(payload,{id:payload.id,error:error})}}return await super.getSigner(address)}}class SocketSubscriber{#provider;#filter;get filter(){return JSON.parse(this.#filter)}#filterId;#paused;#emitPromise;zone;shard;constructor(provider,filter,zone){this.#provider=provider;this.#filter=JSON.stringify(filter);this.#filterId=null;this.#paused=null;this.#emitPromise=null;this.zone=zone;this.shard=toShard(zone)}start(){this.#filterId=this.#provider.send("quai_subscribe",this.filter,this.shard).then(filterId=>{this.#provider._register(filterId,this);return filterId})}stop(){this.#filterId.then(filterId=>{this.#provider.send("quai_unsubscribe",[filterId],this.shard)});this.#filterId=null}pause(dropWhilePaused){assert$1(dropWhilePaused,"preserve logs while paused not supported by SocketSubscriber yet","UNSUPPORTED_OPERATION",{operation:"pause(false)"});this.#paused=!!dropWhilePaused}resume(){this.#paused=null}_handleMessage(message){if(this.#filterId==null){return}if(this.#paused===null){let emitPromise=this.#emitPromise;if(emitPromise==null){emitPromise=this._emit(this.#provider,message)}else{emitPromise=emitPromise.then(async()=>{await this._emit(this.#provider,message)})}this.#emitPromise=emitPromise.then(()=>{if(this.#emitPromise===emitPromise){this.#emitPromise=null}})}}async _emit(provider,message){throw new Error("sub-classes must implement this; _emit")}}class SocketBlockSubscriber extends SocketSubscriber{constructor(provider,zone){super(provider,["newHeads"],zone)}async _emit(provider,message){provider.emit("block",this.zone,parseInt(message.woHeader.number))}}class SocketAccessesSubscriber extends SocketSubscriber{#accessesFilter;get accessesFilter(){return JSON.parse(this.#accessesFilter)}constructor(provider,filter,zone){super(provider,["accesses",filter.address],zone);this.#accessesFilter=JSON.stringify(filter)}async _emit(provider,message){if(this.accessesFilter.type==="balance"){message=await provider.getBalance(this.accessesFilter.address)}provider.emit(this.accessesFilter,this.zone,message)}}class SocketPendingSubscriber extends SocketSubscriber{constructor(provider,zone){super(provider,["newPendingTransactions"],zone)}async _emit(provider,message){provider.emit("pending",message)}}class SocketEventSubscriber extends SocketSubscriber{#logFilter;get logFilter(){return JSON.parse(this.#logFilter)}constructor(provider,filter,zone){super(provider,["logs",filter],zone);this.#logFilter=JSON.stringify(filter)}async _emit(provider,message){provider.emit(this.logFilter,this.zone,provider._wrapLog(message,provider._network))}}class SocketProvider extends JsonRpcApiProvider{#callbacks;#subs;#pending;constructor(network,_options){const options=Object.assign({},_options!=null?_options:{});assertArgument(options.batchMaxCount==null||options.batchMaxCount===1,"sockets-based providers do not support batches","options.batchMaxCount",_options);options.batchMaxCount=1;if(options.staticNetwork==null){options.staticNetwork=true}super(network,options);this.#callbacks=new Map;this.#subs=new Map;this.#pending=new Map}_getSubscriber(sub){switch(sub.type){case"close":return new UnmanagedSubscriber("close");case"block":return new SocketBlockSubscriber(this,sub.zone);case"accesses":return new SocketAccessesSubscriber(this,sub.filter,sub.zone);case"pending":return new SocketPendingSubscriber(this,sub.zone);case"event":return new SocketEventSubscriber(this,sub.filter,sub.zone);case"orphan":if(sub.filter.orphan==="drop-log"){return new UnmanagedSubscriber("drop-log")}}return super._getSubscriber(sub)}_register(filterId,subscriber){this.#subs.set(filterId,subscriber);const pending=this.#pending.get(filterId);if(pending){for(const message of pending){subscriber._handleMessage(message)}this.#pending.delete(filterId)}}async _send(payload,shard,now){if(this._initFailed){console.log("Provider failed to initialize on creation. Run initialize or create a new provider.");return[{id:Array.isArray(payload)?payload[0].id:payload.id,error:{code:-32e3,message:"Provider failed to initialize on creation. Run initialize or create a new provider."}}]}assertArgument(!Array.isArray(payload),"WebSocket does not support batch send","payload",payload);const promise=new Promise((resolve,reject)=>{this.#callbacks.set(payload.id,{payload:payload,resolve:resolve,reject:reject})});try{if(!now){await this._waitUntilReady()}}catch(error){this.#callbacks.delete(payload.id);return[{id:Array.isArray(payload)?payload[0].id:payload.id,error:{code:-32e3,message:"Provider failed to initialize on creation. Run initialize or create a new provider."}}]}await this._write(JSON.stringify(payload),shard);return[await promise]}async _processMessage(message){const result=JSON.parse(message);if(result&&typeof result==="object"&&"id"in result){const callback=this.#callbacks.get(result.id);if(callback==null){this.emit("error",undefined,makeError("received result for unknown id","UNKNOWN_ERROR",{reasonCode:"UNKNOWN_ID",result:result}));return}this.#callbacks.delete(result.id);callback.resolve(result)}else if(result&&result.method==="quai_subscription"){const filterId=result.params.subscription;const subscriber=this.#subs.get(filterId);if(subscriber){subscriber._handleMessage(result.params.result)}else{let pending=this.#pending.get(filterId);if(pending==null){pending=[];this.#pending.set(filterId,pending)}pending.push(result.params.result)}}else{this.emit("error",undefined,makeError("received unexpected message","UNKNOWN_ERROR",{reasonCode:"UNEXPECTED_MESSAGE",result:result}));return}}async _write(message,shard){throw new Error("sub-classes must override this")}validateUrl(url){const urlPattern=/^(wss?):\/\/[a-zA-Z0-9.-]+(:\d+)?$/;if(!urlPattern.test(url)){let errorMessage="Invalid URL: ";if(!/^wss?:\/\//.test(url)){errorMessage+="URL must start with ws:// or wss://. "}if(url.endsWith("/")){errorMessage+="URL should not end with a /. "}if(/\/[^/]+/.test(url)){errorMessage+="URL should not contain a path, query string, or fragment. "}throw new Error(errorMessage.trim())}}}function getGlobal(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")}const _WebSocket=getGlobal().WebSocket;class WebSocketProvider extends SocketProvider{#websockets;readyMap=new Map;get websocket(){if(this.#websockets==null){throw new Error("websocket closed")}return this.#websockets}constructor(url,network,options){super(network,options);this.#websockets=[];if(typeof url==="string"){this.validateUrl(url)}else if(Array.isArray(url)){url.forEach(it=>this.validateUrl(it))}else if(typeof url==="function"){this.validateUrl(url().url)}else{this.validateUrl(url.url)}this.initialize(typeof url==="string"?[url]:url)}initWebSocket(websocket,shard,port){websocket.onerror=error=>{console.log("WebsocketProvider error",error);websocket.close()};websocket.onopen=async()=>{try{await this._start();this.resume();this.readyMap.set(shard,true);try{const zone=toZone(shard);this.provider.startZoneSubscriptions(zone)}catch(error){}}catch(error){console.log("failed to start WebsocketProvider",error);this.readyMap.set(shard,false)}};websocket.onclose=()=>{setTimeout(()=>{const baseUrl=websocket.url.split(":").slice(0,2).join(":").split("/").slice(0,3).join("/");const shardSuffix=this._getOption("usePathing")?`/${fromShard(shard,"nickname")}`:`:${port}`;const newWebSocket=this.createWebSocket(baseUrl,shardSuffix);this.initWebSocket(newWebSocket,shard,port);this.#websockets.push(newWebSocket);this._urlMap.set(shard,newWebSocket)},500)};websocket.onmessage=message=>{this._processMessage(message.data)}}async waitShardReady(shard){let count=0;while(!this.readyMap.get(shard)){await new Promise(resolve=>setTimeout(resolve,Math.pow(2,count)));if(count>11){throw new Error("Timeout waiting for shard to be ready")}count++}}createWebSocket=(baseUrl,suffix)=>{const tempWs=new _WebSocket(`${baseUrl}${suffix}`);return tempWs};async initialize(urls){this.#websockets=[];this._urlMap.clear();try{const primeSuffix=this._getOption("usePathing")?`/${fromShard(Shard.Prime,"nickname")}`:":8001";const initShardWebSockets=async baseUrl=>{const shards=await this._getRunningLocations(Shard.Prime,true);await Promise.all(shards.map(async shard=>{const port=8200+20*shard[0]+shard[1];const shardEnum=toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);const shardSuffix=this._getOption("usePathing")?`/${fromShard(shardEnum,"nickname")}`:`:${port}`;const shardUrl=baseUrl.split(":").slice(0,2).join(":");const websocket=this.createWebSocket(shardUrl,shardSuffix);this.initWebSocket(websocket,shardEnum,port);this.#websockets.push(websocket);this._urlMap.set(shardEnum,websocket);try{await this.waitShardReady(shardEnum)}catch(error){console.log("failed to waitShardReady",error);this._initFailed=true}}))};if(Array.isArray(urls)){for(const url of urls){const baseUrl=`${url.split(":")[0]}:${url.split(":")[1]}`;const primeWebsocket=this.createWebSocket(baseUrl,primeSuffix);this.initWebSocket(primeWebsocket,Shard.Prime,8001);this.#websockets.push(primeWebsocket);this._urlMap.set(Shard.Prime,primeWebsocket);await this.waitShardReady(Shard.Prime);await initShardWebSockets(baseUrl)}}else if(typeof urls==="function"){const primeWebsocket=urls();this.initWebSocket(primeWebsocket,Shard.Prime,8001);this.#websockets.push(primeWebsocket);this._urlMap.set(Shard.Prime,primeWebsocket);await this.waitShardReady(Shard.Prime);const baseUrl=this.#websockets[0].url.split(":").slice(0,2).join(":");await initShardWebSockets(baseUrl)}else{const primeWebsocket=urls;this.initWebSocket(primeWebsocket,Shard.Prime,8001);this.#websockets.push(primeWebsocket);this._urlMap.set(Shard.Prime,primeWebsocket);await this.waitShardReady(Shard.Prime);const baseUrl=primeWebsocket.url.split(":").slice(0,2).join(":");await initShardWebSockets(baseUrl)}if(this.initResolvePromise)this.initResolvePromise()}catch(error){this._initFailed=true;console.log("failed to initialize",error);this.#websockets=[];if(this.initRejectPromise)this.initRejectPromise(error);return}}async _write(message,shard){if(this.websocket.length<1){throw new Error("Websocket closed")}if(shard&&!this._urlMap.has(shard)){throw new Error("Shard not found")}const websocket=shard?this._urlMap.get(shard):this.websocket[this.websocket.length-1];if(!websocket){throw new Error("Websocket is undefined")}if(shard){await this.waitShardReady(shard)}websocket.send(message)}async destroy(){this.#websockets.forEach(it=>it.close());this.#websockets=[];super.destroy()}}const Base64=")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";function decodeBits(width,data){const maxValue=(1<<width)-1;const result=[];let accum=0,bits=0,flood=0;for(let i=0;i<data.length;i++){accum=accum<<6|Base64.indexOf(data[i]);bits+=6;while(bits>=width){const value=accum>>bits-width;accum&=(1<<bits-width)-1;bits-=width;if(value===0){flood+=maxValue}else{result.push(value+flood);flood=0}}}return result}function decodeOwlA(data,accents){let words=decodeOwl(data).join(",");accents.split(/,/g).forEach(accent=>{const match=accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);assertArgument(match!==null,"internal error parsing accents","accents",accents);let posOffset=0;const positions=decodeBits(parseInt(match[3]),match[4]);const charCode=parseInt(match[2]);const regex=new RegExp(`([${match[1]}])`,"g");words=words.replace(regex,(all,letter)=>{const rem=--positions[posOffset];if(rem===0){letter=String.fromCharCode(letter.charCodeAt(0),charCode);posOffset++}return letter})});return words.split(",")}class WordlistOwlA extends WordlistOwl{#accent;constructor(locale,data,accent,checksum){super(locale,data,checksum);this.#accent=accent}get _accent(){return this.#accent}_decodeWords(){return decodeOwlA(this._data,this._accent)}}const words="0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";const accents="aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";const checksum="0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";let wordlist=null;class LangEs extends WordlistOwlA{constructor(){super("es",words,accents,checksum)}static wordlist(){if(wordlist==null){wordlist=new LangEs}return wordlist}}const wordlists={en:LangEn.wordlist(),es:LangEs.wordlist()};var quais=Object.freeze({__proto__:null,AbiCoder:AbiCoder,AbstractProvider:AbstractProvider,AbstractSigner:AbstractSigner,get AddressStatus(){return AddressStatus},BaseContract:BaseContract,Block:Block,BrowserProvider:BrowserProvider,ConstructorFragment:ConstructorFragment,Contract:Contract,ContractEventPayload:ContractEventPayload,ContractFactory:ContractFactory,ContractTransactionReceipt:ContractTransactionReceipt,ContractTransactionResponse:ContractTransactionResponse,ContractUnknownEventPayload:ContractUnknownEventPayload,ErrorDescription:ErrorDescription,ErrorFragment:ErrorFragment,EventFragment:EventFragment,EventLog:EventLog,EventPayload:EventPayload,FallbackFragment:FallbackFragment,FeeData:FeeData,FetchCancelSignal:FetchCancelSignal,FetchRequest:FetchRequest,FetchResponse:FetchResponse,FewestCoinSelector:FewestCoinSelector,FixedNumber:FixedNumber,Fragment:Fragment,FunctionFragment:FunctionFragment,Indexed:Indexed,Interface:Interface,JsonRpcApiProvider:JsonRpcApiProvider,JsonRpcProvider:JsonRpcProvider,JsonRpcSigner:JsonRpcSigner,LangEn:LangEn,LangEs:LangEs,get Ledger(){return Ledger},Log:Log,LogDescription:LogDescription,MaxInt256:MaxInt256,MaxUint256:MaxUint256,MessagePrefix:MessagePrefix,MinInt256:MinInt256,Mnemonic:Mnemonic,N:N$1,NamedFragment:NamedFragment,Network:Network,ParamType:ParamType,QiHDWallet:QiHDWallet,QiTransaction:QiTransaction,QuaiHDWallet:QuaiHDWallet,QuaiTransaction:QuaiTransaction,Result:Result,get Shard(){return Shard},Signature:Signature,SigningKey:SigningKey,SocketBlockSubscriber:SocketBlockSubscriber,SocketEventSubscriber:SocketEventSubscriber,SocketPendingSubscriber:SocketPendingSubscriber,SocketProvider:SocketProvider,SocketSubscriber:SocketSubscriber,StructFragment:StructFragment,TransactionDescription:TransactionDescription,TransactionReceipt:TransactionReceipt,Typed:Typed,TypedDataEncoder:TypedDataEncoder,UTXO:UTXO,UndecodedEventLog:UndecodedEventLog,UnmanagedSubscriber:UnmanagedSubscriber,VoidSigner:VoidSigner,Wallet:Wallet,WebSocketProvider:WebSocketProvider,WeiPerEther:WeiPerEther,Wordlist:Wordlist,WordlistOwl:WordlistOwl,WordlistOwlA:WordlistOwlA,ZeroAddress:ZeroAddress,ZeroHash:ZeroHash,get Zone(){return Zone},accessListify:accessListify,checkResultErrors:checkResultErrors,computeAddress:computeAddress,computeHmac:computeHmac,concat:concat,copyRequest:copyRequest,dataLength:dataLength,dataSlice:dataSlice,decodeBase58:decodeBase58,decodeBase64:decodeBase64,decodeBytes32:decodeBytes32,decryptKeystoreJson:decryptKeystoreJson,decryptKeystoreJsonSync:decryptKeystoreJsonSync,denominations:denominations,encodeBase58:encodeBase58,encodeBase64:encodeBase64,encodeBytes32:encodeBytes32,encryptKeystoreJson:encryptKeystoreJson,encryptKeystoreJsonSync:encryptKeystoreJsonSync,formatMixedCaseChecksumAddress:formatMixedCaseChecksumAddress,formatQi:formatQi,formatQuai:formatQuai,formatUnits:formatUnits,fromTwos:fromTwos,getAddress:getAddress,getAddressDetails:getAddressDetails,getBigInt:getBigInt,getBytes:getBytes,getBytesCopy:getBytesCopy,getCreate2Address:getCreate2Address,getCreateAddress:getCreateAddress,getNumber:getNumber,getTxType:getTxType,getUint:getUint,getZoneForAddress:getZoneForAddress,hashMessage:hashMessage,hexlify:hexlify,id:id,isAddress:isAddress,isAddressable:isAddressable,isBytesLike:isBytesLike,isCallException:isCallException,isError:isError,isHexString:isHexString,isKeystoreJson:isKeystoreJson,isQiAddress:isQiAddress,isQuaiAddress:isQuaiAddress,keccak256:keccak256,lock:lock,makeError:makeError,mask:mask,musigCrypto:musigCrypto,parseQi:parseQi,parseQuai:parseQuai,parseUnits:parseUnits,pbkdf2:pbkdf2,quaisymbol:quaisymbol,randomBytes:randomBytes,recoverAddress:recoverAddress,resolveAddress:resolveAddress,ripemd160:ripemd160,scrypt:scrypt,scryptSync:scryptSync,sha256:sha256,sha512:sha512,solidityPacked:solidityPacked,solidityPackedKeccak256:solidityPackedKeccak256,solidityPackedSha256:solidityPackedSha256,stripZerosLeft:stripZerosLeft,toBeArray:toBeArray,toBeHex:toBeHex,toBigInt:toBigInt,toNumber:toNumber,toQuantity:toQuantity,toShard:toShard,toTwos:toTwos,toUtf8Bytes:toUtf8Bytes,toUtf8CodePoints:toUtf8CodePoints,toUtf8String:toUtf8String,toZone:toZone,uuidV4:uuidV4,validateAddress:validateAddress,verifyMessage:verifyMessage,verifyTypedData:verifyTypedData,version:version,wordlists:wordlists,zeroPadBytes:zeroPadBytes,zeroPadValue:zeroPadValue});export{AbiCoder,AbstractProvider,AbstractSigner,AddressStatus,BaseContract,Block,BrowserProvider,ConstructorFragment,Contract,ContractEventPayload,ContractFactory,ContractTransactionReceipt,ContractTransactionResponse,ContractUnknownEventPayload,ErrorDescription,ErrorFragment,EventFragment,EventLog,EventPayload,FallbackFragment,FeeData,FetchCancelSignal,FetchRequest,FetchResponse,FewestCoinSelector,FixedNumber,Fragment,FunctionFragment,Indexed,Interface,JsonRpcApiProvider,JsonRpcProvider,JsonRpcSigner,LangEn,LangEs,Ledger,Log,LogDescription,MaxInt256,MaxUint256,MessagePrefix,MinInt256,Mnemonic,N$1 as N,NamedFragment,Network,ParamType,QiHDWallet,QiTransaction,QuaiHDWallet,QuaiTransaction,Result,Shard,Signature,SigningKey,SocketBlockSubscriber,SocketEventSubscriber,SocketPendingSubscriber,SocketProvider,SocketSubscriber,StructFragment,TransactionDescription,TransactionReceipt,Typed,TypedDataEncoder,UTXO,UndecodedEventLog,UnmanagedSubscriber,VoidSigner,Wallet,WebSocketProvider,WeiPerEther,Wordlist,WordlistOwl,WordlistOwlA,ZeroAddress,ZeroHash,Zone,accessListify,checkResultErrors,computeAddress,computeHmac,concat,copyRequest,dataLength,dataSlice,decodeBase58,decodeBase64,decodeBytes32,decryptKeystoreJson,decryptKeystoreJsonSync,denominations,encodeBase58,encodeBase64,encodeBytes32,encryptKeystoreJson,encryptKeystoreJsonSync,formatMixedCaseChecksumAddress,formatQi,formatQuai,formatUnits,fromTwos,getAddress,getAddressDetails,getBigInt,getBytes,getBytesCopy,getCreate2Address,getCreateAddress,getNumber,getTxType,getUint,getZoneForAddress,hashMessage,hexlify,id,isAddress,isAddressable,isBytesLike,isCallException,isError,isHexString,isKeystoreJson,isQiAddress,isQuaiAddress,keccak256,lock,makeError,mask,musigCrypto,parseQi,parseQuai,parseUnits,pbkdf2,quais,quaisymbol,randomBytes,recoverAddress,resolveAddress,ripemd160,scrypt,scryptSync,sha256,sha512,solidityPacked,solidityPackedKeccak256,solidityPackedSha256,stripZerosLeft,toBeArray,toBeHex,toBigInt,toNumber,toQuantity,toShard,toTwos,toUtf8Bytes,toUtf8CodePoints,toUtf8String,toZone,uuidV4,validateAddress,verifyMessage,verifyTypedData,version,wordlists,zeroPadBytes,zeroPadValue};