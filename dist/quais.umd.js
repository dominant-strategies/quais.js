const __$G = (typeof globalThis !== 'undefined' ? globalThis: typeof window !== 'undefined' ? window: typeof global !== 'undefined' ? global: typeof self !== 'undefined' ? self: {});
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('google-protobuf'), require('@bitcoinerlab/secp256k1')) :
    typeof define === 'function' && define.amd ? define(['exports', 'google-protobuf', '@bitcoinerlab/secp256k1'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.quais = {}, global.pb_1, global.ecc));
})(this, (function (exports, pb_1, ecc) { 'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var pb_1__namespace = /*#__PURE__*/_interopNamespaceDefault(pb_1);

    /* Do NOT modify this file; see /src/_admin/update-version.ts */
    /**
     * The current version of quais.
     *
     * @ignore
     */
    const version = '1.0.0-alpha.33';

    /**
     * Property helper functions.
     */
    function checkType(value, type, name) {
        const types = type.split('|').map((t) => t.trim());
        for (let i = 0; i < types.length; i++) {
            switch (type) {
                case 'any':
                    return;
                case 'bigint':
                case 'boolean':
                case 'number':
                case 'string':
                    if (typeof value === type) {
                        return;
                    }
            }
        }
        const error = new Error(`invalid value for type ${type}`);
        error.code = 'INVALID_ARGUMENT';
        error.argument = `value.${name}`;
        error.value = value;
        throw error;
    }
    /**
     * Resolves to a new object that is a copy of `value`, but with all values resolved.
     *
     * @category Utils
     * @param {Object} value - The object to resolve.
     * @returns {Promise<Object>} The resolved object.
     */
    async function resolveProperties(value) {
        const keys = Object.keys(value);
        const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
        return results.reduce((accum, v, index) => {
            accum[keys[index]] = v;
            return accum;
        }, {});
    }
    // Crawl up the constructor chain to find a static method
    function getStatic(ctor, key) {
        for (let i = 0; i < 32; i++) {
            if (ctor[key]) {
                return ctor[key];
            }
            if (!ctor.prototype || typeof ctor.prototype !== 'object') {
                break;
            }
            ctor = Object.getPrototypeOf(ctor.prototype).constructor;
        }
        return null;
    }
    /**
     * Assigns the `values` to `target` as read-only values.
     *
     * It `types` is specified, the values are checked.
     *
     * @category Utils
     * @param {Object} target - The target object to assign to.
     * @param {Object} values - The values to assign.
     * @param {Object} types - The types to check.
     */
    function defineProperties(target, values, types) {
        for (const key in values) {
            const value = values[key];
            const type = types ? types[key] : null;
            if (type) {
                checkType(value, type, key);
            }
            Object.defineProperty(target, key, { enumerable: true, value, writable: false });
        }
    }

    /**
     * All errors in quais include properties to ensure they are both human-readable (i.e. `.message`) and machine-readable
     * (i.e. `.code`).
     *
     * The {@link isError | **isError**} function can be used to check the error `code` and provide a type guard for the
     * properties present on that error interface.
     */
    function stringify(value) {
        if (value == null) {
            return 'null';
        }
        if (Array.isArray(value)) {
            return '[ ' + value.map(stringify).join(', ') + ' ]';
        }
        if (value instanceof Uint8Array) {
            const HEX = '0123456789abcdef';
            let result = '0x';
            for (let i = 0; i < value.length; i++) {
                result += HEX[value[i] >> 4];
                result += HEX[value[i] & 0xf];
            }
            return result;
        }
        if (typeof value === 'object' && typeof value.toJSON === 'function') {
            return stringify(value.toJSON());
        }
        switch (typeof value) {
            case 'boolean':
            case 'symbol':
                return value.toString();
            case 'bigint':
                return BigInt(value).toString();
            case 'number':
                return value.toString();
            case 'string':
                return JSON.stringify(value);
            case 'object': {
                const keys = Object.keys(value);
                keys.sort();
                return '{ ' + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(', ') + ' }';
            }
        }
        return `[ COULD NOT SERIALIZE ]`;
    }
    /**
     * Returns true if the `error` matches an error thrown by quais that matches the error `code`.
     *
     * In TypeScript environments, this can be used to check that `error` matches an quaisError type, which means the
     * expected properties will be set.
     *
     * @category Utils
     * @example
     *
     * ```ts
     * try {
     *     // code....
     * } catch (e) {
     *     if (isError(e, 'CALL_EXCEPTION')) {
     *         // The Type Guard has validated this object
     *         console.log(e.data);
     *     }
     * }
     * ```
     *
     * @see [ErrorCodes](api:ErrorCode)
     */
    function isError(error, code) {
        return error && error.code === code;
    }
    /**
     * Returns true if `error` is a {@link CallExceptionError | **CallExceptionError**}.
     *
     * @category Utils
     */
    function isCallException(error) {
        return isError(error, 'CALL_EXCEPTION');
    }
    /**
     * Returns a new Error configured to the format quais emits errors, with the `message`, {@link ErrorCode | **ErrorCode**}
     * `code` and additional properties for the corresponding quaisError.
     *
     * Each error in quais includes the version of quais, a machine-readable {@link ErrorCode | **ErrorCode**}, and depending
     * on `code`, additional required properties. The error message will also include the `message`, quais version, `code`
     * and all additional properties, serialized.
     *
     * @category Utils
     * @param {string} message - The error message.
     * @param {ErrorCode} code - The error code.
     * @param {ErrorInfo<T>} [info] - Additional properties for the error.
     * @returns {T} The new error.
     */
    function makeError(message, code, info) {
        const shortMessage = message;
        {
            const details = [];
            if (info) {
                if ('message' in info || 'code' in info || 'name' in info) {
                    throw new Error(`value will overwrite populated values: ${stringify(info)}`);
                }
                for (const key in info) {
                    if (key === 'shortMessage') {
                        continue;
                    }
                    const value = info[key];
                    details.push(key + '=' + stringify(value));
                }
            }
            details.push(`code=${code}`);
            details.push(`version=${version}`);
            if (details.length) {
                message += ' (' + details.join(', ') + ')';
            }
        }
        let error;
        switch (code) {
            case 'INVALID_ARGUMENT':
                error = new TypeError(message);
                break;
            case 'NUMERIC_FAULT':
            case 'BUFFER_OVERRUN':
                error = new RangeError(message);
                break;
            default:
                error = new Error(message);
        }
        defineProperties(error, { code });
        if (info) {
            Object.assign(error, info);
        }
        if (error.shortMessage == null) {
            defineProperties(error, { shortMessage });
        }
        return error;
    }
    /**
     * Throws an quaisError with `message`, `code` and additional error `info` when `check` is falsish..
     *
     * @category Utils
     * @param {unknown} check - The value to check.
     * @param {string} message - The error message.
     * @param {ErrorCode} code - The error code.
     * @param {ErrorInfo<T>} [info] - Additional properties for the error.
     * @throws {T} Throws the error if `check` is falsish.
     */
    function assert$1(check, message, code, info) {
        if (!check) {
            throw makeError(message, code, info);
        }
    }
    /**
     * A simple helper to simply ensuring provided arguments match expected constraints, throwing if not.
     *
     * In TypeScript environments, the `check` has been asserted true, so any further code does not need additional
     * compile-time checks.
     *
     * @category Utils
     * @param {unknown} check - The value to check.
     * @param {string} message - The error message.
     * @param {string} name - The name of the argument.
     * @param {unknown} value - The value of the argument.
     * @throws {InvalidArgumentError} Throws if `check` is falsish.
     */
    function assertArgument(check, message, name, value) {
        assert$1(check, message, 'INVALID_ARGUMENT', { argument: name, value: value });
    }
    function assertArgumentCount(count, expectedCount, message) {
        if (message == null) {
            message = '';
        }
        if (message) {
            message = ': ' + message;
        }
        assert$1(count >= expectedCount, 'missing arguemnt' + message, 'MISSING_ARGUMENT', {
            count: count,
            expectedCount: expectedCount,
        });
        assert$1(count <= expectedCount, 'too many arguemnts' + message, 'UNEXPECTED_ARGUMENT', {
            count: count,
            expectedCount: expectedCount,
        });
    }
    const _normalizeForms = ['NFD', 'NFC', 'NFKD', 'NFKC'].reduce((accum, form) => {
        try {
            // General test for normalize
            /* c8 ignore start */
            if ('test'.normalize(form) !== 'test') {
                throw new Error('bad');
            }
            /* c8 ignore stop */
            if (form === 'NFD') {
                const check = String.fromCharCode(0xe9).normalize('NFD');
                const expected = String.fromCharCode(0x65, 0x0301);
                /* c8 ignore start */
                if (check !== expected) {
                    throw new Error('broken');
                }
                /* c8 ignore stop */
            }
            accum.push(form);
            // eslint-disable-next-line no-empty
        }
        catch (error) { }
        return accum;
    }, []);
    /**
     * Throws if the normalization `form` is not supported.
     *
     * @category Utils
     * @param {string} form - The normalization form.
     * @throws {UnsupportedOperationError} Throws if the form is not supported.
     */
    function assertNormalize(form) {
        assert$1(_normalizeForms.indexOf(form) >= 0, 'platform missing String.prototype.normalize', 'UNSUPPORTED_OPERATION', {
            operation: 'String.prototype.normalize',
            info: { form },
        });
    }
    /**
     * Many classes use file-scoped values to guard the constructor, making it effectively private. This facilitates that
     * pattern by ensuring the `givenGuard` matches the file-scoped `guard`, throwing if not, indicating the `className%% if
     * provided.
     *
     * @category Utils
     * @param {any} givenGuard - The guard provided to the constructor.
     * @param {any} guard - The file-scoped guard.
     * @param {string} [className] - The class name.
     * @throws {UnsupportedOperationError} Throws if the guards do not match.
     */
    function assertPrivate(givenGuard, guard, className) {
        if (className == null) {
            className = '';
        }
        if (givenGuard !== guard) {
            let method = className, operation = 'new';
            if (className) {
                method += '.';
                operation += ' ' + className;
            }
            assert$1(false, `private constructor; use ${method}from* methods`, 'UNSUPPORTED_OPERATION', {
                operation,
            });
        }
    }

    /**
     * Some data helpers.
     */
    /**
     * Converts a BytesLike value to a Uint8Array.
     *
     * @ignore
     * @category Utils
     * @param {BytesLike} value - The value to convert.
     * @param {string} [name] - The name of the value for error context.
     * @param {boolean} [copy] - Whether to create a copy of the value.
     * @returns {Uint8Array} The converted Uint8Array.
     * @throws {Error} If the value is not a valid BytesLike.
     */
    function _getBytes(value, name, copy) {
        if (value instanceof Uint8Array) {
            if (copy) {
                return new Uint8Array(value);
            }
            return value;
        }
        if (typeof value === 'string' && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            const result = new Uint8Array((value.length - 2) / 2);
            let offset = 2;
            for (let i = 0; i < result.length; i++) {
                result[i] = parseInt(value.substring(offset, offset + 2), 16);
                offset += 2;
            }
            return result;
        }
        assertArgument(false, 'invalid BytesLike value', name || 'value', value);
    }
    /**
     * Get a typed Uint8Array for `value`. If already a Uint8Array the original `value` is returned; if a copy is required
     * use {@link getBytesCopy | **getBytesCopy**}.
     *
     * @category Utils
     * @param {BytesLike} value - The value to convert to a Uint8Array.
     * @param {string} [name] - The name of the value for error context.
     * @returns {Uint8Array} The typed Uint8Array.
     */
    function getBytes(value, name) {
        return _getBytes(value, name, false);
    }
    /**
     * Get a typed Uint8Array for `value`, creating a copy if necessary to prevent any modifications of the returned value
     * from being reflected elsewhere.
     *
     * @category Utils
     * @param {BytesLike} value - The value to convert to a Uint8Array.
     * @param {string} [name] - The name of the value for error context.
     * @returns {Uint8Array} The typed Uint8Array.
     */
    function getBytesCopy(value, name) {
        return _getBytes(value, name, true);
    }
    /**
     * Returns true if `value` is a valid {@link HexString | **HexString**}.
     *
     * If `length` is `true` or a number, it also checks that `value` is a valid {@link DataHexString | **DataHexString**} of
     * `length` (if a number) bytes of data (e.g. `0x1234` is 2 bytes).
     *
     * @category Utils
     * @param {any} value - The value to check.
     * @param {number | boolean} [length] - The expected length of the data.
     * @returns {boolean} True if the value is a valid {@link HexString | **HexString**}.
     */
    function isHexString(value, length) {
        if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
            return false;
        }
        if (typeof length === 'number' && value.length !== 2 + 2 * length) {
            return false;
        }
        if (length === true && value.length % 2 !== 0) {
            return false;
        }
        return true;
    }
    /**
     * Returns true if `value` is a valid representation of arbitrary data (i.e. a valid
     * {@link DataHexString | **DataHexString**} or a Uint8Array).
     *
     * @category Utils
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is a valid {@link DataHexString | **DataHexString**}.
     */
    function isBytesLike(value) {
        return isHexString(value, true) || value instanceof Uint8Array;
    }
    const HexCharacters = '0123456789abcdef';
    /**
     * Returns a {@link DataHexString | **DataHexString**} representation of `data`.
     *
     * @category Utils
     * @param {BytesLike} data - The data to convert to a hex string.
     * @returns {string} The hex string.
     */
    function hexlify(data) {
        const bytes = getBytes(data);
        let result = '0x';
        for (let i = 0; i < bytes.length; i++) {
            const v = bytes[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    /**
     * Returns a {@link DataHexString | **DataHexString** } by concatenating all values within `data`.
     *
     * @category Utils
     * @param {ReadonlyArray<BytesLike>} datas - The data to concatenate.
     * @returns {string} The concatenated data.
     */
    function concat(datas) {
        return '0x' + datas.map((d) => hexlify(d).substring(2)).join('');
    }
    /**
     * Returns the length of `data`, in bytes.
     *
     * @category Utils
     * @param {BytesLike} data - The data to get the length of.
     * @returns {number} The length of the data.
     */
    function dataLength(data) {
        if (isHexString(data, true)) {
            return (data.length - 2) / 2;
        }
        return getBytes(data).length;
    }
    /**
     * Returns a {@link DataHexString | **DataHexString** } by slicing `data` from the `start` offset to the `end` offset.
     *
     * By default `start` is 0 and `end` is the length of `data`.
     *
     * @category Utils
     * @param {BytesLike} data - The data to slice.
     * @param {number} [start] - The start offset.
     * @param {number} [end] - The end offset.
     * @returns {string} The sliced data.
     * @throws {Error} If the end offset is beyond the data bounds.
     */
    function dataSlice(data, start, end) {
        const bytes = getBytes(data);
        if (end != null && end > bytes.length) {
            assert$1(false, 'cannot slice beyond data bounds', 'BUFFER_OVERRUN', {
                buffer: bytes,
                length: bytes.length,
                offset: end,
            });
        }
        return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
    }
    /**
     * Return the {@link DataHexString | **DataHexString**} result by stripping all **leading** zero bytes from `data`.
     *
     * @category Utils
     * @param {BytesLike} data - The data to strip.
     * @returns {string} The stripped data.
     */
    function stripZerosLeft(data) {
        let bytes = hexlify(data).substring(2);
        while (bytes.startsWith('00')) {
            bytes = bytes.substring(2);
        }
        return '0x' + bytes;
    }
    /**
     * Pads the data to the specified length.
     *
     * @ignore
     * @category Utils
     * @param {BytesLike} data - The data to pad.
     * @param {number} length - The length to pad to.
     * @param {boolean} left - Whether to pad on the left.
     * @returns {string} The padded data.
     * @throws {Error} If the padding exceeds data length.
     */
    function zeroPad(data, length, left) {
        const bytes = getBytes(data);
        assert$1(length >= bytes.length, 'padding exceeds data length', 'BUFFER_OVERRUN', {
            buffer: new Uint8Array(bytes),
            length: length,
            offset: length + 1,
        });
        const result = new Uint8Array(length);
        result.fill(0);
        if (left) {
            result.set(bytes, length - bytes.length);
        }
        else {
            result.set(bytes, 0);
        }
        return hexlify(result);
    }
    /**
     * Return the {@link DataHexString | **DataHexString**} of `data` padded on the **left** to `length` bytes.
     *
     * If `data` already exceeds `length`, a [BufferOverrunError](../interfaces/BufferOverrunError) is thrown.
     *
     * This pads data the same as **values** are in Solidity (e.g. `uint128`).
     *
     * @category Utils
     * @param {BytesLike} data - The data to pad.
     * @param {number} length - The length to pad to.
     * @returns {string} The padded data.
     */
    function zeroPadValue(data, length) {
        return zeroPad(data, length, true);
    }
    /**
     * Return the {@link DataHexString | **DataHexString**} of `data` padded on the **right** to `length` bytes.
     *
     * If `data` already exceeds %%length%%, a [BufferOverrunError](../interfaces/BufferOverrunError) is thrown.
     *
     * This pads data the same as **bytes** are in Solidity (e.g. `bytes16`).
     *
     * @category Utils
     * @param {BytesLike} data - The data to pad.
     * @param {number} length - The length to pad to.
     * @returns {string} The padded data.
     */
    function zeroPadBytes(data, length) {
        return zeroPad(data, length, false);
    }

    /**
     * When an {@link EventEmitterable | **EventEmitterable**} triggers a Listener, the callback always ahas one additional
     * argument passed, which is an **EventPayload**.
     *
     * @category Utils
     */
    class EventPayload {
        /**
         * The event filter.
         */
        filter;
        /**
         * The **EventEmitterable**.
         */
        emitter;
        #listener;
        /**
         * Create a new **EventPayload** for `emitter` with the `listener` and for `filter`.
         */
        constructor(emitter, listener, filter) {
            this.#listener = listener;
            defineProperties(this, { emitter, filter });
        }
        /**
         * Unregister the triggered listener for future events.
         */
        async removeListener() {
            if (this.#listener == null) {
                return;
            }
            await this.emitter.off(this.filter, this.#listener);
        }
    }

    function decodeBase64(textData) {
        textData = atob(textData);
        const data = new Uint8Array(textData.length);
        for (let i = 0; i < textData.length; i++) {
            data[i] = textData.charCodeAt(i);
        }
        return getBytes(data);
    }
    function encodeBase64(_data) {
        const data = getBytes(_data);
        let textData = '';
        for (let i = 0; i < data.length; i++) {
            textData += String.fromCharCode(data[i]);
        }
        return btoa(textData);
    }

    /**
     * Provides utility functions for encoding and decoding strings in the Bytes32 format.
     *
     * @category Application Binary Interface
     */
    /**
     * Encodes a string as a Bytes32 string. This is used to encode ABI data.
     *
     * @category Encoding
     * @param {string} text - The string to encode.
     * @returns {string} The Bytes32-encoded string.
     * @throws {Error} If the string is too long to fit in a Bytes32 format.
     */
    function encodeBytes32(text) {
        // Get the bytes
        const bytes = toUtf8Bytes(text);
        // Check we have room for null-termination
        if (bytes.length > 31) {
            throw new Error('bytes32 string must be less than 32 bytes');
        }
        // Zero-pad (implicitly null-terminates)
        return zeroPadBytes(bytes, 32);
    }
    /**
     * Decodes a Bytes32-encoded string into a regular string. This is used to decode ABI-encoded data.
     *
     * @category Encoding
     * @param {BytesLike} _bytes - The Bytes32-encoded data.
     * @returns {string} The decoded string.
     * @throws {Error} If the input is not exactly 32 bytes long or lacks a null terminator.
     */
    function decodeBytes32(_bytes) {
        const data = getBytes(_bytes, 'bytes');
        // Must be 32 bytes with a null-termination
        if (data.length !== 32) {
            throw new Error('invalid bytes32 - not 32 bytes long');
        }
        if (data[31] !== 0) {
            throw new Error('invalid bytes32 string - no null terminator');
        }
        // Find the null termination
        let length = 31;
        while (data[length - 1] === 0) {
            length--;
        }
        // Determine the string value
        return toUtf8String(data.slice(0, length));
    }

    /**
     * Some mathematic operations.
     */
    const BN_0$8 = BigInt(0);
    const BN_1$4 = BigInt(1);
    //const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
    // IEEE 754 support 53-bits of mantissa
    const maxValue = 0x1fffffffffffff;
    /**
     * Convert `value` from a twos-compliment representation of `width` bits to its value.
     *
     * If the highest bit is `1`, the result will be negative.
     *
     * @category Utils
     * @param {BigNumberish} _value - The value to convert.
     * @param {Numeric} _width - The width of the value in bits.
     * @returns {bigint} The value.
     * @throws {Error} If the value is too large for the width.
     */
    function fromTwos(_value, _width) {
        const value = getUint(_value, 'value');
        const width = BigInt(getNumber(_width, 'width'));
        assert$1(value >> width === BN_0$8, 'overflow', 'NUMERIC_FAULT', {
            operation: 'fromTwos',
            fault: 'overflow',
            value: _value,
        });
        // Top bit set; treat as a negative value
        if (value >> (width - BN_1$4)) {
            const mask = (BN_1$4 << width) - BN_1$4;
            return -((~value & mask) + BN_1$4);
        }
        return value;
    }
    /**
     * Convert `value` to a twos-compliment representation of `width` bits.
     *
     * The result will always be positive.
     *
     * @category Utils
     * @param {BigNumberish} _value - The value to convert.
     * @param {Numeric} _width - The width of the value in bits.
     * @returns {bigint} The value.
     * @throws {Error} If the value is too large for the width.
     */
    function toTwos(_value, _width) {
        let value = getBigInt(_value, 'value');
        const width = BigInt(getNumber(_width, 'width'));
        const limit = BN_1$4 << (width - BN_1$4);
        if (value < BN_0$8) {
            value = -value;
            assert$1(value <= limit, 'too low', 'NUMERIC_FAULT', {
                operation: 'toTwos',
                fault: 'overflow',
                value: _value,
            });
            const mask = (BN_1$4 << width) - BN_1$4;
            return (~value & mask) + BN_1$4;
        }
        else {
            assert$1(value < limit, 'too high', 'NUMERIC_FAULT', {
                operation: 'toTwos',
                fault: 'overflow',
                value: _value,
            });
        }
        return value;
    }
    /**
     * Mask `value` with a bitmask of `bits` ones.
     *
     * @category Utils
     * @param {BigNumberish} _value - The value to mask.
     * @param {Numeric} _bits - The number of bits to mask.
     * @returns {bigint} The masked value.
     */
    function mask(_value, _bits) {
        const value = getUint(_value, 'value');
        const bits = BigInt(getNumber(_bits, 'bits'));
        return value & ((BN_1$4 << bits) - BN_1$4);
    }
    /**
     * Gets a BigInt from `value`. If it is an invalid value for a BigInt, then an ArgumentError will be thrown for `name`.
     *
     * @category Utils
     * @param {BigNumberish} value - The value to convert.
     * @param {string} name - The name of the value.
     * @returns {bigint} The value.
     */
    function getBigInt(value, name) {
        switch (typeof value) {
            case 'bigint':
                return value;
            case 'number':
                assertArgument(Number.isInteger(value), 'underflow', name || 'value', value);
                assertArgument(value >= -maxValue && value <= maxValue, 'overflow', name || 'value', value);
                return BigInt(value);
            case 'string':
                try {
                    if (value === '') {
                        throw new Error('empty string');
                    }
                    if (value[0] === '-' && value[1] !== '-') {
                        return -BigInt(value.substring(1));
                    }
                    return BigInt(value);
                }
                catch (e) {
                    assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || 'value', value);
                }
        }
        assertArgument(false, 'invalid BigNumberish value', name || 'value', value);
    }
    /**
     * Returns `value` as a bigint, validating it is valid as a bigint value and that it is positive.
     *
     * @category Utils
     * @param {BigNumberish} value - The value to convert.
     * @param {string} name - The name of the value.
     * @returns {bigint} The value.
     * @throws {Error} If the value is negative.
     */
    function getUint(value, name) {
        const result = getBigInt(value, name);
        assert$1(result >= BN_0$8, 'unsigned value cannot be negative', 'NUMERIC_FAULT', {
            fault: 'overflow',
            operation: 'getUint',
            value,
        });
        return result;
    }
    const Nibbles$1 = '0123456789abcdef';
    /**
     * Converts `value` to a BigInt. If `value` is a Uint8Array, it is treated as Big Endian data.
     *
     * @category Utils
     * @param {BigNumberish | Uint8Array} value - The value to convert.
     * @returns {bigint} The value.
     */
    function toBigInt(value) {
        if (value instanceof Uint8Array) {
            let result = '0x0';
            for (const v of value) {
                result += Nibbles$1[v >> 4];
                result += Nibbles$1[v & 0x0f];
            }
            return BigInt(result);
        }
        return getBigInt(value);
    }
    /**
     * Gets a number from `value`. If it is an invalid value for a number, then an ArgumentError will be thrown for `name`.
     *
     * @category Utils
     * @param {BigNumberish} value - The value to convert.
     * @param {string} name - The name of the value.
     * @returns {number} The value.
     * @throws {Error} If the value is invalid.
     * @throws {Error} If the value is too large.
     */
    function getNumber(value, name) {
        switch (typeof value) {
            case 'bigint':
                assertArgument(value >= -maxValue && value <= maxValue, 'overflow', name || 'value', value);
                return Number(value);
            case 'number':
                assertArgument(Number.isInteger(value), 'underflow', name || 'value', value);
                assertArgument(value >= -maxValue && value <= maxValue, 'overflow', name || 'value', value);
                return value;
            case 'string':
                try {
                    if (value === '') {
                        throw new Error('empty string');
                    }
                    return getNumber(BigInt(value), name);
                }
                catch (e) {
                    assertArgument(false, `invalid numeric string: ${e.message}`, name || 'value', value);
                }
        }
        assertArgument(false, 'invalid numeric value', name || 'value', value);
    }
    /**
     * Converts `value` to a number. If `value` is a Uint8Array, it is treated as Big Endian data. Throws if the value is
     * not safe.
     *
     * @category Utils
     * @param {BigNumberish | Uint8Array} value - The value to convert.
     * @returns {number} The value.
     * @throws {Error} If the value is not safe to convert to a number.
     */
    function toNumber(value) {
        return getNumber(toBigInt(value));
    }
    /**
     * Converts `value` to a Big Endian hexstring, optionally padded to `width` bytes.
     *
     * @category Utils
     * @param {BigNumberish} _value - The value to convert.
     * @param {Numeric} _width - The width of the value in bytes.
     * @returns {string} The hexstring.
     * @throws {Error} If the value exceeds the width.
     */
    function toBeHex(_value, _width) {
        const value = getUint(_value, 'value');
        let result = value.toString(16);
        if (_width == null) {
            // Ensure the value is of even length
            if (result.length % 2) {
                result = '0' + result;
            }
        }
        else {
            const width = getNumber(_width, 'width');
            assert$1(width * 2 >= result.length, `value exceeds width (${width} bytes)`, 'NUMERIC_FAULT', {
                operation: 'toBeHex',
                fault: 'overflow',
                value: _value,
            });
            // Pad the value to the required width
            while (result.length < width * 2) {
                result = '0' + result;
            }
        }
        return '0x' + result;
    }
    /**
     * Converts `value` to a Big Endian Uint8Array.
     *
     * @category Utils
     * @param {BigNumberish} _value - The value to convert.
     * @returns {Uint8Array} The value.
     */
    function toBeArray(_value) {
        const value = getUint(_value, 'value');
        if (value === BN_0$8) {
            return new Uint8Array([]);
        }
        let hex = value.toString(16);
        if (hex.length % 2) {
            hex = '0' + hex;
        }
        const result = new Uint8Array(hex.length / 2);
        for (let i = 0; i < result.length; i++) {
            const offset = i * 2;
            result[i] = parseInt(hex.substring(offset, offset + 2), 16);
        }
        return result;
    }
    /**
     * Returns a `HexString` for `value` safe to use as a Quantity.
     *
     * A Quantity does not have and leading 0 values unless the value is the literal value `0x0`. This is most commonly used
     * for JSSON-RPC numeric values.
     *
     * @category Utils
     * @param {BigNumberish | Uint8Array} value - The value to convert.
     * @returns {string} The quantity.
     */
    function toQuantity(value) {
        let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
        while (result.startsWith('0')) {
            result = result.substring(1);
        }
        if (result === '') {
            result = '0';
        }
        return '0x' + result;
    }

    /**
     * The [Base58 Encoding](https://en.bitcoinwiki.org/wiki/Base58) scheme allows a **numeric** value to be encoded as a
     * compact string using a radix of 58 using only alpha-numeric characters. Confusingly similar characters are omitted
     * (i.e. `"l0O"`).
     *
     * Note that Base58 encodes a **numeric** value, not arbitrary bytes, since any zero-bytes on the left would get
     * removed. To mitigate this issue most schemes that use Base58 choose specific high-order values to ensure non-zero
     * prefixes.
     */
    const Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let Lookup = null;
    function getAlpha(letter) {
        if (Lookup == null) {
            Lookup = {};
            for (let i = 0; i < Alphabet.length; i++) {
                Lookup[Alphabet[i]] = BigInt(i);
            }
        }
        const result = Lookup[letter];
        assertArgument(result != null, `invalid base58 value`, 'letter', letter);
        return result;
    }
    const BN_0$7 = BigInt(0);
    const BN_58 = BigInt(58);
    /**
     * Encode `value` as a Base58-encoded string.
     *
     * @category Encoding
     * @param {BytesLike} _value - The value to encode.
     * @returns {string} The Base58-encoded string.
     */
    function encodeBase58(_value) {
        const bytes = getBytes(_value);
        let value = toBigInt(bytes);
        let result = '';
        while (value) {
            result = Alphabet[Number(value % BN_58)] + result;
            value /= BN_58;
        }
        // Account for leading padding zeros
        for (let i = 0; i < bytes.length; i++) {
            if (bytes[i]) {
                break;
            }
            result = Alphabet[0] + result;
        }
        return result;
    }
    /**
     * Decode the Base58-encoded `value`.
     *
     * @category Encoding
     * @param {string} value - The Base58-encoded value.
     * @returns {bigint} The decoded value.
     */
    function decodeBase58(value) {
        let result = BN_0$7;
        for (let i = 0; i < value.length; i++) {
            result *= BN_58;
            result += getAlpha(value[i]);
        }
        return result;
    }

    /* eslint-disable */
    /**
     * Generated by the protoc-gen-ts. DO NOT EDIT! compiler version: 5.28.2 source: proto_common.proto git:
     * https://github.com/thesayyn/protoc-gen-ts
     */
    var common;
    (function (common) {
        class ProtoLocation extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('value' in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set value(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoLocation({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.value.length)
                    writer.writeBytes(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoLocation();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoLocation.deserialize(bytes);
            }
        }
        common.ProtoLocation = ProtoLocation;
        class ProtoHash extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('value' in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set value(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoHash({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.value.length)
                    writer.writeBytes(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoHash();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoHash.deserialize(bytes);
            }
        }
        common.ProtoHash = ProtoHash;
        class ProtoHashes extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('hashes' in data && data.hashes != undefined) {
                        this.hashes = data.hashes;
                    }
                }
            }
            get hashes() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoHash, 1);
            }
            set hashes(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoHashes({});
                if (data.hashes != null) {
                    message.hashes = data.hashes.map((item) => ProtoHash.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.hashes != null) {
                    data.hashes = this.hashes.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.hashes.length)
                    writer.writeRepeatedMessage(1, this.hashes, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoHashes();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.hashes, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoHash.deserialize(reader), ProtoHash));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoHashes.deserialize(bytes);
            }
        }
        common.ProtoHashes = ProtoHashes;
        class ProtoAddress extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('value' in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set value(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoAddress({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.value.length)
                    writer.writeBytes(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoAddress();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoAddress.deserialize(bytes);
            }
        }
        common.ProtoAddress = ProtoAddress;
        class ProtoNumber extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('value' in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get value() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, 0);
            }
            set value(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoNumber({});
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.value != 0)
                    writer.writeUint64(1, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoNumber();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.value = reader.readUint64();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoNumber.deserialize(bytes);
            }
        }
        common.ProtoNumber = ProtoNumber;
        class ProtoLocations extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('locations' in data && data.locations != undefined) {
                        this.locations = data.locations;
                    }
                }
            }
            get locations() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoLocation, 1);
            }
            set locations(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoLocations({});
                if (data.locations != null) {
                    message.locations = data.locations.map((item) => ProtoLocation.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.locations != null) {
                    data.locations = this.locations.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.locations.length)
                    writer.writeRepeatedMessage(1, this.locations, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoLocations();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.locations, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoLocation.deserialize(reader), ProtoLocation));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoLocations.deserialize(bytes);
            }
        }
        common.ProtoLocations = ProtoLocations;
    })(common || (common = {}));

    /* eslint-disable */
    /**
     * Generated by the protoc-gen-ts. DO NOT EDIT! compiler version: 5.28.2 source: proto_block.proto git:
     * https://github.com/thesayyn/protoc-gen-ts
     */
    var block;
    (function (block) {
        class ProtoHeader extends pb_1__namespace.Message {
            #one_of_decls = [
                [2],
                [3],
                [4],
                [5],
                [6],
                [8],
                [9],
                [13],
                [15],
                [16],
                [17],
                [18],
                [19],
                [20],
                [21],
                [22],
                [23],
                [24],
                [25],
                [26],
                [27],
                [28],
                [29],
                [30],
                [31],
                [32],
                [33],
                [34],
                [35],
                [36],
            ];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 7, 10, 11, 12, 14], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('parent_hash' in data && data.parent_hash != undefined) {
                        this.parent_hash = data.parent_hash;
                    }
                    if ('uncle_hash' in data && data.uncle_hash != undefined) {
                        this.uncle_hash = data.uncle_hash;
                    }
                    if ('evm_root' in data && data.evm_root != undefined) {
                        this.evm_root = data.evm_root;
                    }
                    if ('tx_hash' in data && data.tx_hash != undefined) {
                        this.tx_hash = data.tx_hash;
                    }
                    if ('outbound_etx_hash' in data && data.outbound_etx_hash != undefined) {
                        this.outbound_etx_hash = data.outbound_etx_hash;
                    }
                    if ('etx_rollup_hash' in data && data.etx_rollup_hash != undefined) {
                        this.etx_rollup_hash = data.etx_rollup_hash;
                    }
                    if ('manifest_hash' in data && data.manifest_hash != undefined) {
                        this.manifest_hash = data.manifest_hash;
                    }
                    if ('receipt_hash' in data && data.receipt_hash != undefined) {
                        this.receipt_hash = data.receipt_hash;
                    }
                    if ('difficulty' in data && data.difficulty != undefined) {
                        this.difficulty = data.difficulty;
                    }
                    if ('parent_entropy' in data && data.parent_entropy != undefined) {
                        this.parent_entropy = data.parent_entropy;
                    }
                    if ('parent_delta_entropy' in data && data.parent_delta_entropy != undefined) {
                        this.parent_delta_entropy = data.parent_delta_entropy;
                    }
                    if ('parent_uncled_delta_entropy' in data && data.parent_uncled_delta_entropy != undefined) {
                        this.parent_uncled_delta_entropy = data.parent_uncled_delta_entropy;
                    }
                    if ('uncled_entropy' in data && data.uncled_entropy != undefined) {
                        this.uncled_entropy = data.uncled_entropy;
                    }
                    if ('number' in data && data.number != undefined) {
                        this.number = data.number;
                    }
                    if ('gas_limit' in data && data.gas_limit != undefined) {
                        this.gas_limit = data.gas_limit;
                    }
                    if ('gas_used' in data && data.gas_used != undefined) {
                        this.gas_used = data.gas_used;
                    }
                    if ('base_fee' in data && data.base_fee != undefined) {
                        this.base_fee = data.base_fee;
                    }
                    if ('location' in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ('extra' in data && data.extra != undefined) {
                        this.extra = data.extra;
                    }
                    if ('mix_hash' in data && data.mix_hash != undefined) {
                        this.mix_hash = data.mix_hash;
                    }
                    if ('nonce' in data && data.nonce != undefined) {
                        this.nonce = data.nonce;
                    }
                    if ('utxo_root' in data && data.utxo_root != undefined) {
                        this.utxo_root = data.utxo_root;
                    }
                    if ('etx_set_root' in data && data.etx_set_root != undefined) {
                        this.etx_set_root = data.etx_set_root;
                    }
                    if ('efficiency_score' in data && data.efficiency_score != undefined) {
                        this.efficiency_score = data.efficiency_score;
                    }
                    if ('threshold_count' in data && data.threshold_count != undefined) {
                        this.threshold_count = data.threshold_count;
                    }
                    if ('expansion_number' in data && data.expansion_number != undefined) {
                        this.expansion_number = data.expansion_number;
                    }
                    if ('etx_eligible_slices' in data && data.etx_eligible_slices != undefined) {
                        this.etx_eligible_slices = data.etx_eligible_slices;
                    }
                    if ('prime_terminus_hash' in data && data.prime_terminus_hash != undefined) {
                        this.prime_terminus_hash = data.prime_terminus_hash;
                    }
                    if ('interlink_root_hash' in data && data.interlink_root_hash != undefined) {
                        this.interlink_root_hash = data.interlink_root_hash;
                    }
                    if ('state_limit' in data && data.state_limit != undefined) {
                        this.state_limit = data.state_limit;
                    }
                    if ('state_used' in data && data.state_used != undefined) {
                        this.state_used = data.state_used;
                    }
                    if ('quai_state_size' in data && data.quai_state_size != undefined) {
                        this.quai_state_size = data.quai_state_size;
                    }
                    if ('secondary_coinbase' in data && data.secondary_coinbase != undefined) {
                        this.secondary_coinbase = data.secondary_coinbase;
                    }
                    if ('exchange_rate' in data && data.exchange_rate != undefined) {
                        this.exchange_rate = data.exchange_rate;
                    }
                    if ('quai_to_qi' in data && data.quai_to_qi != undefined) {
                        this.quai_to_qi = data.quai_to_qi;
                    }
                    if ('qi_to_quai' in data && data.qi_to_quai != undefined) {
                        this.qi_to_quai = data.qi_to_quai;
                    }
                }
            }
            get parent_hash() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 1);
            }
            set parent_hash(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            get uncle_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 2);
            }
            set uncle_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
            }
            get has_uncle_hash() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get evm_root() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 3);
            }
            set evm_root(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 3, this.#one_of_decls[1], value);
            }
            get has_evm_root() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get tx_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 4);
            }
            set tx_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 4, this.#one_of_decls[2], value);
            }
            get has_tx_hash() {
                return pb_1__namespace.Message.getField(this, 4) != null;
            }
            get outbound_etx_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 5);
            }
            set outbound_etx_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 5, this.#one_of_decls[3], value);
            }
            get has_outbound_etx_hash() {
                return pb_1__namespace.Message.getField(this, 5) != null;
            }
            get etx_rollup_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 6);
            }
            set etx_rollup_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 6, this.#one_of_decls[4], value);
            }
            get has_etx_rollup_hash() {
                return pb_1__namespace.Message.getField(this, 6) != null;
            }
            get manifest_hash() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 7);
            }
            set manifest_hash(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 7, value);
            }
            get receipt_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 8);
            }
            set receipt_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 8, this.#one_of_decls[5], value);
            }
            get has_receipt_hash() {
                return pb_1__namespace.Message.getField(this, 8) != null;
            }
            get difficulty() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 9, new Uint8Array(0));
            }
            set difficulty(value) {
                pb_1__namespace.Message.setOneofField(this, 9, this.#one_of_decls[6], value);
            }
            get has_difficulty() {
                return pb_1__namespace.Message.getField(this, 9) != null;
            }
            get parent_entropy() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 10, []);
            }
            set parent_entropy(value) {
                pb_1__namespace.Message.setField(this, 10, value);
            }
            get parent_delta_entropy() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 11, []);
            }
            set parent_delta_entropy(value) {
                pb_1__namespace.Message.setField(this, 11, value);
            }
            get parent_uncled_delta_entropy() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 12, []);
            }
            set parent_uncled_delta_entropy(value) {
                pb_1__namespace.Message.setField(this, 12, value);
            }
            get uncled_entropy() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 13, new Uint8Array(0));
            }
            set uncled_entropy(value) {
                pb_1__namespace.Message.setOneofField(this, 13, this.#one_of_decls[7], value);
            }
            get has_uncled_entropy() {
                return pb_1__namespace.Message.getField(this, 13) != null;
            }
            get number() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 14, []);
            }
            set number(value) {
                pb_1__namespace.Message.setField(this, 14, value);
            }
            get gas_limit() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 15, 0);
            }
            set gas_limit(value) {
                pb_1__namespace.Message.setOneofField(this, 15, this.#one_of_decls[8], value);
            }
            get has_gas_limit() {
                return pb_1__namespace.Message.getField(this, 15) != null;
            }
            get gas_used() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 16, 0);
            }
            set gas_used(value) {
                pb_1__namespace.Message.setOneofField(this, 16, this.#one_of_decls[9], value);
            }
            get has_gas_used() {
                return pb_1__namespace.Message.getField(this, 16) != null;
            }
            get base_fee() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 17, new Uint8Array(0));
            }
            set base_fee(value) {
                pb_1__namespace.Message.setOneofField(this, 17, this.#one_of_decls[10], value);
            }
            get has_base_fee() {
                return pb_1__namespace.Message.getField(this, 17) != null;
            }
            get location() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoLocation, 18);
            }
            set location(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 18, this.#one_of_decls[11], value);
            }
            get has_location() {
                return pb_1__namespace.Message.getField(this, 18) != null;
            }
            get extra() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 19, new Uint8Array(0));
            }
            set extra(value) {
                pb_1__namespace.Message.setOneofField(this, 19, this.#one_of_decls[12], value);
            }
            get has_extra() {
                return pb_1__namespace.Message.getField(this, 19) != null;
            }
            get mix_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 20);
            }
            set mix_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 20, this.#one_of_decls[13], value);
            }
            get has_mix_hash() {
                return pb_1__namespace.Message.getField(this, 20) != null;
            }
            get nonce() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 21, 0);
            }
            set nonce(value) {
                pb_1__namespace.Message.setOneofField(this, 21, this.#one_of_decls[14], value);
            }
            get has_nonce() {
                return pb_1__namespace.Message.getField(this, 21) != null;
            }
            get utxo_root() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 22);
            }
            set utxo_root(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 22, this.#one_of_decls[15], value);
            }
            get has_utxo_root() {
                return pb_1__namespace.Message.getField(this, 22) != null;
            }
            get etx_set_root() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 23);
            }
            set etx_set_root(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 23, this.#one_of_decls[16], value);
            }
            get has_etx_set_root() {
                return pb_1__namespace.Message.getField(this, 23) != null;
            }
            get efficiency_score() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 24, 0);
            }
            set efficiency_score(value) {
                pb_1__namespace.Message.setOneofField(this, 24, this.#one_of_decls[17], value);
            }
            get has_efficiency_score() {
                return pb_1__namespace.Message.getField(this, 24) != null;
            }
            get threshold_count() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 25, 0);
            }
            set threshold_count(value) {
                pb_1__namespace.Message.setOneofField(this, 25, this.#one_of_decls[18], value);
            }
            get has_threshold_count() {
                return pb_1__namespace.Message.getField(this, 25) != null;
            }
            get expansion_number() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 26, 0);
            }
            set expansion_number(value) {
                pb_1__namespace.Message.setOneofField(this, 26, this.#one_of_decls[19], value);
            }
            get has_expansion_number() {
                return pb_1__namespace.Message.getField(this, 26) != null;
            }
            get etx_eligible_slices() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 27);
            }
            set etx_eligible_slices(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 27, this.#one_of_decls[20], value);
            }
            get has_etx_eligible_slices() {
                return pb_1__namespace.Message.getField(this, 27) != null;
            }
            get prime_terminus_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 28);
            }
            set prime_terminus_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 28, this.#one_of_decls[21], value);
            }
            get has_prime_terminus_hash() {
                return pb_1__namespace.Message.getField(this, 28) != null;
            }
            get interlink_root_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 29);
            }
            set interlink_root_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 29, this.#one_of_decls[22], value);
            }
            get has_interlink_root_hash() {
                return pb_1__namespace.Message.getField(this, 29) != null;
            }
            get state_limit() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 30, 0);
            }
            set state_limit(value) {
                pb_1__namespace.Message.setOneofField(this, 30, this.#one_of_decls[23], value);
            }
            get has_state_limit() {
                return pb_1__namespace.Message.getField(this, 30) != null;
            }
            get state_used() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 31, 0);
            }
            set state_used(value) {
                pb_1__namespace.Message.setOneofField(this, 31, this.#one_of_decls[24], value);
            }
            get has_state_used() {
                return pb_1__namespace.Message.getField(this, 31) != null;
            }
            get quai_state_size() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 32, new Uint8Array(0));
            }
            set quai_state_size(value) {
                pb_1__namespace.Message.setOneofField(this, 32, this.#one_of_decls[25], value);
            }
            get has_quai_state_size() {
                return pb_1__namespace.Message.getField(this, 32) != null;
            }
            get secondary_coinbase() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 33, new Uint8Array(0));
            }
            set secondary_coinbase(value) {
                pb_1__namespace.Message.setOneofField(this, 33, this.#one_of_decls[26], value);
            }
            get has_secondary_coinbase() {
                return pb_1__namespace.Message.getField(this, 33) != null;
            }
            get exchange_rate() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 34, new Uint8Array(0));
            }
            set exchange_rate(value) {
                pb_1__namespace.Message.setOneofField(this, 34, this.#one_of_decls[27], value);
            }
            get has_exchange_rate() {
                return pb_1__namespace.Message.getField(this, 34) != null;
            }
            get quai_to_qi() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 35, new Uint8Array(0));
            }
            set quai_to_qi(value) {
                pb_1__namespace.Message.setOneofField(this, 35, this.#one_of_decls[28], value);
            }
            get has_quai_to_qi() {
                return pb_1__namespace.Message.getField(this, 35) != null;
            }
            get qi_to_quai() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 36, new Uint8Array(0));
            }
            set qi_to_quai(value) {
                pb_1__namespace.Message.setOneofField(this, 36, this.#one_of_decls[29], value);
            }
            get has_qi_to_quai() {
                return pb_1__namespace.Message.getField(this, 36) != null;
            }
            get _uncle_hash() {
                const cases = {
                    0: 'none',
                    2: 'uncle_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _evm_root() {
                const cases = {
                    0: 'none',
                    3: 'evm_root',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            get _tx_hash() {
                const cases = {
                    0: 'none',
                    4: 'tx_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [4])];
            }
            get _outbound_etx_hash() {
                const cases = {
                    0: 'none',
                    5: 'outbound_etx_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [5])];
            }
            get _etx_rollup_hash() {
                const cases = {
                    0: 'none',
                    6: 'etx_rollup_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [6])];
            }
            get _receipt_hash() {
                const cases = {
                    0: 'none',
                    8: 'receipt_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [8])];
            }
            get _difficulty() {
                const cases = {
                    0: 'none',
                    9: 'difficulty',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [9])];
            }
            get _uncled_entropy() {
                const cases = {
                    0: 'none',
                    13: 'uncled_entropy',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [13])];
            }
            get _gas_limit() {
                const cases = {
                    0: 'none',
                    15: 'gas_limit',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [15])];
            }
            get _gas_used() {
                const cases = {
                    0: 'none',
                    16: 'gas_used',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [16])];
            }
            get _base_fee() {
                const cases = {
                    0: 'none',
                    17: 'base_fee',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [17])];
            }
            get _location() {
                const cases = {
                    0: 'none',
                    18: 'location',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [18])];
            }
            get _extra() {
                const cases = {
                    0: 'none',
                    19: 'extra',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [19])];
            }
            get _mix_hash() {
                const cases = {
                    0: 'none',
                    20: 'mix_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [20])];
            }
            get _nonce() {
                const cases = {
                    0: 'none',
                    21: 'nonce',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [21])];
            }
            get _utxo_root() {
                const cases = {
                    0: 'none',
                    22: 'utxo_root',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [22])];
            }
            get _etx_set_root() {
                const cases = {
                    0: 'none',
                    23: 'etx_set_root',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [23])];
            }
            get _efficiency_score() {
                const cases = {
                    0: 'none',
                    24: 'efficiency_score',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [24])];
            }
            get _threshold_count() {
                const cases = {
                    0: 'none',
                    25: 'threshold_count',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [25])];
            }
            get _expansion_number() {
                const cases = {
                    0: 'none',
                    26: 'expansion_number',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [26])];
            }
            get _etx_eligible_slices() {
                const cases = {
                    0: 'none',
                    27: 'etx_eligible_slices',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [27])];
            }
            get _prime_terminus_hash() {
                const cases = {
                    0: 'none',
                    28: 'prime_terminus_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [28])];
            }
            get _interlink_root_hash() {
                const cases = {
                    0: 'none',
                    29: 'interlink_root_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [29])];
            }
            get _state_limit() {
                const cases = {
                    0: 'none',
                    30: 'state_limit',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [30])];
            }
            get _state_used() {
                const cases = {
                    0: 'none',
                    31: 'state_used',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [31])];
            }
            get _quai_state_size() {
                const cases = {
                    0: 'none',
                    32: 'quai_state_size',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [32])];
            }
            get _secondary_coinbase() {
                const cases = {
                    0: 'none',
                    33: 'secondary_coinbase',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [33])];
            }
            get _exchange_rate() {
                const cases = {
                    0: 'none',
                    34: 'exchange_rate',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [34])];
            }
            get _quai_to_qi() {
                const cases = {
                    0: 'none',
                    35: 'quai_to_qi',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [35])];
            }
            get _qi_to_quai() {
                const cases = {
                    0: 'none',
                    36: 'qi_to_quai',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [36])];
            }
            static fromObject(data) {
                const message = new ProtoHeader({});
                if (data.parent_hash != null) {
                    message.parent_hash = data.parent_hash.map((item) => common.ProtoHash.fromObject(item));
                }
                if (data.uncle_hash != null) {
                    message.uncle_hash = common.ProtoHash.fromObject(data.uncle_hash);
                }
                if (data.evm_root != null) {
                    message.evm_root = common.ProtoHash.fromObject(data.evm_root);
                }
                if (data.tx_hash != null) {
                    message.tx_hash = common.ProtoHash.fromObject(data.tx_hash);
                }
                if (data.outbound_etx_hash != null) {
                    message.outbound_etx_hash = common.ProtoHash.fromObject(data.outbound_etx_hash);
                }
                if (data.etx_rollup_hash != null) {
                    message.etx_rollup_hash = common.ProtoHash.fromObject(data.etx_rollup_hash);
                }
                if (data.manifest_hash != null) {
                    message.manifest_hash = data.manifest_hash.map((item) => common.ProtoHash.fromObject(item));
                }
                if (data.receipt_hash != null) {
                    message.receipt_hash = common.ProtoHash.fromObject(data.receipt_hash);
                }
                if (data.difficulty != null) {
                    message.difficulty = data.difficulty;
                }
                if (data.parent_entropy != null) {
                    message.parent_entropy = data.parent_entropy;
                }
                if (data.parent_delta_entropy != null) {
                    message.parent_delta_entropy = data.parent_delta_entropy;
                }
                if (data.parent_uncled_delta_entropy != null) {
                    message.parent_uncled_delta_entropy = data.parent_uncled_delta_entropy;
                }
                if (data.uncled_entropy != null) {
                    message.uncled_entropy = data.uncled_entropy;
                }
                if (data.number != null) {
                    message.number = data.number;
                }
                if (data.gas_limit != null) {
                    message.gas_limit = data.gas_limit;
                }
                if (data.gas_used != null) {
                    message.gas_used = data.gas_used;
                }
                if (data.base_fee != null) {
                    message.base_fee = data.base_fee;
                }
                if (data.location != null) {
                    message.location = common.ProtoLocation.fromObject(data.location);
                }
                if (data.extra != null) {
                    message.extra = data.extra;
                }
                if (data.mix_hash != null) {
                    message.mix_hash = common.ProtoHash.fromObject(data.mix_hash);
                }
                if (data.nonce != null) {
                    message.nonce = data.nonce;
                }
                if (data.utxo_root != null) {
                    message.utxo_root = common.ProtoHash.fromObject(data.utxo_root);
                }
                if (data.etx_set_root != null) {
                    message.etx_set_root = common.ProtoHash.fromObject(data.etx_set_root);
                }
                if (data.efficiency_score != null) {
                    message.efficiency_score = data.efficiency_score;
                }
                if (data.threshold_count != null) {
                    message.threshold_count = data.threshold_count;
                }
                if (data.expansion_number != null) {
                    message.expansion_number = data.expansion_number;
                }
                if (data.etx_eligible_slices != null) {
                    message.etx_eligible_slices = common.ProtoHash.fromObject(data.etx_eligible_slices);
                }
                if (data.prime_terminus_hash != null) {
                    message.prime_terminus_hash = common.ProtoHash.fromObject(data.prime_terminus_hash);
                }
                if (data.interlink_root_hash != null) {
                    message.interlink_root_hash = common.ProtoHash.fromObject(data.interlink_root_hash);
                }
                if (data.state_limit != null) {
                    message.state_limit = data.state_limit;
                }
                if (data.state_used != null) {
                    message.state_used = data.state_used;
                }
                if (data.quai_state_size != null) {
                    message.quai_state_size = data.quai_state_size;
                }
                if (data.secondary_coinbase != null) {
                    message.secondary_coinbase = data.secondary_coinbase;
                }
                if (data.exchange_rate != null) {
                    message.exchange_rate = data.exchange_rate;
                }
                if (data.quai_to_qi != null) {
                    message.quai_to_qi = data.quai_to_qi;
                }
                if (data.qi_to_quai != null) {
                    message.qi_to_quai = data.qi_to_quai;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.parent_hash != null) {
                    data.parent_hash = this.parent_hash.map((item) => item.toObject());
                }
                if (this.uncle_hash != null) {
                    data.uncle_hash = this.uncle_hash.toObject();
                }
                if (this.evm_root != null) {
                    data.evm_root = this.evm_root.toObject();
                }
                if (this.tx_hash != null) {
                    data.tx_hash = this.tx_hash.toObject();
                }
                if (this.outbound_etx_hash != null) {
                    data.outbound_etx_hash = this.outbound_etx_hash.toObject();
                }
                if (this.etx_rollup_hash != null) {
                    data.etx_rollup_hash = this.etx_rollup_hash.toObject();
                }
                if (this.manifest_hash != null) {
                    data.manifest_hash = this.manifest_hash.map((item) => item.toObject());
                }
                if (this.receipt_hash != null) {
                    data.receipt_hash = this.receipt_hash.toObject();
                }
                if (this.difficulty != null) {
                    data.difficulty = this.difficulty;
                }
                if (this.parent_entropy != null) {
                    data.parent_entropy = this.parent_entropy;
                }
                if (this.parent_delta_entropy != null) {
                    data.parent_delta_entropy = this.parent_delta_entropy;
                }
                if (this.parent_uncled_delta_entropy != null) {
                    data.parent_uncled_delta_entropy = this.parent_uncled_delta_entropy;
                }
                if (this.uncled_entropy != null) {
                    data.uncled_entropy = this.uncled_entropy;
                }
                if (this.number != null) {
                    data.number = this.number;
                }
                if (this.gas_limit != null) {
                    data.gas_limit = this.gas_limit;
                }
                if (this.gas_used != null) {
                    data.gas_used = this.gas_used;
                }
                if (this.base_fee != null) {
                    data.base_fee = this.base_fee;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                if (this.extra != null) {
                    data.extra = this.extra;
                }
                if (this.mix_hash != null) {
                    data.mix_hash = this.mix_hash.toObject();
                }
                if (this.nonce != null) {
                    data.nonce = this.nonce;
                }
                if (this.utxo_root != null) {
                    data.utxo_root = this.utxo_root.toObject();
                }
                if (this.etx_set_root != null) {
                    data.etx_set_root = this.etx_set_root.toObject();
                }
                if (this.efficiency_score != null) {
                    data.efficiency_score = this.efficiency_score;
                }
                if (this.threshold_count != null) {
                    data.threshold_count = this.threshold_count;
                }
                if (this.expansion_number != null) {
                    data.expansion_number = this.expansion_number;
                }
                if (this.etx_eligible_slices != null) {
                    data.etx_eligible_slices = this.etx_eligible_slices.toObject();
                }
                if (this.prime_terminus_hash != null) {
                    data.prime_terminus_hash = this.prime_terminus_hash.toObject();
                }
                if (this.interlink_root_hash != null) {
                    data.interlink_root_hash = this.interlink_root_hash.toObject();
                }
                if (this.state_limit != null) {
                    data.state_limit = this.state_limit;
                }
                if (this.state_used != null) {
                    data.state_used = this.state_used;
                }
                if (this.quai_state_size != null) {
                    data.quai_state_size = this.quai_state_size;
                }
                if (this.secondary_coinbase != null) {
                    data.secondary_coinbase = this.secondary_coinbase;
                }
                if (this.exchange_rate != null) {
                    data.exchange_rate = this.exchange_rate;
                }
                if (this.quai_to_qi != null) {
                    data.quai_to_qi = this.quai_to_qi;
                }
                if (this.qi_to_quai != null) {
                    data.qi_to_quai = this.qi_to_quai;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.parent_hash.length)
                    writer.writeRepeatedMessage(1, this.parent_hash, (item) => item.serialize(writer));
                if (this.has_uncle_hash)
                    writer.writeMessage(2, this.uncle_hash, () => this.uncle_hash.serialize(writer));
                if (this.has_evm_root)
                    writer.writeMessage(3, this.evm_root, () => this.evm_root.serialize(writer));
                if (this.has_tx_hash)
                    writer.writeMessage(4, this.tx_hash, () => this.tx_hash.serialize(writer));
                if (this.has_outbound_etx_hash)
                    writer.writeMessage(5, this.outbound_etx_hash, () => this.outbound_etx_hash.serialize(writer));
                if (this.has_etx_rollup_hash)
                    writer.writeMessage(6, this.etx_rollup_hash, () => this.etx_rollup_hash.serialize(writer));
                if (this.manifest_hash.length)
                    writer.writeRepeatedMessage(7, this.manifest_hash, (item) => item.serialize(writer));
                if (this.has_receipt_hash)
                    writer.writeMessage(8, this.receipt_hash, () => this.receipt_hash.serialize(writer));
                if (this.has_difficulty)
                    writer.writeBytes(9, this.difficulty);
                if (this.parent_entropy.length)
                    writer.writeRepeatedBytes(10, this.parent_entropy);
                if (this.parent_delta_entropy.length)
                    writer.writeRepeatedBytes(11, this.parent_delta_entropy);
                if (this.parent_uncled_delta_entropy.length)
                    writer.writeRepeatedBytes(12, this.parent_uncled_delta_entropy);
                if (this.has_uncled_entropy)
                    writer.writeBytes(13, this.uncled_entropy);
                if (this.number.length)
                    writer.writeRepeatedBytes(14, this.number);
                if (this.has_gas_limit)
                    writer.writeUint64(15, this.gas_limit);
                if (this.has_gas_used)
                    writer.writeUint64(16, this.gas_used);
                if (this.has_base_fee)
                    writer.writeBytes(17, this.base_fee);
                if (this.has_location)
                    writer.writeMessage(18, this.location, () => this.location.serialize(writer));
                if (this.has_extra)
                    writer.writeBytes(19, this.extra);
                if (this.has_mix_hash)
                    writer.writeMessage(20, this.mix_hash, () => this.mix_hash.serialize(writer));
                if (this.has_nonce)
                    writer.writeUint64(21, this.nonce);
                if (this.has_utxo_root)
                    writer.writeMessage(22, this.utxo_root, () => this.utxo_root.serialize(writer));
                if (this.has_etx_set_root)
                    writer.writeMessage(23, this.etx_set_root, () => this.etx_set_root.serialize(writer));
                if (this.has_efficiency_score)
                    writer.writeUint64(24, this.efficiency_score);
                if (this.has_threshold_count)
                    writer.writeUint64(25, this.threshold_count);
                if (this.has_expansion_number)
                    writer.writeUint64(26, this.expansion_number);
                if (this.has_etx_eligible_slices)
                    writer.writeMessage(27, this.etx_eligible_slices, () => this.etx_eligible_slices.serialize(writer));
                if (this.has_prime_terminus_hash)
                    writer.writeMessage(28, this.prime_terminus_hash, () => this.prime_terminus_hash.serialize(writer));
                if (this.has_interlink_root_hash)
                    writer.writeMessage(29, this.interlink_root_hash, () => this.interlink_root_hash.serialize(writer));
                if (this.has_state_limit)
                    writer.writeUint64(30, this.state_limit);
                if (this.has_state_used)
                    writer.writeUint64(31, this.state_used);
                if (this.has_quai_state_size)
                    writer.writeBytes(32, this.quai_state_size);
                if (this.has_secondary_coinbase)
                    writer.writeBytes(33, this.secondary_coinbase);
                if (this.has_exchange_rate)
                    writer.writeBytes(34, this.exchange_rate);
                if (this.has_quai_to_qi)
                    writer.writeBytes(35, this.quai_to_qi);
                if (this.has_qi_to_quai)
                    writer.writeBytes(36, this.qi_to_quai);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoHeader();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.parent_hash, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        case 2:
                            reader.readMessage(message.uncle_hash, () => (message.uncle_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 3:
                            reader.readMessage(message.evm_root, () => (message.evm_root = common.ProtoHash.deserialize(reader)));
                            break;
                        case 4:
                            reader.readMessage(message.tx_hash, () => (message.tx_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 5:
                            reader.readMessage(message.outbound_etx_hash, () => (message.outbound_etx_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 6:
                            reader.readMessage(message.etx_rollup_hash, () => (message.etx_rollup_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 7:
                            reader.readMessage(message.manifest_hash, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 7, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        case 8:
                            reader.readMessage(message.receipt_hash, () => (message.receipt_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 9:
                            message.difficulty = reader.readBytes();
                            break;
                        case 10:
                            pb_1__namespace.Message.addToRepeatedField(message, 10, reader.readBytes());
                            break;
                        case 11:
                            pb_1__namespace.Message.addToRepeatedField(message, 11, reader.readBytes());
                            break;
                        case 12:
                            pb_1__namespace.Message.addToRepeatedField(message, 12, reader.readBytes());
                            break;
                        case 13:
                            message.uncled_entropy = reader.readBytes();
                            break;
                        case 14:
                            pb_1__namespace.Message.addToRepeatedField(message, 14, reader.readBytes());
                            break;
                        case 15:
                            message.gas_limit = reader.readUint64();
                            break;
                        case 16:
                            message.gas_used = reader.readUint64();
                            break;
                        case 17:
                            message.base_fee = reader.readBytes();
                            break;
                        case 18:
                            reader.readMessage(message.location, () => (message.location = common.ProtoLocation.deserialize(reader)));
                            break;
                        case 19:
                            message.extra = reader.readBytes();
                            break;
                        case 20:
                            reader.readMessage(message.mix_hash, () => (message.mix_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 21:
                            message.nonce = reader.readUint64();
                            break;
                        case 22:
                            reader.readMessage(message.utxo_root, () => (message.utxo_root = common.ProtoHash.deserialize(reader)));
                            break;
                        case 23:
                            reader.readMessage(message.etx_set_root, () => (message.etx_set_root = common.ProtoHash.deserialize(reader)));
                            break;
                        case 24:
                            message.efficiency_score = reader.readUint64();
                            break;
                        case 25:
                            message.threshold_count = reader.readUint64();
                            break;
                        case 26:
                            message.expansion_number = reader.readUint64();
                            break;
                        case 27:
                            reader.readMessage(message.etx_eligible_slices, () => (message.etx_eligible_slices = common.ProtoHash.deserialize(reader)));
                            break;
                        case 28:
                            reader.readMessage(message.prime_terminus_hash, () => (message.prime_terminus_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 29:
                            reader.readMessage(message.interlink_root_hash, () => (message.interlink_root_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 30:
                            message.state_limit = reader.readUint64();
                            break;
                        case 31:
                            message.state_used = reader.readUint64();
                            break;
                        case 32:
                            message.quai_state_size = reader.readBytes();
                            break;
                        case 33:
                            message.secondary_coinbase = reader.readBytes();
                            break;
                        case 34:
                            message.exchange_rate = reader.readBytes();
                            break;
                        case 35:
                            message.quai_to_qi = reader.readBytes();
                            break;
                        case 36:
                            message.qi_to_quai = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoHeader.deserialize(bytes);
            }
        }
        block.ProtoHeader = ProtoHeader;
        class ProtoTransaction extends pb_1__namespace.Message {
            #one_of_decls = [
                [1],
                [2],
                [3],
                [4],
                [5],
                [6],
                [7],
                [8],
                [9],
                [10],
                [11],
                [12],
                [13],
                [14],
                [15],
                [16],
                [17],
                [18],
                [19],
                [20],
                [21],
                [22],
                [23],
            ];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('type' in data && data.type != undefined) {
                        this.type = data.type;
                    }
                    if ('to' in data && data.to != undefined) {
                        this.to = data.to;
                    }
                    if ('nonce' in data && data.nonce != undefined) {
                        this.nonce = data.nonce;
                    }
                    if ('value' in data && data.value != undefined) {
                        this.value = data.value;
                    }
                    if ('gas' in data && data.gas != undefined) {
                        this.gas = data.gas;
                    }
                    if ('data' in data && data.data != undefined) {
                        this.data = data.data;
                    }
                    if ('chain_id' in data && data.chain_id != undefined) {
                        this.chain_id = data.chain_id;
                    }
                    if ('miner_tip' in data && data.miner_tip != undefined) {
                        this.miner_tip = data.miner_tip;
                    }
                    if ('gas_price' in data && data.gas_price != undefined) {
                        this.gas_price = data.gas_price;
                    }
                    if ('access_list' in data && data.access_list != undefined) {
                        this.access_list = data.access_list;
                    }
                    if ('v' in data && data.v != undefined) {
                        this.v = data.v;
                    }
                    if ('r' in data && data.r != undefined) {
                        this.r = data.r;
                    }
                    if ('s' in data && data.s != undefined) {
                        this.s = data.s;
                    }
                    if ('originating_tx_hash' in data && data.originating_tx_hash != undefined) {
                        this.originating_tx_hash = data.originating_tx_hash;
                    }
                    if ('etx_index' in data && data.etx_index != undefined) {
                        this.etx_index = data.etx_index;
                    }
                    if ('tx_ins' in data && data.tx_ins != undefined) {
                        this.tx_ins = data.tx_ins;
                    }
                    if ('tx_outs' in data && data.tx_outs != undefined) {
                        this.tx_outs = data.tx_outs;
                    }
                    if ('signature' in data && data.signature != undefined) {
                        this.signature = data.signature;
                    }
                    if ('etx_sender' in data && data.etx_sender != undefined) {
                        this.etx_sender = data.etx_sender;
                    }
                    if ('parent_hash' in data && data.parent_hash != undefined) {
                        this.parent_hash = data.parent_hash;
                    }
                    if ('mix_hash' in data && data.mix_hash != undefined) {
                        this.mix_hash = data.mix_hash;
                    }
                    if ('work_nonce' in data && data.work_nonce != undefined) {
                        this.work_nonce = data.work_nonce;
                    }
                    if ('etx_type' in data && data.etx_type != undefined) {
                        this.etx_type = data.etx_type;
                    }
                }
            }
            get type() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, 0);
            }
            set type(value) {
                pb_1__namespace.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_type() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get to() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
            }
            set to(value) {
                pb_1__namespace.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
            }
            get has_to() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get nonce() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 3, 0);
            }
            set nonce(value) {
                pb_1__namespace.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
            }
            get has_nonce() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get value() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 4, new Uint8Array(0));
            }
            set value(value) {
                pb_1__namespace.Message.setOneofField(this, 4, this.#one_of_decls[3], value);
            }
            get has_value() {
                return pb_1__namespace.Message.getField(this, 4) != null;
            }
            get gas() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 5, 0);
            }
            set gas(value) {
                pb_1__namespace.Message.setOneofField(this, 5, this.#one_of_decls[4], value);
            }
            get has_gas() {
                return pb_1__namespace.Message.getField(this, 5) != null;
            }
            get data() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 6, new Uint8Array(0));
            }
            set data(value) {
                pb_1__namespace.Message.setOneofField(this, 6, this.#one_of_decls[5], value);
            }
            get has_data() {
                return pb_1__namespace.Message.getField(this, 6) != null;
            }
            get chain_id() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 7, new Uint8Array(0));
            }
            set chain_id(value) {
                pb_1__namespace.Message.setOneofField(this, 7, this.#one_of_decls[6], value);
            }
            get has_chain_id() {
                return pb_1__namespace.Message.getField(this, 7) != null;
            }
            get miner_tip() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 8, new Uint8Array(0));
            }
            set miner_tip(value) {
                pb_1__namespace.Message.setOneofField(this, 8, this.#one_of_decls[7], value);
            }
            get has_miner_tip() {
                return pb_1__namespace.Message.getField(this, 8) != null;
            }
            get gas_price() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 9, new Uint8Array(0));
            }
            set gas_price(value) {
                pb_1__namespace.Message.setOneofField(this, 9, this.#one_of_decls[8], value);
            }
            get has_gas_price() {
                return pb_1__namespace.Message.getField(this, 9) != null;
            }
            get access_list() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoAccessList, 10);
            }
            set access_list(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 10, this.#one_of_decls[9], value);
            }
            get has_access_list() {
                return pb_1__namespace.Message.getField(this, 10) != null;
            }
            get v() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 11, new Uint8Array(0));
            }
            set v(value) {
                pb_1__namespace.Message.setOneofField(this, 11, this.#one_of_decls[10], value);
            }
            get has_v() {
                return pb_1__namespace.Message.getField(this, 11) != null;
            }
            get r() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 12, new Uint8Array(0));
            }
            set r(value) {
                pb_1__namespace.Message.setOneofField(this, 12, this.#one_of_decls[11], value);
            }
            get has_r() {
                return pb_1__namespace.Message.getField(this, 12) != null;
            }
            get s() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 13, new Uint8Array(0));
            }
            set s(value) {
                pb_1__namespace.Message.setOneofField(this, 13, this.#one_of_decls[12], value);
            }
            get has_s() {
                return pb_1__namespace.Message.getField(this, 13) != null;
            }
            get originating_tx_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 14);
            }
            set originating_tx_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 14, this.#one_of_decls[13], value);
            }
            get has_originating_tx_hash() {
                return pb_1__namespace.Message.getField(this, 14) != null;
            }
            get etx_index() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 15, 0);
            }
            set etx_index(value) {
                pb_1__namespace.Message.setOneofField(this, 15, this.#one_of_decls[14], value);
            }
            get has_etx_index() {
                return pb_1__namespace.Message.getField(this, 15) != null;
            }
            get tx_ins() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTxIns, 16);
            }
            set tx_ins(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 16, this.#one_of_decls[15], value);
            }
            get has_tx_ins() {
                return pb_1__namespace.Message.getField(this, 16) != null;
            }
            get tx_outs() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTxOuts, 17);
            }
            set tx_outs(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 17, this.#one_of_decls[16], value);
            }
            get has_tx_outs() {
                return pb_1__namespace.Message.getField(this, 17) != null;
            }
            get signature() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 18, new Uint8Array(0));
            }
            set signature(value) {
                pb_1__namespace.Message.setOneofField(this, 18, this.#one_of_decls[17], value);
            }
            get has_signature() {
                return pb_1__namespace.Message.getField(this, 18) != null;
            }
            get etx_sender() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 19, new Uint8Array(0));
            }
            set etx_sender(value) {
                pb_1__namespace.Message.setOneofField(this, 19, this.#one_of_decls[18], value);
            }
            get has_etx_sender() {
                return pb_1__namespace.Message.getField(this, 19) != null;
            }
            get parent_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 20);
            }
            set parent_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 20, this.#one_of_decls[19], value);
            }
            get has_parent_hash() {
                return pb_1__namespace.Message.getField(this, 20) != null;
            }
            get mix_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 21);
            }
            set mix_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 21, this.#one_of_decls[20], value);
            }
            get has_mix_hash() {
                return pb_1__namespace.Message.getField(this, 21) != null;
            }
            get work_nonce() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 22, 0);
            }
            set work_nonce(value) {
                pb_1__namespace.Message.setOneofField(this, 22, this.#one_of_decls[21], value);
            }
            get has_work_nonce() {
                return pb_1__namespace.Message.getField(this, 22) != null;
            }
            get etx_type() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 23, 0);
            }
            set etx_type(value) {
                pb_1__namespace.Message.setOneofField(this, 23, this.#one_of_decls[22], value);
            }
            get has_etx_type() {
                return pb_1__namespace.Message.getField(this, 23) != null;
            }
            get _type() {
                const cases = {
                    0: 'none',
                    1: 'type',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _to() {
                const cases = {
                    0: 'none',
                    2: 'to',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _nonce() {
                const cases = {
                    0: 'none',
                    3: 'nonce',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            get _value() {
                const cases = {
                    0: 'none',
                    4: 'value',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [4])];
            }
            get _gas() {
                const cases = {
                    0: 'none',
                    5: 'gas',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [5])];
            }
            get _data() {
                const cases = {
                    0: 'none',
                    6: 'data',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [6])];
            }
            get _chain_id() {
                const cases = {
                    0: 'none',
                    7: 'chain_id',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [7])];
            }
            get _miner_tip() {
                const cases = {
                    0: 'none',
                    8: 'miner_tip',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [8])];
            }
            get _gas_price() {
                const cases = {
                    0: 'none',
                    9: 'gas_price',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [9])];
            }
            get _access_list() {
                const cases = {
                    0: 'none',
                    10: 'access_list',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [10])];
            }
            get _v() {
                const cases = {
                    0: 'none',
                    11: 'v',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [11])];
            }
            get _r() {
                const cases = {
                    0: 'none',
                    12: 'r',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [12])];
            }
            get _s() {
                const cases = {
                    0: 'none',
                    13: 's',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [13])];
            }
            get _originating_tx_hash() {
                const cases = {
                    0: 'none',
                    14: 'originating_tx_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [14])];
            }
            get _etx_index() {
                const cases = {
                    0: 'none',
                    15: 'etx_index',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [15])];
            }
            get _tx_ins() {
                const cases = {
                    0: 'none',
                    16: 'tx_ins',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [16])];
            }
            get _tx_outs() {
                const cases = {
                    0: 'none',
                    17: 'tx_outs',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [17])];
            }
            get _signature() {
                const cases = {
                    0: 'none',
                    18: 'signature',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [18])];
            }
            get _etx_sender() {
                const cases = {
                    0: 'none',
                    19: 'etx_sender',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [19])];
            }
            get _parent_hash() {
                const cases = {
                    0: 'none',
                    20: 'parent_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [20])];
            }
            get _mix_hash() {
                const cases = {
                    0: 'none',
                    21: 'mix_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [21])];
            }
            get _work_nonce() {
                const cases = {
                    0: 'none',
                    22: 'work_nonce',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [22])];
            }
            get _etx_type() {
                const cases = {
                    0: 'none',
                    23: 'etx_type',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [23])];
            }
            static fromObject(data) {
                const message = new ProtoTransaction({});
                if (data.type != null) {
                    message.type = data.type;
                }
                if (data.to != null) {
                    message.to = data.to;
                }
                if (data.nonce != null) {
                    message.nonce = data.nonce;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                if (data.gas != null) {
                    message.gas = data.gas;
                }
                if (data.data != null) {
                    message.data = data.data;
                }
                if (data.chain_id != null) {
                    message.chain_id = data.chain_id;
                }
                if (data.miner_tip != null) {
                    message.miner_tip = data.miner_tip;
                }
                if (data.gas_price != null) {
                    message.gas_price = data.gas_price;
                }
                if (data.access_list != null) {
                    message.access_list = ProtoAccessList.fromObject(data.access_list);
                }
                if (data.v != null) {
                    message.v = data.v;
                }
                if (data.r != null) {
                    message.r = data.r;
                }
                if (data.s != null) {
                    message.s = data.s;
                }
                if (data.originating_tx_hash != null) {
                    message.originating_tx_hash = common.ProtoHash.fromObject(data.originating_tx_hash);
                }
                if (data.etx_index != null) {
                    message.etx_index = data.etx_index;
                }
                if (data.tx_ins != null) {
                    message.tx_ins = ProtoTxIns.fromObject(data.tx_ins);
                }
                if (data.tx_outs != null) {
                    message.tx_outs = ProtoTxOuts.fromObject(data.tx_outs);
                }
                if (data.signature != null) {
                    message.signature = data.signature;
                }
                if (data.etx_sender != null) {
                    message.etx_sender = data.etx_sender;
                }
                if (data.parent_hash != null) {
                    message.parent_hash = common.ProtoHash.fromObject(data.parent_hash);
                }
                if (data.mix_hash != null) {
                    message.mix_hash = common.ProtoHash.fromObject(data.mix_hash);
                }
                if (data.work_nonce != null) {
                    message.work_nonce = data.work_nonce;
                }
                if (data.etx_type != null) {
                    message.etx_type = data.etx_type;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.type != null) {
                    data.type = this.type;
                }
                if (this.to != null) {
                    data.to = this.to;
                }
                if (this.nonce != null) {
                    data.nonce = this.nonce;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                if (this.gas != null) {
                    data.gas = this.gas;
                }
                if (this.data != null) {
                    data.data = this.data;
                }
                if (this.chain_id != null) {
                    data.chain_id = this.chain_id;
                }
                if (this.miner_tip != null) {
                    data.miner_tip = this.miner_tip;
                }
                if (this.gas_price != null) {
                    data.gas_price = this.gas_price;
                }
                if (this.access_list != null) {
                    data.access_list = this.access_list.toObject();
                }
                if (this.v != null) {
                    data.v = this.v;
                }
                if (this.r != null) {
                    data.r = this.r;
                }
                if (this.s != null) {
                    data.s = this.s;
                }
                if (this.originating_tx_hash != null) {
                    data.originating_tx_hash = this.originating_tx_hash.toObject();
                }
                if (this.etx_index != null) {
                    data.etx_index = this.etx_index;
                }
                if (this.tx_ins != null) {
                    data.tx_ins = this.tx_ins.toObject();
                }
                if (this.tx_outs != null) {
                    data.tx_outs = this.tx_outs.toObject();
                }
                if (this.signature != null) {
                    data.signature = this.signature;
                }
                if (this.etx_sender != null) {
                    data.etx_sender = this.etx_sender;
                }
                if (this.parent_hash != null) {
                    data.parent_hash = this.parent_hash.toObject();
                }
                if (this.mix_hash != null) {
                    data.mix_hash = this.mix_hash.toObject();
                }
                if (this.work_nonce != null) {
                    data.work_nonce = this.work_nonce;
                }
                if (this.etx_type != null) {
                    data.etx_type = this.etx_type;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_type)
                    writer.writeUint64(1, this.type);
                if (this.has_to)
                    writer.writeBytes(2, this.to);
                if (this.has_nonce)
                    writer.writeUint64(3, this.nonce);
                if (this.has_value)
                    writer.writeBytes(4, this.value);
                if (this.has_gas)
                    writer.writeUint64(5, this.gas);
                if (this.has_data)
                    writer.writeBytes(6, this.data);
                if (this.has_chain_id)
                    writer.writeBytes(7, this.chain_id);
                if (this.has_miner_tip)
                    writer.writeBytes(8, this.miner_tip);
                if (this.has_gas_price)
                    writer.writeBytes(9, this.gas_price);
                if (this.has_access_list)
                    writer.writeMessage(10, this.access_list, () => this.access_list.serialize(writer));
                if (this.has_v)
                    writer.writeBytes(11, this.v);
                if (this.has_r)
                    writer.writeBytes(12, this.r);
                if (this.has_s)
                    writer.writeBytes(13, this.s);
                if (this.has_originating_tx_hash)
                    writer.writeMessage(14, this.originating_tx_hash, () => this.originating_tx_hash.serialize(writer));
                if (this.has_etx_index)
                    writer.writeUint32(15, this.etx_index);
                if (this.has_tx_ins)
                    writer.writeMessage(16, this.tx_ins, () => this.tx_ins.serialize(writer));
                if (this.has_tx_outs)
                    writer.writeMessage(17, this.tx_outs, () => this.tx_outs.serialize(writer));
                if (this.has_signature)
                    writer.writeBytes(18, this.signature);
                if (this.has_etx_sender)
                    writer.writeBytes(19, this.etx_sender);
                if (this.has_parent_hash)
                    writer.writeMessage(20, this.parent_hash, () => this.parent_hash.serialize(writer));
                if (this.has_mix_hash)
                    writer.writeMessage(21, this.mix_hash, () => this.mix_hash.serialize(writer));
                if (this.has_work_nonce)
                    writer.writeUint64(22, this.work_nonce);
                if (this.has_etx_type)
                    writer.writeUint64(23, this.etx_type);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTransaction();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.type = reader.readUint64();
                            break;
                        case 2:
                            message.to = reader.readBytes();
                            break;
                        case 3:
                            message.nonce = reader.readUint64();
                            break;
                        case 4:
                            message.value = reader.readBytes();
                            break;
                        case 5:
                            message.gas = reader.readUint64();
                            break;
                        case 6:
                            message.data = reader.readBytes();
                            break;
                        case 7:
                            message.chain_id = reader.readBytes();
                            break;
                        case 8:
                            message.miner_tip = reader.readBytes();
                            break;
                        case 9:
                            message.gas_price = reader.readBytes();
                            break;
                        case 10:
                            reader.readMessage(message.access_list, () => (message.access_list = ProtoAccessList.deserialize(reader)));
                            break;
                        case 11:
                            message.v = reader.readBytes();
                            break;
                        case 12:
                            message.r = reader.readBytes();
                            break;
                        case 13:
                            message.s = reader.readBytes();
                            break;
                        case 14:
                            reader.readMessage(message.originating_tx_hash, () => (message.originating_tx_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 15:
                            message.etx_index = reader.readUint32();
                            break;
                        case 16:
                            reader.readMessage(message.tx_ins, () => (message.tx_ins = ProtoTxIns.deserialize(reader)));
                            break;
                        case 17:
                            reader.readMessage(message.tx_outs, () => (message.tx_outs = ProtoTxOuts.deserialize(reader)));
                            break;
                        case 18:
                            message.signature = reader.readBytes();
                            break;
                        case 19:
                            message.etx_sender = reader.readBytes();
                            break;
                        case 20:
                            reader.readMessage(message.parent_hash, () => (message.parent_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 21:
                            reader.readMessage(message.mix_hash, () => (message.mix_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 22:
                            message.work_nonce = reader.readUint64();
                            break;
                        case 23:
                            message.etx_type = reader.readUint64();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTransaction.deserialize(bytes);
            }
        }
        block.ProtoTransaction = ProtoTransaction;
        class ProtoTransactions extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('transactions' in data && data.transactions != undefined) {
                        this.transactions = data.transactions;
                    }
                }
            }
            get transactions() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoTransaction, 1);
            }
            set transactions(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoTransactions({});
                if (data.transactions != null) {
                    message.transactions = data.transactions.map((item) => ProtoTransaction.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.transactions != null) {
                    data.transactions = this.transactions.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.transactions.length)
                    writer.writeRepeatedMessage(1, this.transactions, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTransactions();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.transactions, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoTransaction.deserialize(reader), ProtoTransaction));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTransactions.deserialize(bytes);
            }
        }
        block.ProtoTransactions = ProtoTransactions;
        class ProtoHeaders extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('headers' in data && data.headers != undefined) {
                        this.headers = data.headers;
                    }
                }
            }
            get headers() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoHeader, 1);
            }
            set headers(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoHeaders({});
                if (data.headers != null) {
                    message.headers = data.headers.map((item) => ProtoHeader.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.headers != null) {
                    data.headers = this.headers.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.headers.length)
                    writer.writeRepeatedMessage(1, this.headers, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoHeaders();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.headers, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoHeader.deserialize(reader), ProtoHeader));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoHeaders.deserialize(bytes);
            }
        }
        block.ProtoHeaders = ProtoHeaders;
        class ProtoManifest extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('manifest' in data && data.manifest != undefined) {
                        this.manifest = data.manifest;
                    }
                }
            }
            get manifest() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 1);
            }
            set manifest(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoManifest({});
                if (data.manifest != null) {
                    message.manifest = data.manifest.map((item) => common.ProtoHash.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.manifest != null) {
                    data.manifest = this.manifest.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.manifest.length)
                    writer.writeRepeatedMessage(1, this.manifest, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoManifest();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.manifest, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoManifest.deserialize(bytes);
            }
        }
        block.ProtoManifest = ProtoManifest;
        class ProtoAccessList extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('access_tuples' in data && data.access_tuples != undefined) {
                        this.access_tuples = data.access_tuples;
                    }
                }
            }
            get access_tuples() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoAccessTuple, 1);
            }
            set access_tuples(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoAccessList({});
                if (data.access_tuples != null) {
                    message.access_tuples = data.access_tuples.map((item) => ProtoAccessTuple.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.access_tuples != null) {
                    data.access_tuples = this.access_tuples.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.access_tuples.length)
                    writer.writeRepeatedMessage(1, this.access_tuples, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoAccessList();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.access_tuples, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoAccessTuple.deserialize(reader), ProtoAccessTuple));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoAccessList.deserialize(bytes);
            }
        }
        block.ProtoAccessList = ProtoAccessList;
        class ProtoWorkObjectHeader extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('header_hash' in data && data.header_hash != undefined) {
                        this.header_hash = data.header_hash;
                    }
                    if ('parent_hash' in data && data.parent_hash != undefined) {
                        this.parent_hash = data.parent_hash;
                    }
                    if ('number' in data && data.number != undefined) {
                        this.number = data.number;
                    }
                    if ('difficulty' in data && data.difficulty != undefined) {
                        this.difficulty = data.difficulty;
                    }
                    if ('tx_hash' in data && data.tx_hash != undefined) {
                        this.tx_hash = data.tx_hash;
                    }
                    if ('nonce' in data && data.nonce != undefined) {
                        this.nonce = data.nonce;
                    }
                    if ('location' in data && data.location != undefined) {
                        this.location = data.location;
                    }
                    if ('mix_hash' in data && data.mix_hash != undefined) {
                        this.mix_hash = data.mix_hash;
                    }
                    if ('time' in data && data.time != undefined) {
                        this.time = data.time;
                    }
                    if ('prime_terminus_number' in data && data.prime_terminus_number != undefined) {
                        this.prime_terminus_number = data.prime_terminus_number;
                    }
                    if ('lock' in data && data.lock != undefined) {
                        this.lock = data.lock;
                    }
                    if ('primary_coinbase' in data && data.primary_coinbase != undefined) {
                        this.primary_coinbase = data.primary_coinbase;
                    }
                }
            }
            get header_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 1);
            }
            set header_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_header_hash() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get parent_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 2);
            }
            set parent_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_parent_hash() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get number() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
            }
            set number(value) {
                pb_1__namespace.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
            }
            get has_number() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get difficulty() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 4, new Uint8Array(0));
            }
            set difficulty(value) {
                pb_1__namespace.Message.setOneofField(this, 4, this.#one_of_decls[3], value);
            }
            get has_difficulty() {
                return pb_1__namespace.Message.getField(this, 4) != null;
            }
            get tx_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 5);
            }
            set tx_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 5, this.#one_of_decls[4], value);
            }
            get has_tx_hash() {
                return pb_1__namespace.Message.getField(this, 5) != null;
            }
            get nonce() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 6, 0);
            }
            set nonce(value) {
                pb_1__namespace.Message.setOneofField(this, 6, this.#one_of_decls[5], value);
            }
            get has_nonce() {
                return pb_1__namespace.Message.getField(this, 6) != null;
            }
            get location() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoLocation, 7);
            }
            set location(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 7, this.#one_of_decls[6], value);
            }
            get has_location() {
                return pb_1__namespace.Message.getField(this, 7) != null;
            }
            get mix_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 8);
            }
            set mix_hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 8, this.#one_of_decls[7], value);
            }
            get has_mix_hash() {
                return pb_1__namespace.Message.getField(this, 8) != null;
            }
            get time() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 9, 0);
            }
            set time(value) {
                pb_1__namespace.Message.setOneofField(this, 9, this.#one_of_decls[8], value);
            }
            get has_time() {
                return pb_1__namespace.Message.getField(this, 9) != null;
            }
            get prime_terminus_number() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 10, new Uint8Array(0));
            }
            set prime_terminus_number(value) {
                pb_1__namespace.Message.setOneofField(this, 10, this.#one_of_decls[9], value);
            }
            get has_prime_terminus_number() {
                return pb_1__namespace.Message.getField(this, 10) != null;
            }
            get lock() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 11, 0);
            }
            set lock(value) {
                pb_1__namespace.Message.setOneofField(this, 11, this.#one_of_decls[10], value);
            }
            get has_lock() {
                return pb_1__namespace.Message.getField(this, 11) != null;
            }
            get primary_coinbase() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoAddress, 12);
            }
            set primary_coinbase(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 12, this.#one_of_decls[11], value);
            }
            get has_primary_coinbase() {
                return pb_1__namespace.Message.getField(this, 12) != null;
            }
            get _header_hash() {
                const cases = {
                    0: 'none',
                    1: 'header_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _parent_hash() {
                const cases = {
                    0: 'none',
                    2: 'parent_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _number() {
                const cases = {
                    0: 'none',
                    3: 'number',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            get _difficulty() {
                const cases = {
                    0: 'none',
                    4: 'difficulty',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [4])];
            }
            get _tx_hash() {
                const cases = {
                    0: 'none',
                    5: 'tx_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [5])];
            }
            get _nonce() {
                const cases = {
                    0: 'none',
                    6: 'nonce',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [6])];
            }
            get _location() {
                const cases = {
                    0: 'none',
                    7: 'location',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [7])];
            }
            get _mix_hash() {
                const cases = {
                    0: 'none',
                    8: 'mix_hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [8])];
            }
            get _time() {
                const cases = {
                    0: 'none',
                    9: 'time',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [9])];
            }
            get _prime_terminus_number() {
                const cases = {
                    0: 'none',
                    10: 'prime_terminus_number',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [10])];
            }
            get _lock() {
                const cases = {
                    0: 'none',
                    11: 'lock',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [11])];
            }
            get _primary_coinbase() {
                const cases = {
                    0: 'none',
                    12: 'primary_coinbase',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [12])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectHeader({});
                if (data.header_hash != null) {
                    message.header_hash = common.ProtoHash.fromObject(data.header_hash);
                }
                if (data.parent_hash != null) {
                    message.parent_hash = common.ProtoHash.fromObject(data.parent_hash);
                }
                if (data.number != null) {
                    message.number = data.number;
                }
                if (data.difficulty != null) {
                    message.difficulty = data.difficulty;
                }
                if (data.tx_hash != null) {
                    message.tx_hash = common.ProtoHash.fromObject(data.tx_hash);
                }
                if (data.nonce != null) {
                    message.nonce = data.nonce;
                }
                if (data.location != null) {
                    message.location = common.ProtoLocation.fromObject(data.location);
                }
                if (data.mix_hash != null) {
                    message.mix_hash = common.ProtoHash.fromObject(data.mix_hash);
                }
                if (data.time != null) {
                    message.time = data.time;
                }
                if (data.prime_terminus_number != null) {
                    message.prime_terminus_number = data.prime_terminus_number;
                }
                if (data.lock != null) {
                    message.lock = data.lock;
                }
                if (data.primary_coinbase != null) {
                    message.primary_coinbase = common.ProtoAddress.fromObject(data.primary_coinbase);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.header_hash != null) {
                    data.header_hash = this.header_hash.toObject();
                }
                if (this.parent_hash != null) {
                    data.parent_hash = this.parent_hash.toObject();
                }
                if (this.number != null) {
                    data.number = this.number;
                }
                if (this.difficulty != null) {
                    data.difficulty = this.difficulty;
                }
                if (this.tx_hash != null) {
                    data.tx_hash = this.tx_hash.toObject();
                }
                if (this.nonce != null) {
                    data.nonce = this.nonce;
                }
                if (this.location != null) {
                    data.location = this.location.toObject();
                }
                if (this.mix_hash != null) {
                    data.mix_hash = this.mix_hash.toObject();
                }
                if (this.time != null) {
                    data.time = this.time;
                }
                if (this.prime_terminus_number != null) {
                    data.prime_terminus_number = this.prime_terminus_number;
                }
                if (this.lock != null) {
                    data.lock = this.lock;
                }
                if (this.primary_coinbase != null) {
                    data.primary_coinbase = this.primary_coinbase.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_header_hash)
                    writer.writeMessage(1, this.header_hash, () => this.header_hash.serialize(writer));
                if (this.has_parent_hash)
                    writer.writeMessage(2, this.parent_hash, () => this.parent_hash.serialize(writer));
                if (this.has_number)
                    writer.writeBytes(3, this.number);
                if (this.has_difficulty)
                    writer.writeBytes(4, this.difficulty);
                if (this.has_tx_hash)
                    writer.writeMessage(5, this.tx_hash, () => this.tx_hash.serialize(writer));
                if (this.has_nonce)
                    writer.writeUint64(6, this.nonce);
                if (this.has_location)
                    writer.writeMessage(7, this.location, () => this.location.serialize(writer));
                if (this.has_mix_hash)
                    writer.writeMessage(8, this.mix_hash, () => this.mix_hash.serialize(writer));
                if (this.has_time)
                    writer.writeUint64(9, this.time);
                if (this.has_prime_terminus_number)
                    writer.writeBytes(10, this.prime_terminus_number);
                if (this.has_lock)
                    writer.writeUint32(11, this.lock);
                if (this.has_primary_coinbase)
                    writer.writeMessage(12, this.primary_coinbase, () => this.primary_coinbase.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectHeader();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.header_hash, () => (message.header_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.parent_hash, () => (message.parent_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 3:
                            message.number = reader.readBytes();
                            break;
                        case 4:
                            message.difficulty = reader.readBytes();
                            break;
                        case 5:
                            reader.readMessage(message.tx_hash, () => (message.tx_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 6:
                            message.nonce = reader.readUint64();
                            break;
                        case 7:
                            reader.readMessage(message.location, () => (message.location = common.ProtoLocation.deserialize(reader)));
                            break;
                        case 8:
                            reader.readMessage(message.mix_hash, () => (message.mix_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 9:
                            message.time = reader.readUint64();
                            break;
                        case 10:
                            message.prime_terminus_number = reader.readBytes();
                            break;
                        case 11:
                            message.lock = reader.readUint32();
                            break;
                        case 12:
                            reader.readMessage(message.primary_coinbase, () => (message.primary_coinbase = common.ProtoAddress.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectHeader.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectHeader = ProtoWorkObjectHeader;
        class ProtoWorkObjectHeaders extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('wo_headers' in data && data.wo_headers != undefined) {
                        this.wo_headers = data.wo_headers;
                    }
                }
            }
            get wo_headers() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoWorkObjectHeader, 1);
            }
            set wo_headers(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectHeaders({});
                if (data.wo_headers != null) {
                    message.wo_headers = data.wo_headers.map((item) => ProtoWorkObjectHeader.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.wo_headers != null) {
                    data.wo_headers = this.wo_headers.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.wo_headers.length)
                    writer.writeRepeatedMessage(1, this.wo_headers, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectHeaders();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.wo_headers, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoWorkObjectHeader.deserialize(reader), ProtoWorkObjectHeader));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectHeaders.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectHeaders = ProtoWorkObjectHeaders;
        class ProtoWorkObjectBody extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2], [3], [4], [5], [6]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('header' in data && data.header != undefined) {
                        this.header = data.header;
                    }
                    if ('transactions' in data && data.transactions != undefined) {
                        this.transactions = data.transactions;
                    }
                    if ('uncles' in data && data.uncles != undefined) {
                        this.uncles = data.uncles;
                    }
                    if ('outbound_etxs' in data && data.outbound_etxs != undefined) {
                        this.outbound_etxs = data.outbound_etxs;
                    }
                    if ('manifest' in data && data.manifest != undefined) {
                        this.manifest = data.manifest;
                    }
                    if ('interlink_hashes' in data && data.interlink_hashes != undefined) {
                        this.interlink_hashes = data.interlink_hashes;
                    }
                }
            }
            get header() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoHeader, 1);
            }
            set header(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_header() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get transactions() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransactions, 2);
            }
            set transactions(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_transactions() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get uncles() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObjectHeaders, 3);
            }
            set uncles(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 3, this.#one_of_decls[2], value);
            }
            get has_uncles() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get outbound_etxs() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransactions, 4);
            }
            set outbound_etxs(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 4, this.#one_of_decls[3], value);
            }
            get has_outbound_etxs() {
                return pb_1__namespace.Message.getField(this, 4) != null;
            }
            get manifest() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoManifest, 5);
            }
            set manifest(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 5, this.#one_of_decls[4], value);
            }
            get has_manifest() {
                return pb_1__namespace.Message.getField(this, 5) != null;
            }
            get interlink_hashes() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHashes, 6);
            }
            set interlink_hashes(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 6, this.#one_of_decls[5], value);
            }
            get has_interlink_hashes() {
                return pb_1__namespace.Message.getField(this, 6) != null;
            }
            get _header() {
                const cases = {
                    0: 'none',
                    1: 'header',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _transactions() {
                const cases = {
                    0: 'none',
                    2: 'transactions',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _uncles() {
                const cases = {
                    0: 'none',
                    3: 'uncles',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            get _outbound_etxs() {
                const cases = {
                    0: 'none',
                    4: 'outbound_etxs',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [4])];
            }
            get _manifest() {
                const cases = {
                    0: 'none',
                    5: 'manifest',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [5])];
            }
            get _interlink_hashes() {
                const cases = {
                    0: 'none',
                    6: 'interlink_hashes',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [6])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectBody({});
                if (data.header != null) {
                    message.header = ProtoHeader.fromObject(data.header);
                }
                if (data.transactions != null) {
                    message.transactions = ProtoTransactions.fromObject(data.transactions);
                }
                if (data.uncles != null) {
                    message.uncles = ProtoWorkObjectHeaders.fromObject(data.uncles);
                }
                if (data.outbound_etxs != null) {
                    message.outbound_etxs = ProtoTransactions.fromObject(data.outbound_etxs);
                }
                if (data.manifest != null) {
                    message.manifest = ProtoManifest.fromObject(data.manifest);
                }
                if (data.interlink_hashes != null) {
                    message.interlink_hashes = common.ProtoHashes.fromObject(data.interlink_hashes);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.header != null) {
                    data.header = this.header.toObject();
                }
                if (this.transactions != null) {
                    data.transactions = this.transactions.toObject();
                }
                if (this.uncles != null) {
                    data.uncles = this.uncles.toObject();
                }
                if (this.outbound_etxs != null) {
                    data.outbound_etxs = this.outbound_etxs.toObject();
                }
                if (this.manifest != null) {
                    data.manifest = this.manifest.toObject();
                }
                if (this.interlink_hashes != null) {
                    data.interlink_hashes = this.interlink_hashes.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_header)
                    writer.writeMessage(1, this.header, () => this.header.serialize(writer));
                if (this.has_transactions)
                    writer.writeMessage(2, this.transactions, () => this.transactions.serialize(writer));
                if (this.has_uncles)
                    writer.writeMessage(3, this.uncles, () => this.uncles.serialize(writer));
                if (this.has_outbound_etxs)
                    writer.writeMessage(4, this.outbound_etxs, () => this.outbound_etxs.serialize(writer));
                if (this.has_manifest)
                    writer.writeMessage(5, this.manifest, () => this.manifest.serialize(writer));
                if (this.has_interlink_hashes)
                    writer.writeMessage(6, this.interlink_hashes, () => this.interlink_hashes.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectBody();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.header, () => (message.header = ProtoHeader.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.transactions, () => (message.transactions = ProtoTransactions.deserialize(reader)));
                            break;
                        case 3:
                            reader.readMessage(message.uncles, () => (message.uncles = ProtoWorkObjectHeaders.deserialize(reader)));
                            break;
                        case 4:
                            reader.readMessage(message.outbound_etxs, () => (message.outbound_etxs = ProtoTransactions.deserialize(reader)));
                            break;
                        case 5:
                            reader.readMessage(message.manifest, () => (message.manifest = ProtoManifest.deserialize(reader)));
                            break;
                        case 6:
                            reader.readMessage(message.interlink_hashes, () => (message.interlink_hashes = common.ProtoHashes.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectBody.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectBody = ProtoWorkObjectBody;
        class ProtoWorkObject extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2], [3]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('wo_header' in data && data.wo_header != undefined) {
                        this.wo_header = data.wo_header;
                    }
                    if ('wo_body' in data && data.wo_body != undefined) {
                        this.wo_body = data.wo_body;
                    }
                    if ('tx' in data && data.tx != undefined) {
                        this.tx = data.tx;
                    }
                }
            }
            get wo_header() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObjectHeader, 1);
            }
            set wo_header(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_wo_header() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get wo_body() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObjectBody, 2);
            }
            set wo_body(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_wo_body() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get tx() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransaction, 3);
            }
            set tx(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 3, this.#one_of_decls[2], value);
            }
            get has_tx() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get _wo_header() {
                const cases = {
                    0: 'none',
                    1: 'wo_header',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _wo_body() {
                const cases = {
                    0: 'none',
                    2: 'wo_body',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _tx() {
                const cases = {
                    0: 'none',
                    3: 'tx',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObject({});
                if (data.wo_header != null) {
                    message.wo_header = ProtoWorkObjectHeader.fromObject(data.wo_header);
                }
                if (data.wo_body != null) {
                    message.wo_body = ProtoWorkObjectBody.fromObject(data.wo_body);
                }
                if (data.tx != null) {
                    message.tx = ProtoTransaction.fromObject(data.tx);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.wo_header != null) {
                    data.wo_header = this.wo_header.toObject();
                }
                if (this.wo_body != null) {
                    data.wo_body = this.wo_body.toObject();
                }
                if (this.tx != null) {
                    data.tx = this.tx.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_wo_header)
                    writer.writeMessage(1, this.wo_header, () => this.wo_header.serialize(writer));
                if (this.has_wo_body)
                    writer.writeMessage(2, this.wo_body, () => this.wo_body.serialize(writer));
                if (this.has_tx)
                    writer.writeMessage(3, this.tx, () => this.tx.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObject();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.wo_header, () => (message.wo_header = ProtoWorkObjectHeader.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.wo_body, () => (message.wo_body = ProtoWorkObjectBody.deserialize(reader)));
                            break;
                        case 3:
                            reader.readMessage(message.tx, () => (message.tx = ProtoTransaction.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObject.deserialize(bytes);
            }
        }
        block.ProtoWorkObject = ProtoWorkObject;
        class ProtoWorkObjects extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('work_objects' in data && data.work_objects != undefined) {
                        this.work_objects = data.work_objects;
                    }
                }
            }
            get work_objects() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoWorkObject, 1);
            }
            set work_objects(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoWorkObjects({});
                if (data.work_objects != null) {
                    message.work_objects = data.work_objects.map((item) => ProtoWorkObject.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.work_objects != null) {
                    data.work_objects = this.work_objects.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.work_objects.length)
                    writer.writeRepeatedMessage(1, this.work_objects, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjects();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.work_objects, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoWorkObject.deserialize(reader), ProtoWorkObject));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjects.deserialize(bytes);
            }
        }
        block.ProtoWorkObjects = ProtoWorkObjects;
        class ProtoWorkObjectBlockView extends pb_1__namespace.Message {
            #one_of_decls = [[1]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('work_object' in data && data.work_object != undefined) {
                        this.work_object = data.work_object;
                    }
                }
            }
            get work_object() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set work_object(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_work_object() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get _work_object() {
                const cases = {
                    0: 'none',
                    1: 'work_object',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectBlockView({});
                if (data.work_object != null) {
                    message.work_object = ProtoWorkObject.fromObject(data.work_object);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.work_object != null) {
                    data.work_object = this.work_object.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_work_object)
                    writer.writeMessage(1, this.work_object, () => this.work_object.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectBlockView();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.work_object, () => (message.work_object = ProtoWorkObject.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectBlockView.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectBlockView = ProtoWorkObjectBlockView;
        class ProtoWorkObjectBlocksView extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('work_objects' in data && data.work_objects != undefined) {
                        this.work_objects = data.work_objects;
                    }
                }
            }
            get work_objects() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoWorkObjectBlockView, 1);
            }
            set work_objects(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectBlocksView({});
                if (data.work_objects != null) {
                    message.work_objects = data.work_objects.map((item) => ProtoWorkObjectBlockView.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.work_objects != null) {
                    data.work_objects = this.work_objects.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.work_objects.length)
                    writer.writeRepeatedMessage(1, this.work_objects, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectBlocksView();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.work_objects, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoWorkObjectBlockView.deserialize(reader), ProtoWorkObjectBlockView));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectBlocksView.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectBlocksView = ProtoWorkObjectBlocksView;
        class ProtoWorkObjectHeaderView extends pb_1__namespace.Message {
            #one_of_decls = [[1]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('work_object' in data && data.work_object != undefined) {
                        this.work_object = data.work_object;
                    }
                }
            }
            get work_object() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set work_object(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_work_object() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get _work_object() {
                const cases = {
                    0: 'none',
                    1: 'work_object',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectHeaderView({});
                if (data.work_object != null) {
                    message.work_object = ProtoWorkObject.fromObject(data.work_object);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.work_object != null) {
                    data.work_object = this.work_object.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_work_object)
                    writer.writeMessage(1, this.work_object, () => this.work_object.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectHeaderView();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.work_object, () => (message.work_object = ProtoWorkObject.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectHeaderView.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectHeaderView = ProtoWorkObjectHeaderView;
        class ProtoWorkObjectShareView extends pb_1__namespace.Message {
            #one_of_decls = [[1]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('work_object' in data && data.work_object != undefined) {
                        this.work_object = data.work_object;
                    }
                }
            }
            get work_object() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set work_object(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_work_object() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get _work_object() {
                const cases = {
                    0: 'none',
                    1: 'work_object',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data) {
                const message = new ProtoWorkObjectShareView({});
                if (data.work_object != null) {
                    message.work_object = ProtoWorkObject.fromObject(data.work_object);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.work_object != null) {
                    data.work_object = this.work_object.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_work_object)
                    writer.writeMessage(1, this.work_object, () => this.work_object.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoWorkObjectShareView();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.work_object, () => (message.work_object = ProtoWorkObject.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoWorkObjectShareView.deserialize(bytes);
            }
        }
        block.ProtoWorkObjectShareView = ProtoWorkObjectShareView;
        class ProtoAccessTuple extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('address' in data && data.address != undefined) {
                        this.address = data.address;
                    }
                    if ('storage_key' in data && data.storage_key != undefined) {
                        this.storage_key = data.storage_key;
                    }
                }
            }
            get address() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set address(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            get storage_key() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 2);
            }
            set storage_key(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data) {
                const message = new ProtoAccessTuple({});
                if (data.address != null) {
                    message.address = data.address;
                }
                if (data.storage_key != null) {
                    message.storage_key = data.storage_key.map((item) => common.ProtoHash.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.address != null) {
                    data.address = this.address;
                }
                if (this.storage_key != null) {
                    data.storage_key = this.storage_key.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.address.length)
                    writer.writeBytes(1, this.address);
                if (this.storage_key.length)
                    writer.writeRepeatedMessage(2, this.storage_key, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoAccessTuple();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.address = reader.readBytes();
                            break;
                        case 2:
                            reader.readMessage(message.storage_key, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 2, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoAccessTuple.deserialize(bytes);
            }
        }
        block.ProtoAccessTuple = ProtoAccessTuple;
        class ProtoReceiptForStorage extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('post_state_or_status' in data && data.post_state_or_status != undefined) {
                        this.post_state_or_status = data.post_state_or_status;
                    }
                    if ('cumulative_gas_used' in data && data.cumulative_gas_used != undefined) {
                        this.cumulative_gas_used = data.cumulative_gas_used;
                    }
                    if ('logs' in data && data.logs != undefined) {
                        this.logs = data.logs;
                    }
                    if ('tx_hash' in data && data.tx_hash != undefined) {
                        this.tx_hash = data.tx_hash;
                    }
                    if ('contract_address' in data && data.contract_address != undefined) {
                        this.contract_address = data.contract_address;
                    }
                    if ('gas_used' in data && data.gas_used != undefined) {
                        this.gas_used = data.gas_used;
                    }
                    if ('outbound_etxs' in data && data.outbound_etxs != undefined) {
                        this.outbound_etxs = data.outbound_etxs;
                    }
                }
            }
            get post_state_or_status() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set post_state_or_status(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            get cumulative_gas_used() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, 0);
            }
            set cumulative_gas_used(value) {
                pb_1__namespace.Message.setField(this, 2, value);
            }
            get logs() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoLogsForStorage, 3);
            }
            set logs(value) {
                pb_1__namespace.Message.setWrapperField(this, 3, value);
            }
            get has_logs() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get tx_hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 4);
            }
            set tx_hash(value) {
                pb_1__namespace.Message.setWrapperField(this, 4, value);
            }
            get has_tx_hash() {
                return pb_1__namespace.Message.getField(this, 4) != null;
            }
            get contract_address() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoAddress, 5);
            }
            set contract_address(value) {
                pb_1__namespace.Message.setWrapperField(this, 5, value);
            }
            get has_contract_address() {
                return pb_1__namespace.Message.getField(this, 5) != null;
            }
            get gas_used() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 6, 0);
            }
            set gas_used(value) {
                pb_1__namespace.Message.setField(this, 6, value);
            }
            get outbound_etxs() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransactions, 7);
            }
            set outbound_etxs(value) {
                pb_1__namespace.Message.setWrapperField(this, 7, value);
            }
            get has_outbound_etxs() {
                return pb_1__namespace.Message.getField(this, 7) != null;
            }
            static fromObject(data) {
                const message = new ProtoReceiptForStorage({});
                if (data.post_state_or_status != null) {
                    message.post_state_or_status = data.post_state_or_status;
                }
                if (data.cumulative_gas_used != null) {
                    message.cumulative_gas_used = data.cumulative_gas_used;
                }
                if (data.logs != null) {
                    message.logs = ProtoLogsForStorage.fromObject(data.logs);
                }
                if (data.tx_hash != null) {
                    message.tx_hash = common.ProtoHash.fromObject(data.tx_hash);
                }
                if (data.contract_address != null) {
                    message.contract_address = common.ProtoAddress.fromObject(data.contract_address);
                }
                if (data.gas_used != null) {
                    message.gas_used = data.gas_used;
                }
                if (data.outbound_etxs != null) {
                    message.outbound_etxs = ProtoTransactions.fromObject(data.outbound_etxs);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.post_state_or_status != null) {
                    data.post_state_or_status = this.post_state_or_status;
                }
                if (this.cumulative_gas_used != null) {
                    data.cumulative_gas_used = this.cumulative_gas_used;
                }
                if (this.logs != null) {
                    data.logs = this.logs.toObject();
                }
                if (this.tx_hash != null) {
                    data.tx_hash = this.tx_hash.toObject();
                }
                if (this.contract_address != null) {
                    data.contract_address = this.contract_address.toObject();
                }
                if (this.gas_used != null) {
                    data.gas_used = this.gas_used;
                }
                if (this.outbound_etxs != null) {
                    data.outbound_etxs = this.outbound_etxs.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.post_state_or_status.length)
                    writer.writeBytes(1, this.post_state_or_status);
                if (this.cumulative_gas_used != 0)
                    writer.writeUint64(2, this.cumulative_gas_used);
                if (this.has_logs)
                    writer.writeMessage(3, this.logs, () => this.logs.serialize(writer));
                if (this.has_tx_hash)
                    writer.writeMessage(4, this.tx_hash, () => this.tx_hash.serialize(writer));
                if (this.has_contract_address)
                    writer.writeMessage(5, this.contract_address, () => this.contract_address.serialize(writer));
                if (this.gas_used != 0)
                    writer.writeUint64(6, this.gas_used);
                if (this.has_outbound_etxs)
                    writer.writeMessage(7, this.outbound_etxs, () => this.outbound_etxs.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoReceiptForStorage();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.post_state_or_status = reader.readBytes();
                            break;
                        case 2:
                            message.cumulative_gas_used = reader.readUint64();
                            break;
                        case 3:
                            reader.readMessage(message.logs, () => (message.logs = ProtoLogsForStorage.deserialize(reader)));
                            break;
                        case 4:
                            reader.readMessage(message.tx_hash, () => (message.tx_hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 5:
                            reader.readMessage(message.contract_address, () => (message.contract_address = common.ProtoAddress.deserialize(reader)));
                            break;
                        case 6:
                            message.gas_used = reader.readUint64();
                            break;
                        case 7:
                            reader.readMessage(message.outbound_etxs, () => (message.outbound_etxs = ProtoTransactions.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoReceiptForStorage.deserialize(bytes);
            }
        }
        block.ProtoReceiptForStorage = ProtoReceiptForStorage;
        class ProtoReceiptsForStorage extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('receipts' in data && data.receipts != undefined) {
                        this.receipts = data.receipts;
                    }
                }
            }
            get receipts() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoReceiptForStorage, 1);
            }
            set receipts(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoReceiptsForStorage({});
                if (data.receipts != null) {
                    message.receipts = data.receipts.map((item) => ProtoReceiptForStorage.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.receipts != null) {
                    data.receipts = this.receipts.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.receipts.length)
                    writer.writeRepeatedMessage(1, this.receipts, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoReceiptsForStorage();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.receipts, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoReceiptForStorage.deserialize(reader), ProtoReceiptForStorage));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoReceiptsForStorage.deserialize(bytes);
            }
        }
        block.ProtoReceiptsForStorage = ProtoReceiptsForStorage;
        class ProtoLogForStorage extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('address' in data && data.address != undefined) {
                        this.address = data.address;
                    }
                    if ('topics' in data && data.topics != undefined) {
                        this.topics = data.topics;
                    }
                    if ('data' in data && data.data != undefined) {
                        this.data = data.data;
                    }
                }
            }
            get address() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoAddress, 1);
            }
            set address(value) {
                pb_1__namespace.Message.setWrapperField(this, 1, value);
            }
            get has_address() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get topics() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 2);
            }
            set topics(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 2, value);
            }
            get data() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
            }
            set data(value) {
                pb_1__namespace.Message.setField(this, 3, value);
            }
            static fromObject(data) {
                const message = new ProtoLogForStorage({});
                if (data.address != null) {
                    message.address = common.ProtoAddress.fromObject(data.address);
                }
                if (data.topics != null) {
                    message.topics = data.topics.map((item) => common.ProtoHash.fromObject(item));
                }
                if (data.data != null) {
                    message.data = data.data;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.address != null) {
                    data.address = this.address.toObject();
                }
                if (this.topics != null) {
                    data.topics = this.topics.map((item) => item.toObject());
                }
                if (this.data != null) {
                    data.data = this.data;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_address)
                    writer.writeMessage(1, this.address, () => this.address.serialize(writer));
                if (this.topics.length)
                    writer.writeRepeatedMessage(2, this.topics, (item) => item.serialize(writer));
                if (this.data.length)
                    writer.writeBytes(3, this.data);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoLogForStorage();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.address, () => (message.address = common.ProtoAddress.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.topics, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 2, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        case 3:
                            message.data = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoLogForStorage.deserialize(bytes);
            }
        }
        block.ProtoLogForStorage = ProtoLogForStorage;
        class ProtoLogsForStorage extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('logs' in data && data.logs != undefined) {
                        this.logs = data.logs;
                    }
                }
            }
            get logs() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoLogForStorage, 1);
            }
            set logs(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoLogsForStorage({});
                if (data.logs != null) {
                    message.logs = data.logs.map((item) => ProtoLogForStorage.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.logs != null) {
                    data.logs = this.logs.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.logs.length)
                    writer.writeRepeatedMessage(1, this.logs, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoLogsForStorage();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.logs, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoLogForStorage.deserialize(reader), ProtoLogForStorage));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoLogsForStorage.deserialize(bytes);
            }
        }
        block.ProtoLogsForStorage = ProtoLogsForStorage;
        class ProtoPendingHeader extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('wo' in data && data.wo != undefined) {
                        this.wo = data.wo;
                    }
                    if ('termini' in data && data.termini != undefined) {
                        this.termini = data.termini;
                    }
                }
            }
            get wo() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set wo(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_wo() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get termini() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTermini, 2);
            }
            set termini(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_termini() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _wo() {
                const cases = {
                    0: 'none',
                    1: 'wo',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _termini() {
                const cases = {
                    0: 'none',
                    2: 'termini',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoPendingHeader({});
                if (data.wo != null) {
                    message.wo = ProtoWorkObject.fromObject(data.wo);
                }
                if (data.termini != null) {
                    message.termini = ProtoTermini.fromObject(data.termini);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.wo != null) {
                    data.wo = this.wo.toObject();
                }
                if (this.termini != null) {
                    data.termini = this.termini.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_wo)
                    writer.writeMessage(1, this.wo, () => this.wo.serialize(writer));
                if (this.has_termini)
                    writer.writeMessage(2, this.termini, () => this.termini.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoPendingHeader();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.wo, () => (message.wo = ProtoWorkObject.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.termini, () => (message.termini = ProtoTermini.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoPendingHeader.deserialize(bytes);
            }
        }
        block.ProtoPendingHeader = ProtoPendingHeader;
        class ProtoTermini extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('dom_termini' in data && data.dom_termini != undefined) {
                        this.dom_termini = data.dom_termini;
                    }
                    if ('sub_termini' in data && data.sub_termini != undefined) {
                        this.sub_termini = data.sub_termini;
                    }
                }
            }
            get dom_termini() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 1);
            }
            set dom_termini(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            get sub_termini() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, common.ProtoHash, 2);
            }
            set sub_termini(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data) {
                const message = new ProtoTermini({});
                if (data.dom_termini != null) {
                    message.dom_termini = data.dom_termini.map((item) => common.ProtoHash.fromObject(item));
                }
                if (data.sub_termini != null) {
                    message.sub_termini = data.sub_termini.map((item) => common.ProtoHash.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.dom_termini != null) {
                    data.dom_termini = this.dom_termini.map((item) => item.toObject());
                }
                if (this.sub_termini != null) {
                    data.sub_termini = this.sub_termini.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.dom_termini.length)
                    writer.writeRepeatedMessage(1, this.dom_termini, (item) => item.serialize(writer));
                if (this.sub_termini.length)
                    writer.writeRepeatedMessage(2, this.sub_termini, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTermini();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.dom_termini, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        case 2:
                            reader.readMessage(message.sub_termini, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 2, common.ProtoHash.deserialize(reader), common.ProtoHash));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTermini.deserialize(bytes);
            }
        }
        block.ProtoTermini = ProtoTermini;
        class ProtoEtxSet extends pb_1__namespace.Message {
            #one_of_decls = [[1]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('etx_hashes' in data && data.etx_hashes != undefined) {
                        this.etx_hashes = data.etx_hashes;
                    }
                }
            }
            get etx_hashes() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
            }
            set etx_hashes(value) {
                pb_1__namespace.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_etx_hashes() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get _etx_hashes() {
                const cases = {
                    0: 'none',
                    1: 'etx_hashes',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            static fromObject(data) {
                const message = new ProtoEtxSet({});
                if (data.etx_hashes != null) {
                    message.etx_hashes = data.etx_hashes;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.etx_hashes != null) {
                    data.etx_hashes = this.etx_hashes;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_etx_hashes)
                    writer.writeBytes(1, this.etx_hashes);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoEtxSet();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.etx_hashes = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoEtxSet.deserialize(bytes);
            }
        }
        block.ProtoEtxSet = ProtoEtxSet;
        class ProtoPendingEtxs extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('header' in data && data.header != undefined) {
                        this.header = data.header;
                    }
                    if ('outbound_etxs' in data && data.outbound_etxs != undefined) {
                        this.outbound_etxs = data.outbound_etxs;
                    }
                }
            }
            get header() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set header(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_header() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get outbound_etxs() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransactions, 2);
            }
            set outbound_etxs(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_outbound_etxs() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _header() {
                const cases = {
                    0: 'none',
                    1: 'header',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _outbound_etxs() {
                const cases = {
                    0: 'none',
                    2: 'outbound_etxs',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoPendingEtxs({});
                if (data.header != null) {
                    message.header = ProtoWorkObject.fromObject(data.header);
                }
                if (data.outbound_etxs != null) {
                    message.outbound_etxs = ProtoTransactions.fromObject(data.outbound_etxs);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.header != null) {
                    data.header = this.header.toObject();
                }
                if (this.outbound_etxs != null) {
                    data.outbound_etxs = this.outbound_etxs.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_header)
                    writer.writeMessage(1, this.header, () => this.header.serialize(writer));
                if (this.has_outbound_etxs)
                    writer.writeMessage(2, this.outbound_etxs, () => this.outbound_etxs.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoPendingEtxs();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.header, () => (message.header = ProtoWorkObject.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.outbound_etxs, () => (message.outbound_etxs = ProtoTransactions.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoPendingEtxs.deserialize(bytes);
            }
        }
        block.ProtoPendingEtxs = ProtoPendingEtxs;
        class ProtoPendingEtxsRollup extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('header' in data && data.header != undefined) {
                        this.header = data.header;
                    }
                    if ('etxs_rollup' in data && data.etxs_rollup != undefined) {
                        this.etxs_rollup = data.etxs_rollup;
                    }
                }
            }
            get header() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoWorkObject, 1);
            }
            set header(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_header() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get etxs_rollup() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTransactions, 2);
            }
            set etxs_rollup(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_etxs_rollup() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _header() {
                const cases = {
                    0: 'none',
                    1: 'header',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _etxs_rollup() {
                const cases = {
                    0: 'none',
                    2: 'etxs_rollup',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoPendingEtxsRollup({});
                if (data.header != null) {
                    message.header = ProtoWorkObject.fromObject(data.header);
                }
                if (data.etxs_rollup != null) {
                    message.etxs_rollup = ProtoTransactions.fromObject(data.etxs_rollup);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.header != null) {
                    data.header = this.header.toObject();
                }
                if (this.etxs_rollup != null) {
                    data.etxs_rollup = this.etxs_rollup.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_header)
                    writer.writeMessage(1, this.header, () => this.header.serialize(writer));
                if (this.has_etxs_rollup)
                    writer.writeMessage(2, this.etxs_rollup, () => this.etxs_rollup.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoPendingEtxsRollup();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.header, () => (message.header = ProtoWorkObject.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.etxs_rollup, () => (message.etxs_rollup = ProtoTransactions.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoPendingEtxsRollup.deserialize(bytes);
            }
        }
        block.ProtoPendingEtxsRollup = ProtoPendingEtxsRollup;
        class ProtoTxIns extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('tx_ins' in data && data.tx_ins != undefined) {
                        this.tx_ins = data.tx_ins;
                    }
                }
            }
            get tx_ins() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoTxIn, 1);
            }
            set tx_ins(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoTxIns({});
                if (data.tx_ins != null) {
                    message.tx_ins = data.tx_ins.map((item) => ProtoTxIn.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.tx_ins != null) {
                    data.tx_ins = this.tx_ins.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.tx_ins.length)
                    writer.writeRepeatedMessage(1, this.tx_ins, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTxIns();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.tx_ins, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoTxIn.deserialize(reader), ProtoTxIn));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTxIns.deserialize(bytes);
            }
        }
        block.ProtoTxIns = ProtoTxIns;
        class ProtoTxOuts extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('tx_outs' in data && data.tx_outs != undefined) {
                        this.tx_outs = data.tx_outs;
                    }
                }
            }
            get tx_outs() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoTxOut, 1);
            }
            set tx_outs(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoTxOuts({});
                if (data.tx_outs != null) {
                    message.tx_outs = data.tx_outs.map((item) => ProtoTxOut.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.tx_outs != null) {
                    data.tx_outs = this.tx_outs.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.tx_outs.length)
                    writer.writeRepeatedMessage(1, this.tx_outs, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTxOuts();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.tx_outs, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoTxOut.deserialize(reader), ProtoTxOut));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTxOuts.deserialize(bytes);
            }
        }
        block.ProtoTxOuts = ProtoTxOuts;
        class ProtoTxIn extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('previous_out_point' in data && data.previous_out_point != undefined) {
                        this.previous_out_point = data.previous_out_point;
                    }
                    if ('pub_key' in data && data.pub_key != undefined) {
                        this.pub_key = data.pub_key;
                    }
                }
            }
            get previous_out_point() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoOutPoint, 1);
            }
            set previous_out_point(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_previous_out_point() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get pub_key() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
            }
            set pub_key(value) {
                pb_1__namespace.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
            }
            get has_pub_key() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _previous_out_point() {
                const cases = {
                    0: 'none',
                    1: 'previous_out_point',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _pub_key() {
                const cases = {
                    0: 'none',
                    2: 'pub_key',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoTxIn({});
                if (data.previous_out_point != null) {
                    message.previous_out_point = ProtoOutPoint.fromObject(data.previous_out_point);
                }
                if (data.pub_key != null) {
                    message.pub_key = data.pub_key;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.previous_out_point != null) {
                    data.previous_out_point = this.previous_out_point.toObject();
                }
                if (this.pub_key != null) {
                    data.pub_key = this.pub_key;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_previous_out_point)
                    writer.writeMessage(1, this.previous_out_point, () => this.previous_out_point.serialize(writer));
                if (this.has_pub_key)
                    writer.writeBytes(2, this.pub_key);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTxIn();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.previous_out_point, () => (message.previous_out_point = ProtoOutPoint.deserialize(reader)));
                            break;
                        case 2:
                            message.pub_key = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTxIn.deserialize(bytes);
            }
        }
        block.ProtoTxIn = ProtoTxIn;
        class ProtoOutPoint extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('hash' in data && data.hash != undefined) {
                        this.hash = data.hash;
                    }
                    if ('index' in data && data.index != undefined) {
                        this.index = data.index;
                    }
                }
            }
            get hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 1);
            }
            set hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_hash() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get index() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, 0);
            }
            set index(value) {
                pb_1__namespace.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
            }
            get has_index() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _hash() {
                const cases = {
                    0: 'none',
                    1: 'hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _index() {
                const cases = {
                    0: 'none',
                    2: 'index',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoOutPoint({});
                if (data.hash != null) {
                    message.hash = common.ProtoHash.fromObject(data.hash);
                }
                if (data.index != null) {
                    message.index = data.index;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.hash != null) {
                    data.hash = this.hash.toObject();
                }
                if (this.index != null) {
                    data.index = this.index;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_hash)
                    writer.writeMessage(1, this.hash, () => this.hash.serialize(writer));
                if (this.has_index)
                    writer.writeUint32(2, this.index);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoOutPoint();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.hash, () => (message.hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 2:
                            message.index = reader.readUint32();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoOutPoint.deserialize(bytes);
            }
        }
        block.ProtoOutPoint = ProtoOutPoint;
        class ProtoTxOut extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2], [3]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('denomination' in data && data.denomination != undefined) {
                        this.denomination = data.denomination;
                    }
                    if ('address' in data && data.address != undefined) {
                        this.address = data.address;
                    }
                    if ('lock' in data && data.lock != undefined) {
                        this.lock = data.lock;
                    }
                }
            }
            get denomination() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, 0);
            }
            set denomination(value) {
                pb_1__namespace.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
            }
            get has_denomination() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get address() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, new Uint8Array(0));
            }
            set address(value) {
                pb_1__namespace.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
            }
            get has_address() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get lock() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
            }
            set lock(value) {
                pb_1__namespace.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
            }
            get has_lock() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get _denomination() {
                const cases = {
                    0: 'none',
                    1: 'denomination',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _address() {
                const cases = {
                    0: 'none',
                    2: 'address',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _lock() {
                const cases = {
                    0: 'none',
                    3: 'lock',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            static fromObject(data) {
                const message = new ProtoTxOut({});
                if (data.denomination != null) {
                    message.denomination = data.denomination;
                }
                if (data.address != null) {
                    message.address = data.address;
                }
                if (data.lock != null) {
                    message.lock = data.lock;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.denomination != null) {
                    data.denomination = this.denomination;
                }
                if (this.address != null) {
                    data.address = this.address;
                }
                if (this.lock != null) {
                    data.lock = this.lock;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_denomination)
                    writer.writeUint32(1, this.denomination);
                if (this.has_address)
                    writer.writeBytes(2, this.address);
                if (this.has_lock)
                    writer.writeBytes(3, this.lock);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoTxOut();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.denomination = reader.readUint32();
                            break;
                        case 2:
                            message.address = reader.readBytes();
                            break;
                        case 3:
                            message.lock = reader.readBytes();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoTxOut.deserialize(bytes);
            }
        }
        block.ProtoTxOut = ProtoTxOut;
        class ProtoOutPointAndDenomination extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2], [3]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('hash' in data && data.hash != undefined) {
                        this.hash = data.hash;
                    }
                    if ('index' in data && data.index != undefined) {
                        this.index = data.index;
                    }
                    if ('denomination' in data && data.denomination != undefined) {
                        this.denomination = data.denomination;
                    }
                }
            }
            get hash() {
                return pb_1__namespace.Message.getWrapperField(this, common.ProtoHash, 1);
            }
            set hash(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_hash() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get index() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 2, 0);
            }
            set index(value) {
                pb_1__namespace.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
            }
            get has_index() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get denomination() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 3, 0);
            }
            set denomination(value) {
                pb_1__namespace.Message.setOneofField(this, 3, this.#one_of_decls[2], value);
            }
            get has_denomination() {
                return pb_1__namespace.Message.getField(this, 3) != null;
            }
            get _hash() {
                const cases = {
                    0: 'none',
                    1: 'hash',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _index() {
                const cases = {
                    0: 'none',
                    2: 'index',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            get _denomination() {
                const cases = {
                    0: 'none',
                    3: 'denomination',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [3])];
            }
            static fromObject(data) {
                const message = new ProtoOutPointAndDenomination({});
                if (data.hash != null) {
                    message.hash = common.ProtoHash.fromObject(data.hash);
                }
                if (data.index != null) {
                    message.index = data.index;
                }
                if (data.denomination != null) {
                    message.denomination = data.denomination;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.hash != null) {
                    data.hash = this.hash.toObject();
                }
                if (this.index != null) {
                    data.index = this.index;
                }
                if (this.denomination != null) {
                    data.denomination = this.denomination;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_hash)
                    writer.writeMessage(1, this.hash, () => this.hash.serialize(writer));
                if (this.has_index)
                    writer.writeUint32(2, this.index);
                if (this.has_denomination)
                    writer.writeUint32(3, this.denomination);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoOutPointAndDenomination();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.hash, () => (message.hash = common.ProtoHash.deserialize(reader)));
                            break;
                        case 2:
                            message.index = reader.readUint32();
                            break;
                        case 3:
                            message.denomination = reader.readUint32();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoOutPointAndDenomination.deserialize(bytes);
            }
        }
        block.ProtoOutPointAndDenomination = ProtoOutPointAndDenomination;
        class ProtoAddressOutPoints extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('out_points' in data && data.out_points != undefined) {
                        this.out_points = data.out_points;
                    }
                }
                if (!this.out_points)
                    this.out_points = new Map();
            }
            get out_points() {
                return pb_1__namespace.Message.getField(this, 1);
            }
            set out_points(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoAddressOutPoints({});
                if (typeof data.out_points == 'object') {
                    message.out_points = new Map(Object.entries(data.out_points).map(([key, value]) => [
                        key,
                        ProtoOutPointAndDenomination.fromObject(value),
                    ]));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.out_points != null) {
                    data.out_points = Object.fromEntries(Array.from(this.out_points).map(([key, value]) => [key, value.toObject()]));
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                for (const [key, value] of this.out_points) {
                    writer.writeMessage(1, this.out_points, () => {
                        writer.writeString(1, key);
                        writer.writeMessage(2, value, () => value.serialize(writer));
                    });
                }
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoAddressOutPoints();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message, () => pb_1__namespace.Map.deserializeBinary(message.out_points, reader, reader.readString, () => {
                                let value;
                                reader.readMessage(message, () => (value = ProtoOutPointAndDenomination.deserialize(reader)));
                                return value;
                            }));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoAddressOutPoints.deserialize(bytes);
            }
        }
        block.ProtoAddressOutPoints = ProtoAddressOutPoints;
        class ProtoOutPointsMap extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('entries' in data && data.entries != undefined) {
                        this.entries = data.entries;
                    }
                }
                if (!this.entries)
                    this.entries = new Map();
            }
            get entries() {
                return pb_1__namespace.Message.getField(this, 1);
            }
            set entries(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoOutPointsMap({});
                if (typeof data.entries == 'object') {
                    message.entries = new Map(Object.entries(data.entries).map(([key, value]) => [key, ProtoAddressOutPoints.fromObject(value)]));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.entries != null) {
                    data.entries = Object.fromEntries(Array.from(this.entries).map(([key, value]) => [key, value.toObject()]));
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                for (const [key, value] of this.entries) {
                    writer.writeMessage(1, this.entries, () => {
                        writer.writeString(1, key);
                        writer.writeMessage(2, value, () => value.serialize(writer));
                    });
                }
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoOutPointsMap();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message, () => pb_1__namespace.Map.deserializeBinary(message.entries, reader, reader.readString, () => {
                                let value;
                                reader.readMessage(message, () => (value = ProtoAddressOutPoints.deserialize(reader)));
                                return value;
                            }));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoOutPointsMap.deserialize(bytes);
            }
        }
        block.ProtoOutPointsMap = ProtoOutPointsMap;
        class ProtoSpentUTXO extends pb_1__namespace.Message {
            #one_of_decls = [[1], [2]];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('outpoint' in data && data.outpoint != undefined) {
                        this.outpoint = data.outpoint;
                    }
                    if ('sutxo' in data && data.sutxo != undefined) {
                        this.sutxo = data.sutxo;
                    }
                }
            }
            get outpoint() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoOutPoint, 1);
            }
            set outpoint(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
            }
            get has_outpoint() {
                return pb_1__namespace.Message.getField(this, 1) != null;
            }
            get sutxo() {
                return pb_1__namespace.Message.getWrapperField(this, ProtoTxOut, 2);
            }
            set sutxo(value) {
                pb_1__namespace.Message.setOneofWrapperField(this, 2, this.#one_of_decls[1], value);
            }
            get has_sutxo() {
                return pb_1__namespace.Message.getField(this, 2) != null;
            }
            get _outpoint() {
                const cases = {
                    0: 'none',
                    1: 'outpoint',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [1])];
            }
            get _sutxo() {
                const cases = {
                    0: 'none',
                    2: 'sutxo',
                };
                return cases[pb_1__namespace.Message.computeOneofCase(this, [2])];
            }
            static fromObject(data) {
                const message = new ProtoSpentUTXO({});
                if (data.outpoint != null) {
                    message.outpoint = ProtoOutPoint.fromObject(data.outpoint);
                }
                if (data.sutxo != null) {
                    message.sutxo = ProtoTxOut.fromObject(data.sutxo);
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.outpoint != null) {
                    data.outpoint = this.outpoint.toObject();
                }
                if (this.sutxo != null) {
                    data.sutxo = this.sutxo.toObject();
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.has_outpoint)
                    writer.writeMessage(1, this.outpoint, () => this.outpoint.serialize(writer));
                if (this.has_sutxo)
                    writer.writeMessage(2, this.sutxo, () => this.sutxo.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoSpentUTXO();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.outpoint, () => (message.outpoint = ProtoOutPoint.deserialize(reader)));
                            break;
                        case 2:
                            reader.readMessage(message.sutxo, () => (message.sutxo = ProtoTxOut.deserialize(reader)));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoSpentUTXO.deserialize(bytes);
            }
        }
        block.ProtoSpentUTXO = ProtoSpentUTXO;
        class ProtoSpentUTXOs extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('sutxos' in data && data.sutxos != undefined) {
                        this.sutxos = data.sutxos;
                    }
                }
            }
            get sutxos() {
                return pb_1__namespace.Message.getRepeatedWrapperField(this, ProtoSpentUTXO, 1);
            }
            set sutxos(value) {
                pb_1__namespace.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoSpentUTXOs({});
                if (data.sutxos != null) {
                    message.sutxos = data.sutxos.map((item) => ProtoSpentUTXO.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.sutxos != null) {
                    data.sutxos = this.sutxos.map((item) => item.toObject());
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.sutxos.length)
                    writer.writeRepeatedMessage(1, this.sutxos, (item) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoSpentUTXOs();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.sutxos, () => pb_1__namespace.Message.addToRepeatedWrapperField(message, 1, ProtoSpentUTXO.deserialize(reader), ProtoSpentUTXO));
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoSpentUTXOs.deserialize(bytes);
            }
        }
        block.ProtoSpentUTXOs = ProtoSpentUTXOs;
        class ProtoKeys extends pb_1__namespace.Message {
            #one_of_decls = [];
            constructor(data) {
                super();
                pb_1__namespace.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == 'object') {
                    if ('keys' in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                }
            }
            get keys() {
                return pb_1__namespace.Message.getFieldWithDefault(this, 1, []);
            }
            set keys(value) {
                pb_1__namespace.Message.setField(this, 1, value);
            }
            static fromObject(data) {
                const message = new ProtoKeys({});
                if (data.keys != null) {
                    message.keys = data.keys;
                }
                return message;
            }
            toObject() {
                const data = {};
                if (this.keys != null) {
                    data.keys = this.keys;
                }
                return data;
            }
            serialize(w) {
                const writer = w || new pb_1__namespace.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedBytes(1, this.keys);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes) {
                const reader = bytes instanceof pb_1__namespace.BinaryReader ? bytes : new pb_1__namespace.BinaryReader(bytes), message = new ProtoKeys();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            pb_1__namespace.Message.addToRepeatedField(message, 1, reader.readBytes());
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary() {
                return this.serialize();
            }
            static deserializeBinary(bytes) {
                return ProtoKeys.deserialize(bytes);
            }
        }
        block.ProtoKeys = ProtoKeys;
    })(block || (block = {}));

    /**
     * @category Encoding
     * @param {ProtoTransaction} protoTx - The signed constructed transaction
     * @returns {string} - The Protobuf encoded transaction
     */
    function encodeProtoTransaction(protoTx) {
        const tx = block.ProtoTransaction.fromObject(protoTx);
        return hexlify(tx.serialize());
    }

    /**
     * @category Encoding
     * @param {Uint8Array} bytes - The Protobuf encoded transaction
     * @returns {ProtoTransaction} - The decoded transaction
     */
    function decodeProtoTransaction(bytes) {
        const tx = block.ProtoTransaction.deserialize(bytes);
        const result = tx.toObject();
        if (result.to?.length == 0) {
            result.to = null;
        }
        return result;
    }

    /**
     * Using strings in Ethereum (or any security-basd system) requires additional care. These utilities attempt to mitigate
     * some of the safety issues as well as provide the ability to recover and analyse strings.
     *
     * @subsection api/utils:Strings and UTF-8  [about-strings]
     */
    // `output` and `badCodepoint` are passed to calls below, but not used in the function
    function errorFunc(reason, offset, bytes, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    output, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    badCodepoint) {
        assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, 'bytes', bytes);
    }
    // `output` and `badCodepoint` are passed to calls below, but not used in the function
    function ignoreFunc(reason, offset, bytes, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    output, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    badCodepoint) {
        // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
        if (reason === 'BAD_PREFIX' || reason === 'UNEXPECTED_CONTINUE') {
            let i = 0;
            for (let o = offset + 1; o < bytes.length; o++) {
                if (bytes[o] >> 6 !== 0x02) {
                    break;
                }
                i++;
            }
            return i;
        }
        // This byte runs us past the end of the string, so just jump to the end
        // (but the first byte was read already read and therefore skipped)
        if (reason === 'OVERRUN') {
            return bytes.length - offset - 1;
        }
        // Nothing to skip
        return 0;
    }
    function replaceFunc(reason, offset, bytes, output, badCodepoint) {
        // Overlong representations are otherwise "valid" code points; just non-deistingtished
        if (reason === 'OVERLONG') {
            assertArgument(typeof badCodepoint === 'number', 'invalid bad code point for replacement', 'badCodepoint', badCodepoint);
            output.push(badCodepoint);
            return 0;
        }
        // Put the replacement character into the output
        output.push(0xfffd);
        // Otherwise, process as if ignoring errors
        return ignoreFunc(reason, offset, bytes);
    }
    /**
     * A handful of popular, built-in UTF-8 error handling strategies.
     *
     * **`"error"`** - throws on ANY illegal UTF-8 sequence or non-canonical (overlong) codepoints (this is the default)
     *
     * **`"ignore"`** - silently drops any illegal UTF-8 sequence and accepts non-canonical (overlong) codepoints
     *
     * **`"replace"`** - replace any illegal UTF-8 sequence with the UTF-8 replacement character (i.e. `"\\ufffd"`) and
     * accepts non-canonical (overlong) codepoints
     *
     * @category Encoding
     * @returns Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
     */
    const Utf8ErrorFuncs = Object.freeze({
        error: errorFunc,
        ignore: ignoreFunc,
        replace: replaceFunc,
    });
    // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
    function getUtf8CodePoints(_bytes, onError) {
        if (onError == null) {
            onError = Utf8ErrorFuncs.error;
        }
        const bytes = getBytes(_bytes, 'bytes');
        const result = [];
        let i = 0;
        // Invalid bytes are ignored
        while (i < bytes.length) {
            const c = bytes[i++];
            // 0xxx xxxx
            if (c >> 7 === 0) {
                result.push(c);
                continue;
            }
            // Multibyte; how many bytes left for this character?
            let extraLength = null;
            let overlongMask = null;
            // 110x xxxx 10xx xxxx
            if ((c & 0xe0) === 0xc0) {
                extraLength = 1;
                overlongMask = 0x7f;
                // 1110 xxxx 10xx xxxx 10xx xxxx
            }
            else if ((c & 0xf0) === 0xe0) {
                extraLength = 2;
                overlongMask = 0x7ff;
                // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
            }
            else if ((c & 0xf8) === 0xf0) {
                extraLength = 3;
                overlongMask = 0xffff;
            }
            else {
                if ((c & 0xc0) === 0x80) {
                    i += onError('UNEXPECTED_CONTINUE', i - 1, bytes, result);
                }
                else {
                    i += onError('BAD_PREFIX', i - 1, bytes, result);
                }
                continue;
            }
            // Do we have enough bytes in our data?
            if (i - 1 + extraLength >= bytes.length) {
                i += onError('OVERRUN', i - 1, bytes, result);
                continue;
            }
            // Remove the length prefix from the char
            let res = c & ((1 << (8 - extraLength - 1)) - 1);
            for (let j = 0; j < extraLength; j++) {
                const nextChar = bytes[i];
                // Invalid continuation byte
                if ((nextChar & 0xc0) != 0x80) {
                    i += onError('MISSING_CONTINUE', i, bytes, result);
                    res = null;
                    break;
                }
                res = (res << 6) | (nextChar & 0x3f);
                i++;
            }
            // See above loop for invalid continuation byte
            if (res === null) {
                continue;
            }
            // Maximum code point
            if (res > 0x10ffff) {
                i += onError('OUT_OF_RANGE', i - 1 - extraLength, bytes, result, res);
                continue;
            }
            // Reserved for UTF-16 surrogate halves
            if (res >= 0xd800 && res <= 0xdfff) {
                i += onError('UTF16_SURROGATE', i - 1 - extraLength, bytes, result, res);
                continue;
            }
            // Check for overlong sequences (more bytes than needed)
            if (res <= overlongMask) {
                i += onError('OVERLONG', i - 1 - extraLength, bytes, result, res);
                continue;
            }
            result.push(res);
        }
        return result;
    }
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    /**
     * Returns the UTF-8 byte representation of `str`.
     *
     * If `form` is specified, the string is normalized.
     *
     * @category Encoding
     * @param {string} str - The string to convert.
     * @param {UnicodeNormalizationForm} [form] - The normalization form to use.
     * @returns {Uint8Array} The UTF-8 byte representation.
     * @throws {Error} If the UTF-8 conversion fails.
     */
    function toUtf8Bytes(str, form) {
        if (form != null) {
            assertNormalize(form);
            str = str.normalize(form);
        }
        const result = [];
        for (let i = 0; i < str.length; i++) {
            const c = str.charCodeAt(i);
            if (c < 0x80) {
                result.push(c);
            }
            else if (c < 0x800) {
                result.push((c >> 6) | 0xc0);
                result.push((c & 0x3f) | 0x80);
            }
            else if ((c & 0xfc00) == 0xd800) {
                i++;
                const c2 = str.charCodeAt(i);
                assertArgument(i < str.length && (c2 & 0xfc00) === 0xdc00, 'invalid surrogate pair', 'str', str);
                // Surrogate Pair
                const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
                result.push((pair >> 18) | 0xf0);
                result.push(((pair >> 12) & 0x3f) | 0x80);
                result.push(((pair >> 6) & 0x3f) | 0x80);
                result.push((pair & 0x3f) | 0x80);
            }
            else {
                result.push((c >> 12) | 0xe0);
                result.push(((c >> 6) & 0x3f) | 0x80);
                result.push((c & 0x3f) | 0x80);
            }
        }
        return new Uint8Array(result);
    }
    /**
     * @ignore
     */
    function _toUtf8String(codePoints) {
        return codePoints
            .map((codePoint) => {
            if (codePoint <= 0xffff) {
                return String.fromCharCode(codePoint);
            }
            codePoint -= 0x10000;
            return String.fromCharCode(((codePoint >> 10) & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
        })
            .join('');
    }
    /**
     * Returns the string represented by the UTF-8 data `bytes`.
     *
     * When `onError` function is specified, it is called on UTF-8 errors allowing recovery using the
     * {@link Utf8ErrorFunc | **Utf8ErrorFunc**} API. (default: [error](Utf8ErrorFuncs))
     *
     * @category Encoding
     * @param {BytesLike} bytes - The UTF-8 data to convert.
     * @param {Utf8ErrorFunc} [onError] - The error handling function.
     * @returns {string} The string.
     */
    function toUtf8String(bytes, onError) {
        return _toUtf8String(getUtf8CodePoints(bytes, onError));
    }
    /**
     * Returns the UTF-8 code-points for `str`.
     *
     * If `form` is specified, the string is normalized.
     *
     * @category Encoding
     * @param {string} str - The string to convert.
     * @param {UnicodeNormalizationForm} [form] - The normalization form to use.
     * @returns {number[]} The UTF-8 code-points.
     */
    function toUtf8CodePoints(str, form) {
        return getUtf8CodePoints(toUtf8Bytes(str, form));
    }

    // @TODO: timeout is completely ignored; start a Promise.any with a reject?
    // TODO: `options` is not used; remove?
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function createGetUrl(options) {
        async function getUrl(req, _signal) {
            const protocol = req.url.split(':')[0].toLowerCase();
            assert$1(protocol === 'http' || protocol === 'https', `unsupported protocol ${protocol}`, 'UNSUPPORTED_OPERATION', {
                info: { protocol },
                operation: 'request',
            });
            assert$1(protocol === 'https' || !req.credentials || req.allowInsecureAuthentication, 'insecure authorized connections unsupported', 'UNSUPPORTED_OPERATION', {
                operation: 'request',
            });
            let signal = undefined;
            if (_signal) {
                const controller = new AbortController();
                signal = controller.signal;
                _signal.addListener(() => {
                    controller.abort();
                });
            }
            const init = {
                method: req.method,
                headers: new Headers(Array.from(req)),
                body: req.body || undefined,
                signal,
            };
            const resp = await fetch(req.url, init);
            const headers = {};
            resp.headers.forEach((value, key) => {
                headers[key.toLowerCase()] = value;
            });
            const respBody = await resp.arrayBuffer();
            const body = respBody == null ? null : new Uint8Array(respBody);
            return {
                statusCode: resp.status,
                statusMessage: resp.statusText,
                headers,
                body,
            };
        }
        return getUrl;
    }

    /**
     * Fetching content from the web is environment-specific, so quais provides an abstraction that each environment can
     * implement to provide this service.
     *
     * On [Node.js](https://nodejs.org/), the `http` and `https` libs are used to create a request object, register event
     * listeners and process data and populate the {@link FetchResponse | **FetchResponse**}.
     *
     * In a browser, the [DOM fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is used, and the resulting
     * `Promise` is waited on to retrieve the payload.
     *
     * The {@link FetchRequest | **FetchRequest**} is responsible for handling many common situations, such as redirects,
     * server throttling, authentication, etc.
     *
     * It also handles common gateways, such as IPFS and data URIs.
     */
    const MAX_ATTEMPTS = 12;
    const SLOT_INTERVAL = 250;
    // The global FetchGetUrlFunc implementation.
    let defaultGetUrlFunc = createGetUrl();
    const reData = new RegExp('^data:([^;:]*)?(;base64)?,(.*)$', 'i');
    const reIpfs = new RegExp('^ipfs://(ipfs/)?(.*)$', 'i');
    // If locked, new Gateways cannot be added
    let locked$5 = false;
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
    // TODO: `signal` is not used; remove?
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async function dataGatewayFunc(url, signal) {
        try {
            const match = url.match(reData);
            if (!match) {
                throw new Error('invalid data');
            }
            return new FetchResponse(200, 'OK', {
                'content-type': match[1] || 'text/plain',
            }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
        }
        catch (error) {
            return new FetchResponse(599, 'BAD REQUEST (invalid data: URI)', {}, null, new FetchRequest(url));
        }
    }
    /**
     * Returns a {@link FetchGatewayFunc | **FetchGatewayFunc**} for fetching content from a standard IPFS gateway hosted at
     * `baseUrl`.
     *
     * @category Utils
     * @param {string} baseUrl - The base URL of the IPFS gateway.
     * @returns {FetchGatewayFunc} The gateway function.
     */
    function getIpfsGatewayFunc(baseUrl) {
        // TODO: `signal` is not used; remove?
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async function gatewayIpfs(url, signal) {
            try {
                const match = url.match(reIpfs);
                if (!match) {
                    throw new Error('invalid link');
                }
                return new FetchRequest(`${baseUrl}${match[2]}`);
            }
            catch (error) {
                return new FetchResponse(599, 'BAD REQUEST (invalid IPFS URI)', {}, null, new FetchRequest(url));
            }
        }
        return gatewayIpfs;
    }
    const Gateways = {
        data: dataGatewayFunc,
        ipfs: getIpfsGatewayFunc('https://gateway.ipfs.io/ipfs/'),
    };
    const fetchSignals = new WeakMap();
    /**
     * @ignore
     */
    class FetchCancelSignal {
        #listeners;
        #cancelled;
        constructor(request) {
            this.#listeners = [];
            this.#cancelled = false;
            fetchSignals.set(request, () => {
                if (this.#cancelled) {
                    return;
                }
                this.#cancelled = true;
                for (const listener of this.#listeners) {
                    setTimeout(() => {
                        listener();
                    }, 0);
                }
                this.#listeners = [];
            });
        }
        addListener(listener) {
            assert$1(!this.#cancelled, 'singal already cancelled', 'UNSUPPORTED_OPERATION', {
                operation: 'fetchCancelSignal.addCancelListener',
            });
            this.#listeners.push(listener);
        }
        get cancelled() {
            return this.#cancelled;
        }
        checkSignal() {
            assert$1(!this.cancelled, 'cancelled', 'CANCELLED', {});
        }
    }
    // Check the signal, throwing if it is cancelled
    function checkSignal(signal) {
        if (signal == null) {
            throw new Error('missing signal; should not happen');
        }
        signal.checkSignal();
        return signal;
    }
    /**
     * Represents a request for a resource using a URI.
     *
     * By default, the supported schemes are `HTTP`, `HTTPS`, `data:`, and `IPFS:`.
     *
     * Additional schemes can be added globally using {@link registerGateway | **registerGateway**}.
     *
     * @category Utils
     * @example
     *
     * ```ts
     * req = new FetchRequest('https://www.ricmoo.com');
     * resp = await req.send();
     * resp.body.length;
     * ```
     */
    class FetchRequest {
        #allowInsecure;
        #gzip;
        #headers;
        #method;
        #timeout;
        #url;
        #body;
        #bodyType;
        #creds;
        // Hooks
        #preflight;
        #process;
        #retry;
        #signal;
        #throttle;
        #getUrlFunc;
        /**
         * The fetch URL to request.
         */
        get url() {
            return this.#url;
        }
        set url(url) {
            this.#url = String(url);
        }
        /**
         * The fetch body, if any, to send as the request body. (default: null)
         *
         * When setting a body, the intrinsic `Content-Type` is automatically set and will be used if **not overridden** by
         * setting a custom header.
         *
         * If `body` is null, the body is cleared (along with the intrinsic `Content-Type`).
         *
         * If `body` is a string, the intrinsic `Content-Type` is set to `text/plain`.
         *
         * If `body` is a Uint8Array, the intrinsic `Content-Type` is set to `application/octet-stream`.
         *
         * If `body` is any other object, the intrinsic `Content-Type` is set to `application/json`.
         */
        get body() {
            if (this.#body == null) {
                return null;
            }
            return new Uint8Array(this.#body);
        }
        set body(body) {
            if (body == null) {
                this.#body = undefined;
                this.#bodyType = undefined;
            }
            else if (typeof body === 'string') {
                this.#body = toUtf8Bytes(body);
                this.#bodyType = 'text/plain';
            }
            else if (body instanceof Uint8Array) {
                this.#body = body;
                this.#bodyType = 'application/octet-stream';
            }
            else if (typeof body === 'object') {
                this.#body = toUtf8Bytes(JSON.stringify(body));
                this.#bodyType = 'application/json';
            }
            else {
                throw new Error('invalid body');
            }
        }
        /**
         * Returns true if the request has a body.
         */
        hasBody() {
            return this.#body != null;
        }
        /**
         * The HTTP method to use when requesting the URI. If no method has been explicitly set, then `GET` is used if the
         * body is null and `POST` otherwise.
         */
        get method() {
            if (this.#method) {
                return this.#method;
            }
            if (this.hasBody()) {
                return 'POST';
            }
            return 'GET';
        }
        set method(method) {
            if (method == null) {
                method = '';
            }
            this.#method = String(method).toUpperCase();
        }
        /**
         * The headers that will be used when requesting the URI. All keys are lower-case.
         *
         * This object is a copy, so any changes will **NOT** be reflected in the `FetchRequest`.
         *
         * To set a header entry, use the `setHeader` method.
         */
        get headers() {
            const headers = Object.assign({}, this.#headers);
            if (this.#creds) {
                headers['authorization'] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
            }
            if (this.allowGzip) {
                headers['accept-encoding'] = 'gzip';
            }
            if (headers['content-type'] == null && this.#bodyType) {
                headers['content-type'] = this.#bodyType;
            }
            if (this.body) {
                headers['content-length'] = String(this.body.length);
            }
            return headers;
        }
        /**
         * Get the header for `key`, ignoring case.
         *
         * @param {string} key - The header key to retrieve.
         * @returns {string} The header value.
         */
        getHeader(key) {
            return this.headers[key.toLowerCase()];
        }
        /**
         * Set the header for `key` to `value`. All values are coerced to a string.
         *
         * @param {string} key - The header key to set.
         * @param {string | number} value - The header value to set.
         */
        setHeader(key, value) {
            this.#headers[String(key).toLowerCase()] = String(value);
        }
        /**
         * Clear all headers, resetting all intrinsic headers.
         */
        clearHeaders() {
            this.#headers = {};
        }
        [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
                next: () => {
                    if (index < keys.length) {
                        const key = keys[index++];
                        return {
                            value: [key, headers[key]],
                            done: false,
                        };
                    }
                    return { value: undefined, done: true };
                },
            };
        }
        /**
         * The value that will be sent for the `Authorization` header.
         *
         * To set the credentials, use the `setCredentials` method.
         */
        get credentials() {
            return this.#creds || null;
        }
        /**
         * Sets an `Authorization` for `username` with `password`.
         *
         * @param {string} username - The username to use for basic authentication.
         * @param {string} password - The password to use for basic authentication.
         * @throws {Error} If the `username` contains a colon.
         */
        setCredentials(username, password) {
            assertArgument(!username.match(/:/), 'invalid basic authentication username', 'username', '[REDACTED]');
            this.#creds = `${username}:${password}`;
        }
        /**
         * Enable and request gzip-encoded responses. The response will automatically be decompressed. (default: true)
         */
        get allowGzip() {
            return this.#gzip;
        }
        set allowGzip(value) {
            this.#gzip = !!value;
        }
        /**
         * Allow `Authentication` credentials to be sent over insecure channels. (default: false)
         */
        get allowInsecureAuthentication() {
            return !!this.#allowInsecure;
        }
        set allowInsecureAuthentication(value) {
            this.#allowInsecure = !!value;
        }
        /**
         * The timeout (in milliseconds) to wait for a complete response. (default: 5 minutes)
         */
        get timeout() {
            return this.#timeout;
        }
        set timeout(timeout) {
            assertArgument(timeout >= 0, 'timeout must be non-zero', 'timeout', timeout);
            this.#timeout = timeout;
        }
        /**
         * This function is called prior to each request, for example during a redirection or retry in case of server
         * throttling.
         *
         * This offers an opportunity to populate headers or update content before sending a request.
         */
        get preflightFunc() {
            return this.#preflight || null;
        }
        set preflightFunc(preflight) {
            this.#preflight = preflight;
        }
        /**
         * This function is called after each response, offering an opportunity to provide client-level throttling or
         * updating response data.
         *
         * Any error thrown in this causes the `send()` to throw.
         *
         * To schedule a retry attempt (assuming the maximum retry limit has not been reached), use
         * {@link FetchResponse.throwThrottleError | **FetchResponse.throwThrottleError**}.
         */
        get processFunc() {
            return this.#process || null;
        }
        set processFunc(process) {
            this.#process = process;
        }
        /**
         * This function is called on each retry attempt.
         */
        get retryFunc() {
            return this.#retry || null;
        }
        set retryFunc(retry) {
            this.#retry = retry;
        }
        /**
         * This function is called to fetch content from HTTP and HTTPS URLs and is platform specific (e.g. nodejs vs
         * browsers).
         *
         * This is by default the currently registered global getUrl function, which can be changed using
         * {@link registerGetUrl | **registerGetUrl**}. If this has been set, setting is to `null` will cause this
         * FetchRequest (and any future clones) to revert back to using the currently registered global getUrl function.
         *
         * Setting this is generally not necessary, but may be useful for developers that wish to intercept requests or to
         * configurege a proxy or other agent.
         */
        get getUrlFunc() {
            return this.#getUrlFunc || defaultGetUrlFunc;
        }
        set getUrlFunc(value) {
            this.#getUrlFunc = value;
        }
        /**
         * Create a new FetchRequest instance with default values.
         *
         * Once created, each property may be set before issuing a `.send()` to make the request.
         */
        constructor(url) {
            this.#url = String(url);
            this.#allowInsecure = false;
            this.#gzip = true;
            this.#headers = {};
            this.#method = '';
            this.#timeout = 300000;
            this.#throttle = {
                slotInterval: SLOT_INTERVAL,
                maxAttempts: MAX_ATTEMPTS,
            };
            this.#getUrlFunc = null;
        }
        toString() {
            return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : 'null'}>`;
        }
        /**
         * Update the throttle parameters used to determine maximum attempts and exponential-backoff properties.
         *
         * @param {FetchThrottleParams} params - The throttle parameters to set.
         * @throws {Error} If the `slotInterval` is not a positive integer.
         */
        setThrottleParams(params) {
            if (params.slotInterval != null) {
                this.#throttle.slotInterval = params.slotInterval;
            }
            if (params.maxAttempts != null) {
                this.#throttle.maxAttempts = params.maxAttempts;
            }
        }
        async #send(attempt, expires, delay, _request, _response) {
            if (attempt >= this.#throttle.maxAttempts) {
                return _response.makeServerError('exceeded maximum retry limit');
            }
            assert$1(getTime$1() <= expires, 'timeout', 'TIMEOUT', {
                operation: 'request.send',
                reason: 'timeout',
                request: _request,
            });
            if (delay > 0) {
                await wait(delay);
            }
            let req = this.clone();
            const scheme = (req.url.split(':')[0] || '').toLowerCase();
            // Process any Gateways
            if (scheme in Gateways) {
                const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
                if (result instanceof FetchResponse) {
                    let response = result;
                    if (this.processFunc) {
                        checkSignal(_request.#signal);
                        try {
                            response = await this.processFunc(req, response);
                        }
                        catch (error) {
                            // Something went wrong during processing; throw a 5xx server error
                            if (error.throttle == null || typeof error.stall !== 'number') {
                                response.makeServerError('error in post-processing function', error).assertOk();
                            }
                            // Ignore throttling
                        }
                    }
                    return response;
                }
                req = result;
            }
            // We have a preflight function; update the request
            if (this.preflightFunc) {
                req = await this.preflightFunc(req);
            }
            const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
            let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
            if (response.statusCode === 301 || response.statusCode === 302) {
                // Redirect
                try {
                    const location = response.headers.location || '';
                    return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
                    // eslint-disable-next-line no-empty
                }
                catch (error) { }
                // Things won't get any better on another attempt; abort
                return response;
            }
            else if (response.statusCode === 429) {
                // Throttle
                if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {
                    const retryAfter = response.headers['retry-after'];
                    let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                    if (typeof retryAfter === 'string' && retryAfter.match(/^[1-9][0-9]*$/)) {
                        delay = parseInt(retryAfter);
                    }
                    return req.clone().#send(attempt + 1, expires, delay, _request, response);
                }
            }
            if (this.processFunc) {
                checkSignal(_request.#signal);
                try {
                    response = await this.processFunc(req, response);
                }
                catch (error) {
                    // Something went wrong during processing; throw a 5xx server error
                    if (error.throttle == null || typeof error.stall !== 'number') {
                        response.makeServerError('error in post-processing function', error).assertOk();
                    }
                    // Throttle
                    let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
                    if (error.stall >= 0) {
                        delay = error.stall;
                    }
                    return req.clone().#send(attempt + 1, expires, delay, _request, response);
                }
            }
            return response;
        }
        /**
         * Resolves to the response by sending the request.
         */
        send() {
            assert$1(this.#signal == null, 'request already sent', 'UNSUPPORTED_OPERATION', {
                operation: 'fetchRequest.send',
            });
            this.#signal = new FetchCancelSignal(this);
            return this.#send(0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, '', {}, null, this));
        }
        /**
         * Cancels the inflight response, causing a `CANCELLED` error to be rejected from the
         * {@link FetchRequest.send | **send**}.
         */
        cancel() {
            assert$1(this.#signal != null, 'request has not been sent', 'UNSUPPORTED_OPERATION', {
                operation: 'fetchRequest.cancel',
            });
            const signal = fetchSignals.get(this);
            if (!signal) {
                throw new Error('missing signal; should not happen');
            }
            signal();
        }
        /**
         * Returns a new {@link FetchRequest | **FetchRequest**} that represents the redirection to `location`.
         *
         * @param {string} location - The location to redirect to.
         * @returns {FetchRequest} The new request.
         */
        redirect(location) {
            // Redirection; for now we only support absolute locations
            const current = this.url.split(':')[0].toLowerCase();
            const target = location.split(':')[0].toLowerCase();
            // Don't allow redirecting:
            // - non-GET requests
            // - downgrading the security (e.g. https => http)
            // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
            assert$1(this.method === 'GET' && (current !== 'https' || target !== 'http') && location.match(/^https?:/), `unsupported redirect`, 'UNSUPPORTED_OPERATION', {
                operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`,
            });
            // Create a copy of this request, with a new URL
            const req = new FetchRequest(location);
            req.method = 'GET';
            req.allowGzip = this.allowGzip;
            req.timeout = this.timeout;
            req.#headers = Object.assign({}, this.#headers);
            if (this.#body) {
                req.#body = new Uint8Array(this.#body);
            }
            req.#bodyType = this.#bodyType;
            return req;
        }
        /**
         * Create a new copy of this request.
         *
         * @returns {FetchRequest} The new request.
         */
        clone() {
            const clone = new FetchRequest(this.url);
            // Preserve "default method" (i.e. null)
            clone.#method = this.#method;
            // Preserve "default body" with type, copying the Uint8Array is present
            if (this.#body) {
                clone.#body = this.#body;
            }
            clone.#bodyType = this.#bodyType;
            // Preserve "default headers"
            clone.#headers = Object.assign({}, this.#headers);
            // Credentials is readonly, so we copy internally
            clone.#creds = this.#creds;
            if (this.allowGzip) {
                clone.allowGzip = true;
            }
            clone.timeout = this.timeout;
            if (this.allowInsecureAuthentication) {
                clone.allowInsecureAuthentication = true;
            }
            clone.#preflight = this.#preflight;
            clone.#process = this.#process;
            clone.#retry = this.#retry;
            clone.#getUrlFunc = this.#getUrlFunc;
            return clone;
        }
        /**
         * Locks all static configuration for gateways and FetchGetUrlFunc registration.
         */
        static lockConfig() {
            locked$5 = true;
        }
        /**
         * Get the current Gateway function for `scheme`.
         *
         * @param {string} scheme - The scheme to get the gateway for.
         * @returns {FetchGatewayFunc | null} The gateway function, or null if not found.
         */
        static getGateway(scheme) {
            return Gateways[scheme.toLowerCase()] || null;
        }
        /**
         * Use the `func` when fetching URIs using `scheme`.
         *
         * This method affects all requests globally.
         *
         * If {@link FetchRequest.lockConfig | **lockConfig**} has been called, no change is made and this throws.
         *
         * @param {string} scheme - The scheme to register the gateway for.
         * @param {FetchGatewayFunc} func - The gateway function to use.
         * @throws {Error} If the scheme is `http` or `https`.
         */
        static registerGateway(scheme, func) {
            scheme = scheme.toLowerCase();
            if (scheme === 'http' || scheme === 'https') {
                throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
            }
            if (locked$5) {
                throw new Error('gateways locked');
            }
            Gateways[scheme] = func;
        }
        /**
         * Use `getUrl` when fetching URIs over HTTP and HTTPS requests.
         *
         * This method affects all requests globally.
         *
         * If {@link FetchRequest.lockConfig | **lockConfig**} has been called, no change is made and this throws.
         *
         * @param {FetchGetUrlFunc} getUrl - The function to use for fetching HTTP and HTTPS URIs.
         * @throws {Error} If the gateways are locked.
         */
        static registerGetUrl(getUrl) {
            if (locked$5) {
                throw new Error('gateways locked');
            }
            defaultGetUrlFunc = getUrl;
        }
        /**
         * Creates a getUrl function that fetches content from HTTP and HTTPS URLs.
         *
         * The available `options` are dependent on the platform implementation of the default getUrl function.
         *
         * This is not generally something that is needed, but is useful when trying to customize simple behaviour when
         * fetching HTTP content.
         *
         * @param {Record<string, any>} [options] - The options to use when creating the getUrl function.
         * @returns {FetchGetUrlFunc} The getUrl function.
         * @throws {Error} If the gateways are locked.
         */
        static createGetUrlFunc(options) {
            return createGetUrl();
        }
        /**
         * Creates a function that can "fetch" data URIs.
         *
         * Note that this is automatically done internally to support data URIs, so it is not necessary to register it.
         *
         * This is not generally something that is needed, but may be useful in a wrapper to perfom custom data URI
         * functionality.
         *
         * @returns {FetchGatewayFunc} The gateway function.
         */
        static createDataGateway() {
            return dataGatewayFunc;
        }
        /**
         * Creates a function that will fetch IPFS (unvalidated) from a custom gateway baseUrl.
         *
         * The default IPFS gateway used internally is `"https:/\/gateway.ipfs.io/ipfs/"`.
         *
         * @param {string} baseUrl - The base URL of the IPFS gateway.
         * @returns {FetchGatewayFunc} The gateway function.
         */
        static createIpfsGatewayFunc(baseUrl) {
            return getIpfsGatewayFunc(baseUrl);
        }
    }
    /**
     * The response for a FetchRequest.
     *
     * @category Utils
     */
    class FetchResponse {
        #statusCode;
        #statusMessage;
        #headers;
        #body;
        #request;
        #error;
        toString() {
            return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : 'null'}>`;
        }
        /**
         * The response status code.
         */
        get statusCode() {
            return this.#statusCode;
        }
        /**
         * The response status message.
         */
        get statusMessage() {
            return this.#statusMessage;
        }
        /**
         * The response headers. All keys are lower-case.
         */
        get headers() {
            return Object.assign({}, this.#headers);
        }
        /**
         * The response body, or `null` if there was no body.
         */
        get body() {
            return this.#body == null ? null : new Uint8Array(this.#body);
        }
        /**
         * The response body as a UTF-8 encoded string, or the empty string (i.e. `""`) if there was no body.
         *
         * An error is thrown if the body is invalid UTF-8 data.
         */
        get bodyText() {
            try {
                return this.#body == null ? '' : toUtf8String(this.#body);
            }
            catch (error) {
                assert$1(false, 'response body is not valid UTF-8 data', 'UNSUPPORTED_OPERATION', {
                    operation: 'bodyText',
                    info: { response: this },
                });
            }
        }
        /**
         * The response body, decoded as JSON.
         *
         * An error is thrown if the body is invalid JSON-encoded data or if there was no body.
         */
        get bodyJson() {
            try {
                return JSON.parse(this.bodyText);
            }
            catch (error) {
                assert$1(false, 'response body is not valid JSON', 'UNSUPPORTED_OPERATION', {
                    operation: 'bodyJson',
                    info: { response: this },
                });
            }
        }
        [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
                next: () => {
                    if (index < keys.length) {
                        const key = keys[index++];
                        return {
                            value: [key, headers[key]],
                            done: false,
                        };
                    }
                    return { value: undefined, done: true };
                },
            };
        }
        constructor(statusCode, statusMessage, headers, body, request) {
            this.#statusCode = statusCode;
            this.#statusMessage = statusMessage;
            this.#headers = Object.keys(headers).reduce((accum, k) => {
                accum[k.toLowerCase()] = String(headers[k]);
                return accum;
            }, {});
            this.#body = body == null ? null : new Uint8Array(body);
            this.#request = request || null;
            this.#error = { message: '' };
        }
        /**
         * Return a Response with matching headers and body, but with an error status code (i.e. 599) and `message` with an
         * optional `error`.
         *
         * @param {string} [message] - The error message to use.
         * @param {Error} [error] - The error to use.
         * @returns {FetchResponse} The error response.
         */
        makeServerError(message, error) {
            let statusMessage;
            if (!message) {
                message = `${this.statusCode} ${this.statusMessage}`;
                statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
            }
            else {
                statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
            }
            const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
            response.#error = { message, error };
            return response;
        }
        /**
         * If called within a [request.processFunc](FetchRequest-processFunc) call, causes the request to retry as if
         * throttled for `stall` milliseconds.
         *
         * @param {string} [message] - The error message to use.
         * @param {number} [stall] - The number of milliseconds to stall before retrying.
         * @throws {Error} If `stall` is not a non-negative integer.
         */
        throwThrottleError(message, stall) {
            if (stall == null) {
                stall = -1;
            }
            else {
                assertArgument(Number.isInteger(stall) && stall >= 0, 'invalid stall timeout', 'stall', stall);
            }
            const error = new Error(message || 'throttling requests');
            defineProperties(error, { stall, throttle: true });
            throw error;
        }
        /**
         * Get the header value for `key`, ignoring case.
         *
         * @param {string} key - The header key to retrieve.
         * @returns {string} The header value.
         */
        getHeader(key) {
            return this.headers[key.toLowerCase()];
        }
        /**
         * Returns true if the response has a body.
         *
         * @returns {boolean} True if the response has a body.
         * @throws {Error} If the body is invalid UTF-8 data.
         */
        hasBody() {
            return this.#body != null;
        }
        /**
         * The request made for this response.
         */
        get request() {
            return this.#request;
        }
        /**
         * Returns true if this response was a success statusCode.
         */
        ok() {
            return this.#error.message === '' && this.statusCode >= 200 && this.statusCode < 300;
        }
        /**
         * Throws a `SERVER_ERROR` if this response is not ok.
         *
         * @throws {Error} If the response is not ok.
         */
        assertOk() {
            if (this.ok()) {
                return;
            }
            // eslint-disable-next-line prefer-const
            let { message, error } = this.#error;
            if (message === '') {
                message = `server response ${this.statusCode} ${this.statusMessage}`;
            }
            assert$1(false, message, 'SERVER_ERROR', {
                request: this.request || 'unknown request',
                response: this,
                error,
            });
        }
    }
    function getTime$1() {
        return new Date().getTime();
    }
    function unpercent(value) {
        return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
            return String.fromCharCode(parseInt(code, 16));
        }));
    }
    function wait(delay) {
        return new Promise((resolve) => setTimeout(resolve, delay));
    }

    /**
     * The **FixedNumber** class permits using values with decimal places, using fixed-pont math.
     *
     * Fixed-point math is still based on integers under-the-hood, but uses an internal offset to store fractional
     * components below, and each operation corrects for this after each operation.
     */
    const BN_N1 = BigInt(-1);
    const BN_0$6 = BigInt(0);
    const BN_1$3 = BigInt(1);
    const BN_5 = BigInt(5);
    const _guard$7 = {};
    // Constant to pull zeros from for multipliers
    let Zeros = '0000';
    while (Zeros.length < 80) {
        Zeros += Zeros;
    }
    // Returns a string "1" followed by decimal "0"s
    function getTens(decimals) {
        let result = Zeros;
        while (result.length < decimals) {
            result += result;
        }
        return BigInt('1' + result.substring(0, decimals));
    }
    function checkValue(val, format, safeOp) {
        const width = BigInt(format.width);
        if (format.signed) {
            const limit = BN_1$3 << (width - BN_1$3);
            assert$1(safeOp == null || (val >= -limit && val < limit), 'overflow', 'NUMERIC_FAULT', {
                operation: safeOp,
                fault: 'overflow',
                value: val,
            });
            if (val > BN_0$6) {
                val = fromTwos(mask(val, width), width);
            }
            else {
                val = -fromTwos(mask(-val, width), width);
            }
        }
        else {
            const limit = BN_1$3 << width;
            assert$1(safeOp == null || (val >= 0 && val < limit), 'overflow', 'NUMERIC_FAULT', {
                operation: safeOp,
                fault: 'overflow',
                value: val,
            });
            val = ((val % limit) + limit) % limit & (limit - BN_1$3);
        }
        return val;
    }
    function getFormat(value) {
        if (typeof value === 'number') {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === 'string') {
            // Parse the format string
            if (value === 'fixed') ;
            else if (value === 'ufixed') {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                assertArgument(match, 'invalid fixed format', 'format', value);
                signed = match[1] !== 'u';
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            // Extract the values from the object
            const v = value;
            const check = (key, type, defaultValue) => {
                if (v[key] == null) {
                    return defaultValue;
                }
                assertArgument(typeof v[key] === type, 'invalid fixed format (' + key + ' not ' + type + ')', 'format.' + key, v[key]);
                return v[key];
            };
            signed = check('signed', 'boolean', signed);
            width = check('width', 'number', width);
            decimals = check('decimals', 'number', decimals);
        }
        assertArgument(width % 8 === 0, 'invalid FixedNumber width (not byte aligned)', 'format.width', width);
        assertArgument(decimals <= 80, 'invalid FixedNumber decimals (too large)', 'format.decimals', decimals);
        const name = (signed ? '' : 'u') + 'fixed' + String(width) + 'x' + String(decimals);
        return { signed, width, decimals, name };
    }
    function toString(val, decimals) {
        let negative = '';
        if (val < BN_0$6) {
            negative = '-';
            val *= BN_N1;
        }
        let str = val.toString();
        // No decimal point for whole values
        if (decimals === 0) {
            return negative + str;
        }
        // Pad out to the whole component (including a whole digit)
        while (str.length <= decimals) {
            str = Zeros + str;
        }
        // Insert the decimal point
        const index = str.length - decimals;
        str = str.substring(0, index) + '.' + str.substring(index);
        // Trim the whole component (leaving at least one 0)
        while (str[0] === '0' && str[1] !== '.') {
            str = str.substring(1);
        }
        // Trim the decimal component (leaving at least one 0)
        while (str[str.length - 1] === '0' && str[str.length - 2] !== '.') {
            str = str.substring(0, str.length - 1);
        }
        return negative + str;
    }
    /**
     * A FixedNumber represents a value over its {@link FixedFormat | **FixedFormat**} arithmetic field.
     *
     * A FixedNumber can be used to perform math, losslessly, on values which have decmial places.
     *
     * A FixedNumber has a fixed bit-width to store values in, and stores all values internally by multiplying the value by
     * 10 raised to the power of `decimals`.
     *
     * If operations are performed that cause a value to grow too high (close to positive infinity) or too low (close to
     * negative infinity), the value is said to overflow.
     *
     * For example, an 8-bit signed value, with 0 decimals may only be within the range `-128` to `127`; so `-128 - 1` will
     * overflow and become `127`. Likewise, `127 + 1` will overflow and become `-127`.
     *
     * Many operation have a normal and unsafe variant. The normal variant will throw a
     * [NumericFaultError](../interfaces/NumericFaultError) on any overflow, while the unsafe variant will silently allow
     * overflow, corrupting its value value.
     *
     * If operations are performed that cause a value to become too small (close to zero), the value loses precison and is
     * said to underflow.
     *
     * For example, an value with 1 decimal place may store a number as small as `0.1`, but the value of `0.1 / 2` is
     * `0.05`, which cannot fit into 1 decimal place, so underflow occurs which means precision is lost and the value
     * becomes `0`.
     *
     * Some operations have a normal and signalling variant. The normal variant will silently ignore underflow, while the
     * signalling variant will thow a [NumericFaultError](../interfaces/NumericFaultError) on underflow.
     *
     * @category Utils
     */
    class FixedNumber {
        /**
         * The specific fixed-point arithmetic field for this value.
         */
        format;
        #format;
        // The actual value (accounting for decimals)
        #val;
        // A base-10 value to multiple values by to maintain the magnitude
        #tens;
        /**
         * This is a property so console.log shows a human-meaningful value.
         *
         * @ignore
         */
        _value;
        // Use this when changing this file to get some typing info,
        // but then switch to any to mask the internal type
        // constructor(guard: any, value: bigint, format: _FixedFormat) {
        /**
         * @ignore
         */
        constructor(guard, value, format) {
            assertPrivate(guard, _guard$7, 'FixedNumber');
            this.#val = value;
            this.#format = format;
            const _value = toString(value, format.decimals);
            defineProperties(this, { format: format.name, _value });
            this.#tens = getTens(format.decimals);
        }
        /**
         * If true, negative values are permitted, otherwise only positive values and zero are allowed.
         */
        get signed() {
            return this.#format.signed;
        }
        /**
         * The number of bits available to store the value.
         */
        get width() {
            return this.#format.width;
        }
        /**
         * The number of decimal places in the fixed-point arithment field.
         */
        get decimals() {
            return this.#format.decimals;
        }
        /**
         * The value as an integer, based on the smallest unit the {@link FixedNumber.decimals | **decimals**} allow.
         */
        get value() {
            return this.#val;
        }
        #checkFormat(other) {
            assertArgument(this.format === other.format, 'incompatible format; use fixedNumber.toFormat', 'other', other);
        }
        #checkValue(val, safeOp) {
            val = checkValue(val, this.#format, safeOp);
            return new FixedNumber(_guard$7, val, this.#format);
        }
        #add(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val + o.#val, safeOp);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` added to `other`, ignoring overflow.
         *
         * @param {FixedNumber} other - The value to add to `this`.
         * @returns {FixedNumber} The result of the addition.
         */
        addUnsafe(other) {
            return this.#add(other);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` added to `other`. A
         * [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs.
         *
         * @param {FixedNumber} other - The value to add to `this`.
         * @returns {FixedNumber} The result of the addition.
         */
        add(other) {
            return this.#add(other, 'add');
        }
        #sub(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val - o.#val, safeOp);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `other` subtracted from `this`, ignoring
         * overflow.
         *
         * @param {FixedNumber} other - The value to subtract from `this`.
         * @returns {FixedNumber} The result of the subtraction.
         */
        subUnsafe(other) {
            return this.#sub(other);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `other` subtracted from `this`. A
         * [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs.
         *
         * @param {FixedNumber} other - The value to subtract from `this`.
         * @returns {FixedNumber} The result of the subtraction.
         */
        sub(other) {
            return this.#sub(other, 'sub');
        }
        #mul(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` multiplied by `other`, ignoring
         * overflow and underflow (precision loss).
         *
         * @param {FixedNumber} other - The value to multiply `this` by.
         * @returns {FixedNumber} The result of the multiplication.
         */
        mulUnsafe(other) {
            return this.#mul(other);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` multiplied by `other`. A
         * [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs.
         *
         * @param {FixedNumber} other - The value to multiply `this` by.
         * @returns {FixedNumber} The result of the multiplication.
         */
        mul(other) {
            return this.#mul(other, 'mul');
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` multiplied by `other`. A
         * [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs or if underflow (precision
         * loss) occurs.
         *
         * @param {FixedNumber} other - The value to multiply `this` by.
         * @returns {FixedNumber} The result of the multiplication.
         * @throws {NumericFaultError} Thrown if overflow or underflow occurs.
         * @throws {NumericFaultError} Thrown if division by 0 occurs.
         */
        mulSignal(other) {
            this.#checkFormat(other);
            const value = this.#val * other.#val;
            assert$1(value % this.#tens === BN_0$6, 'precision lost during signalling mul', 'NUMERIC_FAULT', {
                operation: 'mulSignal',
                fault: 'underflow',
                value: this,
            });
            return this.#checkValue(value / this.#tens, 'mulSignal');
        }
        #div(o, safeOp) {
            assert$1(o.#val !== BN_0$6, 'division by zero', 'NUMERIC_FAULT', {
                operation: 'div',
                fault: 'divide-by-zero',
                value: this,
            });
            this.#checkFormat(o);
            return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` divided by `other`, ignoring
         * underflow (precision loss). A [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs.
         *
         * @param {FixedNumber} other - The value to divide `this` by.
         * @returns {FixedNumber} The result of the division.
         */
        divUnsafe(other) {
            return this.#div(other);
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` divided by `other`, ignoring
         * underflow (precision loss). A [NumericFaultError](../interfaces/NumericFaultError) is thrown if overflow occurs.
         *
         * @param {FixedNumber} other - The value to divide `this` by.
         * @returns {FixedNumber} The result of the division.
         */
        div(other) {
            return this.#div(other, 'div');
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the result of `this` divided by `other`. A
         * [NumericFaultError](../interfaces/NumericFaultError) is thrown if underflow (precision loss) occurs.
         *
         * @param {FixedNumber} other - The value to divide `this` by.
         * @returns {FixedNumber} The result of the division.
         * @throws {NumericFaultError} Thrown if underflow occurs.
         */
        divSignal(other) {
            assert$1(other.#val !== BN_0$6, 'division by zero', 'NUMERIC_FAULT', {
                operation: 'div',
                fault: 'divide-by-zero',
                value: this,
            });
            this.#checkFormat(other);
            const value = this.#val * this.#tens;
            assert$1(value % other.#val === BN_0$6, 'precision lost during signalling div', 'NUMERIC_FAULT', {
                operation: 'divSignal',
                fault: 'underflow',
                value: this,
            });
            return this.#checkValue(value / other.#val, 'divSignal');
        }
        /**
         * Returns a comparison result between `this` and `other`.
         *
         * This is suitable for use in sorting, where `-1` implies `this` is smaller, `1` implies `this` is larger and `0`
         * implies both are equal.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {number} The comparison result.
         */
        cmp(other) {
            let a = this.value, b = other.value;
            // Coerce a and b to the same magnitude
            const delta = this.decimals - other.decimals;
            if (delta > 0) {
                b *= getTens(delta);
            }
            else if (delta < 0) {
                a *= getTens(-delta);
            }
            // Comnpare
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        }
        /**
         * Returns true if `other` is equal to `this`.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {boolean} True if `other` is equal to `this`.
         */
        eq(other) {
            return this.cmp(other) === 0;
        }
        /**
         * Returns true if `other` is less than to `this`.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {boolean} True if `other` is less than to `this`.
         */
        lt(other) {
            return this.cmp(other) < 0;
        }
        /**
         * Returns true if `other` is less than or equal to `this`.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {boolean} True if `other` is less than or equal to `this`.
         */
        lte(other) {
            return this.cmp(other) <= 0;
        }
        /**
         * Returns true if `other` is greater than to `this`.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {boolean} True if `other` is greater than to `this`.
         */
        gt(other) {
            return this.cmp(other) > 0;
        }
        /**
         * Returns true if `other` is greater than or equal to `this`.
         *
         * @param {FixedNumber} other - The value to compare to `this`.
         * @returns {boolean} True if `other` is greater than or equal to `this`.
         */
        gte(other) {
            return this.cmp(other) >= 0;
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} which is the largest **integer** that is less than or equal to
         * `this`.
         *
         * The decimal component of the result will always be `0`.
         *
         * @returns {FixedNumber} The floored value.
         */
        floor() {
            let val = this.#val;
            if (this.#val < BN_0$6) {
                val -= this.#tens - BN_1$3;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, 'floor');
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} which is the smallest **integer** that is greater than or
         * equal to `this`.
         *
         * The decimal component of the result will always be `0`.
         *
         * @returns {FixedNumber} The ceiling value.
         */
        ceiling() {
            let val = this.#val;
            if (this.#val > BN_0$6) {
                val += this.#tens - BN_1$3;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, 'ceiling');
        }
        /**
         * Returns a new {@link FixedNumber | **FixedNumber**} with the decimal component rounded up on ties at `decimals`
         * places.
         *
         * @param {number} [decimals] - The number of decimal places to round to.
         * @returns {FixedNumber} The rounded value.
         */
        round(decimals) {
            if (decimals == null) {
                decimals = 0;
            }
            // Not enough precision to not already be rounded
            if (decimals >= this.decimals) {
                return this;
            }
            const delta = this.decimals - decimals;
            const bump = BN_5 * getTens(delta - 1);
            let value = this.value + bump;
            const tens = getTens(delta);
            value = (value / tens) * tens;
            checkValue(value, this.#format, 'round');
            return new FixedNumber(_guard$7, value, this.#format);
        }
        /**
         * Returns true if `this` is equal to `0`.
         *
         * @returns {boolean} True if `this` is equal to `0`.
         */
        isZero() {
            return this.#val === BN_0$6;
        }
        /**
         * Returns true if `this` is less than `0`.
         *
         * @returns {boolean} True if `this` is less than `0`.
         */
        isNegative() {
            return this.#val < BN_0$6;
        }
        /**
         * Returns the string representation of `this`.
         *
         * @returns {string} The string representation.
         */
        toString() {
            return this._value;
        }
        /**
         * Returns a float approximation.
         *
         * Due to IEEE 754 precission (or lack thereof), this function can only return an approximation and most values will
         * contain rounding errors.
         *
         * @returns {number} The float approximation.
         */
        toUnsafeFloat() {
            return parseFloat(this.toString());
        }
        /**
         * Return a new {@link FixedNumber | **FixedNumber**} with the same value but has had its field set to `format`.
         *
         * This will throw if the value cannot fit into `format`.
         *
         * @param {FixedFormat} format - The new format for the value.
         */
        toFormat(format) {
            return FixedNumber.fromString(this.toString(), format);
        }
        /**
         * Creates a new {@link FixedNumber | **FixedNumber**} for `value` divided by `decimal` places with `format`.
         *
         * This will throw a [NumericFaultError](../interfaces/NumericFaultError) if `value` (once adjusted for `decimals`)
         * cannot fit in `format`, either due to overflow or underflow (precision loss).
         *
         * @param {BigNumberish} _value - The value to create a FixedNumber for.
         * @param {Numeric} [_decimals] - The number of decimal places in `value`.
         * @param {FixedFormat} [_format] - The format for the FixedNumber.
         * @returns {FixedNumber} The FixedNumber for `value`.
         */
        static fromValue(_value, _decimals, _format) {
            const decimals = _decimals == null ? 0 : getNumber(_decimals);
            const format = getFormat(_format);
            let value = getBigInt(_value, 'value');
            const delta = decimals - format.decimals;
            if (delta > 0) {
                const tens = getTens(delta);
                assert$1(value % tens === BN_0$6, 'value loses precision for format', 'NUMERIC_FAULT', {
                    operation: 'fromValue',
                    fault: 'underflow',
                    value: _value,
                });
                value /= tens;
            }
            else if (delta < 0) {
                value *= getTens(-delta);
            }
            checkValue(value, format, 'fromValue');
            return new FixedNumber(_guard$7, value, format);
        }
        /**
         * Creates a new {@link FixedNumber | **FixedNumber**} for `value` with `format`.
         *
         * This will throw a [NumericFaultError](../interfaces/NumericFaultError) if `value` cannot fit in `format`, either
         * due to overflow or underflow (precision loss).
         *
         * @param {BigNumberish} _value - The value to create a FixedNumber for.
         * @param {FixedFormat} [_format] - The format for the FixedNumber.
         * @returns {FixedNumber} The FixedNumber for `value`.
         */
        static fromString(_value, _format) {
            const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            assertArgument(match && match[2].length + match[3].length > 0, 'invalid FixedNumber string value', 'value', _value);
            const format = getFormat(_format);
            const whole = match[2] || '0';
            let decimal = match[3] || '';
            // Pad out the decimals
            while (decimal.length < format.decimals) {
                decimal += Zeros;
            }
            // Check precision is safe
            assert$1(decimal.substring(format.decimals).match(/^0*$/), 'too many decimals for format', 'NUMERIC_FAULT', {
                operation: 'fromString',
                fault: 'underflow',
                value: _value,
            });
            // Remove extra padding
            decimal = decimal.substring(0, format.decimals);
            const value = BigInt(match[1] + whole + decimal);
            checkValue(value, format, 'fromString');
            return new FixedNumber(_guard$7, value, format);
        }
        /**
         * Creates a new {@link FixedNumber | **FixedNumber**} with the big-endian representation `value` with `format`.
         *
         * This will throw a [NumericFaultError](../interfaces/NumericFaultError) if `value` cannot fit in `format` due to
         * overflow.
         *
         * @param {BytesLike} _value - The big-endian representation of the value.
         * @param {FixedFormat} [_format] - The format for the FixedNumber.
         * @returns {FixedNumber} The FixedNumber for `value`.
         */
        static fromBytes(_value, _format) {
            let value = toBigInt(getBytes(_value, 'value'));
            const format = getFormat(_format);
            if (format.signed) {
                value = fromTwos(value, format.width);
            }
            checkValue(value, format, 'fromBytes');
            return new FixedNumber(_guard$7, value, format);
        }
    }

    /**
     * Most interactions with Ethereum requires integer values, which use the smallest magnitude unit.
     *
     * For example, imagine dealing with dollars and cents. Since dollars are divisible, non-integer values are possible,
     * such as `$10.77`. By using the smallest indivisible unit (i.e. cents), the value can be kept as the integer `1077`.
     *
     * When receiving decimal input from the user (as a decimal string), the value should be converted to an integer and
     * when showing a user a value, the integer value should be converted to a decimal string.
     *
     * This creates a clear distinction, between values to be used by code (integers) and values used for display logic to
     * users (decimals).
     *
     * The native unit in Ethereum, ether is divisible to 18 decimal places, where each individual unit is called a wei.
     */
    const names = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
    /**
     * Converts `value` into a decimal string, assuming `unit` decimal places. The `unit` may be the number of decimal
     * places or the name of a unit (e.g. `"gwei"` for 9 decimal places).
     *
     * @category Utils
     * @param {BigNumberish} value - The value to convert.
     * @param {string | Numeric} [unit=18] - The unit to convert to. Default is `18`
     * @returns {string} The converted value.
     * @throws {Error} If the unit is invalid.
     */
    function formatUnits(value, unit) {
        let decimals = 18;
        if (typeof unit === 'string') {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, 'invalid unit', 'unit', unit);
            decimals = 3 * index;
        }
        else if (unit != null) {
            decimals = getNumber(unit, 'unit');
        }
        return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
    }
    /**
     * Converts the decimal string `value` to a BigInt, assuming `unit` decimal places. The `unit` may the number of decimal
     * places or the name of a unit (e.g. `"gwei"` for 9 decimal places).
     *
     * @category Utils
     * @param {string} value - The value to convert.
     * @param {string | Numeric} [unit=18] - The unit to convert from. Default is `18`
     * @returns {bigint} The converted value.
     * @throws {Error} If the unit is invalid.
     * @throws {Error} If the value is not a string.
     */
    function parseUnits(value, unit) {
        assertArgument(typeof value === 'string', 'value must be a string', 'value', value);
        let decimals = 18;
        if (typeof unit === 'string') {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, 'invalid unit', 'unit', unit);
            decimals = 3 * index;
        }
        else if (unit != null) {
            decimals = getNumber(unit, 'unit');
        }
        return FixedNumber.fromString(value, { decimals, width: 512 }).value;
    }
    /**
     * Converts `value` into a decimal string sing 18 decimal places.
     *
     * @category Utils
     * @param {BigNumberish} wei - The value to convert.
     * @returns {string} The converted value.
     */
    function formatQuai(wei) {
        return formatUnits(wei, 18);
    }
    /**
     * Converts `value` into a decimal string using 3 decimal places.
     *
     * @category Utils
     * @param {BigNumberish} value - The value to convert.
     * @returns {string} The converted value.
     */
    function formatQi(value) {
        return formatUnits(value, 3);
    }
    /**
     * Converts the decimal string `quai` to a BigInt, using 18 decimal places.
     *
     * @category Utils
     * @param {string} ether - The value to convert.
     * @returns {bigint} The converted value.
     */
    function parseQuai(ether) {
        return parseUnits(ether, 18);
    }
    /**
     * Converts `value` into a decimal string using 3 decimal places.
     *
     * @category Utils
     * @param {string} value - The value to convert.
     * @returns {bigint} The converted value.
     */
    function parseQi(value) {
        return parseUnits(value, 3);
    }

    /**
     * Explain UUID and link to RFC here.
     */
    /**
     * Returns the version 4 [UUID](https://www.ietf.org/rfc/rfc4122.txt) for the `randomBytes`.
     *
     * @category Utils
     * @param {BytesLike} randomBytes - The random bytes to use.
     * @returns {string} The UUID.
     */
    function uuidV4(randomBytes) {
        const bytes = getBytes(randomBytes, 'randomBytes');
        // Section: 4.1.3:
        // - time_hi_and_version[12:16] = 0b0100
        bytes[6] = (bytes[6] & 0x0f) | 0x40;
        // Section 4.4
        // - clock_seq_hi_and_reserved[6] = 0b0
        // - clock_seq_hi_and_reserved[7] = 0b1
        bytes[8] = (bytes[8] & 0x3f) | 0x80;
        const value = hexlify(bytes);
        return [
            value.substring(2, 10),
            value.substring(10, 14),
            value.substring(14, 18),
            value.substring(18, 22),
            value.substring(22, 34),
        ].join('-');
    }

    /**
     * A zone is the lowest level shard within the Quai network hierarchy. Zones are the only shards in the network that
     * accept user transactions. The value is a hexadecimal string representing the encoded value of the zone. Read more
     * [here](https://github.com/quai-network/qips/blob/master/qip-0002.md).
     *
     * @category Constants
     */
    exports.Zone = void 0;
    (function (Zone) {
        Zone["Cyprus1"] = "0x00";
        Zone["Cyprus2"] = "0x01";
        Zone["Cyprus3"] = "0x02";
        Zone["Paxos1"] = "0x10";
        Zone["Paxos2"] = "0x11";
        Zone["Paxos3"] = "0x12";
        Zone["Hydra1"] = "0x20";
        Zone["Hydra2"] = "0x21";
        Zone["Hydra3"] = "0x22";
    })(exports.Zone || (exports.Zone = {}));
    exports.Ledger = void 0;
    (function (Ledger) {
        Ledger[Ledger["Quai"] = 0] = "Quai";
        Ledger[Ledger["Qi"] = 1] = "Qi";
    })(exports.Ledger || (exports.Ledger = {}));
    function zoneFromBytes(zone) {
        switch (zone) {
            case '0x00':
                return exports.Zone.Cyprus1;
            case '0x01':
                return exports.Zone.Cyprus2;
            case '0x02':
                return exports.Zone.Cyprus3;
            case '0x10':
                return exports.Zone.Paxos1;
            case '0x11':
                return exports.Zone.Paxos2;
            case '0x12':
                return exports.Zone.Paxos3;
            case '0x20':
                return exports.Zone.Hydra1;
            case '0x21':
                return exports.Zone.Hydra2;
            case '0x22':
                return exports.Zone.Hydra3;
            default:
                throw new Error(`Invalid zone: ${zone}`);
        }
    }
    const ZoneData = [
        {
            name: 'Cyprus One',
            nickname: 'cyprus1',
            shard: 'zone-0-0',
            context: 2,
            byte: '0x00', //0000 0000 region-0 zone-0
        },
        {
            name: 'Cyprus Two',
            nickname: 'cyprus2',
            shard: 'zone-0-1',
            context: 2,
            byte: '0x01', // 0000 0001 region-0 zone-1
        },
        {
            name: 'Cyprus Three',
            nickname: 'cyprus3',
            shard: 'zone-0-2',
            context: 2,
            byte: '0x02', // 0000 0010 region-0 zone-2
        },
        {
            name: 'Paxos One',
            nickname: 'paxos1',
            shard: 'zone-1-0',
            context: 2,
            byte: '0x10', // 0001 0000 region-1 zone-0
        },
        {
            name: 'Paxos Two',
            nickname: 'paxos2',
            shard: 'zone-1-1',
            context: 2,
            byte: '0x11', // 0001 0001 region-1 zone-1
        },
        {
            name: 'Paxos Three',
            nickname: 'paxos3',
            shard: 'zone-1-2',
            context: 2,
            byte: '0x12', // 0001 0010 region-1 zone-2
        },
        {
            name: 'Hydra One',
            nickname: 'hydra1',
            shard: 'zone-2-0',
            context: 2,
            byte: '0x20', // 0010 0000 region-2 zone-0
        },
        {
            name: 'Hydra Two',
            nickname: 'hydra2',
            shard: 'zone-2-1',
            context: 2,
            byte: '0x21', // 0010 0001 region-2 zone-1
        },
        {
            name: 'Hydra Three',
            nickname: 'hydra3',
            shard: 'zone-2-2',
            context: 2,
            byte: '0x22', // 0010 0010 region-2 zone-2
        },
    ];
    function toZone(shard) {
        return zoneFromBytes(ZoneData.find((it) => it.name == shard || it.byte == shard || it.nickname == shard || it.shard == shard)
            ?.byte || '');
    }

    function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
    }
    function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
            throw new Error('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function hash(hash) {
        if (typeof hash !== 'function' || typeof hash.create !== 'function')
            throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(hash.outputLen);
        number(hash.blockLen);
    }
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }

    const crypto$1 = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
    // node.js versions earlier than v19 don't declare it in global scope.
    // For node.js, package.json#exports field mapping rewrites import
    // from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated, we can just drop the import.
    const u8a$1 = (a) => a instanceof Uint8Array;
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    // Cast array to view
    const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    // The rotate right (circular right shift) operation for uint32
    const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
    // big-endian hardware is rare. Just in case someone still decides to run hashes:
    // early-throw an error because we don't support BE yet.
    const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    if (!isLE)
        throw new Error('Non little-endian hardware is not supported');
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes$1(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        const len = hex.length;
        if (len % 2)
            throw new Error('padded hex string expected, got unpadded hex of length ' + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new Error('Invalid byte sequence');
            array[i] = byte;
        }
        return array;
    }
    // There is no setImmediate in browser and setTimeout is slow.
    // call of async fn will return Promise, which will be fullfiled only on
    // next scheduler queue processing step and this is exactly what we need.
    const nextTick = async () => { };
    // Returns control to thread each 'tick' ms to avoid blocking
    async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
            cb(i);
            // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick)
                continue;
            await nextTick();
            ts += diff;
        }
    }
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes$1(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    /**
     * Normalizes (non-hex) string or Uint8Array to Uint8Array.
     * Warning: when Uint8Array is passed, it would NOT get copied.
     * Keep in mind for future mutable operations.
     */
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes$1(data);
        if (!u8a$1(data))
            throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
    }
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes$1(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0; // walk through each item, ensure they have proper type
        arrays.forEach((a) => {
            if (!u8a$1(a))
                throw new Error('Uint8Array expected');
            r.set(a, pad);
            pad += a.length;
        });
        return r;
    }
    // For runtime check if class implements interface
    class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    }
    const toStr = {}.toString;
    function checkOpts(defaults, opts) {
        if (opts !== undefined && toStr.call(opts) !== '[object Object]')
            throw new Error('Options should be object or undefined');
        const merged = Object.assign(defaults, opts);
        return merged;
    }
    function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
    }
    /**
     * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
     */
    function randomBytes$2(bytesLength = 32) {
        if (crypto$1 && typeof crypto$1.getRandomValues === 'function') {
            return crypto$1.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error('crypto.getRandomValues must be defined');
    }

    // HMAC (RFC 2104)
    class HMAC extends Hash {
        constructor(hash$1, _key) {
            super();
            this.finished = false;
            this.destroyed = false;
            hash(hash$1);
            const key = toBytes(_key);
            this.iHash = hash$1.create();
            if (typeof this.iHash.update !== 'function')
                throw new Error('Expected instance of class which extends utils.Hash');
            this.blockLen = this.iHash.blockLen;
            this.outputLen = this.iHash.outputLen;
            const blockLen = this.blockLen;
            const pad = new Uint8Array(blockLen);
            // blockLen can be bigger than outputLen
            pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
            for (let i = 0; i < pad.length; i++)
                pad[i] ^= 0x36;
            this.iHash.update(pad);
            // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
            this.oHash = hash$1.create();
            // Undo internal XOR && apply outer XOR
            for (let i = 0; i < pad.length; i++)
                pad[i] ^= 0x36 ^ 0x5c;
            this.oHash.update(pad);
            pad.fill(0);
        }
        update(buf) {
            exists(this);
            this.iHash.update(buf);
            return this;
        }
        digestInto(out) {
            exists(this);
            bytes(out, this.outputLen);
            this.finished = true;
            this.iHash.digestInto(out);
            this.oHash.update(out);
            this.oHash.digestInto(out);
            this.destroy();
        }
        digest() {
            const out = new Uint8Array(this.oHash.outputLen);
            this.digestInto(out);
            return out;
        }
        _cloneInto(to) {
            // Create new instance without calling constructor since key already in state and we don't know it.
            to || (to = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
            to = to;
            to.finished = finished;
            to.destroyed = destroyed;
            to.blockLen = blockLen;
            to.outputLen = outputLen;
            to.oHash = oHash._cloneInto(to.oHash);
            to.iHash = iHash._cloneInto(to.iHash);
            return to;
        }
        destroy() {
            this.destroyed = true;
            this.oHash.destroy();
            this.iHash.destroy();
        }
    }
    /**
     * HMAC: RFC2104 message authentication code.
     * @param hash - function that would be used e.g. sha256
     * @param key - message key
     * @param message - message data
     */
    const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    hmac.create = (hash, key) => new HMAC(hash, key);

    // Common prologue and epilogue for sync/async functions
    function pbkdf2Init(hash$1, _password, _salt, _opts) {
        hash(hash$1);
        const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
        const { c, dkLen, asyncTick } = opts;
        number(c);
        number(dkLen);
        number(asyncTick);
        if (c < 1)
            throw new Error('PBKDF2: iterations (c) should be >= 1');
        const password = toBytes(_password);
        const salt = toBytes(_salt);
        // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
        const DK = new Uint8Array(dkLen);
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        const PRF = hmac.create(hash$1, password);
        const PRFSalt = PRF._cloneInto().update(salt);
        return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
        PRF.destroy();
        PRFSalt.destroy();
        if (prfW)
            prfW.destroy();
        u.fill(0);
        return DK;
    }
    /**
     * PBKDF2-HMAC: RFC 2898 key derivation function
     * @param hash - hash function that would be used e.g. sha256
     * @param password - password from which a derived key is generated
     * @param salt - cryptographic salt
     * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
     */
    function pbkdf2$1(hash, password, salt, opts) {
        const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
        let prfW; // Working copy
        const arr = new Uint8Array(4);
        const view = createView(arr);
        const u = new Uint8Array(PRF.outputLen);
        // DK = T1 + T2 +  + Tdklen/hlen
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
            // Ti = F(Password, Salt, c, i)
            const Ti = DK.subarray(pos, pos + PRF.outputLen);
            view.setInt32(0, ti, false);
            // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
            // U1 = PRF(Password, Salt + INT_32_BE(i))
            (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
            Ti.set(u.subarray(0, Ti.length));
            for (let ui = 1; ui < c; ui++) {
                // Uc = PRF(Password, Uc1)
                PRF._cloneInto(prfW).update(u).digestInto(u);
                for (let i = 0; i < Ti.length; i++)
                    Ti[i] ^= u[i];
            }
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }

    // Polyfill for Safari 14
    function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === 'function')
            return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number((value >> _32n) & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
    }
    // Base SHA2 class (RFC 6234)
    class SHA2 extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = createView(this.buffer);
        }
        update(data) {
            exists(this);
            const { view, buffer, blockLen } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                // Fast path: we have at least one block in input, cast it to view and process
                if (take === blockLen) {
                    const dataView = createView(data);
                    for (; blockLen <= len - pos; pos += blockLen)
                        this.process(dataView, pos);
                    continue;
                }
                buffer.set(data.subarray(pos, pos + take), this.pos);
                this.pos += take;
                pos += take;
                if (this.pos === blockLen) {
                    this.process(view, 0);
                    this.pos = 0;
                }
            }
            this.length += data.length;
            this.roundClean();
            return this;
        }
        digestInto(out) {
            exists(this);
            output(out, this);
            this.finished = true;
            // Padding
            // We can avoid allocation of buffer for padding completely if it
            // was previously not allocated here. But it won't change performance.
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            // append the bit '1' to the message
            buffer[pos++] = 0b10000000;
            this.buffer.subarray(pos).fill(0);
            // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
            if (this.padOffset > blockLen - pos) {
                this.process(view, 0);
                pos = 0;
            }
            // Pad until full block byte with zeros
            for (let i = pos; i < blockLen; i++)
                buffer[i] = 0;
            // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
            // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
            // So we just write lowest 64 bits of that value.
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = createView(out);
            const len = this.outputLen;
            // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
            if (len % 4)
                throw new Error('_sha2: outputLen should be aligned to 32bit');
            const outLen = len / 4;
            const state = this.get();
            if (outLen > state.length)
                throw new Error('_sha2: outputLen bigger than state');
            for (let i = 0; i < outLen; i++)
                oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
        }
        _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen)
                to.buffer.set(buffer);
            return to;
        }
    }

    // SHA2-256 need to try 2^128 hashes to execute birthday attack.
    // BTC network is doing 2^67 hashes/sec as per early 2023.
    // Choice: a ? b : c
    const Chi = (a, b, c) => (a & b) ^ (~a & c);
    // Majority function, true if any two inpust is true
    const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
    // Round constants:
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
    // prettier-ignore
    const SHA256_K = /* @__PURE__ */ new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]);
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // prettier-ignore
    const IV = /* @__PURE__ */ new Uint32Array([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]);
    // Temporary buffer, not used to store anything between runs
    // Named this way because it matches specification.
    const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    class SHA256 extends SHA2 {
        constructor() {
            super(64, 32, 8, false);
            // We cannot use array here since array allows indexing by variable
            // which means optimizer/compiler cannot use registers.
            this.A = IV[0] | 0;
            this.B = IV[1] | 0;
            this.C = IV[2] | 0;
            this.D = IV[3] | 0;
            this.E = IV[4] | 0;
            this.F = IV[5] | 0;
            this.G = IV[6] | 0;
            this.H = IV[7] | 0;
        }
        get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4)
                SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
                const W15 = SHA256_W[i - 15];
                const W2 = SHA256_W[i - 2];
                const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
                const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
                SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            // Compression function main loop, 64 rounds
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
                const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
                const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
                const T2 = (sigma0 + Maj(A, B, C)) | 0;
                H = G;
                G = F;
                F = E;
                E = (D + T1) | 0;
                D = C;
                C = B;
                B = A;
                A = (T1 + T2) | 0;
            }
            // Add the compressed chunk to the current hash value
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
            SHA256_W.fill(0);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
        }
    }
    /**
     * SHA2-256 hash function
     * @param message - data that would be hashed
     */
    const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

    const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    const _32n = /* @__PURE__ */ BigInt(32);
    // We are not using BigUint64Array, because they are extremely slow as per 2022
    function fromBig(n, le = false) {
        if (le)
            return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
        return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
    }
    const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    // for Shift in [0, 32)
    const shrSH = (h, _l, s) => h >>> s;
    const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in [1, 32)
    const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    // Right rotate for shift===32 (just swaps l&h)
    const rotr32H = (_h, l) => l;
    const rotr32L = (h, _l) => h;
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    // JS uses 32-bit signed integers for bitwise operations which means we cannot
    // simple take carry out of low bit sum by shift, we need to use division.
    function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
    }
    // Addition with more than 2 elements
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    // prettier-ignore
    const u64 = {
        fromBig, split, toBig,
        shrSH, shrSL,
        rotrSH, rotrSL, rotrBH, rotrBL,
        rotr32H, rotr32L,
        rotlSH, rotlSL, rotlBH, rotlBL,
        add, add3L, add3H, add4L, add4H, add5H, add5L,
    };

    // Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
    // prettier-ignore
    const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
        '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
        '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
        '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
        '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
        '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
        '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
        '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
        '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
        '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
    ].map(n => BigInt(n))))();
    // Temporary buffer, not used to store anything between runs
    const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    class SHA512 extends SHA2 {
        constructor() {
            super(128, 64, 16, false);
            // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
            // Also looks cleaner and easier to verify with spec.
            // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x6a09e667 | 0;
            this.Al = 0xf3bcc908 | 0;
            this.Bh = 0xbb67ae85 | 0;
            this.Bl = 0x84caa73b | 0;
            this.Ch = 0x3c6ef372 | 0;
            this.Cl = 0xfe94f82b | 0;
            this.Dh = 0xa54ff53a | 0;
            this.Dl = 0x5f1d36f1 | 0;
            this.Eh = 0x510e527f | 0;
            this.El = 0xade682d1 | 0;
            this.Fh = 0x9b05688c | 0;
            this.Fl = 0x2b3e6c1f | 0;
            this.Gh = 0x1f83d9ab | 0;
            this.Gl = 0xfb41bd6b | 0;
            this.Hh = 0x5be0cd19 | 0;
            this.Hl = 0x137e2179 | 0;
        }
        // prettier-ignore
        get() {
            const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
            this.Ah = Ah | 0;
            this.Al = Al | 0;
            this.Bh = Bh | 0;
            this.Bl = Bl | 0;
            this.Ch = Ch | 0;
            this.Cl = Cl | 0;
            this.Dh = Dh | 0;
            this.Dl = Dl | 0;
            this.Eh = Eh | 0;
            this.El = El | 0;
            this.Fh = Fh | 0;
            this.Fl = Fl | 0;
            this.Gh = Gh | 0;
            this.Gl = Gl | 0;
            this.Hh = Hh | 0;
            this.Hl = Hl | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4) {
                SHA512_W_H[i] = view.getUint32(offset);
                SHA512_W_L[i] = view.getUint32((offset += 4));
            }
            for (let i = 16; i < 80; i++) {
                // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
                const W15h = SHA512_W_H[i - 15] | 0;
                const W15l = SHA512_W_L[i - 15] | 0;
                const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
                const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
                // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
                const W2h = SHA512_W_H[i - 2] | 0;
                const W2l = SHA512_W_L[i - 2] | 0;
                const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
                const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
                // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
                const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
                const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
                SHA512_W_H[i] = SUMh | 0;
                SHA512_W_L[i] = SUMl | 0;
            }
            let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            // Compression function main loop, 80 rounds
            for (let i = 0; i < 80; i++) {
                // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
                const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
                const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
                //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const CHIh = (Eh & Fh) ^ (~Eh & Gh);
                const CHIl = (El & Fl) ^ (~El & Gl);
                // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
                // prettier-ignore
                const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
                const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
                const T1l = T1ll | 0;
                // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
                const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
                const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
                const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
                const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
                Hh = Gh | 0;
                Hl = Gl | 0;
                Gh = Fh | 0;
                Gl = Fl | 0;
                Fh = Eh | 0;
                Fl = El | 0;
                ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
                Dh = Ch | 0;
                Dl = Cl | 0;
                Ch = Bh | 0;
                Cl = Bl | 0;
                Bh = Ah | 0;
                Bl = Al | 0;
                const All = u64.add3L(T1l, sigma0l, MAJl);
                Ah = u64.add3H(All, T1h, sigma0h, MAJh);
                Al = All | 0;
            }
            // Add the compressed chunk to the current hash value
            ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
            ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
            ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
            ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
            ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
            ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
            ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
            ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
            this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
            SHA512_W_H.fill(0);
            SHA512_W_L.fill(0);
        }
        destroy() {
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
    }
    const sha512$1 = /* @__PURE__ */ wrapConstructor(() => new SHA512());

    /* Browser Crypto Shims */
    function getGlobal$1() {
        if (typeof self !== 'undefined') {
            return self;
        }
        if (typeof window !== 'undefined') {
            return window;
        }
        if (typeof global !== 'undefined') {
            return global;
        }
        throw new Error('unable to locate global object');
    }
    const anyGlobal = getGlobal$1();
    const crypto = anyGlobal.crypto || anyGlobal.msCrypto;
    function createHash(algo) {
        switch (algo) {
            case 'sha256':
                return sha256$1.create();
            case 'sha512':
                return sha512$1.create();
        }
        assertArgument(false, 'invalid hashing algorithm name', 'algorithm', algo);
    }
    function createHmac(_algo, key) {
        const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
        assertArgument(algo != null, 'invalid hmac algorithm', 'algorithm', _algo);
        return hmac.create(algo, key);
    }
    function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
        const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
        assertArgument(algo != null, 'invalid pbkdf2 algorithm', 'algorithm', _algo);
        return pbkdf2$1(algo, password, salt, { c: iterations, dkLen: keylen });
    }
    function randomBytes$1(length) {
        assert$1(crypto != null, 'platform does not support secure random numbers', 'UNSUPPORTED_OPERATION', {
            operation: 'randomBytes',
        });
        assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, 'invalid length', 'length', length);
        const result = new Uint8Array(length);
        crypto.getRandomValues(result);
        return result;
    }

    /**
     * An **HMAC** enables verification that a given key was used to authenticate a payload.
     *
     * @see {@link https://en.wikipedia.org/wiki/HMAC | HMAC - Wikipedia}
     */
    let locked$4 = false;
    const _computeHmac = function (algorithm, key, data) {
        return createHmac(algorithm, key).update(data).digest();
    };
    let __computeHmac = _computeHmac;
    /**
     * Return the HMAC for `data` using the `key` key with the underlying `algo` used for compression.
     *
     * @category Crypto
     * @example
     *
     * ```js
     * key = id('some-secret');
     *
     * // Compute the HMAC
     * computeHmac('sha256', key, '0x1337');
     *
     * // To compute the HMAC of UTF-8 data, the data must be
     * // converted to UTF-8 bytes
     * computeHmac('sha256', key, toUtf8Bytes('Hello World'));
     * ```
     *
     * @param {'sha256' | 'sha512'} algorithm - The algorithm to use for compression.
     * @param {BytesLike} _key - The key to use for the HMAC.
     * @param {BytesLike} _data - The data to authenticate.
     * @returns {string} The HMAC of the data.
     */
    function computeHmac(algorithm, _key, _data) {
        const key = getBytes(_key, 'key');
        const data = getBytes(_data, 'data');
        return hexlify(__computeHmac(algorithm, key, data));
    }
    computeHmac._ = _computeHmac;
    computeHmac.lock = function () {
        locked$4 = true;
    };
    computeHmac.register = function (func) {
        if (locked$4) {
            throw new Error('computeHmac is locked');
        }
        __computeHmac = func;
    };
    Object.freeze(computeHmac);

    // SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
    // It's called a sponge function.
    // Various per round constants calculations
    const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    const _0n$6 = /* @__PURE__ */ BigInt(0);
    const _1n$6 = /* @__PURE__ */ BigInt(1);
    const _2n$4 = /* @__PURE__ */ BigInt(2);
    const _7n$1 = /* @__PURE__ */ BigInt(7);
    const _256n = /* @__PURE__ */ BigInt(256);
    const _0x71n = /* @__PURE__ */ BigInt(0x71);
    for (let round = 0, R = _1n$6, x = 1, y = 0; round < 24; round++) {
        // Pi
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        // Rotational
        SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
        // Iota
        let t = _0n$6;
        for (let j = 0; j < 7; j++) {
            R = ((R << _1n$6) ^ ((R >> _7n$1) * _0x71n)) % _256n;
            if (R & _2n$4)
                t ^= _1n$6 << ((_1n$6 << /* @__PURE__ */ BigInt(j)) - _1n$6);
        }
        _SHA3_IOTA.push(t);
    }
    const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    // Left rotation (without 0, 32, 64)
    const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
    const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
    // Same as keccakf1600, but allows to skip some rounds
    function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
        for (let round = 24 - rounds; round < 24; round++) {
            // Theta 
            for (let x = 0; x < 10; x++)
                B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
                const idx1 = (x + 8) % 10;
                const idx0 = (x + 2) % 10;
                const B0 = B[idx0];
                const B1 = B[idx0 + 1];
                const Th = rotlH(B0, B1, 1) ^ B[idx1];
                const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                for (let y = 0; y < 50; y += 10) {
                    s[x + y] ^= Th;
                    s[x + y + 1] ^= Tl;
                }
            }
            // Rho () and Pi ()
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
                const shift = SHA3_ROTL[t];
                const Th = rotlH(curH, curL, shift);
                const Tl = rotlL(curH, curL, shift);
                const PI = SHA3_PI[t];
                curH = s[PI];
                curL = s[PI + 1];
                s[PI] = Th;
                s[PI + 1] = Tl;
            }
            // Chi ()
            for (let y = 0; y < 50; y += 10) {
                for (let x = 0; x < 10; x++)
                    B[x] = s[y + x];
                for (let x = 0; x < 10; x++)
                    s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            // Iota ()
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
    }
    class Keccak extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            // Can be passed from user as dkLen
            number(outputLen);
            // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
            if (0 >= this.blockLen || this.blockLen >= 200)
                throw new Error('Sha3 supports only keccak-f1600 function');
            this.state = new Uint8Array(200);
            this.state32 = u32(this.state);
        }
        keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
        }
        update(data) {
            exists(this);
            const { blockLen, state } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                for (let i = 0; i < take; i++)
                    state[this.pos++] ^= data[pos++];
                if (this.pos === blockLen)
                    this.keccak();
            }
            return this;
        }
        finish() {
            if (this.finished)
                return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            // Do the padding
            state[pos] ^= suffix;
            if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
                this.keccak();
            state[blockLen - 1] ^= 0x80;
            this.keccak();
        }
        writeInto(out) {
            exists(this, false);
            bytes(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len;) {
                if (this.posOut >= blockLen)
                    this.keccak();
                const take = Math.min(blockLen - this.posOut, len - pos);
                out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
                this.posOut += take;
                pos += take;
            }
            return out;
        }
        xofInto(out) {
            // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
            if (!this.enableXOF)
                throw new Error('XOF is not possible for this instance');
            return this.writeInto(out);
        }
        xof(bytes) {
            number(bytes);
            return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
            output(out, this);
            if (this.finished)
                throw new Error('digest() was already called');
            this.writeInto(out);
            this.destroy();
            return out;
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
            this.destroyed = true;
            this.state.fill(0);
        }
        _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            // Suffix can change in cSHAKE
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
        }
    }
    const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    /**
     * keccak-256 hash function. Different from SHA3-256.
     * @param message - that would be hashed
     */
    const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);

    /**
     * Cryptographic hashing functions
     */
    let locked$3 = false;
    const _keccak256 = function (data) {
        return keccak_256(data);
    };
    let __keccak256 = _keccak256;
    /**
     * Compute the cryptographic KECCAK256 hash of `data`.
     *
     * The `data` **must** be a data representation, to compute the hash of UTF-8 data use the [**id**}(../functions/id)
     * function.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * keccak256('0x');
     *
     * keccak256('0x1337');
     *
     * keccak256(new Uint8Array([0x13, 0x37]));
     *
     * // Strings are assumed to be DataHexString, otherwise it will
     * // throw. To hash UTF-8 data, see the note above.
     * keccak256('Hello World');
     * ```
     *
     * @param {BytesLike} _data - The data to hash.
     * @returns DataHexstring
     * @returns {string} The hash of the data.
     */
    function keccak256(_data) {
        const data = getBytes(_data, 'data');
        return hexlify(__keccak256(data));
    }
    keccak256._ = _keccak256;
    keccak256.lock = function () {
        locked$3 = true;
    };
    keccak256.register = function (func) {
        if (locked$3) {
            throw new TypeError('keccak256 is locked');
        }
        __keccak256 = func;
    };
    Object.freeze(keccak256);

    // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
    // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
    const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
    const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
    let idxL = [Id];
    let idxR = [Pi];
    for (let i = 0; i < 4; i++)
        for (let j of [idxL, idxR])
            j.push(j[i].map((k) => Rho[k]));
    const shifts = /* @__PURE__ */ [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
    ].map((i) => new Uint8Array(i));
    const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    const Kl = /* @__PURE__ */ new Uint32Array([
        0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
    ]);
    const Kr = /* @__PURE__ */ new Uint32Array([
        0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
    ]);
    // The rotate left (circular left shift) operation for uint32
    const rotl$1 = (word, shift) => (word << shift) | (word >>> (32 - shift));
    // It's called f() in spec.
    function f(group, x, y, z) {
        if (group === 0)
            return x ^ y ^ z;
        else if (group === 1)
            return (x & y) | (~x & z);
        else if (group === 2)
            return (x | ~y) ^ z;
        else if (group === 3)
            return (x & z) | (y & ~z);
        else
            return x ^ (y | ~z);
    }
    // Temporary buffer, not used to store anything between runs
    const BUF = /* @__PURE__ */ new Uint32Array(16);
    class RIPEMD160 extends SHA2 {
        constructor() {
            super(64, 20, 8, true);
            this.h0 = 0x67452301 | 0;
            this.h1 = 0xefcdab89 | 0;
            this.h2 = 0x98badcfe | 0;
            this.h3 = 0x10325476 | 0;
            this.h4 = 0xc3d2e1f0 | 0;
        }
        get() {
            const { h0, h1, h2, h3, h4 } = this;
            return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
            this.h0 = h0 | 0;
            this.h1 = h1 | 0;
            this.h2 = h2 | 0;
            this.h3 = h3 | 0;
            this.h4 = h4 | 0;
        }
        process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4)
                BUF[i] = view.getUint32(offset, true);
            // prettier-ignore
            let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
            // Instead of iterating 0 to 80, we split it into 5 groups
            // And use the groups in constants, functions, etc. Much simpler
            for (let group = 0; group < 5; group++) {
                const rGroup = 4 - group;
                const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
                const rl = idxL[group], rr = idxR[group]; // prettier-ignore
                const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
                for (let i = 0; i < 16; i++) {
                    const tl = (rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                    al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
                }
                // 2 loops are 10% faster
                for (let i = 0; i < 16; i++) {
                    const tr = (rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                    ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
                }
            }
            // Add the compressed chunk to the current hash value
            this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
        }
        roundClean() {
            BUF.fill(0);
        }
        destroy() {
            this.destroyed = true;
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0);
        }
    }
    /**
     * RIPEMD-160 - a hash function from 1990s.
     * @param message - msg that would be hashed
     */
    const ripemd160$1 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());

    let locked$2 = false;
    const _ripemd160 = function (data) {
        return ripemd160$1(data);
    };
    let __ripemd160 = _ripemd160;
    /**
     * Compute the cryptographic RIPEMD-160 hash of `data`.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * ripemd160('0x');
     *
     * ripemd160('0x1337');
     *
     * ripemd160(new Uint8Array([0x13, 0x37]));
     * ```
     *
     * @param {BytesLike} _data - The data to hash.
     * @returns DataHexstring
     * @returns {string} The hash of the data.
     */
    function ripemd160(_data) {
        const data = getBytes(_data, 'data');
        return hexlify(__ripemd160(data));
    }
    ripemd160._ = _ripemd160;
    ripemd160.lock = function () {
        locked$2 = true;
    };
    ripemd160.register = function (func) {
        if (locked$2) {
            throw new TypeError('ripemd160 is locked');
        }
        __ripemd160 = func;
    };
    Object.freeze(ripemd160);

    /**
     * A **Password-Based Key-Derivation Function** is designed to create a sequence of bytes suitible as a **key** from a
     * human-rememberable password.
     */
    let locked$1 = false;
    const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
        return pbkdf2Sync(password, salt, iterations, keylen, algo);
    };
    let __pbkdf2 = _pbkdf2;
    /**
     * Return the [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) for `keylen` bytes for `password` using the `salt` and
     * using `iterations` of `algo`.
     *
     * This PBKDF is outdated and should not be used in new projects, but is required to decrypt older files.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * // The password must be converted to bytes, and it is generally
     * // best practices to ensure the string has been normalized. Many
     * // formats explicitly indicate the normalization form to use.
     * password = 'hello';
     * passwordBytes = toUtf8Bytes(password, 'NFKC');
     *
     * salt = id('some-salt');
     *
     * // Compute the PBKDF2
     * pbkdf2(passwordBytes, salt, 1024, 16, 'sha256');
     * ```
     *
     * @param {BytesLike} _password - The password to use.
     * @param {BytesLike} _salt - The salt to use.
     * @param {number} iterations - The number of iterations to use.
     * @param {number} keylen - The length of the key to generate.
     * @param {'sha256' | 'sha512'} algo - The algorithm to use.
     * @returns {string} The key derived from the password.
     */
    function pbkdf2(_password, _salt, iterations, keylen, algo) {
        const password = getBytes(_password, 'password');
        const salt = getBytes(_salt, 'salt');
        return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
    }
    pbkdf2._ = _pbkdf2;
    pbkdf2.lock = function () {
        locked$1 = true;
    };
    pbkdf2.register = function (func) {
        if (locked$1) {
            throw new Error('pbkdf2 is locked');
        }
        __pbkdf2 = func;
    };
    Object.freeze(pbkdf2);

    /**
     * A **Cryptographically Secure Random Value** is one that has been generated with additional care take to prevent
     * side-channels from allowing others to detect it and prevent others from through coincidence generate the same
     * values.
     */
    let locked = false;
    const _randomBytes = function (length) {
        return new Uint8Array(randomBytes$1(length));
    };
    let __randomBytes = _randomBytes;
    /**
     * Return `length` bytes of cryptographically secure random data.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * randomBytes(8);
     * ```
     *
     * @param {number} length - The number of bytes to generate.
     * @returns {Uint8Array} The random bytes.
     */
    function randomBytes(length) {
        return __randomBytes(length);
    }
    randomBytes._ = _randomBytes;
    randomBytes.lock = function () {
        locked = true;
    };
    randomBytes.register = function (func) {
        if (locked) {
            throw new Error('randomBytes is locked');
        }
        __randomBytes = func;
    };
    Object.freeze(randomBytes);

    // RFC 7914 Scrypt KDF
    // Left rotate for uint32
    const rotl = (a, b) => (a << b) | (a >>> (32 - b));
    // The main Scrypt loop: uses Salsa extensively.
    // Six versions of the function were tried, this is the fastest one.
    // prettier-ignore
    function XorAndSalsa(prev, pi, input, ii, out, oi) {
        // Based on https://cr.yp.to/salsa20.html
        // Xor blocks
        let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
        let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
        let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
        let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
        let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
        let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
        let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
        let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
        // Save state to temporary variables (salsa)
        let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
        // Main loop (salsa)
        for (let i = 0; i < 8; i += 2) {
            x04 ^= rotl(x00 + x12 | 0, 7);
            x08 ^= rotl(x04 + x00 | 0, 9);
            x12 ^= rotl(x08 + x04 | 0, 13);
            x00 ^= rotl(x12 + x08 | 0, 18);
            x09 ^= rotl(x05 + x01 | 0, 7);
            x13 ^= rotl(x09 + x05 | 0, 9);
            x01 ^= rotl(x13 + x09 | 0, 13);
            x05 ^= rotl(x01 + x13 | 0, 18);
            x14 ^= rotl(x10 + x06 | 0, 7);
            x02 ^= rotl(x14 + x10 | 0, 9);
            x06 ^= rotl(x02 + x14 | 0, 13);
            x10 ^= rotl(x06 + x02 | 0, 18);
            x03 ^= rotl(x15 + x11 | 0, 7);
            x07 ^= rotl(x03 + x15 | 0, 9);
            x11 ^= rotl(x07 + x03 | 0, 13);
            x15 ^= rotl(x11 + x07 | 0, 18);
            x01 ^= rotl(x00 + x03 | 0, 7);
            x02 ^= rotl(x01 + x00 | 0, 9);
            x03 ^= rotl(x02 + x01 | 0, 13);
            x00 ^= rotl(x03 + x02 | 0, 18);
            x06 ^= rotl(x05 + x04 | 0, 7);
            x07 ^= rotl(x06 + x05 | 0, 9);
            x04 ^= rotl(x07 + x06 | 0, 13);
            x05 ^= rotl(x04 + x07 | 0, 18);
            x11 ^= rotl(x10 + x09 | 0, 7);
            x08 ^= rotl(x11 + x10 | 0, 9);
            x09 ^= rotl(x08 + x11 | 0, 13);
            x10 ^= rotl(x09 + x08 | 0, 18);
            x12 ^= rotl(x15 + x14 | 0, 7);
            x13 ^= rotl(x12 + x15 | 0, 9);
            x14 ^= rotl(x13 + x12 | 0, 13);
            x15 ^= rotl(x14 + x13 | 0, 18);
        }
        // Write output (salsa)
        out[oi++] = (y00 + x00) | 0;
        out[oi++] = (y01 + x01) | 0;
        out[oi++] = (y02 + x02) | 0;
        out[oi++] = (y03 + x03) | 0;
        out[oi++] = (y04 + x04) | 0;
        out[oi++] = (y05 + x05) | 0;
        out[oi++] = (y06 + x06) | 0;
        out[oi++] = (y07 + x07) | 0;
        out[oi++] = (y08 + x08) | 0;
        out[oi++] = (y09 + x09) | 0;
        out[oi++] = (y10 + x10) | 0;
        out[oi++] = (y11 + x11) | 0;
        out[oi++] = (y12 + x12) | 0;
        out[oi++] = (y13 + x13) | 0;
        out[oi++] = (y14 + x14) | 0;
        out[oi++] = (y15 + x15) | 0;
    }
    function BlockMix(input, ii, out, oi, r) {
        // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
        let head = oi + 0;
        let tail = oi + 16 * r;
        for (let i = 0; i < 16; i++)
            out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
        for (let i = 0; i < r; i++, head += 16, ii += 16) {
            // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
            XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
            if (i > 0)
                tail += 16; // First iteration overwrites tmp value in tail
            XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
        }
    }
    // Common prologue and epilogue for sync/async functions
    function scryptInit(password, salt, _opts) {
        // Maxmem - 1GB+1KB by default
        const opts = checkOpts({
            dkLen: 32,
            asyncTick: 10,
            maxmem: 1024 ** 3 + 1024,
        }, _opts);
        const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
        number(N);
        number(r);
        number(p);
        number(dkLen);
        number(asyncTick);
        number(maxmem);
        if (onProgress !== undefined && typeof onProgress !== 'function')
            throw new Error('progressCb should be function');
        const blockSize = 128 * r;
        const blockSize32 = blockSize / 4;
        if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
            // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
            // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
            throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
        }
        if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {
            throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
        }
        if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
            throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
        }
        const memUsed = blockSize * (N + p);
        if (memUsed > maxmem) {
            throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
        }
        // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
        // Since it has only one iteration there is no reason to use async variant
        const B = pbkdf2$1(sha256$1, password, salt, { c: 1, dkLen: blockSize * p });
        const B32 = u32(B);
        // Re-used between parallel iterations. Array(iterations) of B
        const V = u32(new Uint8Array(blockSize * N));
        const tmp = u32(new Uint8Array(blockSize));
        let blockMixCb = () => { };
        if (onProgress) {
            const totalBlockMix = 2 * N * p;
            // Invoke callback if progress changes from 10.01 to 10.02
            // Allows to draw smooth progress bar on up to 8K screen
            const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
            let blockMixCnt = 0;
            blockMixCb = () => {
                blockMixCnt++;
                if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
                    onProgress(blockMixCnt / totalBlockMix);
            };
        }
        return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
    }
    function scryptOutput(password, dkLen, B, V, tmp) {
        const res = pbkdf2$1(sha256$1, password, B, { c: 1, dkLen });
        B.fill(0);
        V.fill(0);
        tmp.fill(0);
        return res;
    }
    /**
     * Scrypt KDF from RFC 7914.
     * @param password - pass
     * @param salt - salt
     * @param opts - parameters
     * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
     * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
     * - `p` is parallelization factor (1 is common)
     * - `dkLen` is output key length in bytes e.g. 32.
     * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
     * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
     * - `onProgress` - callback function that would be executed for progress report
     * @returns Derived key
     */
    function scrypt$1(password, salt, opts) {
        const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
        for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++)
                V[i] = B32[Pi + i]; // V[0] = B[i]
            for (let i = 0, pos = 0; i < N - 1; i++) {
                BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
                blockMixCb();
            }
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
            blockMixCb();
            for (let i = 0; i < N; i++) {
                // First u32 of the last 64-byte block (u32 is LE)
                const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
                for (let k = 0; k < blockSize32; k++)
                    tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
                BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
                blockMixCb();
            }
        }
        return scryptOutput(password, dkLen, B, V, tmp);
    }
    /**
     * Scrypt KDF from RFC 7914.
     */
    async function scryptAsync(password, salt, opts) {
        const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
        for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++)
                V[i] = B32[Pi + i]; // V[0] = B[i]
            let pos = 0;
            await asyncLoop(N - 1, asyncTick, () => {
                BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
                blockMixCb();
            });
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
            blockMixCb();
            await asyncLoop(N, asyncTick, () => {
                // First u32 of the last 64-byte block (u32 is LE)
                const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
                for (let k = 0; k < blockSize32; k++)
                    tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
                BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
                blockMixCb();
            });
        }
        return scryptOutput(password, dkLen, B, V, tmp);
    }

    let lockedSync = false, lockedAsync = false;
    const _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {
        return await scryptAsync(passwd, salt, { N, r, p, dkLen, onProgress });
    };
    const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
        return scrypt$1(passwd, salt, { N, r, p, dkLen });
    };
    let __scryptAsync = _scryptAsync;
    let __scryptSync = _scryptSync;
    /**
     * The [scrypt PBKDF](https://en.wikipedia.org/wiki/Scrypt) uses a memory and cpu hard method of derivation to increase
     * the resource cost to brute-force a password for a given key.
     *
     * This means this algorithm is intentionally slow, and can be tuned to become slower. As computation and memory speed
     * improve over time, increasing the difficulty maintains the cost of an attacker.
     *
     * For example, if a target time of 5 seconds is used, a legitimate user which knows their password requires only 5
     * seconds to unlock their account. A 6 character password has 68 billion possibilities, which would require an attacker
     * to invest over 10,000 years of CPU time. This is of course a crude example (as password generally aren't random), but
     * demonstrates to value of imposing large costs to decryption.
     *
     * For this reason, if building a UI which involved decrypting or encrypting datsa using scrypt, it is recommended to
     * use a [**ProgressCallback**](../types-aliases/ProgressCallback) (as event short periods can seem lik an eternity if
     * the UI freezes). Including the phrase //"decrypting"// in the UI can also help, assuring the user their waiting is
     * for a good reason.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * // The password must be converted to bytes, and it is generally
     * // best practices to ensure the string has been normalized. Many
     * // formats explicitly indicate the normalization form to use.
     * password = 'hello';
     * passwordBytes = toUtf8Bytes(password, 'NFKC');
     *
     * salt = id('some-salt');
     *
     * // Compute the scrypt
     * scrypt(passwordBytes, salt, 1024, 8, 1, 16);
     * ```
     *
     * @param {BytesLike} _passwd - The password to use.
     * @param {BytesLike} _salt - The salt to use.
     * @param {number} N - The CPU/memory cost parameter.
     * @param {number} r - The block size parameter.
     * @param {number} p - The parallelization parameter.
     * @param {number} dkLen - The length of the key to generate.
     * @param {ProgressCallback} [progress] - A callback to update the progress.
     * @returns {Promise<string>} The key derived from the password.
     */
    async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
        const passwd = getBytes(_passwd, 'passwd');
        const salt = getBytes(_salt, 'salt');
        return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
    }
    scrypt._ = _scryptAsync;
    scrypt.lock = function () {
        lockedAsync = true;
    };
    scrypt.register = function (func) {
        if (lockedAsync) {
            throw new Error('scrypt is locked');
        }
        __scryptAsync = func;
    };
    Object.freeze(scrypt);
    /**
     * Provides a synchronous variant of {@link scrypt | **scrypt**}.
     *
     * This will completely lock up and freeze the UI in a browser and will prevent any event loop from progressing. For
     * this reason, it is preferred to use the [async variant](scrypt).
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * // The password must be converted to bytes, and it is generally
     * // best practices to ensure the string has been normalized. Many
     * // formats explicitly indicate the normalization form to use.
     * password = 'hello';
     * passwordBytes = toUtf8Bytes(password, 'NFKC');
     *
     * salt = id('some-salt');
     *
     * // Compute the scrypt
     * scryptSync(passwordBytes, salt, 1024, 8, 1, 16);
     * ```
     *
     * @param {BytesLike} _passwd - The password to use.
     * @param {BytesLike} _salt - The salt to use.
     * @param {number} N - The CPU/memory cost parameter.
     * @param {number} r - The block size parameter.
     * @param {number} p - The parallelization parameter.
     * @param {number} dkLen - The length of the key to generate.
     * @returns {string} The key derived from the password.
     */
    function scryptSync(_passwd, _salt, N, r, p, dkLen) {
        const passwd = getBytes(_passwd, 'passwd');
        const salt = getBytes(_salt, 'salt');
        return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
    }
    scryptSync._ = _scryptSync;
    scryptSync.lock = function () {
        lockedSync = true;
    };
    scryptSync.register = function (func) {
        if (lockedSync) {
            throw new Error('scryptSync is locked');
        }
        __scryptSync = func;
    };
    Object.freeze(scryptSync);

    const _sha256 = function (data) {
        return createHash('sha256').update(data).digest();
    };
    const _sha512 = function (data) {
        return createHash('sha512').update(data).digest();
    };
    let __sha256 = _sha256;
    let __sha512 = _sha512;
    let locked256 = false, locked512 = false;
    /**
     * Compute the cryptographic SHA2-256 hash of `data`.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * sha256('0x');
     *
     * sha256('0x1337');
     *
     * sha256(new Uint8Array([0x13, 0x37]));
     * ```
     *
     * @param {BytesLike} _data - The data to hash.
     * @returns {string} The hash of the data.
     */
    function sha256(_data) {
        const data = getBytes(_data, 'data');
        return hexlify(__sha256(data));
    }
    sha256._ = _sha256;
    sha256.lock = function () {
        locked256 = true;
    };
    sha256.register = function (func) {
        if (locked256) {
            throw new Error('sha256 is locked');
        }
        __sha256 = func;
    };
    Object.freeze(sha256);
    /**
     * Compute the cryptographic SHA2-512 hash of `data`.
     *
     * @category Crypto
     * @example
     *
     * ```ts
     * sha512('0x');
     *
     * sha512('0x1337');
     *
     * sha512(new Uint8Array([0x13, 0x37]));
     * ```
     *
     * @param {BytesLike} _data - The data to hash.
     * @returns {string} The hash of the data.
     */
    function sha512(_data) {
        const data = getBytes(_data, 'data');
        return hexlify(__sha512(data));
    }
    sha512._ = _sha512;
    sha512.lock = function () {
        locked512 = true;
    };
    sha512.register = function (func) {
        if (locked512) {
            throw new Error('sha512 is locked');
        }
        __sha512 = func;
    };
    Object.freeze(sha256);

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // 100 lines of code in the file are duplicated from noble-hashes (utils).
    // This is OK: `abstract` directory does not use noble-hashes.
    // User may opt-in into using different hashing library. This way, noble-hashes
    // won't be included into their bundle.
    const _0n$5 = BigInt(0);
    const _1n$5 = BigInt(1);
    const _2n$3 = BigInt(2);
    const u8a = (a) => a instanceof Uint8Array;
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
    /**
     * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
     */
    function bytesToHex(bytes) {
        if (!u8a(bytes))
            throw new Error('Uint8Array expected');
        // pre-caching improves the speed 6x
        let hex = '';
        for (let i = 0; i < bytes.length; i++) {
            hex += hexes[bytes[i]];
        }
        return hex;
    }
    function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        // Big Endian
        return BigInt(hex === '' ? '0' : `0x${hex}`);
    }
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
        if (typeof hex !== 'string')
            throw new Error('hex string expected, got ' + typeof hex);
        const len = hex.length;
        if (len % 2)
            throw new Error('padded hex string expected, got unpadded hex of length ' + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new Error('Invalid byte sequence');
            array[i] = byte;
        }
        return array;
    }
    // BE: Big Endian, LE: Little Endian
    function bytesToNumberBE(bytes) {
        return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
        if (!u8a(bytes))
            throw new Error('Uint8Array expected');
        return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
        return hexToBytes(n.toString(16).padStart(len * 2, '0'));
    }
    function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
    }
    // Unpadded, rarely used
    function numberToVarBytesBE(n) {
        return hexToBytes(numberToHexUnpadded(n));
    }
    /**
     * Takes hex string or Uint8Array, converts to Uint8Array.
     * Validates output length.
     * Will throw error for other types.
     * @param title descriptive title for an error e.g. 'private key'
     * @param hex hex string or Uint8Array
     * @param expectedLength optional, will compare to result array's length
     * @returns
     */
    function ensureBytes(title, hex, expectedLength) {
        let res;
        if (typeof hex === 'string') {
            try {
                res = hexToBytes(hex);
            }
            catch (e) {
                throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
            }
        }
        else if (u8a(hex)) {
            // Uint8Array.from() instead of hash.slice() because node.js Buffer
            // is instance of Uint8Array, and its slice() creates **mutable** copy
            res = Uint8Array.from(hex);
        }
        else {
            throw new Error(`${title} must be hex string or Uint8Array`);
        }
        const len = res.length;
        if (typeof expectedLength === 'number' && len !== expectedLength)
            throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
        return res;
    }
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0; // walk through each item, ensure they have proper type
        arrays.forEach((a) => {
            if (!u8a(a))
                throw new Error('Uint8Array expected');
            r.set(a, pad);
            pad += a.length;
        });
        return r;
    }
    function equalBytes(b1, b2) {
        // We don't care about timing attacks here
        if (b1.length !== b2.length)
            return false;
        for (let i = 0; i < b1.length; i++)
            if (b1[i] !== b2[i])
                return false;
        return true;
    }
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    // Bit operations
    /**
     * Calculates amount of bits in a bigint.
     * Same as `n.toString(2).length`
     */
    function bitLen(n) {
        let len;
        for (len = 0; n > _0n$5; n >>= _1n$5, len += 1)
            ;
        return len;
    }
    /**
     * Gets single bit at position.
     * NOTE: first bit position is 0 (same as arrays)
     * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
     */
    function bitGet(n, pos) {
        return (n >> BigInt(pos)) & _1n$5;
    }
    /**
     * Sets single bit at position.
     */
    const bitSet = (n, pos, value) => {
        return n | ((value ? _1n$5 : _0n$5) << BigInt(pos));
    };
    /**
     * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
     * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
     */
    const bitMask = (n) => (_2n$3 << BigInt(n - 1)) - _1n$5;
    // DRBG
    const u8n = (data) => new Uint8Array(data); // creates Uint8Array
    const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
    /**
     * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
     * @returns function that will call DRBG until 2nd arg returns something meaningful
     * @example
     *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
     *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
     */
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== 'number' || hashLen < 2)
            throw new Error('hashLen must be a number');
        if (typeof qByteLen !== 'number' || qByteLen < 2)
            throw new Error('qByteLen must be a number');
        if (typeof hmacFn !== 'function')
            throw new Error('hmacFn must be a function');
        // Step B, Step C: set hashLen to 8*ceil(hlen/8)
        let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
        let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
        let i = 0; // Iterations counter, will throw when over 1000
        const reset = () => {
            v.fill(1);
            k.fill(0);
            i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
        const reseed = (seed = u8n()) => {
            // HMAC-DRBG reseed() function. Steps D-G
            k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
            v = h(); // v = hmac(k || v)
            if (seed.length === 0)
                return;
            k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
            v = h(); // v = hmac(k || v)
        };
        const gen = () => {
            // HMAC-DRBG generate() function
            if (i++ >= 1000)
                throw new Error('drbg: tried 1000 values');
            let len = 0;
            const out = [];
            while (len < qByteLen) {
                v = h();
                const sl = v.slice();
                out.push(sl);
                len += v.length;
            }
            return concatBytes(...out);
        };
        const genUntil = (seed, pred) => {
            reset();
            reseed(seed); // Steps D-G
            let res = undefined; // Step H: grind until k is in [1..n-1]
            while (!(res = pred(gen())))
                reseed();
            reset();
            return res;
        };
        return genUntil;
    }
    // Validating curves and fields
    const validatorFns = {
        bigint: (val) => typeof val === 'bigint',
        function: (val) => typeof val === 'function',
        boolean: (val) => typeof val === 'boolean',
        string: (val) => typeof val === 'string',
        stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
    };
    // type Record<K extends string | number | symbol, T> = { [P in K]: T; }
    function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type, isOptional) => {
            const checkVal = validatorFns[type];
            if (typeof checkVal !== 'function')
                throw new Error(`Invalid validator "${type}", expected function`);
            const val = object[fieldName];
            if (isOptional && val === undefined)
                return;
            if (!checkVal(val, object)) {
                throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
            }
        };
        for (const [fieldName, type] of Object.entries(validators))
            checkField(fieldName, type, false);
        for (const [fieldName, type] of Object.entries(optValidators))
            checkField(fieldName, type, true);
        return object;
    }
    // validate type tests
    // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
    // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
    // // Should fail type-check
    // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
    // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
    // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
    // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

    var ut = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bitGet: bitGet,
        bitLen: bitLen,
        bitMask: bitMask,
        bitSet: bitSet,
        bytesToHex: bytesToHex,
        bytesToNumberBE: bytesToNumberBE,
        bytesToNumberLE: bytesToNumberLE,
        concatBytes: concatBytes,
        createHmacDrbg: createHmacDrbg,
        ensureBytes: ensureBytes,
        equalBytes: equalBytes,
        hexToBytes: hexToBytes,
        hexToNumber: hexToNumber,
        numberToBytesBE: numberToBytesBE,
        numberToBytesLE: numberToBytesLE,
        numberToHexUnpadded: numberToHexUnpadded,
        numberToVarBytesBE: numberToVarBytesBE,
        utf8ToBytes: utf8ToBytes,
        validateObject: validateObject
    });

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Utilities for modular arithmetics and finite fields
    // prettier-ignore
    const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$2 = BigInt(2), _3n$2 = BigInt(3);
    // prettier-ignore
    const _4n = BigInt(4), _5n$1 = BigInt(5), _8n = BigInt(8);
    // prettier-ignore
    BigInt(9); BigInt(16);
    // Calculates a modulo b
    function mod(a, b) {
        const result = a % b;
        return result >= _0n$4 ? result : b + result;
    }
    /**
     * Efficiently raise num to power and do modular division.
     * Unsafe in some contexts: uses ladder, so can expose bigint bits.
     * @example
     * pow(2n, 6n, 11n) // 64n % 11n == 9n
     */
    // TODO: use field version && remove
    function pow(num, power, modulo) {
        if (modulo <= _0n$4 || power < _0n$4)
            throw new Error('Expected power/modulo > 0');
        if (modulo === _1n$4)
            return _0n$4;
        let res = _1n$4;
        while (power > _0n$4) {
            if (power & _1n$4)
                res = (res * num) % modulo;
            num = (num * num) % modulo;
            power >>= _1n$4;
        }
        return res;
    }
    // Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
    function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n$4) {
            res *= res;
            res %= modulo;
        }
        return res;
    }
    // Inverses number over modulo
    function invert(number, modulo) {
        if (number === _0n$4 || modulo <= _0n$4) {
            throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
        // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
        let a = mod(number, modulo);
        let b = modulo;
        // prettier-ignore
        let x = _0n$4, u = _1n$4;
        while (a !== _0n$4) {
            // JIT applies optimization if those two lines follow each other
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            // prettier-ignore
            b = a, a = r, x = u, u = m;
        }
        const gcd = b;
        if (gcd !== _1n$4)
            throw new Error('invert: does not exist');
        return mod(x, modulo);
    }
    /**
     * Tonelli-Shanks square root search algorithm.
     * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
     * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
     * Will start an infinite loop if field order P is not prime.
     * @param P field order
     * @returns function that takes field Fp (created from P) and number n
     */
    function tonelliShanks(P) {
        // Legendre constant: used to calculate Legendre symbol (a | p),
        // which denotes the value of a^((p-1)/2) (mod p).
        // (a | p)  1    if a is a square (mod p)
        // (a | p)  -1   if a is not a square (mod p)
        // (a | p)  0    if a  0 (mod p)
        const legendreC = (P - _1n$4) / _2n$2;
        let Q, S, Z;
        // Step 1: By factoring out powers of 2 from p - 1,
        // find q and s such that p - 1 = q*(2^s) with q odd
        for (Q = P - _1n$4, S = 0; Q % _2n$2 === _0n$4; Q /= _2n$2, S++)
            ;
        // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
        for (Z = _2n$2; Z < P && pow(Z, legendreC, P) !== P - _1n$4; Z++)
            ;
        // Fast-path
        if (S === 1) {
            const p1div4 = (P + _1n$4) / _4n;
            return function tonelliFast(Fp, n) {
                const root = Fp.pow(n, p1div4);
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // Slow-path
        const Q1div2 = (Q + _1n$4) / _2n$2;
        return function tonelliSlow(Fp, n) {
            // Step 0: Check that n is indeed a square: (n | p) should not be  -1
            if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
                throw new Error('Cannot find square root');
            let r = S;
            // TODO: will fail at Fp2/etc
            let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
            let x = Fp.pow(n, Q1div2); // first guess at the square root
            let b = Fp.pow(n, Q); // first guess at the fudge factor
            while (!Fp.eql(b, Fp.ONE)) {
                if (Fp.eql(b, Fp.ZERO))
                    return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
                // Find m such b^(2^m)==1
                let m = 1;
                for (let t2 = Fp.sqr(b); m < r; m++) {
                    if (Fp.eql(t2, Fp.ONE))
                        break;
                    t2 = Fp.sqr(t2); // t2 *= t2
                }
                // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
                const ge = Fp.pow(g, _1n$4 << BigInt(r - m - 1)); // ge = 2^(r-m-1)
                g = Fp.sqr(ge); // g = ge * ge
                x = Fp.mul(x, ge); // x *= ge
                b = Fp.mul(b, g); // b *= g
                r = m;
            }
            return x;
        };
    }
    function FpSqrt(P) {
        // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
        // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
        // P  3 (mod 4)
        // n = n^((P+1)/4)
        if (P % _4n === _3n$2) {
            // Not all roots possible!
            // const ORDER =
            //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
            // const NUM = 72057594037927816n;
            const p1div4 = (P + _1n$4) / _4n;
            return function sqrt3mod4(Fp, n) {
                const root = Fp.pow(n, p1div4);
                // Throw if root**2 != n
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
        if (P % _8n === _5n$1) {
            const c1 = (P - _5n$1) / _8n;
            return function sqrt5mod8(Fp, n) {
                const n2 = Fp.mul(n, _2n$2);
                const v = Fp.pow(n2, c1);
                const nv = Fp.mul(n, v);
                const i = Fp.mul(Fp.mul(nv, _2n$2), v);
                const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
                if (!Fp.eql(Fp.sqr(root), n))
                    throw new Error('Cannot find square root');
                return root;
            };
        }
        // Other cases: Tonelli-Shanks algorithm
        return tonelliShanks(P);
    }
    // prettier-ignore
    const FIELD_FIELDS = [
        'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
        'eql', 'add', 'sub', 'mul', 'pow', 'div',
        'addN', 'subN', 'mulN', 'sqrN'
    ];
    function validateField(field) {
        const initial = {
            ORDER: 'bigint',
            MASK: 'bigint',
            BYTES: 'isSafeInteger',
            BITS: 'isSafeInteger',
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
            map[val] = 'function';
            return map;
        }, initial);
        return validateObject(field, opts);
    }
    // Generic field functions
    /**
     * Same as `pow` but for Fp: non-constant-time.
     * Unsafe in some contexts: uses ladder, so can expose bigint bits.
     */
    function FpPow(f, num, power) {
        // Should have same speed as pow for bigints
        // TODO: benchmark!
        if (power < _0n$4)
            throw new Error('Expected power > 0');
        if (power === _0n$4)
            return f.ONE;
        if (power === _1n$4)
            return num;
        let p = f.ONE;
        let d = num;
        while (power > _0n$4) {
            if (power & _1n$4)
                p = f.mul(p, d);
            d = f.sqr(d);
            power >>= _1n$4;
        }
        return p;
    }
    /**
     * Efficiently invert an array of Field elements.
     * `inv(0)` will return `undefined` here: make sure to throw an error.
     */
    function FpInvertBatch(f, nums) {
        const tmp = new Array(nums.length);
        // Walk from first to last, multiply them by each other MOD p
        const lastMultiplied = nums.reduce((acc, num, i) => {
            if (f.is0(num))
                return acc;
            tmp[i] = acc;
            return f.mul(acc, num);
        }, f.ONE);
        // Invert last element
        const inverted = f.inv(lastMultiplied);
        // Walk from last to first, multiply them by inverted each other MOD p
        nums.reduceRight((acc, num, i) => {
            if (f.is0(num))
                return acc;
            tmp[i] = f.mul(acc, tmp[i]);
            return f.mul(acc, num);
        }, inverted);
        return tmp;
    }
    // CURVE.n lengths
    function nLength(n, nBitLength) {
        // Bit size, byte size of CURVE.n
        const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
    }
    /**
     * Initializes a finite field over prime. **Non-primes are not supported.**
     * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
     * Major performance optimizations:
     * * a) denormalized operations like mulN instead of mul
     * * b) same object shape: never add or remove keys
     * * c) Object.freeze
     * @param ORDER prime positive bigint
     * @param bitLen how many bits the field consumes
     * @param isLE (def: false) if encoding / decoding should be in little-endian
     * @param redef optional faster redefinitions of sqrt and other methods
     */
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
        if (ORDER <= _0n$4)
            throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
        if (BYTES > 2048)
            throw new Error('Field lengths over 2048 bytes are not supported');
        const sqrtP = FpSqrt(ORDER);
        const f = Object.freeze({
            ORDER,
            BITS,
            BYTES,
            MASK: bitMask(BITS),
            ZERO: _0n$4,
            ONE: _1n$4,
            create: (num) => mod(num, ORDER),
            isValid: (num) => {
                if (typeof num !== 'bigint')
                    throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
                return _0n$4 <= num && num < ORDER; // 0 is valid element, but it's not invertible
            },
            is0: (num) => num === _0n$4,
            isOdd: (num) => (num & _1n$4) === _1n$4,
            neg: (num) => mod(-num, ORDER),
            eql: (lhs, rhs) => lhs === rhs,
            sqr: (num) => mod(num * num, ORDER),
            add: (lhs, rhs) => mod(lhs + rhs, ORDER),
            sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
            mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
            pow: (num, power) => FpPow(f, num, power),
            div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
            // Same as above, but doesn't normalize
            sqrN: (num) => num * num,
            addN: (lhs, rhs) => lhs + rhs,
            subN: (lhs, rhs) => lhs - rhs,
            mulN: (lhs, rhs) => lhs * rhs,
            inv: (num) => invert(num, ORDER),
            sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
            invertBatch: (lst) => FpInvertBatch(f, lst),
            // TODO: do we really need constant cmov?
            // We don't have const-time bigints anyway, so probably will be not very useful
            cmov: (a, b, c) => (c ? b : a),
            toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),
            fromBytes: (bytes) => {
                if (bytes.length !== BYTES)
                    throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
                return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
            },
        });
        return Object.freeze(f);
    }
    /**
     * Returns total number of bytes consumed by the field element.
     * For example, 32 bytes for usual 256-bit weierstrass curve.
     * @param fieldOrder number of field elements, usually CURVE.n
     * @returns byte length of field
     */
    function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== 'bigint')
            throw new Error('field order must be bigint');
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
    }
    /**
     * Returns minimal amount of bytes that can be safely reduced
     * by field order.
     * Should be 2^-128 for 128-bit curve such as P256.
     * @param fieldOrder number of field elements, usually CURVE.n
     * @returns byte length of target hash
     */
    function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
    }
    /**
     * "Constant-time" private key generation utility.
     * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
     * and convert them into private scalar, with the modulo bias being negligible.
     * Needs at least 48 bytes of input for 32-byte private key.
     * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
     * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
     * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
     * @param hash hash output from SHA3 or a similar function
     * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
     * @param isLE interpret hash bytes as LE num
     * @returns valid private scalar
     */
    function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
        if (len < 16 || len < minLen || len > 1024)
            throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
        const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
        // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
        const reduced = mod(num, fieldOrder - _1n$4) + _1n$4;
        return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
    }

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Abelian group utilities
    const _0n$3 = BigInt(0);
    const _1n$3 = BigInt(1);
    // Elliptic curve multiplication of Point by scalar. Fragile.
    // Scalars should always be less than curve order: this should be checked inside of a curve itself.
    // Creates precomputation tables for fast multiplication:
    // - private scalar is split by fixed size windows of W bits
    // - every window point is collected from window's table & added to accumulator
    // - since windows are different, same point inside tables won't be accessed more than once per calc
    // - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
    // - +1 window is neccessary for wNAF
    // - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
    // TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
    // windows to be in different memory locations
    function wNAF(c, bits) {
        const constTimeNegate = (condition, item) => {
            const neg = item.negate();
            return condition ? neg : item;
        };
        const opts = (W) => {
            const windows = Math.ceil(bits / W) + 1; // +1, because
            const windowSize = 2 ** (W - 1); // -1 because we skip zero
            return { windows, windowSize };
        };
        return {
            constTimeNegate,
            // non-const time multiplication ladder
            unsafeLadder(elm, n) {
                let p = c.ZERO;
                let d = elm;
                while (n > _0n$3) {
                    if (n & _1n$3)
                        p = p.add(d);
                    d = d.double();
                    n >>= _1n$3;
                }
                return p;
            },
            /**
             * Creates a wNAF precomputation window. Used for caching.
             * Default window size is set by `utils.precompute()` and is equal to 8.
             * Number of precomputed points depends on the curve size:
             * 2^(1) * (Math.ceil( / ) + 1), where:
             * -  is the window size
             * -  is the bitlength of the curve order.
             * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
             * @returns precomputed point tables flattened to a single array
             */
            precomputeWindow(elm, W) {
                const { windows, windowSize } = opts(W);
                const points = [];
                let p = elm;
                let base = p;
                for (let window = 0; window < windows; window++) {
                    base = p;
                    points.push(base);
                    // =1, because we skip zero
                    for (let i = 1; i < windowSize; i++) {
                        base = base.add(p);
                        points.push(base);
                    }
                    p = base.double();
                }
                return points;
            },
            /**
             * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
             * @param W window size
             * @param precomputes precomputed tables
             * @param n scalar (we don't check here, but should be less than curve order)
             * @returns real and fake (for const-time) points
             */
            wNAF(W, precomputes, n) {
                // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
                // But need to carefully remove other checks before wNAF. ORDER == bits here
                const { windows, windowSize } = opts(W);
                let p = c.ZERO;
                let f = c.BASE;
                const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
                const maxNumber = 2 ** W;
                const shiftBy = BigInt(W);
                for (let window = 0; window < windows; window++) {
                    const offset = window * windowSize;
                    // Extract W bits.
                    let wbits = Number(n & mask);
                    // Shift number by W bits.
                    n >>= shiftBy;
                    // If the bits are bigger than max size, we'll split those.
                    // +224 => 256 - 32
                    if (wbits > windowSize) {
                        wbits -= maxNumber;
                        n += _1n$3;
                    }
                    // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                    // there is negate now: it is possible that negated element from low value
                    // would be the same as high element, which will create carry into next window.
                    // It's not obvious how this can fail, but still worth investigating later.
                    // Check if we're onto Zero point.
                    // Add random point inside current window to f.
                    const offset1 = offset;
                    const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                    const cond1 = window % 2 !== 0;
                    const cond2 = wbits < 0;
                    if (wbits === 0) {
                        // The most important part for const-time getPublicKey
                        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                    }
                    else {
                        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                    }
                }
                // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
                // Even if the variable is still unused, there are some checks which will
                // throw an exception, so compiler needs to prove they won't happen, which is hard.
                // At this point there is a way to F be infinity-point even if p is not,
                // which makes it less const-time: around 1 bigint multiply.
                return { p, f };
            },
            wNAFCached(P, precomputesMap, n, transform) {
                // @ts-ignore
                const W = P._WINDOW_SIZE || 1;
                // Calculate precomputes on a first run, reuse them after
                let comp = precomputesMap.get(P);
                if (!comp) {
                    comp = this.precomputeWindow(P, W);
                    if (W !== 1) {
                        precomputesMap.set(P, transform(comp));
                    }
                }
                return this.wNAF(W, comp, n);
            },
        };
    }
    function validateBasic(curve) {
        validateField(curve.Fp);
        validateObject(curve, {
            n: 'bigint',
            h: 'bigint',
            Gx: 'field',
            Gy: 'field',
        }, {
            nBitLength: 'isSafeInteger',
            nByteLength: 'isSafeInteger',
        });
        // Set defaults
        return Object.freeze({
            ...nLength(curve.n, curve.nBitLength),
            ...curve,
            ...{ p: curve.Fp.ORDER },
        });
    }

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Short Weierstrass curve. The formula is: y = x + ax + b
    function validatePointOpts(curve) {
        const opts = validateBasic(curve);
        validateObject(opts, {
            a: 'field',
            b: 'field',
        }, {
            allowedPrivateKeyLengths: 'array',
            wrapPrivateKey: 'boolean',
            isTorsionFree: 'function',
            clearCofactor: 'function',
            allowInfinityPoint: 'boolean',
            fromBytes: 'function',
            toBytes: 'function',
        });
        const { endo, Fp, a } = opts;
        if (endo) {
            if (!Fp.eql(a, Fp.ZERO)) {
                throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
            }
            if (typeof endo !== 'object' ||
                typeof endo.beta !== 'bigint' ||
                typeof endo.splitScalar !== 'function') {
                throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
            }
        }
        return Object.freeze({ ...opts });
    }
    // ASN.1 DER encoding utilities
    const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    const DER = {
        // asn.1 DER encoding utils
        Err: class DERErr extends Error {
            constructor(m = '') {
                super(m);
            }
        },
        _parseInt(data) {
            const { Err: E } = DER;
            if (data.length < 2 || data[0] !== 0x02)
                throw new E('Invalid signature integer tag');
            const len = data[1];
            const res = data.subarray(2, len + 2);
            if (!len || res.length !== len)
                throw new E('Invalid signature integer: wrong length');
            // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
            // since we always use positive integers here. It must always be empty:
            // - add zero byte if exists
            // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
            if (res[0] & 0b10000000)
                throw new E('Invalid signature integer: negative');
            if (res[0] === 0x00 && !(res[1] & 0b10000000))
                throw new E('Invalid signature integer: unnecessary leading zero');
            return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
        },
        toSig(hex) {
            // parse DER signature
            const { Err: E } = DER;
            const data = typeof hex === 'string' ? h2b(hex) : hex;
            if (!(data instanceof Uint8Array))
                throw new Error('ui8a expected');
            let l = data.length;
            if (l < 2 || data[0] != 0x30)
                throw new E('Invalid signature tag');
            if (data[1] !== l - 2)
                throw new E('Invalid signature: incorrect length');
            const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
            const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
            if (rBytesLeft.length)
                throw new E('Invalid signature: left bytes after parsing');
            return { r, s };
        },
        hexFromSig(sig) {
            // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
            const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
            const h = (num) => {
                const hex = num.toString(16);
                return hex.length & 1 ? `0${hex}` : hex;
            };
            const s = slice(h(sig.s));
            const r = slice(h(sig.r));
            const shl = s.length / 2;
            const rhl = r.length / 2;
            const sl = h(shl);
            const rl = h(rhl);
            return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        },
    };
    // Be friendly to bad ECMAScript parsers by not using bigint literals
    // prettier-ignore
    const _0n$2 = BigInt(0), _1n$2 = BigInt(1); BigInt(2); const _3n$1 = BigInt(3); BigInt(4);
    function weierstrassPoints(opts) {
        const CURVE = validatePointOpts(opts);
        const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
        const toBytes = CURVE.toBytes ||
            ((_c, point, _isCompressed) => {
                const a = point.toAffine();
                return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
            });
        const fromBytes = CURVE.fromBytes ||
            ((bytes) => {
                // const head = bytes[0];
                const tail = bytes.subarray(1);
                // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            });
        /**
         * y = x + ax + b: Short weierstrass curve formula
         * @returns y
         */
        function weierstrassEquation(x) {
            const { a, b } = CURVE;
            const x2 = Fp.sqr(x); // x * x
            const x3 = Fp.mul(x2, x); // x2 * x
            return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
        }
        // Validate whether the passed curve params are valid.
        // We check if curve equation works for generator point.
        // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
        // ProjectivePoint class has not been initialized yet.
        if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
            throw new Error('bad generator point: equation left != right');
        // Valid group elements reside in range 1..n-1
        function isWithinCurveOrder(num) {
            return typeof num === 'bigint' && _0n$2 < num && num < CURVE.n;
        }
        function assertGE(num) {
            if (!isWithinCurveOrder(num))
                throw new Error('Expected valid bigint: 0 < bigint < curve.n');
        }
        // Validates if priv key is valid and converts it to bigint.
        // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
        function normPrivateKeyToScalar(key) {
            const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
            if (lengths && typeof key !== 'bigint') {
                if (key instanceof Uint8Array)
                    key = bytesToHex(key);
                // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
                if (typeof key !== 'string' || !lengths.includes(key.length))
                    throw new Error('Invalid key');
                key = key.padStart(nByteLength * 2, '0');
            }
            let num;
            try {
                num =
                    typeof key === 'bigint'
                        ? key
                        : bytesToNumberBE(ensureBytes('private key', key, nByteLength));
            }
            catch (error) {
                throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
            }
            if (wrapPrivateKey)
                num = mod(num, n); // disabled by default, enabled for BLS
            assertGE(num); // num in range [1..N-1]
            return num;
        }
        const pointPrecomputes = new Map();
        function assertPrjPoint(other) {
            if (!(other instanceof Point))
                throw new Error('ProjectivePoint expected');
        }
        /**
         * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
         * Default Point works in 2d / affine coordinates: (x, y)
         * We're doing calculations in projective, because its operations don't require costly inversion.
         */
        class Point {
            constructor(px, py, pz) {
                this.px = px;
                this.py = py;
                this.pz = pz;
                if (px == null || !Fp.isValid(px))
                    throw new Error('x required');
                if (py == null || !Fp.isValid(py))
                    throw new Error('y required');
                if (pz == null || !Fp.isValid(pz))
                    throw new Error('z required');
            }
            // Does not validate if the point is on-curve.
            // Use fromHex instead, or call assertValidity() later.
            static fromAffine(p) {
                const { x, y } = p || {};
                if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                    throw new Error('invalid affine point');
                if (p instanceof Point)
                    throw new Error('projective point not allowed');
                const is0 = (i) => Fp.eql(i, Fp.ZERO);
                // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
                if (is0(x) && is0(y))
                    return Point.ZERO;
                return new Point(x, y, Fp.ONE);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            /**
             * Takes a bunch of Projective Points but executes only one
             * inversion on all of them. Inversion is very slow operation,
             * so this improves performance massively.
             * Optimization: converts a list of projective points to a list of identical points with Z=1.
             */
            static normalizeZ(points) {
                const toInv = Fp.invertBatch(points.map((p) => p.pz));
                return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            }
            /**
             * Converts hash string or Uint8Array to Point.
             * @param hex short/long ECDSA hex
             */
            static fromHex(hex) {
                const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));
                P.assertValidity();
                return P;
            }
            // Multiplies generator point by privateKey.
            static fromPrivateKey(privateKey) {
                return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
            }
            // "Private method", don't use it directly
            _setWindowSize(windowSize) {
                this._WINDOW_SIZE = windowSize;
                pointPrecomputes.delete(this);
            }
            // A point on curve is valid if it conforms to equation.
            assertValidity() {
                if (this.is0()) {
                    // (0, 1, 0) aka ZERO is invalid in most contexts.
                    // In BLS, ZERO can be serialized, so we allow it.
                    // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                    if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                        return;
                    throw new Error('bad point: ZERO');
                }
                // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
                const { x, y } = this.toAffine();
                // Check if x, y are valid field elements
                if (!Fp.isValid(x) || !Fp.isValid(y))
                    throw new Error('bad point: x or y not FE');
                const left = Fp.sqr(y); // y
                const right = weierstrassEquation(x); // x + ax + b
                if (!Fp.eql(left, right))
                    throw new Error('bad point: equation left != right');
                if (!this.isTorsionFree())
                    throw new Error('bad point: not in prime-order subgroup');
            }
            hasEvenY() {
                const { y } = this.toAffine();
                if (Fp.isOdd)
                    return !Fp.isOdd(y);
                throw new Error("Field doesn't support isOdd");
            }
            /**
             * Compare one point to another.
             */
            equals(other) {
                assertPrjPoint(other);
                const { px: X1, py: Y1, pz: Z1 } = this;
                const { px: X2, py: Y2, pz: Z2 } = other;
                const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
                const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
                return U1 && U2;
            }
            /**
             * Flips point to one corresponding to (x, -y) in Affine coordinates.
             */
            negate() {
                return new Point(this.px, Fp.neg(this.py), this.pz);
            }
            // Renes-Costello-Batina exception-free doubling formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 3
            // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
            double() {
                const { a, b } = CURVE;
                const b3 = Fp.mul(b, _3n$1);
                const { px: X1, py: Y1, pz: Z1 } = this;
                let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
                let t0 = Fp.mul(X1, X1); // step 1
                let t1 = Fp.mul(Y1, Y1);
                let t2 = Fp.mul(Z1, Z1);
                let t3 = Fp.mul(X1, Y1);
                t3 = Fp.add(t3, t3); // step 5
                Z3 = Fp.mul(X1, Z1);
                Z3 = Fp.add(Z3, Z3);
                X3 = Fp.mul(a, Z3);
                Y3 = Fp.mul(b3, t2);
                Y3 = Fp.add(X3, Y3); // step 10
                X3 = Fp.sub(t1, Y3);
                Y3 = Fp.add(t1, Y3);
                Y3 = Fp.mul(X3, Y3);
                X3 = Fp.mul(t3, X3);
                Z3 = Fp.mul(b3, Z3); // step 15
                t2 = Fp.mul(a, t2);
                t3 = Fp.sub(t0, t2);
                t3 = Fp.mul(a, t3);
                t3 = Fp.add(t3, Z3);
                Z3 = Fp.add(t0, t0); // step 20
                t0 = Fp.add(Z3, t0);
                t0 = Fp.add(t0, t2);
                t0 = Fp.mul(t0, t3);
                Y3 = Fp.add(Y3, t0);
                t2 = Fp.mul(Y1, Z1); // step 25
                t2 = Fp.add(t2, t2);
                t0 = Fp.mul(t2, t3);
                X3 = Fp.sub(X3, t0);
                Z3 = Fp.mul(t2, t1);
                Z3 = Fp.add(Z3, Z3); // step 30
                Z3 = Fp.add(Z3, Z3);
                return new Point(X3, Y3, Z3);
            }
            // Renes-Costello-Batina exception-free addition formula.
            // There is 30% faster Jacobian formula, but it is not complete.
            // https://eprint.iacr.org/2015/1060, algorithm 1
            // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
            add(other) {
                assertPrjPoint(other);
                const { px: X1, py: Y1, pz: Z1 } = this;
                const { px: X2, py: Y2, pz: Z2 } = other;
                let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
                const a = CURVE.a;
                const b3 = Fp.mul(CURVE.b, _3n$1);
                let t0 = Fp.mul(X1, X2); // step 1
                let t1 = Fp.mul(Y1, Y2);
                let t2 = Fp.mul(Z1, Z2);
                let t3 = Fp.add(X1, Y1);
                let t4 = Fp.add(X2, Y2); // step 5
                t3 = Fp.mul(t3, t4);
                t4 = Fp.add(t0, t1);
                t3 = Fp.sub(t3, t4);
                t4 = Fp.add(X1, Z1);
                let t5 = Fp.add(X2, Z2); // step 10
                t4 = Fp.mul(t4, t5);
                t5 = Fp.add(t0, t2);
                t4 = Fp.sub(t4, t5);
                t5 = Fp.add(Y1, Z1);
                X3 = Fp.add(Y2, Z2); // step 15
                t5 = Fp.mul(t5, X3);
                X3 = Fp.add(t1, t2);
                t5 = Fp.sub(t5, X3);
                Z3 = Fp.mul(a, t4);
                X3 = Fp.mul(b3, t2); // step 20
                Z3 = Fp.add(X3, Z3);
                X3 = Fp.sub(t1, Z3);
                Z3 = Fp.add(t1, Z3);
                Y3 = Fp.mul(X3, Z3);
                t1 = Fp.add(t0, t0); // step 25
                t1 = Fp.add(t1, t0);
                t2 = Fp.mul(a, t2);
                t4 = Fp.mul(b3, t4);
                t1 = Fp.add(t1, t2);
                t2 = Fp.sub(t0, t2); // step 30
                t2 = Fp.mul(a, t2);
                t4 = Fp.add(t4, t2);
                t0 = Fp.mul(t1, t4);
                Y3 = Fp.add(Y3, t0);
                t0 = Fp.mul(t5, t4); // step 35
                X3 = Fp.mul(t3, X3);
                X3 = Fp.sub(X3, t0);
                t0 = Fp.mul(t3, t1);
                Z3 = Fp.mul(t5, Z3);
                Z3 = Fp.add(Z3, t0); // step 40
                return new Point(X3, Y3, Z3);
            }
            subtract(other) {
                return this.add(other.negate());
            }
            is0() {
                return this.equals(Point.ZERO);
            }
            wNAF(n) {
                return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                    const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                    return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
                });
            }
            /**
             * Non-constant-time multiplication. Uses double-and-add algorithm.
             * It's faster, but should only be used when you don't care about
             * an exposed private key e.g. sig verification, which works over *public* keys.
             */
            multiplyUnsafe(n) {
                const I = Point.ZERO;
                if (n === _0n$2)
                    return I;
                assertGE(n); // Will throw on 0
                if (n === _1n$2)
                    return this;
                const { endo } = CURVE;
                if (!endo)
                    return wnaf.unsafeLadder(this, n);
                // Apply endomorphism
                let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let k1p = I;
                let k2p = I;
                let d = this;
                while (k1 > _0n$2 || k2 > _0n$2) {
                    if (k1 & _1n$2)
                        k1p = k1p.add(d);
                    if (k2 & _1n$2)
                        k2p = k2p.add(d);
                    d = d.double();
                    k1 >>= _1n$2;
                    k2 >>= _1n$2;
                }
                if (k1neg)
                    k1p = k1p.negate();
                if (k2neg)
                    k2p = k2p.negate();
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                return k1p.add(k2p);
            }
            /**
             * Constant time multiplication.
             * Uses wNAF method. Windowed method may be 10% faster,
             * but takes 2x longer to generate and consumes 2x memory.
             * Uses precomputes when available.
             * Uses endomorphism for Koblitz curves.
             * @param scalar by which the point would be multiplied
             * @returns New point
             */
            multiply(scalar) {
                assertGE(scalar);
                let n = scalar;
                let point, fake; // Fake point is used to const-time mult
                const { endo } = CURVE;
                if (endo) {
                    const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                    let { p: k1p, f: f1p } = this.wNAF(k1);
                    let { p: k2p, f: f2p } = this.wNAF(k2);
                    k1p = wnaf.constTimeNegate(k1neg, k1p);
                    k2p = wnaf.constTimeNegate(k2neg, k2p);
                    k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                    point = k1p.add(k2p);
                    fake = f1p.add(f2p);
                }
                else {
                    const { p, f } = this.wNAF(n);
                    point = p;
                    fake = f;
                }
                // Normalize `z` for both points, but return only real one
                return Point.normalizeZ([point, fake])[0];
            }
            /**
             * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
             * Not using Strauss-Shamir trick: precomputation tables are faster.
             * The trick could be useful if both P and Q are not G (not in our case).
             * @returns non-zero affine point
             */
            multiplyAndAddUnsafe(Q, a, b) {
                const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
                const mul = (P, a // Select faster multiply() method
                ) => (a === _0n$2 || a === _1n$2 || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
                const sum = mul(this, a).add(mul(Q, b));
                return sum.is0() ? undefined : sum;
            }
            // Converts Projective point to affine (x, y) coordinates.
            // Can accept precomputed Z^-1 - for example, from invertBatch.
            // (x, y, z)  (x=x/z, y=y/z)
            toAffine(iz) {
                const { px: x, py: y, pz: z } = this;
                const is0 = this.is0();
                // If invZ was 0, we return zero point. However we still want to execute
                // all operations, so we replace invZ with a random number, 1.
                if (iz == null)
                    iz = is0 ? Fp.ONE : Fp.inv(z);
                const ax = Fp.mul(x, iz);
                const ay = Fp.mul(y, iz);
                const zz = Fp.mul(z, iz);
                if (is0)
                    return { x: Fp.ZERO, y: Fp.ZERO };
                if (!Fp.eql(zz, Fp.ONE))
                    throw new Error('invZ was invalid');
                return { x: ax, y: ay };
            }
            isTorsionFree() {
                const { h: cofactor, isTorsionFree } = CURVE;
                if (cofactor === _1n$2)
                    return true; // No subgroups, always torsion-free
                if (isTorsionFree)
                    return isTorsionFree(Point, this);
                throw new Error('isTorsionFree() has not been declared for the elliptic curve');
            }
            clearCofactor() {
                const { h: cofactor, clearCofactor } = CURVE;
                if (cofactor === _1n$2)
                    return this; // Fast-path
                if (clearCofactor)
                    return clearCofactor(Point, this);
                return this.multiplyUnsafe(CURVE.h);
            }
            toRawBytes(isCompressed = true) {
                this.assertValidity();
                return toBytes(Point, this, isCompressed);
            }
            toHex(isCompressed = true) {
                return bytesToHex(this.toRawBytes(isCompressed));
            }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        const _bits = CURVE.nBitLength;
        const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
        // Validate if generator point is on curve
        return {
            CURVE,
            ProjectivePoint: Point,
            normPrivateKeyToScalar,
            weierstrassEquation,
            isWithinCurveOrder,
        };
    }
    function validateOpts(curve) {
        const opts = validateBasic(curve);
        validateObject(opts, {
            hash: 'hash',
            hmac: 'function',
            randomBytes: 'function',
        }, {
            bits2int: 'function',
            bits2int_modN: 'function',
            lowS: 'boolean',
        });
        return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { Fp, n: CURVE_ORDER } = CURVE;
        const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
        const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
        function isValidFieldElement(num) {
            return _0n$2 < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
        }
        function modN(a) {
            return mod(a, CURVE_ORDER);
        }
        function invN(a) {
            return invert(a, CURVE_ORDER);
        }
        const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
            ...CURVE,
            toBytes(_c, point, isCompressed) {
                const a = point.toAffine();
                const x = Fp.toBytes(a.x);
                const cat = concatBytes;
                if (isCompressed) {
                    return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
                }
                else {
                    return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
                }
            },
            fromBytes(bytes) {
                const len = bytes.length;
                const head = bytes[0];
                const tail = bytes.subarray(1);
                // this.assertValidity() is done inside of fromHex
                if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                    const x = bytesToNumberBE(tail);
                    if (!isValidFieldElement(x))
                        throw new Error('Point is not on curve');
                    const y2 = weierstrassEquation(x); // y = x + ax + b
                    let y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                    const isYOdd = (y & _1n$2) === _1n$2;
                    // ECDSA
                    const isHeadOdd = (head & 1) === 1;
                    if (isHeadOdd !== isYOdd)
                        y = Fp.neg(y);
                    return { x, y };
                }
                else if (len === uncompressedLen && head === 0x04) {
                    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                    return { x, y };
                }
                else {
                    throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
                }
            },
        });
        const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
        function isBiggerThanHalfOrder(number) {
            const HALF = CURVE_ORDER >> _1n$2;
            return number > HALF;
        }
        function normalizeS(s) {
            return isBiggerThanHalfOrder(s) ? modN(-s) : s;
        }
        // slice bytes num
        const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
        /**
         * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
         */
        class Signature {
            constructor(r, s, recovery) {
                this.r = r;
                this.s = s;
                this.recovery = recovery;
                this.assertValidity();
            }
            // pair (bytes of r, bytes of s)
            static fromCompact(hex) {
                const l = CURVE.nByteLength;
                hex = ensureBytes('compactSignature', hex, l * 2);
                return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
            }
            // DER encoded ECDSA signature
            // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
            static fromDER(hex) {
                const { r, s } = DER.toSig(ensureBytes('DER', hex));
                return new Signature(r, s);
            }
            assertValidity() {
                // can use assertGE here
                if (!isWithinCurveOrder(this.r))
                    throw new Error('r must be 0 < r < CURVE.n');
                if (!isWithinCurveOrder(this.s))
                    throw new Error('s must be 0 < s < CURVE.n');
            }
            addRecoveryBit(recovery) {
                return new Signature(this.r, this.s, recovery);
            }
            recoverPublicKey(msgHash) {
                const { r, s, recovery: rec } = this;
                const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash
                if (rec == null || ![0, 1, 2, 3].includes(rec))
                    throw new Error('recovery id invalid');
                const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
                if (radj >= Fp.ORDER)
                    throw new Error('recovery id 2 or 3 invalid');
                const prefix = (rec & 1) === 0 ? '02' : '03';
                const R = Point.fromHex(prefix + numToNByteStr(radj));
                const ir = invN(radj); // r^-1
                const u1 = modN(-h * ir); // -hr^-1
                const u2 = modN(s * ir); // sr^-1
                const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
                if (!Q)
                    throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
                Q.assertValidity();
                return Q;
            }
            // Signatures should be low-s, to prevent malleability.
            hasHighS() {
                return isBiggerThanHalfOrder(this.s);
            }
            normalizeS() {
                return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
            }
            // DER-encoded
            toDERRawBytes() {
                return hexToBytes(this.toDERHex());
            }
            toDERHex() {
                return DER.hexFromSig({ r: this.r, s: this.s });
            }
            // padded bytes of r, then padded bytes of s
            toCompactRawBytes() {
                return hexToBytes(this.toCompactHex());
            }
            toCompactHex() {
                return numToNByteStr(this.r) + numToNByteStr(this.s);
            }
        }
        const utils = {
            isValidPrivateKey(privateKey) {
                try {
                    normPrivateKeyToScalar(privateKey);
                    return true;
                }
                catch (error) {
                    return false;
                }
            },
            normPrivateKeyToScalar: normPrivateKeyToScalar,
            /**
             * Produces cryptographically secure private key from random of size
             * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
             */
            randomPrivateKey: () => {
                const length = getMinHashLength(CURVE.n);
                return mapHashToField(CURVE.randomBytes(length), CURVE.n);
            },
            /**
             * Creates precompute table for an arbitrary EC point. Makes point "cached".
             * Allows to massively speed-up `point.multiply(scalar)`.
             * @returns cached point
             * @example
             * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
             * fast.multiply(privKey); // much faster ECDH now
             */
            precompute(windowSize = 8, point = Point.BASE) {
                point._setWindowSize(windowSize);
                point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
                return point;
            },
        };
        /**
         * Computes public key for a private key. Checks for validity of the private key.
         * @param privateKey private key
         * @param isCompressed whether to return compact (default), or full key
         * @returns Public key, full when isCompressed=false; short when isCompressed=true
         */
        function getPublicKey(privateKey, isCompressed = true) {
            return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        }
        /**
         * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
         */
        function isProbPub(item) {
            const arr = item instanceof Uint8Array;
            const str = typeof item === 'string';
            const len = (arr || str) && item.length;
            if (arr)
                return len === compressedLen || len === uncompressedLen;
            if (str)
                return len === 2 * compressedLen || len === 2 * uncompressedLen;
            if (item instanceof Point)
                return true;
            return false;
        }
        /**
         * ECDH (Elliptic Curve Diffie Hellman).
         * Computes shared public key from private key and public key.
         * Checks: 1) private key validity 2) shared key is on-curve.
         * Does NOT hash the result.
         * @param privateA private key
         * @param publicB different public key
         * @param isCompressed whether to return compact (default), or full key
         * @returns shared public key
         */
        function getSharedSecret(privateA, publicB, isCompressed = true) {
            if (isProbPub(privateA))
                throw new Error('first arg must be private key');
            if (!isProbPub(publicB))
                throw new Error('second arg must be public key');
            const b = Point.fromHex(publicB); // check for being on-curve
            return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
        }
        // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
        // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
        // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
        // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
        const bits2int = CURVE.bits2int ||
            function (bytes) {
                // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
                // for some cases, since bytes.length * 8 is not actual bitLength.
                const num = bytesToNumberBE(bytes); // check for == u8 done here
                const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
                return delta > 0 ? num >> BigInt(delta) : num;
            };
        const bits2int_modN = CURVE.bits2int_modN ||
            function (bytes) {
                return modN(bits2int(bytes)); // can't use bytesToNumberBE here
            };
        // NOTE: pads output with zero as per spec
        const ORDER_MASK = bitMask(CURVE.nBitLength);
        /**
         * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
         */
        function int2octets(num) {
            if (typeof num !== 'bigint')
                throw new Error('bigint expected');
            if (!(_0n$2 <= num && num < ORDER_MASK))
                throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
            // works with order, can have different size than numToField!
            return numberToBytesBE(num, CURVE.nByteLength);
        }
        // Steps A, D of RFC6979 3.2
        // Creates RFC6979 seed; converts msg/privKey to numbers.
        // Used only in sign, not in verify.
        // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
        // Also it can be bigger for P224 + SHA256
        function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
            if (['recovered', 'canonical'].some((k) => k in opts))
                throw new Error('sign() legacy options not supported');
            const { hash, randomBytes } = CURVE;
            let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
            if (lowS == null)
                lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
            msgHash = ensureBytes('msgHash', msgHash);
            if (prehash)
                msgHash = ensureBytes('prehashed msgHash', hash(msgHash));
            // We can't later call bits2octets, since nested bits2int is broken for curves
            // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
            // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
            const h1int = bits2int_modN(msgHash);
            const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
            const seedArgs = [int2octets(d), int2octets(h1int)];
            // extraEntropy. RFC6979 3.6: additional k' (optional).
            if (ent != null) {
                // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
                const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
                seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes
            }
            const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2
            const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
            // Converts signature params into point w r/s, checks result for validity.
            function k2sig(kBytes) {
                // RFC 6979 Section 3.2, step 3: k = bits2int(T)
                const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
                if (!isWithinCurveOrder(k))
                    return; // Important: all mod() calls here must be done over N
                const ik = invN(k); // k^-1 mod n
                const q = Point.BASE.multiply(k).toAffine(); // q = Gk
                const r = modN(q.x); // r = q.x mod n
                if (r === _0n$2)
                    return;
                // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
                // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
                // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
                const s = modN(ik * modN(m + r * d)); // Not using blinding here
                if (s === _0n$2)
                    return;
                let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$2); // recovery bit (2 or 3, when q.x > n)
                let normS = s;
                if (lowS && isBiggerThanHalfOrder(s)) {
                    normS = normalizeS(s); // if lowS was passed, ensure s is always
                    recovery ^= 1; // // in the bottom half of N
                }
                return new Signature(r, normS, recovery); // use normS, not s
            }
            return { seed, k2sig };
        }
        const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
        const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
        /**
         * Signs message hash with a private key.
         * ```
         * sign(m, d, k) where
         *   (x, y) = G  k
         *   r = x mod n
         *   s = (m + dr)/k mod n
         * ```
         * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
         * @param privKey private key
         * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
         * @returns signature with recovery param
         */
        function sign(msgHash, privKey, opts = defaultSigOpts) {
            const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
            const C = CURVE;
            const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
            return drbg(seed, k2sig); // Steps B, C, D, E, F, G
        }
        // Enable precomputes. Slows down first publicKey computation by 20ms.
        Point.BASE._setWindowSize(8);
        // utils.precompute(8, ProjectivePoint.BASE)
        /**
         * Verifies a signature against message hash and public key.
         * Rejects lowS signatures by default: to override,
         * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
         *
         * ```
         * verify(r, s, h, P) where
         *   U1 = hs^-1 mod n
         *   U2 = rs^-1 mod n
         *   R = U1G - U2P
         *   mod(R.x, n) == r
         * ```
         */
        function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
            const sg = signature;
            msgHash = ensureBytes('msgHash', msgHash);
            publicKey = ensureBytes('publicKey', publicKey);
            if ('strict' in opts)
                throw new Error('options.strict was renamed to lowS');
            const { lowS, prehash } = opts;
            let _sig = undefined;
            let P;
            try {
                if (typeof sg === 'string' || sg instanceof Uint8Array) {
                    // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                    // Since DER can also be 2*nByteLength bytes, we check for it first.
                    try {
                        _sig = Signature.fromDER(sg);
                    }
                    catch (derError) {
                        if (!(derError instanceof DER.Err))
                            throw derError;
                        _sig = Signature.fromCompact(sg);
                    }
                }
                else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                    const { r, s } = sg;
                    _sig = new Signature(r, s);
                }
                else {
                    throw new Error('PARSE');
                }
                P = Point.fromHex(publicKey);
            }
            catch (error) {
                if (error.message === 'PARSE')
                    throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
                return false;
            }
            if (lowS && _sig.hasHighS())
                return false;
            if (prehash)
                msgHash = CURVE.hash(msgHash);
            const { r, s } = _sig;
            const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
            const is = invN(s); // s^-1
            const u1 = modN(h * is); // u1 = hs^-1 mod n
            const u2 = modN(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
            if (!R)
                return false;
            const v = modN(R.x);
            return v === r;
        }
        return {
            CURVE,
            getPublicKey,
            getSharedSecret,
            sign,
            verify,
            ProjectivePoint: Point,
            Signature,
            utils,
        };
    }

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // connects noble-curves to noble-hashes
    function getHash(hash) {
        return {
            hash,
            hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
            randomBytes: randomBytes$2,
        };
    }
    function createCurve(curveDef, defHash) {
        const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
        return Object.freeze({ ...create(defHash), create });
    }

    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
    const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    const _1n$1 = BigInt(1);
    const _2n$1 = BigInt(2);
    const divNearest = (a, b) => (a + b / _2n$1) / b;
    /**
     * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
     * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
     */
    function sqrtMod(y) {
        const P = secp256k1P;
        // prettier-ignore
        const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
        // prettier-ignore
        const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
        const b2 = (y * y * y) % P; // x^3, 11
        const b3 = (b2 * b2 * y) % P; // x^7
        const b6 = (pow2(b3, _3n, P) * b3) % P;
        const b9 = (pow2(b6, _3n, P) * b3) % P;
        const b11 = (pow2(b9, _2n$1, P) * b2) % P;
        const b22 = (pow2(b11, _11n, P) * b11) % P;
        const b44 = (pow2(b22, _22n, P) * b22) % P;
        const b88 = (pow2(b44, _44n, P) * b44) % P;
        const b176 = (pow2(b88, _88n, P) * b88) % P;
        const b220 = (pow2(b176, _44n, P) * b44) % P;
        const b223 = (pow2(b220, _3n, P) * b3) % P;
        const t1 = (pow2(b223, _23n, P) * b22) % P;
        const t2 = (pow2(t1, _6n, P) * b2) % P;
        const root = pow2(t2, _2n$1, P);
        if (!Fp.eql(Fp.sqr(root), y))
            throw new Error('Cannot find square root');
        return root;
    }
    const Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
    const secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp,
        n: secp256k1N,
        // Base point (x, y) aka generator point
        Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
        Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
        h: BigInt(1),
        lowS: true,
        /**
         * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
         * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
         * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
         * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
         */
        endo: {
            beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
            splitScalar: (k) => {
                const n = secp256k1N;
                const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
                const b1 = -_1n$1 * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
                const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
                const b2 = a1;
                const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
                const c1 = divNearest(b2 * k, n);
                const c2 = divNearest(-b1 * k, n);
                let k1 = mod(k - c1 * a1 - c2 * a2, n);
                let k2 = mod(-c1 * b1 - c2 * b2, n);
                const k1neg = k1 > POW_2_128;
                const k2neg = k2 > POW_2_128;
                if (k1neg)
                    k1 = n - k1;
                if (k2neg)
                    k2 = n - k2;
                if (k1 > POW_2_128 || k2 > POW_2_128) {
                    throw new Error('splitScalar: Endomorphism failed, k=' + k);
                }
                return { k1neg, k1, k2neg, k2 };
            },
        },
    }, sha256$1);
    // Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
    // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
    const _0n$1 = BigInt(0);
    const fe = (x) => typeof x === 'bigint' && _0n$1 < x && x < secp256k1P;
    const ge = (x) => typeof x === 'bigint' && _0n$1 < x && x < secp256k1N;
    /** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
    const TAGGED_HASH_PREFIXES = {};
    function taggedHash$1(tag, ...messages) {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = sha256$1(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return sha256$1(concatBytes(tagP, ...messages));
    }
    // ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
    const pointToBytes = (point) => point.toRawBytes(true).slice(1);
    const numTo32b = (n) => numberToBytesBE(n, 32);
    const modP = (x) => mod(x, secp256k1P);
    const modN = (x) => mod(x, secp256k1N);
    const Point = secp256k1.ProjectivePoint;
    const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    // Calculate point, scalar and bytes
    function schnorrGetExtPubKey(priv) {
        let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
        let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
        const scalar = p.hasEvenY() ? d_ : modN(-d_);
        return { scalar: scalar, bytes: pointToBytes(p) };
    }
    /**
     * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
     * @returns valid point checked for being on-curve
     */
    function lift_x(x) {
        if (!fe(x))
            throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
        const xx = modP(x * x);
        const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
        let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
        if (y % _2n$1 !== _0n$1)
            y = modP(-y); // Return the unique point P such that x(P) = x and
        const p = new Point(x, y, _1n$1); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
        p.assertValidity();
        return p;
    }
    /**
     * Create tagged hash, convert it to bigint, reduce modulo-n.
     */
    function challenge(...args) {
        return modN(bytesToNumberBE(taggedHash$1('BIP0340/challenge', ...args)));
    }
    /**
     * Schnorr public key is just `x` coordinate of Point as per BIP340.
     */
    function schnorrGetPublicKey(privateKey) {
        return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
    }
    /**
     * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
     * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
     */
    function schnorrSign(message, privateKey, auxRand = randomBytes$2(32)) {
        const m = ensureBytes('message', message);
        const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
        const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
        const t = numTo32b(d ^ bytesToNumberBE(taggedHash$1('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
        const rand = taggedHash$1('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
        const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n
        if (k_ === _0n$1)
            throw new Error('sign failed: k is zero'); // Fail if k' = 0.
        const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.
        const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
        const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
        sig.set(rx, 0);
        sig.set(numTo32b(modN(k + e * d)), 32);
        // If Verify(bytes(P), m, sig) (see below) returns failure, abort
        if (!schnorrVerify(sig, m, px))
            throw new Error('sign: Invalid signature produced');
        return sig;
    }
    /**
     * Verifies Schnorr signature.
     * Will swallow errors & return false except for initial type validation of arguments.
     */
    function schnorrVerify(signature, message, publicKey) {
        const sig = ensureBytes('signature', signature, 64);
        const m = ensureBytes('message', message);
        const pub = ensureBytes('publicKey', publicKey, 32);
        try {
            const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails
            const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
            if (!fe(r))
                return false;
            const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
            if (!ge(s))
                return false;
            const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
            const R = GmulAdd(P, s, modN(-e)); // R = sG - eP
            if (!R || !R.hasEvenY() || R.toAffine().x !== r)
                return false; // -eP == (n-e)P
            return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
        }
        catch (error) {
            return false;
        }
    }
    const schnorr = /* @__PURE__ */ (() => ({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: secp256k1.utils.randomPrivateKey,
            lift_x,
            pointToBytes,
            numberToBytesBE,
            bytesToNumberBE,
            taggedHash: taggedHash$1,
            mod,
        },
    }))();

    /**
     * A constant for the zero address.
     *
     * (**i.e.** `"0x0000000000000000000000000000000000000000"`)
     *
     * @category Constants
     */
    const ZeroAddress = '0x0000000000000000000000000000000000000000';

    /**
     * A constant for the zero hash.
     *
     * (**i.e.** `"0x0000000000000000000000000000000000000000000000000000000000000000"`)
     *
     * @category Constants
     */
    const ZeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';

    /**
     * A constant for the order N for the secp256k1 curve.
     *
     * (**i.e.** `0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n`)
     *
     * @category Constants
     */
    const N$1 = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    /**
     * A constant for the number of wei in a single ether.
     *
     * (**i.e.** `1000000000000000000n`)
     *
     * @category Constants
     */
    const WeiPerEther = BigInt('1000000000000000000');
    /**
     * A constant for the maximum value for a `uint256`.
     *
     * (**i.e.** `0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn`)
     *
     * @category Constants
     */
    const MaxUint256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
    /**
     * A constant for the minimum value for an `int256`.
     *
     * (**i.e.** `-8000000000000000000000000000000000000000000000000000000000000000n`)
     *
     * @category Constants
     */
    const MinInt256 = BigInt('0x8000000000000000000000000000000000000000000000000000000000000000') * BigInt(-1);
    /**
     * A constant for the maximum value for an `int256`.
     *
     * (**i.e.** `0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn`)
     *
     * @category Constants
     */
    const MaxInt256 = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

    // NFKC (composed)             // (decomposed)
    /**
     * A constant for the ether symbol (normalized using NFKC).
     *
     * (**i.e.** `"\\u039e"`)
     *
     * @category Constants
     */
    const quaisymbol = '\u039e'; // "\uD835\uDF63";
    /**
     * A constant for the Quai Network equivalent of the [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal message
     * prefix.
     *
     * (**i.e.** `"\\x19Quai Signed Message:\\n"`)
     *
     * @category Constants
     */
    const MessagePrefix = '\x19Ethereum Signed Message:\n';

    /**
     * A shard represents a chain within the Quai network hierarchy. A shard refer to the Prime chain, a region under the
     * Prime chain, or a Zone within a region. The value is a hexadecimal string representing the encoded value of the
     * shard. Read more [here](https://github.com/quai-network/qips/blob/master/qip-0002.md).
     *
     * @category Constants
     */
    exports.Shard = void 0;
    (function (Shard) {
        Shard["Cyprus"] = "0x0";
        Shard["Cyprus1"] = "0x00";
        Shard["Cyprus2"] = "0x01";
        Shard["Cyprus3"] = "0x02";
        Shard["Paxos"] = "0x1";
        Shard["Paxos1"] = "0x10";
        Shard["Paxos2"] = "0x11";
        Shard["Paxos3"] = "0x12";
        Shard["Hydra"] = "0x2";
        Shard["Hydra1"] = "0x20";
        Shard["Hydra2"] = "0x21";
        Shard["Hydra3"] = "0x22";
        Shard["Prime"] = "0x";
    })(exports.Shard || (exports.Shard = {}));
    function shardFromBytes(shard) {
        switch (shard) {
            case '0x':
                return exports.Shard.Prime;
            case '0x0':
                return exports.Shard.Cyprus;
            case '0x1':
                return exports.Shard.Paxos;
            case '0x2':
                return exports.Shard.Hydra;
            case '0x00':
                return exports.Shard.Cyprus1;
            case '0x01':
                return exports.Shard.Cyprus2;
            case '0x02':
                return exports.Shard.Cyprus3;
            case '0x10':
                return exports.Shard.Paxos1;
            case '0x11':
                return exports.Shard.Paxos2;
            case '0x12':
                return exports.Shard.Paxos3;
            case '0x20':
                return exports.Shard.Hydra1;
            case '0x21':
                return exports.Shard.Hydra2;
            case '0x22':
                return exports.Shard.Hydra3;
            default:
                throw new Error('Invalid shard');
        }
    }
    /**
     * Constant data that defines each shard within the network.
     *
     * @category Constants
     */
    const ShardData = [
        ...ZoneData,
        {
            name: 'Cyprus',
            nickname: 'cyprus',
            shard: 'region-0',
            context: 2,
            byte: '0x0',
        },
        {
            name: 'Paxos',
            nickname: 'paxos',
            shard: 'region-1',
            context: 2,
            byte: '0x1',
        },
        {
            name: 'Hydra',
            nickname: 'hydra',
            shard: 'region-2',
            context: 2,
            byte: '0x2',
        },
        {
            name: 'Prime',
            nickname: 'prime',
            shard: 'prime',
            context: 2,
            byte: '0x',
        },
    ];
    function toShard(shard) {
        return shardFromBytes(ShardData.find((it) => it.name == shard || it.byte == shard || it.nickname == shard || it.shard == shard)
            ?.byte || '');
    }
    function fromShard(shard, key) {
        return ShardData.find((it) => it.byte == shard)?.[key] || '';
    }

    // Constants
    const BN_0$5 = BigInt(0);
    const BN_1$2 = BigInt(1);
    const BN_2 = BigInt(2);
    const BN_27 = BigInt(27);
    const BN_28 = BigInt(28);
    const BN_35 = BigInt(35);
    const _guard$6 = {};
    function toUint256(value) {
        return zeroPadValue(toBeArray(value), 32);
    }
    /**
     * A Signature @TODO
     *
     * @category Crypto
     */
    class Signature {
        #r;
        #s;
        #v;
        #networkV;
        /**
         * The `r` value for a signautre.
         *
         * This represents the `x` coordinate of a "reference" or challenge point, from which the `y` can be computed.
         */
        get r() {
            return this.#r;
        }
        set r(value) {
            assertArgument(dataLength(value) === 32, 'invalid r', 'value', value);
            this.#r = hexlify(value);
        }
        /**
         * The `s` value for a signature.
         */
        get s() {
            return this.#s;
        }
        set s(_value) {
            assertArgument(dataLength(_value) === 32, 'invalid s', 'value', _value);
            const value = hexlify(_value);
            assertArgument(parseInt(value.substring(0, 3)) < 8, 'non-canonical s', 'value', value);
            this.#s = value;
        }
        /**
         * The `v` value for a signature.
         *
         * Since a given `x` value for `r` has two possible values for its correspondin `y`, the `v` indicates which of the
         * two `y` values to use.
         *
         * It is normalized to the values `27` or `28` for legacy purposes.
         */
        get v() {
            return this.#v;
        }
        set v(value) {
            const v = getNumber(value, 'value');
            assertArgument(v === 27 || v === 28, 'invalid v', 'v', value);
            this.#v = v;
        }
        /**
         * The EIP-155 `v` for legacy transactions. For non-legacy transactions, this value is `null`.
         */
        get networkV() {
            return this.#networkV;
        }
        /**
         * The chain ID for EIP-155 legacy transactions. For non-legacy transactions, this value is `null`.
         */
        get legacyChainId() {
            const v = this.networkV;
            if (v == null) {
                return null;
            }
            return Signature.getChainId(v);
        }
        /**
         * The `yParity` for the signature.
         *
         * See `v` for more details on how this value is used.
         */
        get yParity() {
            return this.v === 27 ? 0 : 1;
        }
        /**
         * The [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact representation of the `yParity` and `s` compacted
         * into a single `bytes32`.
         */
        get yParityAndS() {
            // The EIP-2098 compact representation
            const yParityAndS = getBytes(this.s);
            if (this.yParity) {
                yParityAndS[0] |= 0x80;
            }
            return hexlify(yParityAndS);
        }
        /**
         * The [EIP-2098](https://eips.ethereum.org/EIPS/eip-2098) compact representation.
         */
        get compactSerialized() {
            return concat([this.r, this.yParityAndS]);
        }
        /**
         * The serialized representation.
         */
        get serialized() {
            return concat([this.r, this.s, this.yParity ? '0x1c' : '0x1b']);
        }
        /**
         * @ignore
         */
        constructor(guard, r, s, v) {
            assertPrivate(guard, _guard$6, 'Signature');
            this.#r = r;
            this.#s = s;
            this.#v = v;
            this.#networkV = null;
        }
        [Symbol.for('nodejs.util.inspect.custom')]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        /**
         * Returns a new identical {@link Signature | **Signature**}.
         */
        clone() {
            const clone = new Signature(_guard$6, this.r, this.s, this.v);
            if (this.networkV) {
                clone.#networkV = this.networkV;
            }
            return clone;
        }
        /**
         * Returns a representation that is compatible with `JSON.stringify`.
         */
        toJSON() {
            const networkV = this.networkV;
            return {
                _type: 'signature',
                networkV: networkV != null ? networkV.toString() : null,
                r: this.r,
                s: this.s,
                v: this.v,
            };
        }
        /**
         * Compute the chain ID from the `v` in a legacy EIP-155 transactions.
         *
         * @example
         *
         * ```ts
         * Signature.getChainId(45);
         *
         * Signature.getChainId(46);
         * ```
         *
         * @param {BigNumberish} v - The `v` value from the signature.
         * @returns {bigint} The chain ID.
         */
        static getChainId(v) {
            const bv = getBigInt(v, 'v');
            // The v is not an EIP-155 v, so it is the unspecified chain ID
            if (bv == BN_27 || bv == BN_28) {
                return BN_0$5;
            }
            // Bad value for an EIP-155 v
            assertArgument(bv >= BN_35, 'invalid EIP-155 v', 'v', v);
            return (bv - BN_35) / BN_2;
        }
        /**
         * Compute the `v` for a chain ID for a legacy EIP-155 transactions.
         *
         * Legacy transactions which use [EIP-155](https://eips.ethereum.org/EIPS/eip-155) hijack the `v` property to
         * include the chain ID.
         *
         * @example
         *
         * ```ts
         * Signature.getChainIdV(5, 27);
         *
         * Signature.getChainIdV(5, 28);
         * ```
         *
         * @param {BigNumberish} chainId - The chain ID.
         * @param {27 | 28} v - The `v` value.
         * @returns {bigint} The `v` value.
         */
        static getChainIdV(chainId, v) {
            return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
        }
        /**
         * Compute the normalized legacy transaction `v` from a `yParirty`, a legacy transaction `v` or a legacy
         * [EIP-155](https://eips.ethereum.org/EIPS/eip-155) transaction.
         *
         * @example
         *
         * ```ts
         * // The values 0 and 1 imply v is actually yParity
         * Signature.getNormalizedV(0);
         *
         * // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
         * Signature.getNormalizedV(27);
         *
         * // Legacy EIP-155 transaction (i.e. >= 35)
         * Signature.getNormalizedV(46);
         *
         * // Invalid values throw
         * Signature.getNormalizedV(5);
         * ```
         *
         * @param {BigNumberish} v - The `v` value.
         * @returns {27 | 28} The normalized `v` value.
         * @throws {Error} Thrown if the `v` is invalid.
         */
        static getNormalizedV(v) {
            const bv = getBigInt(v);
            if (bv === BN_0$5 || bv === BN_27) {
                return 27;
            }
            if (bv === BN_1$2 || bv === BN_28) {
                return 28;
            }
            assertArgument(bv >= BN_35, 'invalid v', 'v', v);
            // Otherwise, EIP-155 v means odd is 27 and even is 28
            return bv & BN_1$2 ? 27 : 28;
        }
        /**
         * Creates a new {@link Signature | **Signature**}.
         *
         * If no `sig` is provided, a new {@link Signature | **Signature**} is created with default values.
         *
         * If `sig` is a string, it is parsed.
         *
         * @param {SignatureLike} [sig] - The signature to create.
         * @returns {Signature} The new signature.
         */
        static from(sig) {
            function assertError(check, message) {
                assertArgument(check, message, 'signature', sig);
            }
            if (sig == null) {
                return new Signature(_guard$6, ZeroHash, ZeroHash, 27);
            }
            if (typeof sig === 'string') {
                const bytes = getBytes(sig, 'signature');
                if (bytes.length === 64) {
                    const r = hexlify(bytes.slice(0, 32));
                    const s = bytes.slice(32, 64);
                    const v = s[0] & 0x80 ? 28 : 27;
                    s[0] &= 0x7f;
                    return new Signature(_guard$6, r, hexlify(s), v);
                }
                if (bytes.length === 65) {
                    const r = hexlify(bytes.slice(0, 32));
                    const s = bytes.slice(32, 64);
                    assertError((s[0] & 0x80) === 0, 'non-canonical s');
                    const v = Signature.getNormalizedV(bytes[64]);
                    return new Signature(_guard$6, r, hexlify(s), v);
                }
                assertError(false, 'invalid raw signature length');
            }
            if (sig instanceof Signature) {
                return sig.clone();
            }
            // Get r
            const _r = sig.r;
            assertError(_r != null, 'missing r');
            const r = toUint256(_r);
            // Get s; by any means necessary (we check consistency below)
            const s = (function (s, yParityAndS) {
                if (s != null) {
                    return toUint256(s);
                }
                if (yParityAndS != null) {
                    assertError(isHexString(yParityAndS, 32), 'invalid yParityAndS');
                    const bytes = getBytes(yParityAndS);
                    bytes[0] &= 0x7f;
                    return hexlify(bytes);
                }
                assertError(false, 'missing s');
            })(sig.s, sig.yParityAndS);
            assertError((getBytes(s)[0] & 0x80) == 0, 'non-canonical s');
            // Get v; by any means necessary (we check consistency below)
            const { networkV, v } = (function (_v, yParityAndS, yParity) {
                if (_v != null) {
                    const v = getBigInt(_v);
                    return {
                        networkV: v >= BN_35 ? v : undefined,
                        v: Signature.getNormalizedV(v),
                    };
                }
                if (yParityAndS != null) {
                    assertError(isHexString(yParityAndS, 32), 'invalid yParityAndS');
                    return { v: getBytes(yParityAndS)[0] & 0x80 ? 28 : 27 };
                }
                if (yParity != null) {
                    switch (yParity) {
                        case 0:
                            return { v: 27 };
                        case 1:
                            return { v: 28 };
                    }
                    assertError(false, 'invalid yParity');
                }
                assertError(false, 'missing v');
            })(sig.v, sig.yParityAndS, sig.yParity);
            const result = new Signature(_guard$6, r, s, v);
            if (networkV) {
                result.#networkV = networkV;
            }
            // If multiple of v, yParity, yParityAndS we given, check they match
            assertError(!('yParity' in sig && sig.yParity !== result.yParity), 'yParity mismatch');
            assertError(!('yParityAndS' in sig && sig.yParityAndS !== result.yParityAndS), 'yParityAndS mismatch');
            return result;
        }
    }

    /**
     * Add details about signing here.
     */
    /**
     * A **SigningKey** provides high-level access to the elliptic curve cryptography (ECC) operations and key management.
     *
     * @category Crypto
     */
    class SigningKey {
        #privateKey;
        /**
         * Creates a new **SigningKey** for `privateKey`.
         */
        constructor(privateKey) {
            assertArgument(dataLength(privateKey) === 32, 'invalid private key', 'privateKey', '[REDACTED]');
            this.#privateKey = hexlify(privateKey);
        }
        /**
         * The private key.
         */
        get privateKey() {
            return this.#privateKey;
        }
        /**
         * The uncompressed public key.
         *
         * This will always begin with the prefix `0x04` and be 132 characters long (the `0x` prefix and 130 hexadecimal
         * nibbles).
         */
        get publicKey() {
            return SigningKey.computePublicKey(this.#privateKey);
        }
        /**
         * The compressed public key.
         *
         * This will always begin with either the prefix `0x02` or `0x03` and be 68 characters long (the `0x` prefix and 33
         * hexadecimal nibbles)
         */
        get compressedPublicKey() {
            return SigningKey.computePublicKey(this.#privateKey, true);
        }
        /**
         * Return the signature of the signed `digest`.
         *
         * @param {BytesLike} digest - The data to sign.
         * @returns {Signature} The signature of the data.
         * @throws {Error} If the digest is not 32 bytes long.
         */
        sign(digest) {
            assertArgument(dataLength(digest) === 32, 'invalid digest length', 'digest', digest);
            const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
                lowS: true,
            });
            return Signature.from({
                r: toBeHex('0x' + sig.r.toString(16), 32),
                s: toBeHex('0x' + sig.s.toString(16), 32),
                v: sig.recovery ? 0x1c : 0x1b,
            });
        }
        /**
         * Returns the [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie-Hellman) shared secret between this
         * private key and the `other` key.
         *
         * The `other` key may be any type of key, a raw public key, a compressed/uncompressed pubic key or aprivate key.
         *
         * Best practice is usually to use a cryptographic hash on the returned value before using it as a symetric secret.
         *
         * @example
         *
         * ```ts
         * sign1 = new SigningKey(id('some-secret-1'));
         * sign2 = new SigningKey(id('some-secret-2'));
         *
         * // Notice that privA.computeSharedSecret(pubB)...
         * sign1.computeSharedSecret(sign2.publicKey);
         *
         * // ...is equal to privB.computeSharedSecret(pubA).
         * sign2.computeSharedSecret(sign1.publicKey);
         * ```
         *
         * @param {BytesLike} other - The other key to compute the shared secret with.
         * @returns {string} The shared secret.
         */
        computeSharedSecret(other) {
            const pubKey = SigningKey.computePublicKey(other);
            return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
        }
        /**
         * Compute the public key for `key`, optionally `compressed`.
         *
         * The `key` may be any type of key, a raw public key, a compressed/uncompressed public key or private key.
         *
         * @example
         *
         * ```ts
         * sign = new SigningKey(id('some-secret'));
         *
         * // Compute the uncompressed public key for a private key
         * SigningKey.computePublicKey(sign.privateKey);
         *
         * // Compute the compressed public key for a private key
         * SigningKey.computePublicKey(sign.privateKey, true);
         *
         * // Compute the uncompressed public key
         * SigningKey.computePublicKey(sign.publicKey, false);
         *
         * // Compute the Compressed a public key
         * SigningKey.computePublicKey(sign.publicKey, true);
         * ```
         *
         * @param {BytesLike} key - The key to compute the public key for.
         * @param {boolean} [compressed] - Whether to return the compressed public key.
         * @returns {string} The public key.
         */
        static computePublicKey(key, compressed) {
            let bytes = getBytes(key, 'key');
            // private key
            if (bytes.length === 32) {
                const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
                return hexlify(pubKey);
            }
            // raw public key; use uncompressed key with 0x04 prefix
            if (bytes.length === 64) {
                const pub = new Uint8Array(65);
                pub[0] = 0x04;
                pub.set(bytes, 1);
                bytes = pub;
            }
            const point = secp256k1.ProjectivePoint.fromHex(bytes);
            return hexlify(point.toRawBytes(compressed));
        }
        /**
         * Returns the public key for the private key which produced the `signature` for the given `digest`.
         *
         * @example
         *
         * ```ts
         * key = new SigningKey(id('some-secret'));
         * digest = id('hello world');
         * sig = key.sign(digest);
         *
         * // Notice the signer public key...
         * key.publicKey;
         *
         * // ...is equal to the recovered public key
         * SigningKey.recoverPublicKey(digest, sig);
         * ```
         *
         * @param {BytesLike} digest - The data that was signed.
         * @param {SignatureLike} signature - The signature of the data.
         * @returns {string} The public key.
         */
        static recoverPublicKey(digest, signature) {
            assertArgument(dataLength(digest) === 32, 'invalid digest length', 'digest', digest);
            const sig = Signature.from(signature);
            let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
            secpSig = secpSig.addRecoveryBit(sig.yParity);
            const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
            assertArgument(pubKey != null, 'invalid signautre for digest', 'signature', signature);
            return '0x' + pubKey.toHex(false);
        }
        /**
         * Returns the point resulting from adding the ellipic curve points `p0` and `p1`.
         *
         * This is not a common function most developers should require, but can be useful for certain privacy-specific
         * techniques.
         *
         * For example, it is used by [**QuaiHDWallet**](../classes/QuaiHDWallet) to compute child addresses from parent
         * public keys and chain codes.
         *
         * @param {BytesLike} p0 - The first point to add.
         * @param {BytesLike} p1 - The second point to add.
         * @param {boolean} [compressed] - Whether to return the compressed public key.
         * @returns {string} The sum of the points.
         */
        static addPoints(p0, p1, compressed) {
            const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
            const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
            return '0x' + pub0.add(pub1).toHex(!!compressed);
        }
    }

    // BigInt / Uint8Array versions of Crypto functions that do not require point
    // math. If your JS interpreter has BigInt, you can use all of these. If not,
    // you'll need to either shim it in or override more of these functions.
    // Idea from noble-secp256k1, be nice to bad JS parsers
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    const _3n = BigInt(3);
    const _5n = BigInt(5);
    const _7n = BigInt(7);
    const _64n = BigInt(64);
    const _64mask = BigInt('0xFFFFFFFFFFFFFFFF');
    const CURVE = {
        b: BigInt(7),
        P: BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F'),
        n: BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'),
    };
    // Big Endian
    function read32b(bytes) {
        if (bytes.length !== 32)
            throw new Error(`Expected 32-bytes, not ${bytes.length}`);
        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.length);
        let b = view.getBigUint64(0);
        for (let offs = 8; offs < bytes.length; offs += 8) {
            b <<= _64n;
            b += view.getBigUint64(offs);
        }
        return b;
    }
    function write32b(num, dest = new Uint8Array(32)) {
        // All input values are modulo P or n, so no bounds checking needed
        const view = new DataView(dest.buffer, dest.byteOffset, dest.length);
        for (let offs = 24; offs >= 0; offs -= 8) {
            view.setBigUint64(offs, num & _64mask);
            num >>= _64n;
        }
        return dest;
    }
    function readScalar(bytes) {
        const a = read32b(bytes);
        if (a >= CURVE.n)
            throw new Error('Expected value mod n');
        return a;
    }
    function readSecret(bytes) {
        const a = readScalar(bytes);
        if (a === 0n)
            throw new Error('Expected non-zero');
        return a;
    }
    // The short Weierstrass form curve equation simplifes to y^2 = x^3 + 7.
    function secp256k1Right(x) {
        const x2 = (x * x) % CURVE.P;
        const x3 = (x2 * x) % CURVE.P;
        return (x3 + CURVE.b) % CURVE.P;
    }
    // For prime P, the Jacobi Symbol of 'a' is 1 if and only if 'a' is a quadratic
    // residue mod P, ie. there exists a value 'x' for whom x^2 = a.
    function jacobiSymbol(a) {
        if (a === _0n)
            return 0; // Vanishingly improbable
        let p = CURVE.P;
        let sign = 1;
        // This algorithm is fairly heavily optimized, so don't simplify it w/o benchmarking
        for (;;) {
            let and3;
            // Handle runs of zeros efficiently w/o flipping sign each time
            for (and3 = a & _3n; and3 === _0n; a >>= _2n, and3 = a & _3n)
                ;
            // If there's one more zero, shift it off and flip the sign
            if (and3 === _2n) {
                a >>= _1n;
                const pand7 = p & _7n;
                if (pand7 === _3n || pand7 === _5n)
                    sign = -sign;
            }
            if (a === _1n)
                break;
            if ((_3n & a) === _3n && (_3n & p) === _3n)
                sign = -sign;
            [a, p] = [p % a, a];
        }
        return sign > 0 ? 1 : -1;
    }
    function isPoint(p) {
        if (p.length < 33)
            return false;
        const t = p[0];
        if (p.length === 33) {
            return (t === 0x02 || t === 0x03) && isXOnlyPoint(p.subarray(1));
        }
        if (t !== 0x04 || p.length !== 65)
            return false;
        const x = read32b(p.subarray(1, 33));
        if (x === _0n)
            return false;
        if (x >= CURVE.P)
            return false;
        const y = read32b(p.subarray(33));
        if (y === _0n)
            return false;
        if (y >= CURVE.P)
            return false;
        const left = (y * y) % CURVE.P;
        const right = secp256k1Right(x);
        return left === right;
    }
    function isXOnlyPoint(p) {
        if (p.length !== 32)
            return false;
        const x = read32b(p);
        if (x === _0n)
            return false;
        if (x >= CURVE.P)
            return false;
        const y2 = secp256k1Right(x);
        return jacobiSymbol(y2) === 1; // If sqrt(y^2) exists, x is on the curve.
    }
    function scalarAdd(a, b) {
        const aN = readScalar(a);
        const bN = readScalar(b);
        const sum = (aN + bN) % CURVE.n;
        return write32b(sum);
    }
    function scalarMultiply(a, b) {
        const aN = readScalar(a);
        const bN = readScalar(b);
        const product = (aN * bN) % CURVE.n;
        return write32b(product);
    }
    function scalarNegate(a) {
        const aN = readScalar(a);
        const negated = aN === _0n ? _0n : CURVE.n - aN;
        return write32b(negated);
    }
    function scalarMod(a) {
        const aN = read32b(a);
        const remainder = aN % CURVE.n;
        return write32b(remainder);
    }
    function isScalar(t) {
        try {
            readScalar(t);
            return true;
        }
        catch {
            return false;
        }
    }
    function isSecret(s) {
        try {
            readSecret(s);
            return true;
        }
        catch {
            return false;
        }
    }
    function pointNegate(p) {
        // hasEvenY does basic structure check, so start there
        const even = hasEvenY(p);
        // `from` because node.Buffer.slice doesn't copy but looks like a Uint8Array
        const negated = Uint8Array.from(p);
        if (p.length === 33) {
            negated[0] = even ? 3 : 2;
        }
        else if (p.length === 65) {
            const y = read32b(p.subarray(33));
            if (y >= CURVE.P)
                throw new Error('Expected Y coordinate mod P');
            const minusY = y === _0n ? _0n : CURVE.P - y;
            write32b(minusY, negated.subarray(33));
        }
        return negated;
    }
    function pointX(p) {
        if (p.length === 32)
            return p;
        hasEvenY(p); // hasEvenY throws if not well structured
        return p.slice(1, 33);
    }
    function hasEvenY(p) {
        if (p.length === 33) {
            if (p[0] === 2)
                return true;
            else if (p[0] === 3)
                return false;
            else
                throw new Error('Wrong first byte to be a point');
        }
        if (p.length === 65) {
            if (p[0] !== 4)
                throw new Error('Wrong first byte to be point');
            return p[64] % 2 === 0;
        }
        throw new Error('Wrong length to be a point');
    }
    function pointMultiplyUnsafe(p, a, compress) {
        try {
            const product = secp256k1.ProjectivePoint.fromHex(p).multiplyAndAddUnsafe(secp256k1.ProjectivePoint.ZERO, BigInt(`0x${Buffer.from(a).toString('hex')}`), BigInt(1));
            if (!product)
                return null;
            return product.toRawBytes(compress);
        }
        catch {
            return null;
        }
    }
    function pointMultiplyAndAddUnsafe(p1, a, p2, compress) {
        try {
            const p2p = secp256k1.ProjectivePoint.fromHex(p2);
            const p = secp256k1.ProjectivePoint.fromHex(p1).multiplyAndAddUnsafe(p2p, BigInt(`0x${Buffer.from(a).toString('hex')}`), BigInt(1));
            if (!p)
                return null;
            return p.toRawBytes(compress);
        }
        catch {
            return null;
        }
    }
    function pointAdd(a, b, compress) {
        try {
            return secp256k1.ProjectivePoint.fromHex(a).add(secp256k1.ProjectivePoint.fromHex(b)).toRawBytes(compress);
        }
        catch {
            return null;
        }
    }
    function pointAddTweak(p, tweak, compress) {
        try {
            const P = secp256k1.ProjectivePoint.fromHex(p);
            const t = readSecret(tweak);
            const Q = secp256k1.ProjectivePoint.BASE.multiplyAndAddUnsafe(P, t, 1n);
            if (!Q)
                throw new Error('Tweaked point at infinity');
            return Q.toRawBytes(compress);
        }
        catch {
            return null;
        }
    }
    function pointCompress(p, compress = true) {
        return secp256k1.ProjectivePoint.fromHex(p).toRawBytes(compress);
    }
    function liftX(p) {
        try {
            return secp256k1.ProjectivePoint.fromHex(p).toRawBytes(false);
        }
        catch {
            return null;
        }
    }
    function getPublicKey(s, compress) {
        try {
            return secp256k1.getPublicKey(s, compress);
        }
        catch {
            return null;
        }
    }
    function taggedHash(tag, ...messages) {
        return schnorr.utils.taggedHash(tag, ...messages);
    }
    function sha256Hash(...messages) {
        const h = sha256$1.create();
        for (const message of messages)
            h.update(message);
        return h.digest();
    }
    const musigCrypto = {
        read32b,
        write32b,
        readScalar,
        readSecret,
        secp256k1Right,
        jacobiSymbol,
        isPoint,
        isXOnlyPoint,
        scalarAdd,
        scalarMultiply,
        scalarNegate,
        scalarMod,
        isScalar,
        isSecret,
        pointNegate,
        pointX,
        hasEvenY,
        pointMultiplyUnsafe,
        pointMultiplyAndAddUnsafe,
        pointAdd,
        pointAddTweak,
        pointCompress,
        liftX,
        getPublicKey,
        taggedHash,
        sha256: sha256Hash,
    };

    /**
     * A fundamental building block of Ethereum is the underlying cryptographic primitives.
     */
    /**
     * Once called, prevents any future change to the underlying cryptographic primitives using the `.register` feature for
     * hooks.
     *
     * @category Crypto
     */
    function lock() {
        computeHmac.lock();
        keccak256.lock();
        pbkdf2.lock();
        randomBytes.lock();
        ripemd160.lock();
        scrypt.lock();
        scryptSync.lock();
        sha256.lock();
        sha512.lock();
        randomBytes.lock();
    }

    function formatMixedCaseChecksumAddress(address) {
        address = address.toLowerCase();
        const chars = address.substring(2).split('');
        const expanded = new Uint8Array(40);
        for (let i = 0; i < 40; i++) {
            expanded[i] = chars[i].charCodeAt(0);
        }
        const hashed = getBytes(keccak256(expanded));
        for (let i = 0; i < 40; i += 2) {
            if (hashed[i >> 1] >> 4 >= 8) {
                chars[i] = chars[i].toUpperCase();
            }
            if ((hashed[i >> 1] & 0x0f) >= 8) {
                chars[i + 1] = chars[i + 1].toUpperCase();
            }
        }
        return '0x' + chars.join('');
    }
    /**
     * Returns a normalized and checksumed address for `address`. This accepts non-checksum addressesa and checksum
     * addresses.
     *
     * The checksum in Quai uses the capitalization (upper-case vs lower-case) of the characters within an address to encode
     * its checksum, which offers, on average, a checksum of 15-bits.
     *
     * If `address` contains both upper-case and lower-case, it is assumed to already be a checksum address and its checksum
     * is validated, and if the address fails its expected checksum an error is thrown.
     *
     * If you wish the checksum of `address` to be ignore, it should be converted to lower-case (i.e. `.toLowercase()`)
     * before being passed in. This should be a very rare situation though, that you wish to bypass the safeguards in place
     * to protect against an address that has been incorrectly copied from another source.
     *
     * @category Address
     * @example
     *
     * ```js
     * // Adds the checksum (via upper-casing specific letters)
     * getAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');
     *
     * // Throws an error if an address contains mixed case,
     * // but the checksum fails
     * getAddress('0x8Ba1f109551bD432803012645Ac136ddd64DBA72');
     * ```
     */
    function getAddress(address) {
        assertArgument(typeof address === 'string', 'invalid address', 'address', address);
        if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
            // Missing the 0x prefix
            if (!address.startsWith('0x')) {
                address = '0x' + address;
            }
            const result = formatMixedCaseChecksumAddress(address);
            // If original address is mix cased and recomputed version doesn't
            // match the original this could indicate a potential typo or mispaste.
            assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, 'invalid address checksum', 'address', address);
            return result;
        }
        assertArgument(false, 'invalid address string format', 'address', address);
    }
    function getContractAddress(from, nonce, data) {
        const nonceBytes = zeroPadValue(toBeHex(toBigInt(nonce)), 8);
        return getAddress(dataSlice(keccak256(concat([getAddress(from), nonceBytes, stripZerosLeft(data)])), 12));
    }
    /**
     * Returns the address for the `key`.
     *
     * The key may be any standard form of public key or a private key.
     *
     * @category Address
     * @param {string | SigningKey} key - The key to compute the address for.
     * @returns {string} The address.
     */
    function computeAddress(key) {
        let pubkey;
        if (typeof key === 'string') {
            pubkey = SigningKey.computePublicKey(key, false);
        }
        else {
            pubkey = key.publicKey;
        }
        return getAddress(keccak256('0x' + pubkey.substring(4)).substring(26));
    }
    /**
     * Returns the recovered address for the private key that was used to sign `digest` that resulted in `signature`.
     *
     * @category Address
     * @param {BytesLike} digest - The digest of the message.
     * @param {SignatureLike} signature - The signature.
     * @returns {string} The address.
     */
    function recoverAddress(digest, signature) {
        return computeAddress(SigningKey.recoverPublicKey(digest, signature));
    }

    /**
     * Returns true if `value` is an object which implements the [**Addressable**](../interfaces/Addressable) interface.
     *
     * @category Address
     * @example
     *
     * ```js
     * // Wallets and AbstractSigner sub-classes
     * isAddressable(Wallet.createRandom());
     *
     * // Contracts
     * contract = new Contract('0x643aA0A61eADCC9Cc202D1915D942d35D005400C', [], provider);
     * isAddressable(contract);
     * ```
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is an Addressable.
     */
    function isAddressable(value) {
        return value && typeof value.getAddress === 'function';
    }
    /**
     * Returns true if `value` is a valid address.
     *
     * @category Address
     * @example
     *
     * ```js
     * // Valid address
     * isAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72');
     *
     * // Invalid checksum
     * isAddress('0x8Ba1f109551bD432803012645Ac136ddd64DBa72');
     * ```
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is a valid address.
     */
    function isAddress(value) {
        try {
            getAddress(value);
            return true;
            // eslint-disable-next-line no-empty
        }
        catch (error) { }
        return false;
    }
    async function checkAddress(target, promise) {
        const result = await promise;
        if (result == null || result === '0x0000000000000000000000000000000000000000') {
            assertArgument(false, 'invalid AddressLike value; did not resolve to a value address', 'target', target);
        }
        return result;
    }
    /**
     * Resolves to an address for the `target`, which may be any supported address type, an
     * [**Addressable**](../interfaces/Addressable) or a Promise which resolves to an address.
     *
     * @category Address
     * @example
     *
     * ```js
     * addr = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
     *
     * // Addresses are return synchronously
     * resolveAddress(addr, provider);
     *
     * // Address promises are resolved asynchronously
     * resolveAddress(Promise.resolve(addr));
     *
     * // Addressable objects are resolved asynchronously
     * contract = new Contract(addr, []);
     * resolveAddress(contract, provider);
     * ```
     *
     * @param {AddressLike} target - The target to resolve to an address.
     * @returns {string | Promise<string>} The resolved address.
     */
    function resolveAddress(target) {
        if (typeof target === 'string') {
            if (target.match(/^0x[0-9a-f]{40}$/i)) {
                return target;
            }
        }
        else if (isAddressable(target)) {
            return checkAddress(target, target.getAddress());
        }
        else if (target && typeof target.then === 'function') {
            return checkAddress(target, target);
        }
        assertArgument(false, 'unsupported addressable value', 'target', target);
    }
    /**
     * Checks if the address is a valid mixed case checksummed address.
     *
     * @category Address
     * @param address - The address to validate.
     * @returns True if the address is a valid mixed case checksummed address.
     */
    function validateAddress(address) {
        assertArgument(typeof address === 'string', 'address must be string', 'address', address);
        assertArgument(Boolean(address.match(/^(0x)?[0-9a-fA-F]{40}$/)), 'invalid address string format', 'address', address);
        assertArgument(formatMixedCaseChecksumAddress(address) === address, 'invalid address checksum', 'address', address);
    }
    /**
     * Checks whether a given address is in the Qi ledger scope by checking the 9th bit of the address.
     *
     * @category Address
     * @param {string} address - The address to check
     * @returns {boolean} True if the address is in the Qi ledger scope, false otherwise.
     */
    function isQiAddress(address) {
        const secondByte = address.substring(4, 6);
        const binaryString = parseInt(secondByte, 16).toString(2).padStart(8, '0');
        const isUTXO = binaryString[0] === '1';
        return isUTXO;
    }
    /**
     * Checks whether a given address is in the Quai ledger scope by checking the 9th bit of the address.
     *
     * @category Address
     * @param {string} address - The address to check
     * @returns {boolean} True if the address is in the Quai ledger scope, false otherwise.
     */
    function isQuaiAddress(address) {
        return !isQiAddress(address);
    }

    /**
     * Retrieves the shard information for a given address based on its byte prefix. The function parses the address to
     * extract its byte prefix, then filters the ShardData to find a matching shard entry. If no matching shard is found, it
     * returns null.
     *
     * @category Utils
     * @param {string} address - The blockchain address to be analyzed. The address should start with "0x" followed by the
     *   hexadecimal representation.
     * @returns {Object | null} An object containing the shard information, or null if no
     */
    function getZoneForAddress(address) {
        try {
            return toZone(address.slice(0, 4));
        }
        catch (error) {
            return null;
        }
    }
    /**
     * Extracts both zone and UTXO information from a given blockchain address. This function first determines the address's
     * zone by its byte prefix, then checks the 9th bit of the address to ascertain if it's a UTXO or non-UTXO address.
     *
     * @category Utils
     * @param {string} address - The blockchain address to be analyzed, expected to start with "0x" followed by its
     *   hexadecimal representation.
     * @returns {Object | null} An object containing the zone and UTXO information, or null if no address is found.
     */
    function getAddressDetails(address) {
        const isQiLedger = (parseInt(address.substring(4, 5), 16) & 0x1) === exports.Ledger.Qi;
        return { zone: toZone(address.substring(0, 4)), ledger: isQiLedger ? exports.Ledger.Qi : exports.Ledger.Quai };
    }
    /**
     * Determines the transaction type based on the sender and recipient addresses. The function checks if both addresses
     * are UTXO addresses, in which case it returns 2. If only the sender address is a UTXO address, it returns 1.
     * Otherwise, it returns 0.
     *
     * @category Utils
     * @param {string | null} from - The sender address. If null, the function returns 0.
     * @param {string | null} to - The recipient address. If null, the function returns 0.
     * @returns {number} The transaction type based on the addresses.
     */
    function getTxType(from, to) {
        if (from === null || to === null)
            return 0;
        const senderAddressIsQi = isQiAddress(from);
        const recipientAddressIsQi = isQiAddress(to);
        switch (true) {
            case senderAddressIsQi && recipientAddressIsQi:
                return 2;
            case senderAddressIsQi && !recipientAddressIsQi:
                return 1;
            default:
                return 0;
        }
    }
    /**
     * Location of a chain within the Quai hierarchy
     *
     * Prime = [] region[0] = [0] zone[1,2] = [1, 2]
     *
     * @param shard - The shard to get the location for
     * @returns The location of the chain within the Quai hierarchy
     */
    function getNodeLocationFromZone(zone) {
        const zoneId = zone.slice(2);
        if (zoneId.length > 2) {
            throw new Error(`Invalid zone: ${zone}`);
        }
        else if (zoneId.length === 0) {
            return [];
        }
        return zoneId.split('').map(Number);
    }
    function getZoneFromNodeLocation(location) {
        if (location.length > 2) {
            throw new Error('Invalid location');
        }
        return toZone(`0x${location.join('')}`);
    }

    /**
     * @ignore
     */
    const WordSize = 32;
    const Padding = new Uint8Array(WordSize);
    // Properties used to immediate pass through to the underlying object
    // - `then` is used to detect if an object is a Promise for await
    const passProperties$1 = ['then'];
    const _guard$5 = {};
    function throwError(name, error) {
        const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
        wrapped.error = error;
        throw wrapped;
    }
    /**
     * A {@link Result | **Result**} is a sub-class of Array, which allows accessing any of its values either positionally by
     * its index or, if keys are provided by its name.
     *
     * @category Application Binary Interface
     */
    class Result extends Array {
        #names;
        /**
         * @ignore
         */
        constructor(...args) {
            // To properly sub-class Array so the other built-in
            // functions work, the constructor has to behave fairly
            // well. So, in the event we are created via fromItems()
            // we build the read-only Result object we want, but on
            // any other input, we use the default constructor
            // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
            const guard = args[0];
            let items = args[1];
            let names = (args[2] || []).slice();
            let wrap = true;
            if (guard !== _guard$5) {
                items = args;
                names = [];
                wrap = false;
            }
            // Can't just pass in ...items since an array of length 1
            // is a special case in the super.
            super(items.length);
            items.forEach((item, index) => {
                this[index] = item;
            });
            // Find all unique keys
            const nameCounts = names.reduce((accum, name) => {
                if (typeof name === 'string') {
                    accum.set(name, (accum.get(name) || 0) + 1);
                }
                return accum;
            }, new Map());
            // Remove any key thats not unique
            this.#names = Object.freeze(items.map((item, index) => {
                const name = names[index];
                if (name != null && nameCounts.get(name) === 1) {
                    return name;
                }
                return null;
            }));
            if (!wrap) {
                return;
            }
            // A wrapped Result is immutable
            Object.freeze(this);
            // Proxy indices and names so we can trap deferred errors
            return new Proxy(this, {
                get: (target, prop, receiver) => {
                    if (typeof prop === 'string') {
                        // Index accessor
                        if (prop.match(/^[0-9]+$/)) {
                            const index = getNumber(prop, '%index');
                            if (index < 0 || index >= this.length) {
                                throw new RangeError('out of result range');
                            }
                            const item = target[index];
                            if (item instanceof Error) {
                                throwError(`index ${index}`, item);
                            }
                            return item;
                        }
                        // Pass important checks (like `then` for Promise) through
                        if (passProperties$1.indexOf(prop) >= 0) {
                            return Reflect.get(target, prop, receiver);
                        }
                        const value = target[prop];
                        if (value instanceof Function) {
                            // Make sure functions work with private variables
                            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                            return function (...args) {
                                return value.apply(this === receiver ? target : this, args);
                            };
                        }
                        else if (!(prop in target)) {
                            // Possible name accessor
                            return target.getValue.apply(this === receiver ? target : this, [prop]);
                        }
                    }
                    return Reflect.get(target, prop, receiver);
                },
            });
        }
        /**
         * Returns the Result as a normal Array.
         *
         * This will throw if there are any outstanding deferred errors.
         */
        toArray() {
            const result = [];
            this.forEach((item, index) => {
                if (item instanceof Error) {
                    throwError(`index ${index}`, item);
                }
                result.push(item);
            });
            return result;
        }
        /**
         * Returns the Result as an Object with each name-value pair.
         *
         * This will throw if any value is unnamed, or if there are any outstanding deferred errors.
         */
        toObject() {
            return this.#names.reduce(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (accum, name, index) => {
                assert$1(name != null, 'value at index ${ index } unnamed', 'UNSUPPORTED_OPERATION', {
                    operation: 'toObject()',
                });
                // Add values for names that don't conflict
                if (!(name in accum)) {
                    accum[name] = this.getValue(name);
                }
                return accum;
            }, {});
        }
        /**
         * @ignore
         */
        slice(start, end) {
            if (start == null) {
                start = 0;
            }
            if (start < 0) {
                start += this.length;
                if (start < 0) {
                    start = 0;
                }
            }
            if (end == null) {
                end = this.length;
            }
            if (end < 0) {
                end += this.length;
                if (end < 0) {
                    end = 0;
                }
            }
            if (end > this.length) {
                end = this.length;
            }
            const result = [], names = [];
            for (let i = start; i < end; i++) {
                result.push(this[i]);
                names.push(this.#names[i]);
            }
            return new Result(_guard$5, result, names);
        }
        /**
         * @ignore
         */
        filter(callback, thisArg) {
            const result = [], names = [];
            for (let i = 0; i < this.length; i++) {
                const item = this[i];
                if (item instanceof Error) {
                    throwError(`index ${i}`, item);
                }
                if (callback.call(thisArg, item, i, this)) {
                    result.push(item);
                    names.push(this.#names[i]);
                }
            }
            return new Result(_guard$5, result, names);
        }
        /**
         * @ignore
         */
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint
        map(callback, thisArg) {
            const result = [];
            for (let i = 0; i < this.length; i++) {
                const item = this[i];
                if (item instanceof Error) {
                    throwError(`index ${i}`, item);
                }
                result.push(callback.call(thisArg, item, i, this));
            }
            return result;
        }
        /**
         * Returns the value for `name`.
         *
         * Since it is possible to have a key whose name conflicts with a method on a {@link Result | **Result**} or its
         * superclass Array, or any JavaScript keyword, this ensures all named values are still accessible by name.
         *
         * @param {string} name - The name of the value to retrieve.
         *
         * @returns The value for `name`.
         */
        getValue(name) {
            const index = this.#names.indexOf(name);
            if (index === -1) {
                return undefined;
            }
            const value = this[index];
            if (value instanceof Error) {
                throwError(`property ${JSON.stringify(name)}`, value.error);
            }
            return value;
        }
        /**
         * Creates a new {@link Result | **Result**} for `items` with each entry also accessible by its corresponding name in
         * `keys`.
         *
         * @param {any[]} items - The items to include in the Result.
         * @param {(null | string)[]} [keys] - The names for each item in `items`.
         *
         * @returns The new Result.
         */
        static fromItems(items, keys) {
            return new Result(_guard$5, items, keys);
        }
    }
    /**
     * Returns all errors found in a {@link Result | **Result**}.
     *
     * Since certain errors encountered when creating a {@link Result | **Result**} do not impact the ability to continue
     * parsing data, they are deferred until they are actually accessed. Hence a faulty string in an Event that is never
     * used does not impact the program flow.
     *
     * However, sometimes it may be useful to access, identify or validate correctness of a {@link Result | **Result**}.
     *
     * @category Application Binary Interface
     * @param {Result} result - The Result to check for errors.
     *
     * @returns An array of objects with the path to the error and the error itself.
     */
    function checkResultErrors(result) {
        // Find the first error (if any)
        const errors = [];
        const checkErrors = function (path, object) {
            if (!Array.isArray(object)) {
                return;
            }
            for (const key in object) {
                const childPath = path.slice();
                childPath.push(key);
                try {
                    checkErrors(childPath, object[key]);
                }
                catch (error) {
                    errors.push({ path: childPath, error: error });
                }
            }
        };
        checkErrors([], result);
        return errors;
    }
    function getValue$1(value) {
        let bytes = toBeArray(value);
        assert$1(bytes.length <= WordSize, 'value out-of-bounds', 'BUFFER_OVERRUN', {
            buffer: bytes,
            length: WordSize,
            offset: bytes.length,
        });
        if (bytes.length !== WordSize) {
            bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
        }
        return bytes;
    }
    /**
     * @ignore
     */
    class Coder {
        // The coder name:
        //   - address, uint256, tuple, array, etc.
        name;
        // The fully expanded type, including composite types:
        //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
        type;
        // The localName bound in the signature, in this example it is "baz":
        //   - tuple(address foo, uint bar) baz
        localName;
        // Whether this type is dynamic:
        //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
        //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
        dynamic;
        constructor(name, type, localName, dynamic) {
            defineProperties(this, { name, type, localName, dynamic }, {
                name: 'string',
                type: 'string',
                localName: 'string',
                dynamic: 'boolean',
            });
        }
        _throwError(message, value) {
            assertArgument(false, message, this.localName, value);
        }
    }
    /**
     * @ignore
     */
    class Writer {
        // An array of WordSize lengthed objects to concatenation
        #data;
        #dataLength;
        constructor() {
            this.#data = [];
            this.#dataLength = 0;
        }
        get data() {
            return concat(this.#data);
        }
        get length() {
            return this.#dataLength;
        }
        #writeData(data) {
            this.#data.push(data);
            this.#dataLength += data.length;
            return data.length;
        }
        appendWriter(writer) {
            return this.#writeData(getBytesCopy(writer.data));
        }
        // Arrayish item; pad on the right to *nearest* WordSize
        writeBytes(value) {
            let bytes = getBytesCopy(value);
            const paddingOffset = bytes.length % WordSize;
            if (paddingOffset) {
                bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
            }
            return this.#writeData(bytes);
        }
        // Numeric item; pad on the left *to* WordSize
        writeValue(value) {
            return this.#writeData(getValue$1(value));
        }
        // Inserts a numeric place-holder, returning a callback that can
        // be used to asjust the value later
        writeUpdatableValue() {
            const offset = this.#data.length;
            this.#data.push(Padding);
            this.#dataLength += WordSize;
            return (value) => {
                this.#data[offset] = getValue$1(value);
            };
        }
    }
    /**
     * @ignore
     */
    class Reader {
        // Allows incomplete unpadded data to be read; otherwise an error
        // is raised if attempting to overrun the buffer. This is required
        // to deal with an old Solidity bug, in which event data for
        // external (not public thoguh) was tightly packed.
        allowLoose;
        #data;
        #offset;
        #bytesRead;
        #parent;
        #maxInflation;
        constructor(data, allowLoose, maxInflation) {
            defineProperties(this, { allowLoose: !!allowLoose });
            this.#data = getBytesCopy(data);
            this.#bytesRead = 0;
            this.#parent = null;
            this.#maxInflation = maxInflation != null ? maxInflation : 1024;
            this.#offset = 0;
        }
        get data() {
            return hexlify(this.#data);
        }
        get dataLength() {
            return this.#data.length;
        }
        get consumed() {
            return this.#offset;
        }
        get bytes() {
            return new Uint8Array(this.#data);
        }
        #incrementBytesRead(count) {
            if (this.#parent) {
                return this.#parent.#incrementBytesRead(count);
            }
            this.#bytesRead += count;
            // Check for excessive inflation (see: #4537)
            assert$1(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, 
            // eslint-disable-next-line no-useless-escape
            `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`, 'BUFFER_OVERRUN', {
                buffer: getBytesCopy(this.#data),
                offset: this.#offset,
                length: count,
                info: {
                    bytesRead: this.#bytesRead,
                    dataLength: this.dataLength,
                },
            });
        }
        #peekBytes(offset, length, loose) {
            let alignedLength = Math.ceil(length / WordSize) * WordSize;
            if (this.#offset + alignedLength > this.#data.length) {
                if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
                    alignedLength = length;
                }
                else {
                    assert$1(false, 'data out-of-bounds', 'BUFFER_OVERRUN', {
                        buffer: getBytesCopy(this.#data),
                        length: this.#data.length,
                        offset: this.#offset + alignedLength,
                    });
                }
            }
            return this.#data.slice(this.#offset, this.#offset + alignedLength);
        }
        // Create a sub-reader with the same underlying data, but offset
        subReader(offset) {
            const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
            reader.#parent = this;
            return reader;
        }
        // Read bytes
        readBytes(length, loose) {
            const bytes = this.#peekBytes(0, length, !!loose);
            this.#incrementBytesRead(length);
            this.#offset += bytes.length;
            // @TODO: Make sure the length..end bytes are all 0?
            return bytes.slice(0, length);
        }
        // Read a numeric values
        readValue() {
            return toBigInt(this.readBytes(WordSize));
        }
        readIndex() {
            return toNumber(this.readBytes(WordSize));
        }
    }

    // http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
    /**
     * Returns the address that would result from a `CREATE` for `tx`.
     *
     * This can be used to compute the address a contract will be deployed to by an EOA when sending a deployment
     * transaction (i.e. when the `to` address is `null`).
     *
     * This can also be used to compute the address a contract will be deployed to by a contract, by using the contract's
     * address as the `to` and the contract's nonce.
     *
     * @category Address
     * @example
     *
     * ```js
     * from = '0x8ba1f109551bD432803012645Ac136ddd64DBA72';
     * nonce = 5;
     *
     * getCreateAddress({ from, nonce });
     * ```
     *
     * @param {object} tx - The transaction object.
     * @param {string} tx.from - The address of the sender.
     * @param {BigNumberish} tx.nonce - The nonce of the sender.
     * @param {string} [tx.data] - The data of the transaction.
     */
    function getCreateAddress(tx) {
        const from = getAddress(tx.from);
        const nonce = getBigInt(tx.nonce, 'tx.nonce');
        const nonceBytes = bigEndianNonce(nonce);
        const fromBytes = getBytes(from);
        const codeBytes = tx.data ? getBytes(tx.data) : new Uint8Array();
        const concatenated = new Uint8Array([...fromBytes, ...nonceBytes, ...codeBytes]);
        const hash = keccak256(concatenated);
        return getAddress(dataSlice(hash, 12));
    }
    /**
     * Returns the address that would result from a `CREATE2` operation with the given `from`, `salt` and `initCodeHash`.
     *
     * To compute the `initCodeHash` from a contract's init code, use the [**keccak256**](../functions/keccak256) function.
     *
     * For a quick overview and example of `CREATE2`, see [Wisps: The Magical World of
     * Create2](https://blog.ricmoo.com/wisps-the-magical-world-of-create2-5c2177027604).
     *
     * @category Address
     * @example
     *
     * ```js
     * // The address of the contract
     * from = '0x8ba1f109551bD432803012645Ac136ddd64DBA72';
     *
     * // The salt
     * salt = id('HelloWorld');
     *
     * // The hash of the initCode
     * initCode = '0x6394198df16000526103ff60206004601c335afa6040516060f3';
     * initCodeHash = keccak256(initCode);
     *
     * getCreate2Address(from, salt, initCodeHash);
     * ```
     *
     * @param {string} _from - The address of the sender.
     * @param {BytesLike} _salt - The salt value.
     * @param {BytesLike} _initCodeHash - The hash of the init code.
     * @returns {string} The computed address.
     * @throws {Error} If the salt is not exactly 32 bytes long.
     * @throws {Error} If the initCodeHash is not exactly 32 bytes long.
     */
    function getCreate2Address(_from, _salt, _initCodeHash) {
        const from = getAddress(_from);
        const salt = getBytes(_salt, 'salt');
        const initCodeHash = getBytes(_initCodeHash, 'initCodeHash');
        assertArgument(salt.length === 32, 'salt must be 32 bytes', 'salt', _salt);
        assertArgument(initCodeHash.length === 32, 'initCodeHash must be 32 bytes', 'initCodeHash', _initCodeHash);
        return getAddress(dataSlice(keccak256(concat(['0xff', from, salt, initCodeHash])), 12));
    }
    // Helper function to convert a BigInt nonce to a big-endian byte array
    function bigEndianNonce(nonce) {
        const buffer = new ArrayBuffer(8);
        const view = new DataView(buffer);
        view.setBigUint64(0, nonce, false);
        return new Uint8Array(buffer);
    }

    /**
     * A Typed object allows a value to have its type explicitly specified.
     *
     * For example, in Solidity, the value `45` could represent a `uint8` or a `uint256`. The value `0x1234` could represent
     * a `bytes2` or `bytes`.
     *
     * Since JavaScript has no meaningful way to explicitly inform any APIs which what the type is, this allows transparent
     * interoperation with Soldity.
     *
     * @category Application Binary Interface
     */
    const _guard$4 = {};
    function n(value, width) {
        let signed = false;
        if (width < 0) {
            signed = true;
            width *= -1;
        }
        // @TODO: Check range is valid for value
        return new Typed(_guard$4, `${signed ? '' : 'u'}int${width}`, value, { signed, width });
    }
    function b(value, size) {
        // @TODO: Check range is valid for value
        return new Typed(_guard$4, `bytes${size ? size : ''}`, value, { size });
    }
    const _typedSymbol = Symbol.for('_quais_typed');
    /**
     * The **Typed** class to wrap values providing explicit type information.
     *
     * @category Application Binary Interface
     */
    class Typed {
        /**
         * The type, as a Solidity-compatible type.
         */
        type;
        /**
         * The actual value.
         */
        value;
        #options;
        /**
         * @ignore
         */
        _typedSymbol;
        /**
         * @ignore
         */
        constructor(guard, type, value, options) {
            if (options == null) {
                options = null;
            }
            assertPrivate(_guard$4, guard, 'Typed');
            defineProperties(this, { _typedSymbol, type, value });
            this.#options = options;
            // Check the value is valid
            this.format();
        }
        /**
         * Format the type as a Human-Readable type.
         *
         * @returns The human-readable type for the provided type.
         * @throws If the type is array or dynamic array.
         */
        format() {
            if (this.type === 'array') {
                throw new Error('');
            }
            else if (this.type === 'dynamicArray') {
                throw new Error('');
            }
            else if (this.type === 'tuple') {
                return `tuple(${this.value.map((v) => v.format()).join(',')})`;
            }
            return this.type;
        }
        /**
         * The default value returned by this type.
         *
         * @returns The default value for this type.
         */
        defaultValue() {
            return 0;
        }
        /**
         * The minimum value for numeric types.
         *
         * @returns The minimum value for the provided numeric type.
         */
        minValue() {
            return 0;
        }
        /**
         * The maximum value for numeric types.
         *
         * @returns The maximum value for the provided numeric type.
         */
        maxValue() {
            return 0;
        }
        /**
         * Returns whether this is a {@link TypedBigInt | **TypedBigInt**}. If true, a type guard is provided.
         *
         * @returns `true` if this is a big integer.
         */
        isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
        }
        /**
         * Returns whether this is a {@link TypedData | **TypedData**}. If true, a type guard is provided.
         *
         * @returns {boolean} `true` if this is a number.
         */
        isData() {
            return this.type.startsWith('bytes');
        }
        /**
         * Return whether this is a {@link TypedString | **TypedString**}. If true, a type guard is provided.
         *
         * @returns {boolean} `true` if this is a string.
         */
        isString() {
            return this.type === 'string';
        }
        /**
         * Returns the tuple name.
         *
         * @returns {boolean} The tuple name if this is a tuple.
         * @throws If this is not a tuple.
         */
        get tupleName() {
            if (this.type !== 'tuple') {
                throw TypeError('not a tuple');
            }
            return this.#options;
        }
        /**
         * Returns the length of a typed array.
         *
         * @returns {number} The length of the array type or `-1` if it is dynamic.
         * @throws If this is not an array.
         */
        get arrayLength() {
            if (this.type !== 'array') {
                throw TypeError('not an array');
            }
            if (this.#options === true) {
                return -1;
            }
            if (this.#options === false) {
                return this.value.length;
            }
            return null;
        }
        /**
         * Returns a new **Typed** of `type` with the `value`.
         *
         * @param {string} type - The type to use.
         * @param {any} value - The value to use.
         */
        static from(type, value) {
            return new Typed(_guard$4, type, value);
        }
        /**
         * Return a new `uint8` type for v.
         *
         * @param {BigNumberish} v - The value to convert to a `uint8`.
         * @returns {uint8} A new `uint8` type for `v`.
         */
        static uint8(v) {
            return n(v, 8);
        }
        /**
         * Return a new `uint16` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint16`.
         * @returns A new `uint16` type for `v`.
         */
        static uint16(v) {
            return n(v, 16);
        }
        /**
         * Return a new `uint24` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint24`.
         * @returns A new `uint24` type for `v`.
         */
        static uint24(v) {
            return n(v, 24);
        }
        /**
         * Return a new `uint32` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint32`.
         * @returns A new `uint32` type for `v`.
         */
        static uint32(v) {
            return n(v, 32);
        }
        /**
         * Return a new `uint40` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint40`.
         * @returns A new `uint40` type for `v`.
         */
        static uint40(v) {
            return n(v, 40);
        }
        /**
         * Return a new `uint48` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint48`.
         * @returns A new `uint48` type for `v`.
         */
        static uint48(v) {
            return n(v, 48);
        }
        /**
         * Return a new `uint56` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint56`.
         * @returns A new `uint56` type for `v`.
         */
        static uint56(v) {
            return n(v, 56);
        }
        /**
         * Return a new `uint64` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint64`.
         * @returns A new `uint64` type for `v`.
         */
        static uint64(v) {
            return n(v, 64);
        }
        /**
         * Return a new `uint72` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint72`.
         * @returns A new `uint72` type for `v`.
         */
        static uint72(v) {
            return n(v, 72);
        }
        /**
         * Return a new `uint80` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint80`.
         * @returns A new `uint80` type for `v`.
         */
        static uint80(v) {
            return n(v, 80);
        }
        /**
         * Return a new `uint88` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint88`.
         * @returns A new `uint88` type for `v`.
         */
        static uint88(v) {
            return n(v, 88);
        }
        /**
         * Return a new `uint96` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint96`.
         * @returns A new `uint96` type for `v`.
         */
        static uint96(v) {
            return n(v, 96);
        }
        /**
         * Return a new `uint104` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint104`.
         * @returns A new `uint104` type for `v`.
         */
        static uint104(v) {
            return n(v, 104);
        }
        /**
         * Return a new `uint112` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint112`.
         * @returns A new `uint112` type for `v`.
         */
        static uint112(v) {
            return n(v, 112);
        }
        /**
         * Return a new `uint120` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint120`.
         * @returns A new `uint120` type for `v`.
         */
        static uint120(v) {
            return n(v, 120);
        }
        /**
         * Return a new `uint128` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint128`.
         * @returns A new `uint128` type for `v`.
         */
        static uint128(v) {
            return n(v, 128);
        }
        /**
         * Return a new `uint136` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint136`.
         * @returns A new `uint136` type for `v`.
         */
        static uint136(v) {
            return n(v, 136);
        }
        /**
         * Return a new `uint144` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint144`.
         * @returns A new `uint144` type for `v`.
         */
        static uint144(v) {
            return n(v, 144);
        }
        /**
         * Return a new `uint152` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint152`.
         * @returns A new `uint152` type for `v`.
         */
        static uint152(v) {
            return n(v, 152);
        }
        /**
         * Return a new `uint160` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint160`.
         * @returns A new `uint160` type for `v`.
         */
        static uint160(v) {
            return n(v, 160);
        }
        /**
         * Return a new `uint168` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint168`.
         * @returns A new `uint168` type for `v`.
         */
        static uint168(v) {
            return n(v, 168);
        }
        /**
         * Return a new `uint176` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint176`.
         * @returns A new `uint176` type for `v`.
         */
        static uint176(v) {
            return n(v, 176);
        }
        /**
         * Return a new `uint184` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint184`.
         * @returns A new `uint184` type for `v`.
         */
        static uint184(v) {
            return n(v, 184);
        }
        /**
         * Return a new `uint192` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint192`.
         * @returns A new `uint192` type for `v`.
         */
        static uint192(v) {
            return n(v, 192);
        }
        /**
         * Return a new `uint200` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint200`.
         * @returns A new `uint200` type for `v`.
         */
        static uint200(v) {
            return n(v, 200);
        }
        /**
         * Return a new `uint208` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint208`.
         * @returns A new `uint208` type for `v`.
         */
        static uint208(v) {
            return n(v, 208);
        }
        /**
         * Return a new `uint216` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint216`.
         * @returns A new `uint216` type for `v`.
         */
        static uint216(v) {
            return n(v, 216);
        }
        /**
         * Return a new `uint224` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint224`.
         * @returns A new `uint224` type for `v`.
         */
        static uint224(v) {
            return n(v, 224);
        }
        /**
         * Return a new `uint232` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint232`.
         * @returns A new `uint232` type for `v`.
         */
        static uint232(v) {
            return n(v, 232);
        }
        /**
         * Return a new `uint240` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint240`.
         * @returns A new `uint240` type for `v`.
         */
        static uint240(v) {
            return n(v, 240);
        }
        /**
         * Return a new `uint248` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint248`.
         * @returns A new `uint248` type for `v`.
         */
        static uint248(v) {
            return n(v, 248);
        }
        /**
         * Return a new `uint256` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint256`.
         * @returns A new `uint256` type for `v`.
         */
        static uint256(v) {
            return n(v, 256);
        }
        /**
         * Return a new `uint256` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to a `uint256`.
         * @returns A new `uint256` type for `v`.
         */
        static uint(v) {
            return n(v, 256);
        }
        /**
         * Return a new `int8` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int8`.
         * @returns A new `int8` type for `v`.
         */
        static int8(v) {
            return n(v, -8);
        }
        /**
         * Return a new `int16` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int16`.
         * @returns A new `int16` type for `v`.
         */
        static int16(v) {
            return n(v, -16);
        }
        /**
         * Return a new `int24` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int24`.
         * @returns A new `int24` type for `v`.
         */
        static int24(v) {
            return n(v, -24);
        }
        /**
         * Return a new `int32` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int32`.
         * @returns A new `int32` type for `v`.
         */
        static int32(v) {
            return n(v, -32);
        }
        /**
         * Return a new `int40` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int40`.
         * @returns A new `int40` type for `v`.
         */
        static int40(v) {
            return n(v, -40);
        }
        /**
         * Return a new `int48` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int48`.
         * @returns A new `int48` type for `v`.
         */
        static int48(v) {
            return n(v, -48);
        }
        /**
         * Return a new `int56` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int56`.
         * @returns A new `int56` type for `v`.
         */
        static int56(v) {
            return n(v, -56);
        }
        /**
         * Return a new `int64` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int64`.
         * @returns A new `int64` type for `v`.
         */
        static int64(v) {
            return n(v, -64);
        }
        /**
         * Return a new `int72` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int72`.
         * @returns A new `int72` type for `v`.
         */
        static int72(v) {
            return n(v, -72);
        }
        /**
         * Return a new `int80` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int80`.
         * @returns A new `int80` type for `v`.
         */
        static int80(v) {
            return n(v, -80);
        }
        /**
         * Return a new `int88` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int88`.
         * @returns A new `int88` type for `v`.
         */
        static int88(v) {
            return n(v, -88);
        }
        /**
         * Return a new `int96` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int96`.
         * @returns A new `int96` type for `v`.
         */
        static int96(v) {
            return n(v, -96);
        }
        /**
         * Return a new `int104` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int104`.
         * @returns A new `int104` type for `v`.
         */
        static int104(v) {
            return n(v, -104);
        }
        /**
         * Return a new `int112` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int112`.
         * @returns A new `int112` type for `v`.
         */
        static int112(v) {
            return n(v, -112);
        }
        /**
         * Return a new `int120` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int120`.
         * @returns A new `int120` type for `v`.
         */
        static int120(v) {
            return n(v, -120);
        }
        /**
         * Return a new `int128` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int128`.
         * @returns A new `int128` type for `v`.
         */
        static int128(v) {
            return n(v, -128);
        }
        /**
         * Return a new `int136` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int136`.
         * @returns A new `int136` type for `v`.
         */
        static int136(v) {
            return n(v, -136);
        }
        /**
         * Return a new `int144` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int144`.
         * @returns A new `int144` type for `v`.
         */
        static int144(v) {
            return n(v, -144);
        }
        /**
         * Return a new `int152` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int152`.
         * @returns A new `int152` type for `v`.
         */
        static int152(v) {
            return n(v, -152);
        }
        /**
         * Return a new `int160` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int160`.
         * @returns A new `int160` type for `v`.
         */
        static int160(v) {
            return n(v, -160);
        }
        /**
         * Return a new `int168` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int168`.
         * @returns A new `int168` type for `v`.
         */
        static int168(v) {
            return n(v, -168);
        }
        /**
         * Return a new `int176` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int176`.
         * @returns A new `int176` type for `v`.
         */
        static int176(v) {
            return n(v, -176);
        }
        /**
         * Return a new `int184` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int184`.
         * @returns A new `int184` type for `v`.
         */
        static int184(v) {
            return n(v, -184);
        }
        /**
         * Return a new `int192` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int192`.
         * @returns A new `int192` type for `v`.
         */
        static int192(v) {
            return n(v, -192);
        }
        /**
         * Return a new `int200` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int200`.
         * @returns A new `int200` type for `v`.
         */
        static int200(v) {
            return n(v, -200);
        }
        /**
         * Return a new `int208` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int208`.
         * @returns A new `int208` type for `v`.
         */
        static int208(v) {
            return n(v, -208);
        }
        /**
         * Return a new `int216` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int216`.
         * @returns A new `int216` type for `v`.
         */
        static int216(v) {
            return n(v, -216);
        }
        /**
         * Return a new `int224` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int224`.
         * @returns A new `int224` type for `v`.
         */
        static int224(v) {
            return n(v, -224);
        }
        /**
         * Return a new `int232` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int232`.
         * @returns A new `int232` type for `v`.
         */
        static int232(v) {
            return n(v, -232);
        }
        /**
         * Return a new `int240` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int240`.
         * @returns A new `int240` type for `v`.
         */
        static int240(v) {
            return n(v, -240);
        }
        /**
         * Return a new `int248` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int248`.
         * @returns A new `int248` type for `v`.
         */
        static int248(v) {
            return n(v, -248);
        }
        /**
         * Return a new `int256` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int256`.
         * @returns A new `int256` type for `v`.
         */
        static int256(v) {
            return n(v, -256);
        }
        /**
         * Return a new `int256` type for `v`.
         *
         * @param {BigNumberish} v - The value to convert to an `int256`.
         * @returns A new `int256` type for `v`.
         */
        static int(v) {
            return n(v, -256);
        }
        /**
         * Return a new `bytes1` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes1`.
         * @returns A new `bytes1` type for `v`.
         */
        static bytes1(v) {
            return b(v, 1);
        }
        /**
         * Return a new `bytes2` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes2`.
         * @returns A new `bytes2` type for `v`.
         */
        static bytes2(v) {
            return b(v, 2);
        }
        /**
         * Return a new `bytes3` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes3`.
         * @returns A new `bytes3` type for `v`.
         */
        static bytes3(v) {
            return b(v, 3);
        }
        /**
         * Return a new `bytes4` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes4`.
         * @returns A new `bytes4` type for `v`.
         */
        static bytes4(v) {
            return b(v, 4);
        }
        /**
         * Return a new `bytes5` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes5`.
         * @returns A new `bytes5` type for `v`.
         */
        static bytes5(v) {
            return b(v, 5);
        }
        /**
         * Return a new `bytes6` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes6`.
         * @returns A new `bytes6` type for `v`.
         */
        static bytes6(v) {
            return b(v, 6);
        }
        /**
         * Return a new `bytes7` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes7`.
         * @returns A new `bytes7` type for `v`.
         */
        static bytes7(v) {
            return b(v, 7);
        }
        /**
         * Return a new `bytes8` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes8`.
         * @returns A new `bytes8` type for `v`.
         */
        static bytes8(v) {
            return b(v, 8);
        }
        /**
         * Return a new `bytes9` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes9`.
         * @returns A new `bytes9` type for `v`.
         */
        static bytes9(v) {
            return b(v, 9);
        }
        /**
         * Return a new `bytes10` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes10`.
         * @returns A new `bytes10` type for `v`.
         */
        static bytes10(v) {
            return b(v, 10);
        }
        /**
         * Return a new `bytes11` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes11`.
         * @returns A new `bytes11` type for `v`.
         */
        static bytes11(v) {
            return b(v, 11);
        }
        /**
         * Return a new `bytes12` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes12`.
         * @returns A new `bytes12` type for `v`.
         */
        static bytes12(v) {
            return b(v, 12);
        }
        /**
         * Return a new `bytes13` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes13`.
         * @returns A new `bytes13` type for `v`.
         */
        static bytes13(v) {
            return b(v, 13);
        }
        /**
         * Return a new `bytes14` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes14`.
         * @returns A new `bytes14` type for `v`.
         */
        static bytes14(v) {
            return b(v, 14);
        }
        /**
         * Return a new `bytes15` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes15`.
         * @returns A new `bytes15` type for `v`.
         */
        static bytes15(v) {
            return b(v, 15);
        }
        /**
         * Return a new `bytes16` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes16`.
         * @returns A new `bytes16` type for `v`.
         */
        static bytes16(v) {
            return b(v, 16);
        }
        /**
         * Return a new `bytes17` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes17`.
         * @returns A new `bytes17` type for `v`.
         */
        static bytes17(v) {
            return b(v, 17);
        }
        /**
         * Return a new `bytes18` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes18`.
         * @returns A new `bytes18` type for `v`.
         */
        static bytes18(v) {
            return b(v, 18);
        }
        /**
         * Return a new `bytes19` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes19`.
         * @returns A new `bytes19` type for `v`.
         */
        static bytes19(v) {
            return b(v, 19);
        }
        /**
         * Return a new `bytes20` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes20`.
         * @returns A new `bytes20` type for `v`.
         */
        static bytes20(v) {
            return b(v, 20);
        }
        /**
         * Return a new `bytes21` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes21`.
         * @returns A new `bytes21` type for `v`.
         */
        static bytes21(v) {
            return b(v, 21);
        }
        /**
         * Return a new `bytes22` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes22`.
         * @returns A new `bytes22` type for `v`.
         */
        static bytes22(v) {
            return b(v, 22);
        }
        /**
         * Return a new `bytes23` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes23`.
         * @returns A new `bytes23` type for `v`.
         */
        static bytes23(v) {
            return b(v, 23);
        }
        /**
         * Return a new `bytes24` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes24`.
         * @returns A new `bytes24` type for `v`.
         */
        static bytes24(v) {
            return b(v, 24);
        }
        /**
         * Return a new `bytes25` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes25`.
         * @returns A new `bytes25` type for `v`.
         */
        static bytes25(v) {
            return b(v, 25);
        }
        /**
         * Return a new `bytes26` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes26`.
         * @returns A new `bytes26` type for `v`.
         */
        static bytes26(v) {
            return b(v, 26);
        }
        /**
         * Return a new `bytes27` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes27`.
         * @returns A new `bytes27` type for `v`.
         */
        static bytes27(v) {
            return b(v, 27);
        }
        /**
         * Return a new `bytes28` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes28`.
         * @returns A new `bytes28` type for `v`.
         */
        static bytes28(v) {
            return b(v, 28);
        }
        /**
         * Return a new `bytes29` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes29`.
         * @returns A new `bytes29` type for `v`.
         */
        static bytes29(v) {
            return b(v, 29);
        }
        /**
         * Return a new `bytes30` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes30`.
         * @returns A new `bytes30` type for `v`.
         */
        static bytes30(v) {
            return b(v, 30);
        }
        /**
         * Return a new `bytes31` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes31`.
         * @returns A new `bytes31` type for `v`.
         */
        static bytes31(v) {
            return b(v, 31);
        }
        /**
         * Return a new `bytes32` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes32`.
         * @returns A new `bytes32` type for `v`.
         */
        static bytes32(v) {
            return b(v, 32);
        }
        /**
         * Return a new `address` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to an `address`.
         * @returns A new `address` type for `v`.
         */
        static address(v) {
            return new Typed(_guard$4, 'address', v);
        }
        /**
         * Return a new `bool` type for `v`.
         *
         * @param {any} v - The value to convert to a `bool`.
         * @returns A new `bool` type for `v`.
         */
        static bool(v) {
            return new Typed(_guard$4, 'bool', !!v);
        }
        /**
         * Return a new `bytes` type for `v`.
         *
         * @param {BytesLike} v - The value to convert to a `bytes`.
         * @returns A new `bytes` type for `v`.
         */
        static bytes(v) {
            return new Typed(_guard$4, 'bytes', v);
        }
        /**
         * Return a new `string` type for `v`.
         *
         * @param {string} v - The value to convert to a `string`.
         * @returns A new `string` type for `v`.
         */
        static string(v) {
            return new Typed(_guard$4, 'string', v);
        }
        /**
         * Return a new `array` type for v, allowing dynamic length.
         *
         * @param {(any | Typed)[]} v - The value to convert to an `array`.
         * @param {null | boolean} dynamic - Whether the array is dynamic.
         * @returns A new `array` type for `v`.
         */
        static array(v, dynamic) {
            throw new Error('not implemented yet');
        }
        /**
         * Return a new `tuple` type for v, with the optional name.
         *
         * @param {(any | Typed)[]} v - The value to convert to a `tuple`.
         * @param {string} name - The name of the tuple.
         * @returns A new `tuple` type for `v`.
         */
        static tuple(v, name) {
            throw new Error('not implemented yet');
        }
        /**
         * Return a new `overrides` type with the provided properties.
         *
         * @param {Record<string, any>} v - A record containing the properties to be included in the `overrides` type.
         * @returns A new `overrides` type with the given properties.
         */
        static overrides(v) {
            return new Typed(_guard$4, 'overrides', Object.assign({}, v));
        }
        /**
         * Returns true only if `value` is a {@link Typed | **Typed**} instance.
         *
         * @param {any} value - The value to check.
         * @returns {boolean} True if `value` is a {@link Typed | **Typed**} instance.
         */
        static isTyped(value) {
            return value && typeof value === 'object' && '_typedSymbol' in value && value._typedSymbol === _typedSymbol;
        }
        /**
         * If the value is a {@link Typed | **Typed**} instance, validates the underlying value and returns it, otherwise
         * returns value directly.
         *
         * This is useful for functions that with to accept either a {@link Typed | **Typed**} object or values.
         *
         * @param {Typed | T} value - The value to dereference.
         * @param {string} type - The dereferenced value.
         */
        static dereference(value, type) {
            if (Typed.isTyped(value)) {
                if (value.type !== type) {
                    throw new Error(`invalid type: expected ${type}, got ${value.type}`);
                }
                return value.value;
            }
            return value;
        }
    }

    /**
     *  @ignore
     */
    class AddressCoder extends Coder {
        constructor(localName) {
            super("address", "address", localName, false);
        }
        defaultValue() {
            return "0x0000000000000000000000000000000000000000";
        }
        encode(writer, _value) {
            let value = Typed.dereference(_value, "string");
            try {
                value = getAddress(value);
            }
            catch (error) {
                return this._throwError(error.message, _value);
            }
            return writer.writeValue(value);
        }
        decode(reader) {
            return getAddress(toBeHex(reader.readValue(), 20));
        }
    }

    /**
     *  Clones the functionality of an existing Coder, but without a localName
     *
     *  @ignore
     */
    class AnonymousCoder extends Coder {
        coder;
        constructor(coder) {
            super(coder.name, coder.type, "_", coder.dynamic);
            this.coder = coder;
        }
        defaultValue() {
            return this.coder.defaultValue();
        }
        encode(writer, value) {
            return this.coder.encode(writer, value);
        }
        decode(reader) {
            return this.coder.decode(reader);
        }
    }

    /**
     *  @ignore
     */
    function pack(writer, coders, values) {
        let arrayValues = [];
        if (Array.isArray(values)) {
            arrayValues = values;
        }
        else if (values && typeof (values) === "object") {
            let unique = {};
            arrayValues = coders.map((coder) => {
                const name = coder.localName;
                assert$1(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
                assert$1(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
                unique[name] = true;
                return values[name];
            });
        }
        else {
            assertArgument(false, "invalid tuple value", "tuple", values);
        }
        assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
        let staticWriter = new Writer();
        let dynamicWriter = new Writer();
        let updateFuncs = [];
        coders.forEach((coder, index) => {
            let value = arrayValues[index];
            if (coder.dynamic) {
                // Get current dynamic offset (for the future pointer)
                let dynamicOffset = dynamicWriter.length;
                // Encode the dynamic value into the dynamicWriter
                coder.encode(dynamicWriter, value);
                // Prepare to populate the correct offset once we are done
                let updateFunc = staticWriter.writeUpdatableValue();
                updateFuncs.push((baseOffset) => {
                    updateFunc(baseOffset + dynamicOffset);
                });
            }
            else {
                coder.encode(staticWriter, value);
            }
        });
        // Backfill all the dynamic offsets, now that we know the static length
        updateFuncs.forEach((func) => { func(staticWriter.length); });
        let length = writer.appendWriter(staticWriter);
        length += writer.appendWriter(dynamicWriter);
        return length;
    }
    /**
     *  @ignore
     */
    function unpack(reader, coders) {
        let values = [];
        let keys = [];
        // A reader anchored to this base
        let baseReader = reader.subReader(0);
        coders.forEach((coder) => {
            let value = null;
            if (coder.dynamic) {
                let offset = reader.readIndex();
                let offsetReader = baseReader.subReader(offset);
                try {
                    value = coder.decode(offsetReader);
                }
                catch (error) {
                    // Cannot recover from this
                    if (isError(error, "BUFFER_OVERRUN")) {
                        throw error;
                    }
                    value = error;
                    value.baseType = coder.name;
                    value.name = coder.localName;
                    value.type = coder.type;
                }
            }
            else {
                try {
                    value = coder.decode(reader);
                }
                catch (error) {
                    // Cannot recover from this
                    if (isError(error, "BUFFER_OVERRUN")) {
                        throw error;
                    }
                    value = error;
                    value.baseType = coder.name;
                    value.name = coder.localName;
                    value.type = coder.type;
                }
            }
            if (value == undefined) {
                throw new Error("investigate");
            }
            values.push(value);
            keys.push(coder.localName || null);
        });
        return Result.fromItems(values, keys);
    }
    /**
     *  @ignore
     */
    class ArrayCoder extends Coder {
        coder;
        length;
        constructor(coder, length, localName) {
            const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
            const dynamic = (length === -1 || coder.dynamic);
            super("array", type, localName, dynamic);
            defineProperties(this, { coder, length });
        }
        defaultValue() {
            // Verifies the child coder is valid (even if the array is dynamic or 0-length)
            const defaultChild = this.coder.defaultValue();
            const result = [];
            for (let i = 0; i < this.length; i++) {
                result.push(defaultChild);
            }
            return result;
        }
        encode(writer, _value) {
            const value = Typed.dereference(_value, "array");
            if (!Array.isArray(value)) {
                this._throwError("expected array value", value);
            }
            let count = this.length;
            if (count === -1) {
                count = value.length;
                writer.writeValue(value.length);
            }
            assertArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
            let coders = [];
            for (let i = 0; i < value.length; i++) {
                coders.push(this.coder);
            }
            return pack(writer, coders, value);
        }
        decode(reader) {
            let count = this.length;
            if (count === -1) {
                count = reader.readIndex();
                // Check that there is *roughly* enough data to ensure
                // stray random data is not being read as a length. Each
                // slot requires at least 32 bytes for their value (or 32
                // bytes as a link to the data). This could use a much
                // tighter bound, but we are erroring on the side of safety.
                assert$1(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
            }
            let coders = [];
            for (let i = 0; i < count; i++) {
                coders.push(new AnonymousCoder(this.coder));
            }
            return unpack(reader, coders);
        }
    }

    /**
     *  @ignore
     */
    class BooleanCoder extends Coder {
        constructor(localName) {
            super("bool", "bool", localName, false);
        }
        defaultValue() {
            return false;
        }
        encode(writer, _value) {
            const value = Typed.dereference(_value, "bool");
            return writer.writeValue(value ? 1 : 0);
        }
        decode(reader) {
            return !!reader.readValue();
        }
    }

    /**
     *  @ignore
     */
    class DynamicBytesCoder extends Coder {
        constructor(type, localName) {
            super(type, type, localName, true);
        }
        defaultValue() {
            return "0x";
        }
        encode(writer, value) {
            value = getBytesCopy(value);
            let length = writer.writeValue(value.length);
            length += writer.writeBytes(value);
            return length;
        }
        decode(reader) {
            return reader.readBytes(reader.readIndex(), true);
        }
    }
    /**
     *  @ignore
     */
    class BytesCoder extends DynamicBytesCoder {
        constructor(localName) {
            super("bytes", localName);
        }
        decode(reader) {
            return hexlify(super.decode(reader));
        }
    }

    /**
     *  @ignore
     */
    class FixedBytesCoder extends Coder {
        size;
        constructor(size, localName) {
            let name = "bytes" + String(size);
            super(name, name, localName, false);
            defineProperties(this, { size }, { size: "number" });
        }
        defaultValue() {
            return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
        }
        encode(writer, _value) {
            let data = getBytesCopy(Typed.dereference(_value, this.type));
            if (data.length !== this.size) {
                this._throwError("incorrect data length", _value);
            }
            return writer.writeBytes(data);
        }
        decode(reader) {
            return hexlify(reader.readBytes(this.size));
        }
    }

    const Empty = new Uint8Array([]);
    /**
     *  @ignore
     */
    class NullCoder extends Coder {
        constructor(localName) {
            super("null", "", localName, false);
        }
        defaultValue() {
            return null;
        }
        encode(writer, value) {
            if (value != null) {
                this._throwError("not null", value);
            }
            return writer.writeBytes(Empty);
        }
        decode(reader) {
            reader.readBytes(0);
            return null;
        }
    }

    const BN_0$4 = BigInt(0);
    const BN_1$1 = BigInt(1);
    const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    /**
     *  @ignore
     */
    class NumberCoder extends Coder {
        size;
        signed;
        constructor(size, signed, localName) {
            const name = ((signed ? "int" : "uint") + (size * 8));
            super(name, name, localName, false);
            defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
        }
        defaultValue() {
            return 0;
        }
        encode(writer, _value) {
            let value = getBigInt(Typed.dereference(_value, this.type));
            // Check bounds are safe for encoding
            let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
            if (this.signed) {
                let bounds = mask(maxUintValue, (this.size * 8) - 1);
                if (value > bounds || value < -(bounds + BN_1$1)) {
                    this._throwError("value out-of-bounds", _value);
                }
                value = toTwos(value, 8 * WordSize);
            }
            else if (value < BN_0$4 || value > mask(maxUintValue, this.size * 8)) {
                this._throwError("value out-of-bounds", _value);
            }
            return writer.writeValue(value);
        }
        decode(reader) {
            let value = mask(reader.readValue(), this.size * 8);
            if (this.signed) {
                value = fromTwos(value, this.size * 8);
            }
            return value;
        }
    }

    /**
     *  @ignore
     */
    class StringCoder extends DynamicBytesCoder {
        constructor(localName) {
            super("string", localName);
        }
        defaultValue() {
            return "";
        }
        encode(writer, _value) {
            return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
        }
        decode(reader) {
            return toUtf8String(super.decode(reader));
        }
    }

    /**
     *  @ignore
     */
    class TupleCoder extends Coder {
        coders;
        constructor(coders, localName) {
            let dynamic = false;
            const types = [];
            coders.forEach((coder) => {
                if (coder.dynamic) {
                    dynamic = true;
                }
                types.push(coder.type);
            });
            const type = ("tuple(" + types.join(",") + ")");
            super("tuple", type, localName, dynamic);
            defineProperties(this, { coders: Object.freeze(coders.slice()) });
        }
        defaultValue() {
            const values = [];
            this.coders.forEach((coder) => {
                values.push(coder.defaultValue());
            });
            // We only output named properties for uniquely named coders
            const uniqueNames = this.coders.reduce((accum, coder) => {
                const name = coder.localName;
                if (name) {
                    if (!accum[name]) {
                        accum[name] = 0;
                    }
                    accum[name]++;
                }
                return accum;
            }, {});
            // Add named values
            this.coders.forEach((coder, index) => {
                let name = coder.localName;
                if (!name || uniqueNames[name] !== 1) {
                    return;
                }
                if (name === "length") {
                    name = "_length";
                }
                if (values[name] != null) {
                    return;
                }
                values[name] = values[index];
            });
            return Object.freeze(values);
        }
        encode(writer, _value) {
            const value = Typed.dereference(_value, "tuple");
            return pack(writer, this.coders, value);
        }
        decode(reader) {
            return unpack(reader, this.coders);
        }
    }

    /**
     * A simple hashing function which operates on UTF-8 strings to compute an 32-byte identifier.
     *
     * This simply computes the {@link toUtf8Bytes | **UTF-8 bytes**} and computes the {@link keccak256 | **keccak256**}.
     *
     * @category Hash
     * @example
     *
     * ```ts
     * id('hello world');
     * ```
     *
     * @param {string} value - The string to hash.
     * @returns {string} The 32-byte identifier.
     */
    function id(value) {
        return keccak256(toUtf8Bytes(value));
    }

    /**
     * Computes the Quai Network equivalent of the [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal-sign message
     * digest to sign.
     *
     * This prefixes the message with {@link MessagePrefix | **MessagePrefix**} and the decimal length of `message` and
     * computes the {@link keccak256 | **keccak256**} digest.
     *
     * If `message` is a string, it is converted to its UTF-8 bytes first. To compute the digest of a
     * [**DataHexString**](../types-aliases/DataHex), it must be converted to [**bytes**](../functions/getBytes).
     *
     * @category Hash
     * @example
     *
     * ```ts
     * hashMessage('Hello World');
     *
     * // Hashes the SIX (6) string characters, i.e.
     * // [ "0", "x", "4", "2", "4", "3" ]
     * hashMessage('0x4243');
     *
     * // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
     * hashMessage(getBytes('0x4243'));
     *
     * // ...which is equal to using data
     * hashMessage(new Uint8Array([0x42, 0x43]));
     * ```
     *
     * @param {Uint8Array | string} message - The message to hash.
     * @returns {string} The message digest.
     */
    function hashMessage(message) {
        if (typeof message === 'string') {
            message = toUtf8Bytes(message);
        }
        return keccak256(concat([toUtf8Bytes(MessagePrefix), toUtf8Bytes(String(message.length)), message]));
    }
    /**
     * Return the address of the private key that produced the signature `sig` during signing for `message`.
     *
     * @category Hash
     * @param {Uint8Array | string} message - The message that was signed.
     * @param {SignatureLike} sig - The signature to verify.
     * @returns {string} The address of the signer.
     */
    function verifyMessage(message, sig) {
        const digest = hashMessage(message);
        return recoverAddress(digest, sig);
    }

    const regexBytes = new RegExp('^bytes([0-9]+)$');
    const regexNumber = new RegExp('^(u?int)([0-9]*)$');
    const regexArray = new RegExp('^(.*)\\[([0-9]*)\\]$');
    function _pack(type, value, isArray) {
        switch (type) {
            case 'address':
                if (isArray) {
                    return getBytes(zeroPadValue(value, 32));
                }
                return getBytes(getAddress(value));
            case 'string':
                return toUtf8Bytes(value);
            case 'bytes':
                return getBytes(value);
            case 'bool':
                value = value ? '0x01' : '0x00';
                if (isArray) {
                    return getBytes(zeroPadValue(value, 32));
                }
                return getBytes(value);
        }
        let match = type.match(regexNumber);
        if (match) {
            const signed = match[1] === 'int';
            let size = parseInt(match[2] || '256');
            assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, 'invalid number type', 'type', type);
            if (isArray) {
                size = 256;
            }
            if (signed) {
                value = toTwos(value, size);
            }
            return getBytes(zeroPadValue(toBeArray(value), size / 8));
        }
        match = type.match(regexBytes);
        if (match) {
            const size = parseInt(match[1]);
            assertArgument(String(size) === match[1] && size !== 0 && size <= 32, 'invalid bytes type', 'type', type);
            assertArgument(dataLength(value) === size, `invalid value for ${type}`, 'value', value);
            if (isArray) {
                return getBytes(zeroPadBytes(value, 32));
            }
            return value;
        }
        match = type.match(regexArray);
        if (match && Array.isArray(value)) {
            const baseType = match[1];
            const count = parseInt(match[2] || String(value.length));
            assertArgument(count === value.length, `invalid array length for ${type}`, 'value', value);
            const result = [];
            value.forEach(function (value) {
                result.push(_pack(baseType, value, true));
            });
            return getBytes(concat(result));
        }
        assertArgument(false, 'invalid type', 'type', type);
    }
    // @TODO: Array Enum
    /**
     * Computes the [Non-Standard Packed
     * Mode](https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#non-standard-packed-mode) representation of `values`
     * respectively to their `types`.
     *
     * @category Hash
     * @example
     *
     * ```ts
     * addr = '0x8ba1f109551bd432803012645ac136ddd64dba72';
     * solidityPacked(['address', 'uint'], [addr, 45]);
     * ```
     *
     * @param {string[]} types - The types of the values.
     * @param {ReadonlyArray<any>} values - The values to pack.
     * @returns {string} The packed values.
     */
    function solidityPacked(types, values) {
        assertArgument(types.length === values.length, 'wrong number of values; expected ${ types.length }', 'values', values);
        const tight = [];
        types.forEach(function (type, index) {
            tight.push(_pack(type, values[index]));
        });
        return hexlify(concat(tight));
    }
    /**
     * Computes the [Non-Standard Packed
     * Mode](https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#non-standard-packed-mode)
     * [**keccak256**](../functions/keccak256) hash of `values` respectively to their `types`.
     *
     * @category Hash
     * @example
     *
     * ```ts
     * addr = '0x8ba1f109551bd432803012645ac136ddd64dba72';
     * solidityPackedKeccak256(['address', 'uint'], [addr, 45]);
     * ```
     *
     * @param {ReadonlyArray<string>} types - The types of the values.
     * @param {ReadonlyArray<any>} values - The values to hash.
     * @returns {string} The hash of the packed values.
     */
    function solidityPackedKeccak256(types, values) {
        return keccak256(solidityPacked(types, values));
    }
    /**
     * Computes the [Non-Standard Packed
     * Mode](https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#non-standard-packed-mode) [sha256](../functions/sha256)
     * hash of `values` respectively to their `types`.
     *
     * @category Hash
     * @example
     *
     * ```ts
     * addr = '0x8ba1f109551bd432803012645ac136ddd64dba72';
     * solidityPackedSha256(['address', 'uint'], [addr, 45]);
     * ```
     *
     * @param {ReadonlyArray<string>} types - The types of the values.
     * @param {ReadonlyArray<any>} values - The values to hash.
     * @returns {string} The hash of the packed values.
     */
    function solidityPackedSha256(types, values) {
        return sha256(solidityPacked(types, values));
    }

    const padding = new Uint8Array(32);
    padding.fill(0);
    const BN__1 = BigInt(-1);
    const BN_0$3 = BigInt(0);
    const BN_1 = BigInt(1);
    const BN_MAX_UINT256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
    function hexPadRight(value) {
        const bytes = getBytes(value);
        const padOffset = bytes.length % 32;
        if (padOffset) {
            return concat([bytes, padding.slice(padOffset)]);
        }
        return hexlify(bytes);
    }
    const hexTrue = toBeHex(BN_1, 32);
    const hexFalse = toBeHex(BN_0$3, 32);
    const domainFieldTypes = {
        name: 'string',
        version: 'string',
        chainId: 'uint256',
        verifyingContract: 'address',
        salt: 'bytes32',
    };
    const domainFieldNames = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
    function checkString(key) {
        return function (value) {
            assertArgument(typeof value === 'string', `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
            return value;
        };
    }
    const domainChecks = {
        name: checkString('name'),
        version: checkString('version'),
        chainId: function (_value) {
            const value = getBigInt(_value, 'domain.chainId');
            assertArgument(value >= 0, 'invalid chain ID', 'domain.chainId', _value);
            if (Number.isSafeInteger(value)) {
                return Number(value);
            }
            return toQuantity(value);
        },
        verifyingContract: function (value) {
            try {
                return getAddress(value);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            assertArgument(false, `invalid domain value "verifyingContract"`, 'domain.verifyingContract', value);
        },
        salt: function (value) {
            const bytes = getBytes(value, 'domain.salt');
            assertArgument(bytes.length === 32, `invalid domain value "salt"`, 'domain.salt', value);
            return hexlify(bytes);
        },
    };
    function getBaseEncoder(type) {
        // intXX and uintXX
        {
            const match = type.match(/^(u?)int(\d*)$/);
            if (match) {
                const signed = match[1] === '';
                const width = parseInt(match[2] || '256');
                assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), 'invalid numeric width', 'type', type);
                const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
                const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
                return function (_value) {
                    const value = getBigInt(_value, 'value');
                    assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, 'value', value);
                    return toBeHex(signed ? toTwos(value, 256) : value, 32);
                };
            }
        }
        // bytesXX
        {
            const match = type.match(/^bytes(\d+)$/);
            if (match) {
                const width = parseInt(match[1]);
                assertArgument(width !== 0 && width <= 32 && match[1] === String(width), 'invalid bytes width', 'type', type);
                return function (value) {
                    const bytes = getBytes(value);
                    assertArgument(bytes.length === width, `invalid length for ${type}`, 'value', value);
                    return hexPadRight(value);
                };
            }
        }
        switch (type) {
            case 'address':
                return function (value) {
                    return zeroPadValue(getAddress(value), 32);
                };
            case 'bool':
                return function (value) {
                    return !value ? hexFalse : hexTrue;
                };
            case 'bytes':
                return function (value) {
                    return keccak256(value);
                };
            case 'string':
                return function (value) {
                    return id(value);
                };
        }
        return null;
    }
    function encodeType(name, fields) {
        return `${name}(${fields.map(({ name, type }) => type + ' ' + name).join(',')})`;
    }
    /**
     * A **TypedDataEncode** prepares and encodes [EIP-712](https://eips.ethereum.org/EIPS/eip-712) payloads for signed
     * typed data.
     *
     * This is useful for those that wish to compute various components of a typed data hash, primary types, or
     * sub-components, but generally the higher level [`Signer.signTypedData`](../classes/Signer#signTypedData) is more
     * useful.
     *
     * @category Hash
     */
    class TypedDataEncoder {
        /**
         * The primary type for the structured {@link types | **types**}.
         *
         * This is derived automatically from the {@link types | **types**}, since no recursion is possible, once the DAG for
         * the types is consturcted internally, the primary type must be the only remaining type with no parent nodes.
         */
        primaryType;
        #types;
        /**
         * The types.
         */
        get types() {
            return JSON.parse(this.#types);
        }
        #fullTypes;
        #encoderCache;
        /**
         * Create a new **TypedDataEncoder** for `types`.
         *
         * This performs all necessary checking that types are valid and do not violate the
         * [EIP-712](https://eips.ethereum.org/EIPS/eip-712) structural constraints as well as computes the
         * {@link primaryType | **primaryType**}.
         */
        constructor(types) {
            this.#types = JSON.stringify(types);
            this.#fullTypes = new Map();
            this.#encoderCache = new Map();
            // Link struct types to their direct child structs
            const links = new Map();
            // Link structs to structs which contain them as a child
            const parents = new Map();
            // Link all subtypes within a given struct
            const subtypes = new Map();
            Object.keys(types).forEach((type) => {
                links.set(type, new Set());
                parents.set(type, []);
                subtypes.set(type, new Set());
            });
            for (const name in types) {
                const uniqueNames = new Set();
                for (const field of types[name]) {
                    // Check each field has a unique name
                    assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, 'types', types);
                    uniqueNames.add(field.name);
                    // Get the base type (drop any array specifiers)
                    const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                    assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, 'types', types);
                    // Is this a base encoding type?
                    const encoder = getBaseEncoder(baseType);
                    if (encoder) {
                        continue;
                    }
                    assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, 'types', types);
                    // Add linkage
                    parents.get(baseType).push(name);
                    links.get(name).add(baseType);
                }
            }
            // Deduce the primary type
            const primaryTypes = Array.from(parents.keys()).filter((n) => parents.get(n).length === 0);
            assertArgument(primaryTypes.length !== 0, 'missing primary type', 'types', types);
            assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(', ')}`, 'types', types);
            defineProperties(this, { primaryType: primaryTypes[0] });
            // Check for circular type references
            function checkCircular(type, found) {
                assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, 'types', types);
                found.add(type);
                for (const child of links.get(type)) {
                    if (!parents.has(child)) {
                        continue;
                    }
                    // Recursively check children
                    checkCircular(child, found);
                    // Mark all ancestors as having this decendant
                    for (const subtype of found) {
                        subtypes.get(subtype).add(child);
                    }
                }
                found.delete(type);
            }
            checkCircular(this.primaryType, new Set());
            // Compute each fully describe type
            for (const [name, set] of subtypes) {
                const st = Array.from(set);
                st.sort();
                this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(''));
            }
        }
        /**
         * Returnthe encoder for the specific `type`.
         *
         * @param {string} type - The type to get the encoder for.
         * @returns {(value: any) => string} The encoder for the type.
         */
        getEncoder(type) {
            let encoder = this.#encoderCache.get(type);
            if (!encoder) {
                encoder = this.#getEncoder(type);
                this.#encoderCache.set(type, encoder);
            }
            return encoder;
        }
        #getEncoder(type) {
            // Basic encoder type (address, bool, uint256, etc)
            {
                const encoder = getBaseEncoder(type);
                if (encoder) {
                    return encoder;
                }
            }
            // Array
            const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
                const subtype = match[1];
                const subEncoder = this.getEncoder(subtype);
                return (value) => {
                    assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, 'value', value);
                    let result = value.map(subEncoder);
                    if (this.#fullTypes.has(subtype)) {
                        result = result.map(keccak256);
                    }
                    return keccak256(concat(result));
                };
            }
            // Struct
            const fields = this.types[type];
            if (fields) {
                const encodedType = id(this.#fullTypes.get(type));
                return (value) => {
                    const values = fields.map(({ name, type }) => {
                        const result = this.getEncoder(type)(value[name]);
                        if (this.#fullTypes.has(type)) {
                            return keccak256(result);
                        }
                        return result;
                    });
                    values.unshift(encodedType);
                    return concat(values);
                };
            }
            assertArgument(false, `unknown type: ${type}`, 'type', type);
        }
        /**
         * Return the full type for `name`.
         *
         * @param {string} name - The name to get the full type for.
         * @returns {string} The full type.
         */
        encodeType(name) {
            const result = this.#fullTypes.get(name);
            assertArgument(result, `unknown type: ${JSON.stringify(name)}`, 'name', name);
            return result;
        }
        /**
         * Return the encoded `value` for the `type`.
         *
         * @param {string} type - The type to encode the value for.
         * @param {any} value - The value to encode.
         * @returns {string} The encoded value.
         */
        encodeData(type, value) {
            return this.getEncoder(type)(value);
        }
        /**
         * Returns the hash of `value` for the type of `name`.
         *
         * @param {string} name - The name of the type.
         * @param {Record<string, any>} value - The value to hash.
         * @returns {string} The hash of the value.
         */
        hashStruct(name, value) {
            return keccak256(this.encodeData(name, value));
        }
        /**
         * Return the fulled encoded `value` for the {@link types | **types**}.
         *
         * @param {Record<string, any>} value - The value to encode.
         * @returns {string} The encoded value.
         */
        encode(value) {
            return this.encodeData(this.primaryType, value);
        }
        /**
         * Return the hash of the fully encoded `value` for the {@link types | **types**}.
         *
         * @param {Record<string, any>} value - The value to hash.
         * @returns {string} The hash of the value.
         */
        hash(value) {
            return this.hashStruct(this.primaryType, value);
        }
        /**
         * @ignore
         */
        _visit(type, value, callback) {
            // Basic encoder type (address, bool, uint256, etc)
            {
                const encoder = getBaseEncoder(type);
                if (encoder) {
                    return callback(type, value);
                }
            }
            // Array
            const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
                assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, 'value', value);
                return value.map((v) => this._visit(match[1], v, callback));
            }
            // Struct
            const fields = this.types[type];
            if (fields) {
                return fields.reduce((accum, { name, type }) => {
                    accum[name] = this._visit(type, value[name], callback);
                    return accum;
                }, {});
            }
            assertArgument(false, `unknown type: ${type}`, 'type', type);
        }
        /**
         * Call `calback` for each value in `value`, passing the type and component within `value`.
         *
         * This is useful for replacing addresses or other transformation that may be desired on each component, based on
         * its type.
         *
         * @param {Record<string, any>} value - The value to visit.
         * @param {(type: string, data: any) => any} callback - The callback to call for each value.
         * @returns {any} The result of the callback.
         */
        visit(value, callback) {
            return this._visit(this.primaryType, value, callback);
        }
        /**
         * Create a new **TypedDataEncoder** for `types`.
         *
         * @param {Record<string, TypedDataField[]>} types - The types to encode.
         * @returns {TypedDataEncoder} The encoder for the types.
         * @throws {Error} If the types are invalid.
         */
        static from(types) {
            return new TypedDataEncoder(types);
        }
        /**
         * Return the primary type for `types`.
         *
         * @param {Record<string, TypedDataField[]>} types - The types to get the primary type for.
         * @returns {string} The primary type.
         * @throws {Error} If the types are invalid.
         */
        static getPrimaryType(types) {
            return TypedDataEncoder.from(types).primaryType;
        }
        /**
         * Return the hashed struct for `value` using `types` and `name`.
         *
         * @param {string} name - The name of the type.
         * @param {Record<string, TypedDataField[]>} types - The types to hash.
         * @param {Record<string, any>} value - The value to hash.
         * @returns {string} The hash of the value.
         */
        static hashStruct(name, types, value) {
            return TypedDataEncoder.from(types).hashStruct(name, value);
        }
        /**
         * Return the domain hash for `domain`.
         *
         * @param {TypedDataDomain} domain - The domain to hash.
         * @returns {string} The hash of the domain.
         * @throws {Error} If the domain is invalid.
         */
        static hashDomain(domain) {
            const domainFields = [];
            for (const name in domain) {
                if (domain[name] == null) {
                    continue;
                }
                const type = domainFieldTypes[name];
                assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, 'domain', domain);
                domainFields.push({ name, type });
            }
            domainFields.sort((a, b) => {
                return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
            });
            return TypedDataEncoder.hashStruct('EIP712Domain', { EIP712Domain: domainFields }, domain);
        }
        /**
         * Return the fully encoded [EIP-712](https://eips.ethereum.org/EIPS/eip-712) `value` for `types` with `domain`.
         *
         * @param {TypedDataDomain} domain - The domain to use.
         * @param {Record<string, TypedDataField[]>} types - The types to encode.
         * @param {Record<string, any>} value - The value to encode.
         * @returns {string} The encoded value.
         */
        static encode(domain, types, value) {
            return concat(['0x1901', TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
        }
        /**
         * Return the hash of the fully encoded [EIP-712](https://eips.ethereum.org/EIPS/eip-712) `value` for `types` with
         * `domain`.
         *
         * @param {TypedDataDomain} domain - The domain to use.
         * @param {Record<string, TypedDataField[]>} types - The types to hash.
         * @param {Record<string, any>} value - The value to hash.
         * @returns {string} The hash of the value.
         */
        static hash(domain, types, value) {
            return keccak256(TypedDataEncoder.encode(domain, types, value));
        }
        /**
         * Returns the JSON-encoded payload expected by nodes which implement the JSON-RPC
         * [EIP-712](https://eips.ethereum.org/EIPS/eip-712) method.
         *
         * @param {TypedDataDomain} domain - The domain to use.
         * @param {Record<string, TypedDataField[]>} types - The types to encode.
         * @param {Record<string, any>} value - The value to encode.
         * @returns {any} The JSON-encoded payload.
         */
        static getPayload(domain, types, value) {
            // Validate the domain fields
            TypedDataEncoder.hashDomain(domain);
            // Derive the EIP712Domain Struct reference type
            const domainValues = {};
            const domainTypes = [];
            domainFieldNames.forEach((name) => {
                const value = domain[name];
                if (value == null) {
                    return;
                }
                domainValues[name] = domainChecks[name](value);
                domainTypes.push({ name, type: domainFieldTypes[name] });
            });
            const encoder = TypedDataEncoder.from(types);
            const typesWithDomain = Object.assign({}, types);
            assertArgument(typesWithDomain.EIP712Domain == null, 'types must not contain EIP712Domain type', 'types.EIP712Domain', types);
            typesWithDomain.EIP712Domain = domainTypes;
            // Validate the data structures and types
            encoder.encode(value);
            return {
                types: typesWithDomain,
                domain: domainValues,
                primaryType: encoder.primaryType,
                message: encoder.visit(value, (type, value) => {
                    // bytes
                    if (type.match(/^bytes(\d*)/)) {
                        return hexlify(getBytes(value));
                    }
                    // uint or int
                    if (type.match(/^u?int/)) {
                        return getBigInt(value).toString();
                    }
                    switch (type) {
                        case 'address':
                            return value.toLowerCase();
                        case 'bool':
                            return !!value;
                        case 'string':
                            assertArgument(typeof value === 'string', 'invalid string', 'value', value);
                            return value;
                    }
                    assertArgument(false, 'unsupported type', 'type', type);
                }),
            };
        }
    }
    /**
     * Compute the address used to sign the typed data for the `signature`.
     *
     * @category Hash
     * @param {TypedDataDomain} domain - The domain of the typed data.
     * @param {Record<string, TypedDataField[]>} types - The types of the typed data.
     * @param {Record<string, any>} value - The value of the typed data.
     * @param {SignatureLike} signature - The signature to verify.
     * @returns {string} The address that signed the typed data.
     */
    function verifyTypedData(domain, types, value, signature) {
        return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
    }

    /**
     * A fragment is a single item from an ABI, which may represent any of:
     *
     * - {@link FunctionFragment | Functions}
     * - {@link EventFragment | Events}
     * - {@link ConstructorFragment | Constructors}
     * - Custom {@link ErrorFragment | Errors}
     * - {@link FallbackFragment | Fallback or Recieve} functions
     *
     * @category Application Binary Interface
     */
    // [ "a", "b" ] => { "a": 1, "b": 1 }
    function setify(items) {
        const result = new Set();
        items.forEach((k) => result.add(k));
        return Object.freeze(result);
    }
    const _kwVisibDeploy = 'external public payable';
    const KwVisibDeploy = setify(_kwVisibDeploy.split(' '));
    // Visibility Keywords
    const _kwVisib = 'constant external internal payable private public pure view';
    const KwVisib = setify(_kwVisib.split(' '));
    const _kwTypes = 'constructor error event fallback function receive struct';
    const KwTypes = setify(_kwTypes.split(' '));
    const _kwModifiers = 'calldata memory storage payable indexed';
    const KwModifiers = setify(_kwModifiers.split(' '));
    const _kwOther = 'tuple returns';
    // All Keywords
    const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(' ');
    const Keywords = setify(_keywords.split(' '));
    // Single character tokens
    const SimpleTokens = {
        '(': 'OPEN_PAREN',
        ')': 'CLOSE_PAREN',
        '[': 'OPEN_BRACKET',
        ']': 'CLOSE_BRACKET',
        ',': 'COMMA',
        '@': 'AT',
    };
    // Parser regexes to consume the next token
    const regexWhitespacePrefix = new RegExp('^(\\s*)');
    const regexNumberPrefix = new RegExp('^([0-9]+)');
    const regexIdPrefix = new RegExp('^([a-zA-Z$_][a-zA-Z0-9$_]*)');
    // Parser regexs to check validity
    const regexId = new RegExp('^([a-zA-Z$_][a-zA-Z0-9$_]*)$');
    const regexType = new RegExp('^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$');
    /**
     * Represents a parsed list of tokens.
     *
     * @category Application Binary Interface
     */
    class TokenString {
        #offset;
        #tokens;
        get offset() {
            return this.#offset;
        }
        get length() {
            return this.#tokens.length - this.#offset;
        }
        constructor(tokens) {
            this.#offset = 0;
            this.#tokens = tokens.slice();
        }
        /**
         * Returns a clone of the current token string.
         *
         * @returns {TokenString} A cloned TokenString object.
         */
        clone() {
            return new TokenString(this.#tokens);
        }
        reset() {
            this.#offset = 0;
        }
        /**
         * @ignore
         */
        #subTokenString(from = 0, to = 0) {
            return new TokenString(this.#tokens.slice(from, to).map((t) => {
                return Object.freeze(Object.assign({}, t, {
                    match: t.match - from,
                    linkBack: t.linkBack - from,
                    linkNext: t.linkNext - from,
                }));
            }));
        }
        // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
        popKeyword(allowed) {
            const top = this.peek();
            if (top.type !== 'KEYWORD' || !allowed.has(top.text)) {
                throw new Error(`expected keyword ${top.text}`);
            }
            return this.pop().text;
        }
        // Pops and returns the value of the next token if it is `type`; throws if out of tokens
        popType(type) {
            if (this.peek().type !== type) {
                throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
            }
            return this.pop().text;
        }
        // Pops and returns a "(" TOKENS ")"
        popParen() {
            const top = this.peek();
            if (top.type !== 'OPEN_PAREN') {
                throw new Error('bad start');
            }
            const result = this.#subTokenString(this.#offset + 1, top.match + 1);
            this.#offset = top.match + 1;
            return result;
        }
        // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
        popParams() {
            const top = this.peek();
            if (top.type !== 'OPEN_PAREN') {
                throw new Error('bad start');
            }
            const result = [];
            while (this.#offset < top.match - 1) {
                const link = this.peek().linkNext;
                result.push(this.#subTokenString(this.#offset + 1, link));
                this.#offset = link;
            }
            this.#offset = top.match + 1;
            return result;
        }
        // Returns the top Token, throwing if out of tokens
        peek() {
            if (this.#offset >= this.#tokens.length) {
                throw new Error('out-of-bounds');
            }
            return this.#tokens[this.#offset];
        }
        // Returns the next value, if it is a keyword in `allowed`
        peekKeyword(allowed) {
            const top = this.peekType('KEYWORD');
            return top != null && allowed.has(top) ? top : null;
        }
        // Returns the value of the next token if it is `type`
        peekType(type) {
            if (this.length === 0) {
                return null;
            }
            const top = this.peek();
            return top.type === type ? top.text : null;
        }
        // Returns the next token; throws if out of tokens
        pop() {
            const result = this.peek();
            this.#offset++;
            return result;
        }
        toString() {
            const tokens = [];
            for (let i = this.#offset; i < this.#tokens.length; i++) {
                const token = this.#tokens[i];
                tokens.push(`${token.type}:${token.text}`);
            }
            return `<TokenString ${tokens.join(' ')}>`;
        }
    }
    function lex(text) {
        const tokens = [];
        const throwError = (message) => {
            const token = offset < text.length ? JSON.stringify(text[offset]) : '$EOI';
            throw new Error(`invalid token ${token} at ${offset}: ${message}`);
        };
        const brackets = [];
        const commas = [];
        let offset = 0;
        while (offset < text.length) {
            // Strip off any leading whitespace
            let cur = text.substring(offset);
            let match = cur.match(regexWhitespacePrefix);
            if (match) {
                offset += match[1].length;
                cur = text.substring(offset);
            }
            const token = {
                depth: brackets.length,
                linkBack: -1,
                linkNext: -1,
                match: -1,
                type: '',
                text: '',
                offset,
                value: -1,
            };
            tokens.push(token);
            const type = SimpleTokens[cur[0]] || '';
            if (type) {
                token.type = type;
                token.text = cur[0];
                offset++;
                if (type === 'OPEN_PAREN') {
                    brackets.push(tokens.length - 1);
                    commas.push(tokens.length - 1);
                }
                else if (type == 'CLOSE_PAREN') {
                    if (brackets.length === 0) {
                        throwError('no matching open bracket');
                    }
                    token.match = brackets.pop();
                    tokens[token.match].match = tokens.length - 1;
                    token.depth--;
                    token.linkBack = commas.pop();
                    tokens[token.linkBack].linkNext = tokens.length - 1;
                }
                else if (type === 'COMMA') {
                    token.linkBack = commas.pop();
                    tokens[token.linkBack].linkNext = tokens.length - 1;
                    commas.push(tokens.length - 1);
                }
                else if (type === 'OPEN_BRACKET') {
                    token.type = 'BRACKET';
                }
                else if (type === 'CLOSE_BRACKET') {
                    // Remove the CLOSE_BRACKET
                    let suffix = tokens.pop().text;
                    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'NUMBER') {
                        const value = tokens.pop().text;
                        suffix = value + suffix;
                        tokens[tokens.length - 1].value = getNumber(value);
                    }
                    if (tokens.length === 0 || tokens[tokens.length - 1].type !== 'BRACKET') {
                        throw new Error('missing opening bracket');
                    }
                    tokens[tokens.length - 1].text += suffix;
                }
                continue;
            }
            match = cur.match(regexIdPrefix);
            if (match) {
                token.text = match[1];
                offset += token.text.length;
                if (Keywords.has(token.text)) {
                    token.type = 'KEYWORD';
                    continue;
                }
                if (token.text.match(regexType)) {
                    token.type = 'TYPE';
                    continue;
                }
                token.type = 'ID';
                continue;
            }
            match = cur.match(regexNumberPrefix);
            if (match) {
                token.text = match[1];
                token.type = 'NUMBER';
                offset += token.text.length;
                continue;
            }
            throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
        }
        return new TokenString(tokens.map((t) => Object.freeze(t)));
    }
    // Check only one of `allowed` is in `set`
    function allowSingle(set, allowed) {
        const included = [];
        for (const key in allowed.keys()) {
            if (set.has(key)) {
                included.push(key);
            }
        }
        if (included.length > 1) {
            throw new Error(`conflicting types: ${included.join(', ')}`);
        }
    }
    // Functions to process a Solidity Signature TokenString from left-to-right for...
    // ...the name with an optional type, returning the name
    function consumeName(type, tokens) {
        if (tokens.peekKeyword(KwTypes)) {
            const keyword = tokens.pop().text;
            if (keyword !== type) {
                throw new Error(`expected ${type}, got ${keyword}`);
            }
        }
        return tokens.popType('ID');
    }
    // ...all keywords matching allowed, returning the keywords
    function consumeKeywords(tokens, allowed) {
        const keywords = new Set();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const keyword = tokens.peekType('KEYWORD');
            if (keyword == null || (allowed && !allowed.has(keyword))) {
                break;
            }
            tokens.pop();
            if (keywords.has(keyword)) {
                throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
            }
            keywords.add(keyword);
        }
        return Object.freeze(keywords);
    }
    // ...all visibility keywords, returning the coalesced mutability
    function consumeMutability(tokens) {
        const modifiers = consumeKeywords(tokens, KwVisib);
        // Detect conflicting modifiers
        allowSingle(modifiers, setify('constant payable nonpayable'.split(' ')));
        allowSingle(modifiers, setify('pure view payable nonpayable'.split(' ')));
        // Process mutability states
        if (modifiers.has('view')) {
            return 'view';
        }
        if (modifiers.has('pure')) {
            return 'pure';
        }
        if (modifiers.has('payable')) {
            return 'payable';
        }
        if (modifiers.has('nonpayable')) {
            return 'nonpayable';
        }
        // Process legacy `constant` last
        if (modifiers.has('constant')) {
            return 'view';
        }
        return 'nonpayable';
    }
    // ...a parameter list, returning the ParamType list
    function consumeParams(tokens, allowIndexed) {
        return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
    }
    // ...a gas limit, returning a BigNumber or null if none
    function consumeGas(tokens) {
        if (tokens.peekType('AT')) {
            tokens.pop();
            if (tokens.peekType('NUMBER')) {
                return getBigInt(tokens.pop().text);
            }
            throw new Error('invalid gas');
        }
        return null;
    }
    function consumeEoi(tokens) {
        if (tokens.length) {
            throw new Error(`unexpected tokens: ${tokens.toString()}`);
        }
    }
    const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
    function verifyBasicType(type) {
        const match = type.match(regexType);
        assertArgument(match, 'invalid type', 'type', type);
        if (type === 'uint') {
            return 'uint256';
        }
        if (type === 'int') {
            return 'int256';
        }
        if (match[2]) {
            // bytesXX
            const length = parseInt(match[2]);
            assertArgument(length !== 0 && length <= 32, 'invalid bytes length', 'type', type);
        }
        else if (match[3]) {
            // intXX or uintXX
            const size = parseInt(match[3]);
            assertArgument(size !== 0 && size <= 256 && size % 8 === 0, 'invalid numeric width', 'type', type);
        }
        return type;
    }
    // Make the Fragment constructors effectively private
    const _guard$3 = {};
    const internal$1 = Symbol.for('_quais_internal');
    const ParamTypeInternal = '_ParamTypeInternal';
    const ErrorFragmentInternal = '_ErrorInternal';
    const EventFragmentInternal = '_EventInternal';
    const ConstructorFragmentInternal = '_ConstructorInternal';
    const FallbackFragmentInternal = '_FallbackInternal';
    const FunctionFragmentInternal = '_FunctionInternal';
    const StructFragmentInternal = '_StructInternal';
    /**
     * Each input and output of a {@link Fragment | **Fragment**} is an Array of {@link ParamType | **ParamType**}.
     *
     * @category Application Binary Interface
     */
    class ParamType {
        /**
         * The local name of the parameter (or `""` if unbound)
         */
        name;
        /**
         * The fully qualified type (e.g. `"address"`, `"tuple(address)"`, `"uint256[3][]"`)
         */
        type;
        /**
         * The base type (e.g. `"address"`, `"tuple"`, `"array"`)
         */
        baseType;
        /**
         * True if the parameters is indexed.
         *
         * For non-indexable types this is `null`.
         */
        indexed;
        /**
         * The components for the tuple.
         *
         * For non-tuple types this is `null`.
         */
        components;
        /**
         * The array length, or `-1` for dynamic-lengthed arrays.
         *
         * For non-array types this is `null`.
         */
        arrayLength;
        /**
         * The type of each child in the array.
         *
         * For non-array types this is `null`.
         */
        arrayChildren;
        /**
         * @ignore
         */
        constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
            assertPrivate(guard, _guard$3, 'ParamType');
            Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
            if (components) {
                components = Object.freeze(components.slice());
            }
            if (baseType === 'array') {
                if (arrayLength == null || arrayChildren == null) {
                    throw new Error('');
                }
            }
            else if (arrayLength != null || arrayChildren != null) {
                throw new Error('');
            }
            if (baseType === 'tuple') {
                if (components == null) {
                    throw new Error('');
                }
            }
            else if (components != null) {
                throw new Error('');
            }
            defineProperties(this, {
                name,
                type,
                baseType,
                indexed,
                components,
                arrayLength,
                arrayChildren,
            });
        }
        /**
         * Return a string representation of this type.
         *
         * For example,
         *
         * `sighash" => "(uint256,address)"`
         *
         * `"minimal" => "tuple(uint256,address) indexed"`
         *
         * `"full" => "tuple(uint256 foo, address bar) indexed baz"`
         *
         * @returns {string} The formatted type.
         */
        format(format) {
            if (format == null) {
                format = 'sighash';
            }
            if (format === 'json') {
                const name = this.name || '';
                if (this.isArray()) {
                    const result = JSON.parse(this.arrayChildren.format('json'));
                    result.name = name;
                    result.type += `[${this.arrayLength < 0 ? '' : String(this.arrayLength)}]`;
                    return JSON.stringify(result);
                }
                const result = {
                    type: this.baseType === 'tuple' ? 'tuple' : this.type,
                    name,
                };
                if (typeof this.indexed === 'boolean') {
                    result.indexed = this.indexed;
                }
                if (this.isTuple()) {
                    result.components = this.components.map((c) => JSON.parse(c.format(format)));
                }
                return JSON.stringify(result);
            }
            let result = '';
            // Array
            if (this.isArray()) {
                result += this.arrayChildren.format(format);
                result += `[${this.arrayLength < 0 ? '' : String(this.arrayLength)}]`;
            }
            else {
                if (this.isTuple()) {
                    result +=
                        '(' + this.components.map((comp) => comp.format(format)).join(format === 'full' ? ', ' : ',') + ')';
                }
                else {
                    result += this.type;
                }
            }
            if (format !== 'sighash') {
                if (this.indexed === true) {
                    result += ' indexed';
                }
                if (format === 'full' && this.name) {
                    result += ' ' + this.name;
                }
            }
            return result;
        }
        /**
         * This provides a type guard ensuring that {@link arrayChildren | **arrayChildren**} and
         * {@link arrayLength | **arrayLength**} are non-null.
         *
         * @returns {boolean} True if this is an Array type.
         */
        isArray() {
            return this.baseType === 'array';
        }
        /**
         * This provides a type guard ensuring that {@link components | **components**} is non-null.
         *
         * @returns {boolean} True if this is a Tuple type.
         */
        isTuple() {
            return this.baseType === 'tuple';
        }
        /**
         * This provides a type guard ensuring that {@link indexed | **indexed**} is non-null.
         *
         * @returns {boolean} True if this is an Indexable type.
         */
        isIndexable() {
            return this.indexed != null;
        }
        /**
         * Walks the **ParamType** with `value`, calling `process` on each type, destructing the `value` recursively.
         */
        walk(value, process) {
            if (this.isArray()) {
                if (!Array.isArray(value)) {
                    throw new Error('invalid array value');
                }
                if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                    throw new Error('array is wrong length');
                }
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const _this = this;
                return value.map((v) => _this.arrayChildren.walk(v, process));
            }
            if (this.isTuple()) {
                if (!Array.isArray(value)) {
                    throw new Error('invalid tuple value');
                }
                if (value.length !== this.components.length) {
                    throw new Error('array is wrong length');
                }
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const _this = this;
                return value.map((v, i) => _this.components[i].walk(v, process));
            }
            return process(this.type, value);
        }
        /**
         * @ignore
         */
        #walkAsync(promises, value, process, setValue) {
            if (this.isArray()) {
                if (!Array.isArray(value)) {
                    throw new Error('invalid array value');
                }
                if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                    throw new Error('array is wrong length');
                }
                const childType = this.arrayChildren;
                const result = value.slice();
                result.forEach((value, index) => {
                    childType.#walkAsync(promises, value, process, (value) => {
                        result[index] = value;
                    });
                });
                setValue(result);
                return;
            }
            if (this.isTuple()) {
                const components = this.components;
                // Convert the object into an array
                let result;
                if (Array.isArray(value)) {
                    result = value.slice();
                }
                else {
                    if (value == null || typeof value !== 'object') {
                        throw new Error('invalid tuple value');
                    }
                    result = components.map((param) => {
                        if (!param.name) {
                            throw new Error('cannot use object value with unnamed components');
                        }
                        if (!(param.name in value)) {
                            throw new Error(`missing value for component ${param.name}`);
                        }
                        return value[param.name];
                    });
                }
                if (result.length !== this.components.length) {
                    throw new Error('array is wrong length');
                }
                result.forEach((value, index) => {
                    components[index].#walkAsync(promises, value, process, (value) => {
                        result[index] = value;
                    });
                });
                setValue(result);
                return;
            }
            const result = process(this.type, value);
            if (result.then) {
                promises.push((async function () {
                    setValue(await result);
                })());
            }
            else {
                setValue(result);
            }
        }
        /**
         * Walks the **ParamType** with `value`, asynchronously calling `process` on each type, destructing the `value`
         * recursively.
         *
         * This can be used to resolve ENS naes by walking and resolving each `"address"` type.
         */
        async walkAsync(value, process) {
            const promises = [];
            const result = [value];
            this.#walkAsync(promises, value, process, (value) => {
                result[0] = value;
            });
            if (promises.length) {
                await Promise.all(promises);
            }
            return result[0];
        }
        /**
         * Creates a new **ParamType** for `obj`.
         *
         * If `allowIndexed` then the `indexed` keyword is permitted, otherwise the `indexed` keyword will throw an error.
         */
        static from(obj, allowIndexed) {
            if (ParamType.isParamType(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                try {
                    return ParamType.from(lex(obj), allowIndexed);
                }
                catch (error) {
                    assertArgument(false, 'invalid param type', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                let type = '', baseType = '';
                let comps = null;
                if (consumeKeywords(obj, setify(['tuple'])).has('tuple') || obj.peekType('OPEN_PAREN')) {
                    // Tuple
                    baseType = 'tuple';
                    comps = obj.popParams().map((t) => ParamType.from(t));
                    type = `tuple(${comps.map((c) => c.format()).join(',')})`;
                }
                else {
                    // Normal
                    type = verifyBasicType(obj.popType('TYPE'));
                    baseType = type;
                }
                // Check for Array
                let arrayChildren = null;
                let arrayLength = null;
                while (obj.length && obj.peekType('BRACKET')) {
                    const bracket = obj.pop(); //arrays[i];
                    arrayChildren = new ParamType(_guard$3, '', type, baseType, null, comps, arrayLength, arrayChildren);
                    arrayLength = bracket.value;
                    type += bracket.text;
                    baseType = 'array';
                    comps = null;
                }
                let indexed = null;
                const keywords = consumeKeywords(obj, KwModifiers);
                if (keywords.has('indexed')) {
                    if (!allowIndexed) {
                        throw new Error('');
                    }
                    indexed = true;
                }
                const name = obj.peekType('ID') ? obj.pop().text : '';
                if (obj.length) {
                    throw new Error('leftover tokens');
                }
                return new ParamType(_guard$3, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
            }
            const name = obj.name;
            assertArgument(!name || (typeof name === 'string' && name.match(regexId)), 'invalid name', 'obj.name', name);
            let indexed = obj.indexed;
            if (indexed != null) {
                assertArgument(allowIndexed, 'parameter cannot be indexed', 'obj.indexed', obj.indexed);
                indexed = !!indexed;
            }
            let type = obj.type;
            const arrayMatch = type.match(regexArrayType);
            if (arrayMatch) {
                const arrayLength = parseInt(arrayMatch[2] || '-1');
                const arrayChildren = ParamType.from({
                    type: arrayMatch[1],
                    components: obj.components,
                });
                return new ParamType(_guard$3, name || '', type, 'array', indexed, null, arrayLength, arrayChildren);
            }
            if (type === 'tuple' || type.startsWith('tuple(' /* fix: ) */) || type.startsWith('(' /* fix: ) */)) {
                const comps = obj.components != null ? obj.components.map((c) => ParamType.from(c)) : null;
                const tuple = new ParamType(_guard$3, name || '', type, 'tuple', indexed, comps, null, null);
                // @TODO: use lexer to validate and normalize type
                return tuple;
            }
            type = verifyBasicType(obj.type);
            return new ParamType(_guard$3, name || '', type, type, indexed, null, null, null);
        }
        /**
         * Returns true if `value` is a **ParamType**.
         */
        static isParamType(value) {
            return value && value[internal$1] === ParamTypeInternal;
        }
    }
    /**
     * An abstract class to represent An individual fragment from a parse ABI.
     *
     * @category Application Binary Interface
     */
    class Fragment {
        /**
         * The type of the fragment.
         */
        type;
        /**
         * The inputs for the fragment.
         */
        inputs;
        /**
         * @ignore
         */
        constructor(guard, type, inputs) {
            assertPrivate(guard, _guard$3, 'Fragment');
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { type, inputs });
        }
        /**
         * Creates a new **Fragment** for `obj`, wich can be any supported ABI frgament type.
         */
        static from(obj) {
            if (typeof obj === 'string') {
                // Try parsing JSON...
                try {
                    Fragment.from(JSON.parse(obj));
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
                // ...otherwise, use the human-readable lexer
                return Fragment.from(lex(obj));
            }
            if (obj instanceof TokenString) {
                // Human-readable ABI (already lexed)
                const type = obj.peekKeyword(KwTypes);
                switch (type) {
                    case 'constructor':
                        return ConstructorFragment.from(obj);
                    case 'error':
                        return ErrorFragment.from(obj);
                    case 'event':
                        return EventFragment.from(obj);
                    case 'fallback':
                    case 'receive':
                        return FallbackFragment.from(obj);
                    case 'function':
                        return FunctionFragment.from(obj);
                    case 'struct':
                        return StructFragment.from(obj);
                }
            }
            else if (typeof obj === 'object') {
                // JSON ABI
                switch (obj.type) {
                    case 'constructor':
                        return ConstructorFragment.from(obj);
                    case 'error':
                        return ErrorFragment.from(obj);
                    case 'event':
                        return EventFragment.from(obj);
                    case 'fallback':
                    case 'receive':
                        return FallbackFragment.from(obj);
                    case 'function':
                        return FunctionFragment.from(obj);
                    case 'struct':
                        return StructFragment.from(obj);
                }
                assert$1(false, `unsupported type: ${obj.type}`, 'UNSUPPORTED_OPERATION', {
                    operation: 'Fragment.from',
                });
            }
            assertArgument(false, 'unsupported frgament object', 'obj', obj);
        }
        /**
         * Returns true if `value` is a {@link ConstructorFragment | **ConstructorFragment**}.
         */
        static isConstructor(value) {
            return ConstructorFragment.isFragment(value);
        }
        /**
         * Returns true if `value` is an {@link ErrorFragment | **ErrorFragment**}.
         */
        static isError(value) {
            return ErrorFragment.isFragment(value);
        }
        /**
         * Returns true if `value` is an {@link EventFragment | **EventFragment**}.
         */
        static isEvent(value) {
            return EventFragment.isFragment(value);
        }
        /**
         * Returns true if `value` is a {@link FunctionFragment | **FunctionFragment**}.
         */
        static isFunction(value) {
            return FunctionFragment.isFragment(value);
        }
        /**
         * Returns true if `value` is a {@link StructFragment | **StructFragment**}.
         */
        static isStruct(value) {
            return StructFragment.isFragment(value);
        }
    }
    /**
     * An abstract class to represent An individual fragment which has a name from a parse ABI.
     *
     * @category Application Binary Interface
     */
    class NamedFragment extends Fragment {
        /**
         * The name of the fragment.
         */
        name;
        /**
         * @ignore
         */
        constructor(guard, type, name, inputs) {
            super(guard, type, inputs);
            assertArgument(typeof name === 'string' && name.match(regexId), 'invalid identifier', 'name', name);
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { name });
        }
    }
    function joinParams(format, params) {
        return '(' + params.map((p) => p.format(format)).join(format === 'full' ? ', ' : ',') + ')';
    }
    /**
     * A Fragment which represents a _Custom Error_.
     *
     * @category Application Binary Interface
     */
    class ErrorFragment extends NamedFragment {
        /**
         * @ignore
         */
        constructor(guard, name, inputs) {
            super(guard, 'error', name, inputs);
            Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
        }
        /**
         * The Custom Error selector.
         */
        get selector() {
            return id(this.format('sighash')).substring(0, 10);
        }
        /**
         * Returns a string representation of this fragment as `format`.
         */
        format(format) {
            if (format == null) {
                format = 'sighash';
            }
            if (format === 'json') {
                return JSON.stringify({
                    type: 'error',
                    name: this.name,
                    inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                });
            }
            const result = [];
            if (format !== 'sighash') {
                result.push('error');
            }
            result.push(this.name + joinParams(format, this.inputs));
            return result.join(' ');
        }
        /**
         * Returns a new **ErrorFragment** for `obj`.
         */
        static from(obj) {
            if (ErrorFragment.isFragment(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                return ErrorFragment.from(lex(obj));
            }
            else if (obj instanceof TokenString) {
                const name = consumeName('error', obj);
                const inputs = consumeParams(obj);
                consumeEoi(obj);
                return new ErrorFragment(_guard$3, name, inputs);
            }
            return new ErrorFragment(_guard$3, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        /**
         * Returns `true` and provides a type guard if `value` is an **ErrorFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === ErrorFragmentInternal;
        }
    }
    /**
     * A Fragment which represents an Event.
     *
     * @category Application Binary Interface
     */
    class EventFragment extends NamedFragment {
        /**
         * Whether this event is anonymous.
         */
        anonymous;
        /**
         * @ignore
         */
        constructor(guard, name, inputs, anonymous) {
            super(guard, 'event', name, inputs);
            Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
            defineProperties(this, { anonymous });
        }
        /**
         * The Event topic hash.
         */
        get topicHash() {
            return id(this.format('sighash'));
        }
        /**
         * Returns a string representation of this event as `format`.
         */
        format(format) {
            if (format == null) {
                format = 'sighash';
            }
            if (format === 'json') {
                return JSON.stringify({
                    type: 'event',
                    anonymous: this.anonymous,
                    name: this.name,
                    inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                });
            }
            const result = [];
            if (format !== 'sighash') {
                result.push('event');
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== 'sighash' && this.anonymous) {
                result.push('anonymous');
            }
            return result.join(' ');
        }
        /**
         * Return the topic hash for an event with `name` and `params`.
         */
        static getTopicHash(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new EventFragment(_guard$3, name, params, false);
            return fragment.topicHash;
        }
        /**
         * Returns a new **EventFragment** for `obj`.
         */
        static from(obj) {
            if (EventFragment.isFragment(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                try {
                    return EventFragment.from(lex(obj));
                }
                catch (error) {
                    assertArgument(false, 'invalid event fragment', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                const name = consumeName('event', obj);
                const inputs = consumeParams(obj, true);
                const anonymous = !!consumeKeywords(obj, setify(['anonymous'])).has('anonymous');
                consumeEoi(obj);
                return new EventFragment(_guard$3, name, inputs, anonymous);
            }
            return new EventFragment(_guard$3, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
        }
        /**
         * Returns `true` and provides a type guard if `value` is an **EventFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === EventFragmentInternal;
        }
    }
    /**
     * A Fragment which represents a constructor.
     *
     * @category Application Binary Interface
     */
    class ConstructorFragment extends Fragment {
        /**
         * Whether the constructor can receive an endowment.
         */
        payable;
        /**
         * The recommended gas limit for deployment or `null`.
         */
        gas;
        /**
         * @ignore
         */
        constructor(guard, type, inputs, payable, gas) {
            super(guard, type, inputs);
            Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
            defineProperties(this, { payable, gas });
        }
        /**
         * Returns a string representation of this constructor as `format`.
         */
        format(format) {
            assert$1(format != null && format !== 'sighash', 'cannot format a constructor for sighash', 'UNSUPPORTED_OPERATION', { operation: 'format(sighash)' });
            if (format === 'json') {
                return JSON.stringify({
                    type: 'constructor',
                    stateMutability: this.payable ? 'payable' : 'undefined',
                    payable: this.payable,
                    gas: this.gas != null ? this.gas : undefined,
                    inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                });
            }
            const result = [`constructor${joinParams(format, this.inputs)}`];
            if (this.payable) {
                result.push('payable');
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
            return result.join(' ');
        }
        /**
         * Returns a new **ConstructorFragment** for `obj`.
         */
        static from(obj) {
            if (ConstructorFragment.isFragment(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                try {
                    return ConstructorFragment.from(lex(obj));
                }
                catch (error) {
                    assertArgument(false, 'invalid constuctor fragment', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                consumeKeywords(obj, setify(['constructor']));
                const inputs = consumeParams(obj);
                const payable = !!consumeKeywords(obj, KwVisibDeploy).has('payable');
                const gas = consumeGas(obj);
                consumeEoi(obj);
                return new ConstructorFragment(_guard$3, 'constructor', inputs, payable, gas);
            }
            return new ConstructorFragment(_guard$3, 'constructor', obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
        }
        /**
         * Returns `true` and provides a type guard if `value` is a **ConstructorFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === ConstructorFragmentInternal;
        }
    }
    /**
     * A Fragment which represents a method.
     *
     * @category Application Binary Interface
     */
    class FallbackFragment extends Fragment {
        /**
         * If the function can be sent value during invocation.
         */
        payable;
        constructor(guard, inputs, payable) {
            super(guard, 'fallback', inputs);
            Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
            defineProperties(this, { payable });
        }
        /**
         * Returns a string representation of this fallback as `format`.
         */
        format(format) {
            const type = this.inputs.length === 0 ? 'receive' : 'fallback';
            if (format === 'json') {
                const stateMutability = this.payable ? 'payable' : 'nonpayable';
                return JSON.stringify({ type, stateMutability });
            }
            return `${type}()${this.payable ? ' payable' : ''}`;
        }
        /**
         * Returns a new **FallbackFragment** for `obj`.
         */
        static from(obj) {
            if (FallbackFragment.isFragment(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                try {
                    return FallbackFragment.from(lex(obj));
                }
                catch (error) {
                    assertArgument(false, 'invalid fallback fragment', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                const errorObj = obj.toString();
                const topIsValid = obj.peekKeyword(setify(['fallback', 'receive']));
                assertArgument(topIsValid, 'type must be fallback or receive', 'obj', errorObj);
                const type = obj.popKeyword(setify(['fallback', 'receive']));
                // receive()
                if (type === 'receive') {
                    const inputs = consumeParams(obj);
                    assertArgument(inputs.length === 0, `receive cannot have arguments`, 'obj.inputs', inputs);
                    consumeKeywords(obj, setify(['payable']));
                    consumeEoi(obj);
                    return new FallbackFragment(_guard$3, [], true);
                }
                // fallback() [payable]
                // fallback(bytes) [payable] returns (bytes)
                let inputs = consumeParams(obj);
                if (inputs.length) {
                    assertArgument(inputs.length === 1 && inputs[0].type === 'bytes', 'invalid fallback inputs', 'obj.inputs', inputs.map((i) => i.format('minimal')).join(', '));
                }
                else {
                    inputs = [ParamType.from('bytes')];
                }
                const mutability = consumeMutability(obj);
                assertArgument(mutability === 'nonpayable' || mutability === 'payable', 'fallback cannot be constants', 'obj.stateMutability', mutability);
                if (consumeKeywords(obj, setify(['returns'])).has('returns')) {
                    const outputs = consumeParams(obj);
                    assertArgument(outputs.length === 1 && outputs[0].type === 'bytes', 'invalid fallback outputs', 'obj.outputs', outputs.map((i) => i.format('minimal')).join(', '));
                }
                consumeEoi(obj);
                return new FallbackFragment(_guard$3, inputs, mutability === 'payable');
            }
            if (obj.type === 'receive') {
                return new FallbackFragment(_guard$3, [], true);
            }
            if (obj.type === 'fallback') {
                const inputs = [ParamType.from('bytes')];
                const payable = obj.stateMutability === 'payable';
                return new FallbackFragment(_guard$3, inputs, payable);
            }
            assertArgument(false, 'invalid fallback description', 'obj', obj);
        }
        /**
         * Returns `true` and provides a type guard if `value` is a **FallbackFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === FallbackFragmentInternal;
        }
    }
    /**
     * A Fragment which represents a method.
     *
     * @category Application Binary Interface
     */
    class FunctionFragment extends NamedFragment {
        /**
         * If the function is constant (e.g. `pure` or `view` functions).
         */
        constant;
        /**
         * The returned types for the result of calling this function.
         */
        outputs;
        /**
         * The state mutability (e.g. `payable`, `nonpayable`, `view` or `pure`)
         */
        stateMutability;
        /**
         * If the function can be sent value during invocation.
         */
        payable;
        /**
         * The recommended gas limit to send when calling this function.
         */
        gas;
        /**
         * @ignore
         */
        constructor(guard, name, stateMutability, inputs, outputs, gas) {
            super(guard, 'function', name, inputs);
            Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
            outputs = Object.freeze(outputs.slice());
            const constant = stateMutability === 'view' || stateMutability === 'pure';
            const payable = stateMutability === 'payable';
            defineProperties(this, { constant, gas, outputs, payable, stateMutability });
        }
        /**
         * The Function selector.
         */
        get selector() {
            return id(this.format('sighash')).substring(0, 10);
        }
        /**
         * Returns a string representation of this function as `format`.
         */
        format(format) {
            if (format == null) {
                format = 'sighash';
            }
            if (format === 'json') {
                return JSON.stringify({
                    type: 'function',
                    name: this.name,
                    constant: this.constant,
                    stateMutability: this.stateMutability !== 'nonpayable' ? this.stateMutability : undefined,
                    payable: this.payable,
                    gas: this.gas != null ? this.gas : undefined,
                    inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                    outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
                });
            }
            const result = [];
            if (format !== 'sighash') {
                result.push('function');
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== 'sighash') {
                if (this.stateMutability !== 'nonpayable') {
                    result.push(this.stateMutability);
                }
                if (this.outputs && this.outputs.length) {
                    result.push('returns');
                    result.push(joinParams(format, this.outputs));
                }
                if (this.gas != null) {
                    result.push(`@${this.gas.toString()}`);
                }
            }
            return result.join(' ');
        }
        /**
         * Return the selector for a function with `name` and `params`.
         */
        static getSelector(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new FunctionFragment(_guard$3, name, 'view', params, [], null);
            return fragment.selector;
        }
        /**
         * Returns a new **FunctionFragment** for `obj`.
         */
        static from(obj) {
            if (FunctionFragment.isFragment(obj)) {
                return obj;
            }
            if (typeof obj === 'string') {
                try {
                    return FunctionFragment.from(lex(obj));
                }
                catch (error) {
                    assertArgument(false, 'invalid function fragment', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                const name = consumeName('function', obj);
                const inputs = consumeParams(obj);
                const mutability = consumeMutability(obj);
                let outputs = [];
                if (consumeKeywords(obj, setify(['returns'])).has('returns')) {
                    outputs = consumeParams(obj);
                }
                const gas = consumeGas(obj);
                consumeEoi(obj);
                return new FunctionFragment(_guard$3, name, mutability, inputs, outputs, gas);
            }
            let stateMutability = obj.stateMutability;
            // Use legacy Solidity ABI logic if stateMutability is missing
            if (stateMutability == null) {
                stateMutability = 'payable';
                if (typeof obj.constant === 'boolean') {
                    stateMutability = 'view';
                    if (!obj.constant) {
                        stateMutability = 'payable';
                        if (typeof obj.payable === 'boolean' && !obj.payable) {
                            stateMutability = 'nonpayable';
                        }
                    }
                }
                else if (typeof obj.payable === 'boolean' && !obj.payable) {
                    stateMutability = 'nonpayable';
                }
            }
            // @TODO: verifyState for stateMutability (e.g. throw if
            //        payable: false but stateMutability is "nonpayable")
            return new FunctionFragment(_guard$3, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
        }
        /**
         * Returns `true` and provides a type guard if `value` is a **FunctionFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === FunctionFragmentInternal;
        }
    }
    /**
     * A Fragment which represents a structure.
     *
     * @category Application Binary Interface
     */
    class StructFragment extends NamedFragment {
        /**
         * @ignore
         */
        constructor(guard, name, inputs) {
            super(guard, 'struct', name, inputs);
            Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
        }
        /**
         * Returns a string representation of this struct as `format`.
         */
        format() {
            throw new Error('@TODO');
        }
        /**
         * Returns a new **StructFragment** for `obj`.
         */
        static from(obj) {
            if (typeof obj === 'string') {
                try {
                    return StructFragment.from(lex(obj));
                }
                catch (error) {
                    assertArgument(false, 'invalid struct fragment', 'obj', obj);
                }
            }
            else if (obj instanceof TokenString) {
                const name = consumeName('struct', obj);
                const inputs = consumeParams(obj);
                consumeEoi(obj);
                return new StructFragment(_guard$3, name, inputs);
            }
            return new StructFragment(_guard$3, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        // @TODO: fix this return type
        /**
         * Returns `true` and provides a type guard if `value` is a **StructFragment**.
         */
        static isFragment(value) {
            return value && value[internal$1] === StructFragmentInternal;
        }
    }

    /**
     * When sending values to or receiving values from a [Contract](../classes/Contract), the data is generally encoded
     * using the [ABI
     * Specification](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html#formal-specification-of-the-encoding).
     *
     * The AbiCoder provides a utility to encode values to ABI data and decode values from ABI data.
     *
     * Most of the time, developers should favor the [Contract](../classes/Contract) class, which further abstracts the
     * finer details of ABI data.
     *
     * @category Application Binary Interface
     */
    // https://docs.soliditylang.org/en/v0.8.17/control-structures.html
    const PanicReasons$1 = new Map();
    PanicReasons$1.set(0x00, 'GENERIC_PANIC');
    PanicReasons$1.set(0x01, 'ASSERT_FALSE');
    PanicReasons$1.set(0x11, 'OVERFLOW');
    PanicReasons$1.set(0x12, 'DIVIDE_BY_ZERO');
    PanicReasons$1.set(0x21, 'ENUM_RANGE_ERROR');
    PanicReasons$1.set(0x22, 'BAD_STORAGE_DATA');
    PanicReasons$1.set(0x31, 'STACK_UNDERFLOW');
    PanicReasons$1.set(0x32, 'ARRAY_RANGE_ERROR');
    PanicReasons$1.set(0x41, 'OUT_OF_MEMORY');
    PanicReasons$1.set(0x51, 'UNINITIALIZED_FUNCTION_CALL');
    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    let defaultCoder = null;
    let defaultMaxInflation = 1024;
    function getBuiltinCallException(action, tx, data, abiCoder) {
        let message = 'missing revert data';
        let reason = null;
        const invocation = null;
        let revert = null;
        if (data) {
            message = 'execution reverted';
            const bytes = getBytes(data);
            data = hexlify(data);
            if (bytes.length === 0) {
                message += ' (no data present; likely require(false) occurred';
                reason = 'require(false)';
            }
            else if (bytes.length % 32 !== 4) {
                message += ' (could not decode reason; invalid data length)';
            }
            else if (hexlify(bytes.slice(0, 4)) === '0x08c379a0') {
                // Error(string)
                try {
                    reason = abiCoder.decode(['string'], bytes.slice(4))[0];
                    revert = {
                        signature: 'Error(string)',
                        name: 'Error',
                        args: [reason],
                    };
                    message += `: ${JSON.stringify(reason)}`;
                }
                catch (error) {
                    message += ' (could not decode reason; invalid string data)';
                }
            }
            else if (hexlify(bytes.slice(0, 4)) === '0x4e487b71') {
                // Panic(uint256)
                try {
                    const code = Number(abiCoder.decode(['uint256'], bytes.slice(4))[0]);
                    revert = {
                        signature: 'Panic(uint256)',
                        name: 'Panic',
                        args: [code],
                    };
                    reason = `Panic due to ${PanicReasons$1.get(code) || 'UNKNOWN'}(${code})`;
                    message += `: ${reason}`;
                }
                catch (error) {
                    message += ' (could not decode panic code)';
                }
            }
            else {
                message += ' (unknown custom error)';
            }
        }
        const transaction = {
            to: tx.to ? getAddress(tx.to) : null,
            data: tx.data || '0x',
        };
        if (tx.from) {
            transaction.from = getAddress(tx.from);
        }
        return makeError(message, 'CALL_EXCEPTION', {
            action,
            data,
            reason,
            transaction,
            invocation,
            revert,
        });
    }
    /**
     * The **AbiCoder** is a low-level class responsible for encoding JavaScript values into binary data and decoding binary
     * data into JavaScript values.
     *
     * @category Application Binary Interface
     */
    class AbiCoder {
        #getCoder(param) {
            if (param.isArray()) {
                return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
            }
            if (param.isTuple()) {
                return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
            }
            switch (param.baseType) {
                case 'address':
                    return new AddressCoder(param.name);
                case 'bool':
                    return new BooleanCoder(param.name);
                case 'string':
                    return new StringCoder(param.name);
                case 'bytes':
                    return new BytesCoder(param.name);
                case '':
                    return new NullCoder(param.name);
            }
            // u?int[0-9]*
            let match = param.type.match(paramTypeNumber);
            if (match) {
                const size = parseInt(match[2] || '256');
                assertArgument(size !== 0 && size <= 256 && size % 8 === 0, 'invalid ' + match[1] + ' bit length', 'param', param);
                return new NumberCoder(size / 8, match[1] === 'int', param.name);
            }
            // bytes[0-9]+
            match = param.type.match(paramTypeBytes);
            if (match) {
                const size = parseInt(match[1]);
                assertArgument(size !== 0 && size <= 32, 'invalid bytes length', 'param', param);
                return new FixedBytesCoder(size, param.name);
            }
            assertArgument(false, 'invalid type', 'type', param.type);
        }
        /**
         * Get the default values for the given types. For example, a `uint` is by default `0` and `bool` is by default
         * `false`.
         *
         * @param {(string | ParamType)[]} types - Array of parameter types to get default values for.
         * @returns {Result} The default values corresponding to the given types.
         */
        getDefaultValue(types) {
            const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
            const coder = new TupleCoder(coders, '_');
            return coder.defaultValue();
        }
        /**
         * Encode the values as the specified types into ABI data.
         *
         * @param {(string | ParamType)[]} types - Array of parameter types.
         * @param {any[]} values - Array of values to encode.
         * @returns {string} The encoded data in hexadecimal format.
         */
        encode(types, values) {
            assertArgumentCount(values.length, types.length, 'types/values length mismatch');
            const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
            const coder = new TupleCoder(coders, '_');
            const writer = new Writer();
            coder.encode(writer, values);
            return writer.data;
        }
        /**
         * Decode the ABI data as the types into values.
         *
         * If loose decoding is enabled, then strict padding is not enforced. Some older versions of Solidity incorrectly
         * padded event data emitted from `external` functions.
         *
         * @param {(string | ParamType)[]} types - Array of parameter types.
         * @param {BytesLike} data - The ABI data to decode.
         * @param {boolean} [loose=false] - Enable loose decoding. Default is `false`
         * @returns {Result} The decoded values.
         */
        decode(types, data, loose) {
            const coders = types.map((type) => this.#getCoder(ParamType.from(type)));
            const coder = new TupleCoder(coders, '_');
            return coder.decode(new Reader(data, loose, defaultMaxInflation));
        }
        /**
         * Set the default maximum inflation factor.
         *
         * @ignore
         * @param {number} value - The new inflation factor.
         */
        static _setDefaultMaxInflation(value) {
            assertArgument(typeof value === 'number' && Number.isInteger(value), 'invalid defaultMaxInflation factor', 'value', value);
            defaultMaxInflation = value;
        }
        /**
         * Returns the shared singleton instance of a default {@link AbiCoder | **AbiCoder**}.
         *
         * On the first call, the instance is created internally.
         *
         * @returns {AbiCoder} The default ABI coder instance.
         */
        static defaultAbiCoder() {
            if (defaultCoder == null) {
                defaultCoder = new AbiCoder();
            }
            return defaultCoder;
        }
        /**
         * Returns a quais-compatible {@link CallExceptionError | **CallExceptionError**} for the given result data.
         *
         * @param {CallExceptionAction} action - The action that triggered the exception.
         * @param {Object} tx - The transaction information.
         * @param {BytesLike | null} data - The data associated with the call exception.
         * @returns {CallExceptionError} The corresponding call exception error.
         */
        static getBuiltinCallException(action, tx, data) {
            return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
        }
    }

    /**
     * The Interface class is a low-level class that accepts an ABI and provides all the necessary functionality to encode
     * and decode paramaters to and results from methods, events and errors.
     *
     * It also provides several convenience methods to automatically search and find matching transactions and events to
     * parse them.
     *
     * @category Application Binary Interface
     */
    /**
     * When using the {@link Interface.parseLog | **Interface.parseLog**} to automatically match a Log to its event for
     * parsing, a **LogDescription** is returned.
     *
     * @category Application Binary Interface
     */
    class LogDescription {
        /**
         * The matching fragment for the `topic0`.
         */
        fragment;
        /**
         * The name of the Event.
         */
        name;
        /**
         * The full Event signature.
         */
        signature;
        /**
         * The topic hash for the Event.
         */
        topic;
        /**
         * The arguments passed into the Event with `emit`.
         */
        args;
        /**
         * @ignore
         */
        constructor(fragment, topic, args) {
            const name = fragment.name, signature = fragment.format();
            defineProperties(this, {
                fragment,
                name,
                signature,
                topic,
                args,
            });
        }
    }
    /**
     * When using the {@link Interface.parseTransaction | **Interface.parseTransaction**} to automatically match a
     * transaction data to its function for parsing, a **TransactionDescription** is returned.
     *
     * @category Application Binary Interface
     */
    class TransactionDescription {
        /**
         * The matching fragment from the transaction `data`.
         */
        fragment;
        /**
         * The name of the Function from the transaction `data`.
         */
        name;
        /**
         * The arguments passed to the Function from the transaction `data`.
         */
        args;
        /**
         * The full Function signature from the transaction `data`.
         */
        signature;
        /**
         * The selector for the Function from the transaction `data`.
         */
        selector;
        /**
         * The `value` (in wei) from the transaction.
         */
        value;
        /**
         * @ignore
         */
        constructor(fragment, selector, args, value) {
            const name = fragment.name, signature = fragment.format();
            defineProperties(this, {
                fragment,
                name,
                args,
                signature,
                selector,
                value,
            });
        }
    }
    /**
     * When using the {@link Interface.parseError | **Interface.parseError**} to automatically match an error for a call
     * result for parsing, an **ErrorDescription** is returned.
     *
     * @category Application Binary Interface
     */
    class ErrorDescription {
        /**
         * The matching fragment.
         */
        fragment;
        /**
         * The name of the Error.
         */
        name;
        /**
         * The arguments passed to the Error with `revert`.
         */
        args;
        /**
         * The full Error signature.
         */
        signature;
        /**
         * The selector for the Error.
         */
        selector;
        /**
         * @ignore
         */
        constructor(fragment, selector, args) {
            const name = fragment.name, signature = fragment.format();
            defineProperties(this, {
                fragment,
                name,
                args,
                signature,
                selector,
            });
        }
    }
    /**
     * An **Indexed** is used as a value when a value that does not fit within a topic (i.e. not a fixed-length, 32-byte
     * type). It is the `keccak256` of the value, and used for types such as arrays, tuples, bytes and strings.
     *
     * @category Application Binary Interface
     */
    class Indexed {
        /**
         * The `keccak256` of the value logged.
         */
        hash;
        /**
         * @ignore
         */
        _isIndexed;
        /**
         * Check if a value is an **Indexed** This provides a Type Guard for property access.
         *
         * @param value - The value to check.
         * @returns `true` if the value is an **Indexed**.
         */
        static isIndexed(value) {
            return !!(value && value._isIndexed);
        }
        /**
         * @ignore
         */
        constructor(hash) {
            defineProperties(this, { hash, _isIndexed: true });
        }
    }
    // https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
    const PanicReasons = {
        '0': 'generic panic',
        '1': 'assert(false)',
        '17': 'arithmetic overflow',
        '18': 'division or modulo by zero',
        '33': 'enum overflow',
        '34': 'invalid encoded storage byte array accessed',
        '49': 'out-of-bounds array access; popping on an empty array',
        '50': 'out-of-bounds access of an array or bytesN',
        '65': 'out of memory',
        '81': 'uninitialized function',
    };
    const BuiltinErrors = {
        '0x08c379a0': {
            signature: 'Error(string)',
            name: 'Error',
            inputs: ['string'],
            reason: (message) => {
                return `reverted with reason string ${JSON.stringify(message)}`;
            },
        },
        '0x4e487b71': {
            signature: 'Panic(uint256)',
            name: 'Panic',
            inputs: ['uint256'],
            reason: (code) => {
                let reason = 'unknown panic code';
                if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
                    reason = PanicReasons[code.toString()];
                }
                return `reverted with panic code 0x${code.toString(16)} (${reason})`;
            },
        },
    };
    /**
     * An Interface abstracts many of the low-level details for encoding and decoding the data on the blockchain.
     *
     * An ABI provides information on how to encode data to send to a Contract, how to decode the results and events and how
     * to interpret revert errors.
     *
     * The ABI can be specified by {@link InterfaceAbi | any supported format}.
     *
     * @category Application Binary Interface
     */
    class Interface {
        /**
         * All the Contract ABI members (i.e. methods, events, errors, etc).
         */
        fragments;
        /**
         * The Contract constructor.
         */
        deploy;
        /**
         * The Fallback method, if any.
         */
        fallback;
        /**
         * If receiving ether is supported.
         */
        receive;
        #errors;
        #events;
        #functions;
        // #structs: Map<string, StructFragment>;
        #abiCoder;
        /**
         * Create a new Interface for the fragments.
         *
         * @param {InterfaceAbi} fragments - The ABI fragments.
         */
        constructor(fragments) {
            let abi = [];
            if (typeof fragments === 'string') {
                abi = JSON.parse(fragments);
            }
            else {
                abi = fragments;
            }
            this.#functions = new Map();
            this.#errors = new Map();
            this.#events = new Map();
            const frags = [];
            for (const a of abi) {
                try {
                    frags.push(Fragment.from(a));
                }
                catch (error) {
                    console.log('Error parsing ABI fragment', error);
                }
            }
            defineProperties(this, {
                fragments: Object.freeze(frags),
            });
            let fallback = null;
            let receive = false;
            this.#abiCoder = this.getAbiCoder();
            // Add all fragments by their signature
            this.fragments.forEach((fragment, index) => {
                let bucket;
                switch (fragment.type) {
                    case 'constructor':
                        if (this.deploy) {
                            console.log('duplicate definition - constructor');
                            return;
                        }
                        defineProperties(this, { deploy: fragment });
                        return;
                    case 'fallback':
                        if (fragment.inputs.length === 0) {
                            receive = true;
                        }
                        else {
                            assertArgument(!fallback || fragment.payable !== fallback.payable, 'conflicting fallback fragments', `fragments[${index}]`, fragment);
                            fallback = fragment;
                            receive = fallback.payable;
                        }
                        return;
                    case 'function':
                        bucket = this.#functions;
                        break;
                    case 'event':
                        bucket = this.#events;
                        break;
                    case 'error':
                        bucket = this.#errors;
                        break;
                    default:
                        return;
                }
                // Two identical entries; ignore it
                const signature = fragment.format();
                if (bucket.has(signature)) {
                    return;
                }
                bucket.set(signature, fragment);
            });
            // If we do not have a constructor add a default
            if (!this.deploy) {
                defineProperties(this, {
                    deploy: ConstructorFragment.from('constructor()'),
                });
            }
            defineProperties(this, { fallback, receive });
        }
        /**
         * Returns the entire Human-Readable ABI, as an array of signatures, optionally as `minimal` strings, which removes
         * parameter names and unneceesary spaces.
         */
        format(minimal) {
            const format = minimal ? 'minimal' : 'full';
            const abi = this.fragments.map((f) => f.format(format));
            return abi;
        }
        /**
         * Return the JSON-encoded ABI. This is the format Solidiy returns.
         */
        formatJson() {
            const abi = this.fragments.map((f) => f.format('json'));
            // We need to re-bundle the JSON fragments a bit
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        /**
         * The ABI coder that will be used to encode and decode binary data.
         */
        getAbiCoder() {
            return AbiCoder.defaultAbiCoder();
        }
        // Find a function definition by any means necessary (unless it is ambiguous)
        #getFunction(key, values, forceUnique) {
            // Selector
            if (isHexString(key)) {
                const selector = key.toLowerCase();
                for (const fragment of this.#functions.values()) {
                    if (selector === fragment.selector) {
                        return fragment;
                    }
                }
                return null;
            }
            // It is a bare name, look up the function (will return null if ambiguous)
            if (key.indexOf('(') === -1) {
                const matching = [];
                for (const [name, fragment] of this.#functions) {
                    if (name.split('(' /* fix:) */)[0] === key) {
                        matching.push(fragment);
                    }
                }
                if (values) {
                    const lastValue = values.length > 0 ? values[values.length - 1] : null;
                    let valueLength = values.length;
                    let allowOptions = true;
                    if (Typed.isTyped(lastValue) && lastValue.type === 'overrides') {
                        allowOptions = false;
                        valueLength--;
                    }
                    // Remove all matches that don't have a compatible length. The args
                    // may contain an overrides, so the match may have n or n - 1 parameters
                    for (let i = matching.length - 1; i >= 0; i--) {
                        const inputs = matching[i].inputs.length;
                        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                            matching.splice(i, 1);
                        }
                    }
                    // Remove all matches that don't match the Typed signature
                    for (let i = matching.length - 1; i >= 0; i--) {
                        const inputs = matching[i].inputs;
                        for (let j = 0; j < values.length; j++) {
                            // Not a typed value
                            if (!Typed.isTyped(values[j])) {
                                continue;
                            }
                            // We are past the inputs
                            if (j >= inputs.length) {
                                if (values[j].type === 'overrides') {
                                    continue;
                                }
                                matching.splice(i, 1);
                                break;
                            }
                            // Make sure the value type matches the input type
                            if (values[j].type !== inputs[j].baseType) {
                                matching.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                // We found a single matching signature with an overrides, but the
                // last value is something that cannot possibly be an options
                if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
                    const lastArg = values[values.length - 1];
                    if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== 'object') {
                        matching.splice(0, 1);
                    }
                }
                if (matching.length === 0) {
                    return null;
                }
                if (matching.length > 1 && forceUnique) {
                    const matchStr = matching.map((m) => JSON.stringify(m.format())).join(', ');
                    assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, 'key', key);
                }
                return matching[0];
            }
            // Normalize the signature and lookup the function
            const result = this.#functions.get(FunctionFragment.from(key).format());
            if (result) {
                return result;
            }
            return null;
        }
        /**
         * Get the function name for `key`, which may be a function selector, function name or function signature that
         * belongs to the ABI.
         */
        getFunctionName(key) {
            const fragment = this.#getFunction(key, null, false);
            assertArgument(fragment, 'no matching function', 'key', key);
            return fragment.name;
        }
        /**
         * Returns true if `key` (a function selector, function name or function signature) is present in the ABI.
         *
         * In the case of a function name, the name may be ambiguous, so accessing the
         * {@link FunctionFragment | **FunctionFragment**} may require refinement.
         */
        hasFunction(key) {
            return !!this.#getFunction(key, null, false);
        }
        /**
         * Get the {@link FunctionFragment | **FunctionFragment**} for `key`, which may be a function selector, function name
         * or function signature that belongs to the ABI.
         *
         * If `values` is provided, it will use the Typed API to handle ambiguous cases where multiple functions match by
         * name.
         *
         * If the `key` and `values` do not refine to a single function in the ABI, this will throw.
         */
        getFunction(key, values) {
            return this.#getFunction(key, values || null, true);
        }
        /**
         * Iterate over all functions, calling `callback`, sorted by their name.
         */
        forEachFunction(callback) {
            const names = Array.from(this.#functions.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                callback(this.#functions.get(name), i);
            }
        }
        // Find an event definition by any means necessary (unless it is ambiguous)
        #getEvent(key, values, forceUnique) {
            // EventTopic
            if (isHexString(key)) {
                const eventTopic = key.toLowerCase();
                for (const fragment of this.#events.values()) {
                    if (eventTopic === fragment.topicHash) {
                        return fragment;
                    }
                }
                return null;
            }
            // It is a bare name, look up the function (will return null if ambiguous)
            if (key.indexOf('(') === -1) {
                const matching = [];
                for (const [name, fragment] of this.#events) {
                    if (name.split('(' /* fix:) */)[0] === key) {
                        matching.push(fragment);
                    }
                }
                if (values) {
                    // Remove all matches that don't have a compatible length.
                    for (let i = matching.length - 1; i >= 0; i--) {
                        if (matching[i].inputs.length < values.length) {
                            matching.splice(i, 1);
                        }
                    }
                    // Remove all matches that don't match the Typed signature
                    for (let i = matching.length - 1; i >= 0; i--) {
                        const inputs = matching[i].inputs;
                        for (let j = 0; j < values.length; j++) {
                            // Not a typed value
                            if (!Typed.isTyped(values[j])) {
                                continue;
                            }
                            // Make sure the value type matches the input type
                            if (values[j].type !== inputs[j].baseType) {
                                matching.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                if (matching.length === 0) {
                    return null;
                }
                if (matching.length > 1 && forceUnique) {
                    const matchStr = matching.map((m) => JSON.stringify(m.format())).join(', ');
                    assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, 'key', key);
                }
                return matching[0];
            }
            // Normalize the signature and lookup the function
            const result = this.#events.get(EventFragment.from(key).format());
            if (result) {
                return result;
            }
            return null;
        }
        /**
         * Get the event name for `key`, which may be a topic hash, event name or event signature that belongs to the ABI.
         */
        getEventName(key) {
            const fragment = this.#getEvent(key, null, false);
            assertArgument(fragment, 'no matching event', 'key', key);
            return fragment.name;
        }
        /**
         * Returns true if `key` (an event topic hash, event name or event signature) is present in the ABI.
         *
         * In the case of an event name, the name may be ambiguous, so accessing the
         * {@link EventFragment | **EventFragment**} may require refinement.
         */
        hasEvent(key) {
            return !!this.#getEvent(key, null, false);
        }
        /**
         * Get the {@link EventFragment | **EventFragment**} for `key`, which may be a topic hash, event name or event
         * signature that belongs to the ABI.
         *
         * If `values` is provided, it will use the Typed API to handle ambiguous cases where multiple events match by name.
         *
         * If the `key` and `values` do not refine to a single event in the ABI, this will throw.
         */
        getEvent(key, values) {
            return this.#getEvent(key, values || null, true);
        }
        /**
         * Iterate over all events, calling `callback`, sorted by their name.
         */
        forEachEvent(callback) {
            const names = Array.from(this.#events.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                callback(this.#events.get(name), i);
            }
        }
        /**
         * Get the {@link ErrorFragment | **ErroFragment**} for `key`, which may be an error selector, error name or error
         * signature that belongs to the ABI.
         *
         * If `values` is provided, it will use the Typed API to handle ambiguous cases where multiple errors match by name.
         *
         * If the `key` and `values` do not refine to a single error in the ABI, this will throw.
         */
        // TODO: `values` is not used, remove?
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getError(key, values) {
            if (isHexString(key)) {
                const selector = key.toLowerCase();
                if (BuiltinErrors[selector]) {
                    return ErrorFragment.from(BuiltinErrors[selector].signature);
                }
                for (const fragment of this.#errors.values()) {
                    if (selector === fragment.selector) {
                        return fragment;
                    }
                }
                return null;
            }
            // It is a bare name, look up the function (will return null if ambiguous)
            if (key.indexOf('(') === -1) {
                const matching = [];
                for (const [name, fragment] of this.#errors) {
                    if (name.split('(' /* fix:) */)[0] === key) {
                        matching.push(fragment);
                    }
                }
                if (matching.length === 0) {
                    if (key === 'Error') {
                        return ErrorFragment.from('error Error(string)');
                    }
                    if (key === 'Panic') {
                        return ErrorFragment.from('error Panic(uint256)');
                    }
                    return null;
                }
                else if (matching.length > 1) {
                    const matchStr = matching.map((m) => JSON.stringify(m.format())).join(', ');
                    assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, 'name', key);
                }
                return matching[0];
            }
            // Normalize the signature and lookup the function
            key = ErrorFragment.from(key).format();
            if (key === 'Error(string)') {
                return ErrorFragment.from('error Error(string)');
            }
            if (key === 'Panic(uint256)') {
                return ErrorFragment.from('error Panic(uint256)');
            }
            const result = this.#errors.get(key);
            if (result) {
                return result;
            }
            return null;
        }
        /**
         * Iterate over all errors, calling `callback`, sorted by their name.
         */
        forEachError(callback) {
            const names = Array.from(this.#errors.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                callback(this.#errors.get(name), i);
            }
        }
        /**
         * @ignore
         */
        _decodeParams(params, data) {
            return this.#abiCoder.decode(params, data);
        }
        /**
         * @ignore
         */
        _encodeParams(params, values) {
            return this.#abiCoder.encode(params, values);
        }
        /**
         * Encodes a `tx.data` object for deploying the Contract with the `values` as the constructor arguments.
         */
        encodeDeploy(values) {
            return this._encodeParams(this.deploy.inputs, values || []);
        }
        /**
         * Decodes the result `data` (e.g. from an `quai_call`) for the specified error (see {@link getError | **getError**}
         * for valid values for `key`).
         *
         * Most developers should prefer the {@link parseCallResult | **parseCallResult**} method instead, which will
         * automatically detect a `CALL_EXCEPTION` and throw the corresponding error.
         */
        decodeErrorResult(fragment, data) {
            if (typeof fragment === 'string') {
                const f = this.getError(fragment);
                assertArgument(f, 'unknown error', 'fragment', fragment);
                fragment = f;
            }
            assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, 'data', data);
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
        }
        /**
         * Encodes the transaction revert data for a call result that reverted from the the Contract with the sepcified
         * `error` (see {@link getError | **getError**} for valid values for `fragment`) with the `values`.
         *
         * This is generally not used by most developers, unless trying to mock a result from a Contract.
         */
        encodeErrorResult(fragment, values) {
            if (typeof fragment === 'string') {
                const f = this.getError(fragment);
                assertArgument(f, 'unknown error', 'fragment', fragment);
                fragment = f;
            }
            return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        /**
         * Decodes the `data` from a transaction `tx.data` for the function specified (see
         * {@link getFunction | **getFunction**} for valid values for `fragment`).
         *
         * Most developers should prefer the {@link parseTransaction | **parseTransaction**} method instead, which will
         * automatically detect the fragment.
         */
        decodeFunctionData(fragment, data) {
            if (typeof fragment === 'string') {
                const f = this.getFunction(fragment);
                assertArgument(f, 'unknown function', 'fragment', fragment);
                fragment = f;
            }
            assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, 'data', data);
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
        }
        /**
         * Encodes the `tx.data` for a transaction that calls the function specified (see
         * {@link getFunction | **getFunction**} for valid values for `fragment`) with the `values`.
         */
        encodeFunctionData(fragment, values) {
            if (typeof fragment === 'string') {
                const f = this.getFunction(fragment);
                assertArgument(f, 'unknown function', 'fragment', fragment);
                fragment = f;
            }
            return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        /**
         * Decodes the result `data` (e.g. from an `quai_call`) for the specified function (see
         * {@link getFunction | **getFunction**} for valid values for `key`).
         *
         * Most developers should prefer the {@link parseCallResult | **parseCallResult**} method instead, which will
         * automatically detect a `CALL_EXCEPTION` and throw the corresponding error.
         */
        decodeFunctionResult(fragment, data) {
            if (typeof fragment === 'string') {
                const f = this.getFunction(fragment);
                assertArgument(f, 'unknown function', 'fragment', fragment);
                fragment = f;
            }
            let message = 'invalid length for result data';
            const bytes = getBytesCopy(data);
            if (bytes.length % 32 === 0) {
                try {
                    return this.#abiCoder.decode(fragment.outputs, bytes);
                }
                catch (error) {
                    message = 'could not decode result data';
                }
            }
            // Call returned data with no error, but the data is junk
            assert$1(false, message, 'BAD_DATA', {
                value: hexlify(bytes),
                info: { method: fragment.name, signature: fragment.format() },
            });
        }
        makeError(_data, tx) {
            const data = getBytes(_data, 'data');
            const error = AbiCoder.getBuiltinCallException('call', tx, data);
            // Not a built-in error; try finding a custom error
            const customPrefix = 'execution reverted (unknown custom error)';
            if (error.message.startsWith(customPrefix)) {
                const selector = hexlify(data.slice(0, 4));
                const ef = this.getError(selector);
                if (ef) {
                    try {
                        const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                        error.revert = {
                            name: ef.name,
                            signature: ef.format(),
                            args,
                        };
                        error.reason = error.revert.signature;
                        error.message = `execution reverted: ${error.reason}`;
                    }
                    catch (e) {
                        error.message = `execution reverted (coult not decode custom error)`;
                    }
                }
            }
            // Add the invocation, if available
            const parsed = this.parseTransaction(tx);
            if (parsed) {
                error.invocation = {
                    method: parsed.name,
                    signature: parsed.signature,
                    args: parsed.args,
                };
            }
            return error;
        }
        /**
         * Encodes the result data (e.g. from an `quai_call`) for the specified function (see
         * {@link getFunction | **getFunction**} for valid values for `fragment`) with `values`.
         *
         * This is generally not used by most developers, unless trying to mock a result from a Contract.
         */
        encodeFunctionResult(fragment, values) {
            if (typeof fragment === 'string') {
                const f = this.getFunction(fragment);
                assertArgument(f, 'unknown function', 'fragment', fragment);
                fragment = f;
            }
            return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
        }
        // Create the filter for the event with search criteria (e.g. for quai_filterLog)
        encodeFilterTopics(fragment, values) {
            if (typeof fragment === 'string') {
                const f = this.getEvent(fragment);
                assertArgument(f, 'unknown event', 'eventFragment', fragment);
                fragment = f;
            }
            assert$1(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, 'UNEXPECTED_ARGUMENT', { count: values.length, expectedCount: fragment.inputs.length });
            const topics = [];
            if (!fragment.anonymous) {
                topics.push(fragment.topicHash);
            }
            // @TODO: Use the coders for this; to properly support tuples, etc.
            const encodeTopic = (param, value) => {
                if (param.type === 'string') {
                    return id(value);
                }
                else if (param.type === 'bytes') {
                    return keccak256(hexlify(value));
                }
                if (param.type === 'bool' && typeof value === 'boolean') {
                    value = value ? '0x01' : '0x00';
                }
                else if (param.type.match(/^u?int/)) {
                    value = toBeHex(value); // @TODO: Should this toTwos??
                }
                else if (param.type.match(/^bytes/)) {
                    value = zeroPadBytes(value, 32);
                }
                else if (param.type === 'address') {
                    // Check addresses are valid
                    this.#abiCoder.encode(['address'], [value]);
                }
                return zeroPadValue(hexlify(value), 32);
            };
            values.forEach((value, index) => {
                const param = fragment.inputs[index];
                if (!param.indexed) {
                    assertArgument(value == null, 'cannot filter non-indexed parameters; must be null', 'contract.' + param.name, value);
                    return;
                }
                if (value == null) {
                    topics.push(null);
                }
                else if (param.baseType === 'array' || param.baseType === 'tuple') {
                    assertArgument(false, 'filtering with tuples or arrays not supported', 'contract.' + param.name, value);
                }
                else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                }
                else {
                    topics.push(encodeTopic(param, value));
                }
            });
            // Trim off trailing nulls
            while (topics.length && topics[topics.length - 1] === null) {
                topics.pop();
            }
            return topics;
        }
        encodeEventLog(fragment, values) {
            if (typeof fragment === 'string') {
                const f = this.getEvent(fragment);
                assertArgument(f, 'unknown event', 'eventFragment', fragment);
                fragment = f;
            }
            const topics = [];
            const dataTypes = [];
            const dataValues = [];
            if (!fragment.anonymous) {
                topics.push(fragment.topicHash);
            }
            assertArgument(values.length === fragment.inputs.length, 'event arguments/values mismatch', 'values', values);
            fragment.inputs.forEach((param, index) => {
                const value = values[index];
                if (param.indexed) {
                    if (param.type === 'string') {
                        topics.push(id(value));
                    }
                    else if (param.type === 'bytes') {
                        topics.push(keccak256(value));
                    }
                    else if (param.baseType === 'tuple' || param.baseType === 'array') {
                        // @TODO
                        throw new Error('not implemented');
                    }
                    else {
                        topics.push(this.#abiCoder.encode([param.type], [value]));
                    }
                }
                else {
                    dataTypes.push(param);
                    dataValues.push(value);
                }
            });
            return {
                data: this.#abiCoder.encode(dataTypes, dataValues),
                topics: topics,
            };
        }
        // Decode a filter for the event and the search criteria
        decodeEventLog(fragment, data, topics) {
            if (typeof fragment === 'string') {
                const f = this.getEvent(fragment);
                assertArgument(f, 'unknown event', 'eventFragment', fragment);
                fragment = f;
            }
            if (topics != null && !fragment.anonymous) {
                const eventTopic = fragment.topicHash;
                assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, 'fragment/topic mismatch', 'topics[0]', topics[0]);
                topics = topics.slice(1);
            }
            const indexed = [];
            const nonIndexed = [];
            const dynamic = [];
            // TODO: `index` is not used, remove?
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            fragment.inputs.forEach((param, index) => {
                if (param.indexed) {
                    if (param.type === 'string' ||
                        param.type === 'bytes' ||
                        param.baseType === 'tuple' ||
                        param.baseType === 'array') {
                        indexed.push(ParamType.from({ type: 'bytes32', name: param.name }));
                        dynamic.push(true);
                    }
                    else {
                        indexed.push(param);
                        dynamic.push(false);
                    }
                }
                else {
                    nonIndexed.push(param);
                    dynamic.push(false);
                }
            });
            const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
            const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
            //const result: (Array<any> & { [ key: string ]: any }) = [ ];
            const values = [];
            const keys = [];
            let nonIndexedIndex = 0, indexedIndex = 0;
            fragment.inputs.forEach((param, index) => {
                let value = null;
                if (param.indexed) {
                    if (resultIndexed == null) {
                        value = new Indexed(null);
                    }
                    else if (dynamic[index]) {
                        value = new Indexed(resultIndexed[indexedIndex++]);
                    }
                    else {
                        try {
                            value = resultIndexed[indexedIndex++];
                        }
                        catch (error) {
                            value = error;
                        }
                    }
                }
                else {
                    try {
                        value = resultNonIndexed[nonIndexedIndex++];
                    }
                    catch (error) {
                        value = error;
                    }
                }
                values.push(value);
                keys.push(param.name || null);
            });
            return Result.fromItems(values, keys);
        }
        /**
         * Parses a transaction, finding the matching function and extracts the parameter values along with other useful
         * function details.
         *
         * If the matching function cannot be found, return null.
         */
        parseTransaction(tx) {
            const data = getBytes(tx.data, 'tx.data');
            const value = getBigInt(tx.value != null ? tx.value : 0, 'tx.value');
            const fragment = this.getFunction(hexlify(data.slice(0, 4)));
            if (!fragment) {
                return null;
            }
            const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
            return new TransactionDescription(fragment, fragment.selector, args, value);
        }
        // TODO: not implemented
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        parseCallResult(data) {
            throw new Error('@TODO');
        }
        /**
         * Parses a receipt log, finding the matching event and extracts the parameter values along with other useful event
         * details.
         *
         * If the matching event cannot be found, returns null.
         */
        parseLog(log) {
            const fragment = this.getEvent(log.topics[0]);
            if (!fragment || fragment.anonymous) {
                return null;
            }
            // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
            //        Probably not, because just because it is the only event in the ABI does
            //        not mean we have the full ABI; maybe just a fragment?
            return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
        }
        /**
         * Parses a revert data, finding the matching error and extracts the parameter values along with other useful error
         * details.
         *
         * If the matching error cannot be found, returns null.
         */
        parseError(data) {
            const hexData = hexlify(data);
            const fragment = this.getError(dataSlice(hexData, 0, 4));
            if (!fragment) {
                return null;
            }
            const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
            return new ErrorDescription(fragment, fragment.selector, args);
        }
        /**
         * Creates a new {@link Interface | **Interface**} from the ABI `value`.
         *
         * The `value` may be provided as an existing {@link Interface | **Interface**} object, a JSON-encoded ABI or any
         * Human-Readable ABI format.
         */
        static from(value) {
            // Already an Interface, which is immutable
            if (value instanceof Interface) {
                return value;
            }
            // JSON
            if (typeof value === 'string') {
                return new Interface(JSON.parse(value));
            }
            // Maybe an interface from an older version, or from a symlinked copy
            if (typeof value.format === 'function') {
                return new Interface(value.format('json'));
            }
            // Array of fragments
            return new Interface(value);
        }
    }

    /**
     * Converts an address and storage keys into an access set.
     *
     * @param {string} addr - The address to validate and convert.
     * @param {string[]} storageKeys - The storage keys to validate and convert.
     * @returns {{ address: string; storageKeys: string[] }} The access set.
     */
    function accessSetify(addr, storageKeys) {
        validateAddress(addr);
        return {
            address: getAddress(addr),
            storageKeys: storageKeys.map((storageKey, index) => {
                assertArgument(isHexString(storageKey, 32), 'invalid slot', `storageKeys[${index}]`, storageKey);
                return storageKey.toLowerCase();
            }),
        };
    }
    /**
     * Returns an {@link AccessList | **AccessList**} from any quasi-supported access-list structure.
     *
     * @category Transaction
     * @param {AccessListish} value - The value to convert to an access list.
     * @returns {AccessList} The access list.
     * @throws {Error} If the value is not a valid access list.
     */
    function accessListify(value) {
        if (Array.isArray(value)) {
            return value.map((set, index) => {
                if (Array.isArray(set)) {
                    assertArgument(set.length === 2, 'invalid slot set', `value[${index}]`, set);
                    return accessSetify(formatMixedCaseChecksumAddress(set[0]), set[1]);
                }
                assertArgument(set != null && typeof set === 'object', 'invalid address-slot set', 'value', value);
                return accessSetify(formatMixedCaseChecksumAddress(set.address), set.storageKeys);
            });
        }
        assertArgument(value != null && typeof value === 'object', 'invalid access list', 'value', value);
        const result = Object.keys(value).map((addr) => {
            const storageKeys = value[addr].reduce((accum, storageKey) => {
                accum[storageKey] = true;
                return accum;
            }, {});
            return accessSetify(addr, Object.keys(storageKeys).sort());
        });
        result.sort((a, b) => a.address.localeCompare(b.address));
        return result;
    }

    /**
     * An **AbstractTransaction** describes the common operations to be executed on Quai and Qi ledgers by an Externally
     * Owned Account (EOA). This class must be subclassed by concrete implementations of transactions on each ledger.
     */
    class AbstractTransaction {
        _type;
        _signature;
        _chainId;
        /**
         * The transaction type.
         *
         * If null, the type will be automatically inferred based on explicit properties.
         */
        get type() {
            return this._type;
        }
        set type(value) {
            switch (value) {
                case null:
                    this._type = null;
                    break;
                case 0:
                case 'standard':
                    this._type = 0;
                    break;
                case 2:
                case 'utxo':
                    this._type = 2;
                    break;
                default:
                    assertArgument(false, 'unsupported transaction type', 'type', value);
            }
        }
        /**
         * The name of the transaction type.
         */
        get typeName() {
            switch (this.type) {
                case 0:
                    return 'standard';
                case 1:
                    return 'external';
                case 2:
                    return 'utxo';
            }
            return null;
        }
        /**
         * The chain ID this transaction is valid on.
         */
        get chainId() {
            return this._chainId;
        }
        set chainId(value) {
            this._chainId = getBigInt(value);
        }
        /**
         * If signed, the signature for this transaction.
         */
        get signature() {
            return (this._signature || null);
        }
        set signature(value) {
            if (typeof value === 'string') {
                this._signature = value;
            }
            else {
                this._signature = (value == null ? null : Signature.from(value));
            }
        }
        /**
         * Creates a new Transaction with default values.
         */
        constructor() {
            this._type = null;
            this._chainId = BigInt(0);
            this._signature = null;
        }
        /**
         * The pre-image hash of this transaction.
         *
         * This is the digest that a [Signer](../interfaces/Signer) must sign to authorize this transaction.
         */
        get digest() {
            return keccak256(this.unsignedSerialized);
        }
        /**
         * Returns true if signed.
         *
         * This provides a Type Guard that properties requiring a signed transaction are non-null.
         *
         * @returns {boolean} Indicates if the transaction is signed.
         */
        isSigned() {
            return this.signature != null;
        }
        /**
         * The serialized transaction.
         *
         * This throws if the transaction is unsigned. For the pre-image, use
         * {@link AbstractTransaction.unsignedSerialized | **unsignedSerialized** }.
         */
        get serialized() {
            assert$1(this.signature != null, 'cannot serialize unsigned transaction; maybe you meant .unsignedSerialized', 'UNSUPPORTED_OPERATION', { operation: '.serialized' });
            return encodeProtoTransaction(this.toProtobuf(true));
        }
        /**
         * The transaction pre-image.
         *
         * The hash of this is the digest which needs to be signed to authorize this transaction.
         */
        get unsignedSerialized() {
            return encodeProtoTransaction(this.toProtobuf(false));
        }
        /**
         * Return the most "likely" type; currently the highest supported transaction type.
         *
         * @returns {number} The inferred transaction type.
         */
        inferType() {
            return this.inferTypes().pop();
        }
        /**
         * Check if the transaction is external.
         *
         * @returns {boolean} True if the transaction is external.
         */
        get isExternal() {
            return this.destZone !== undefined && this.originZone !== this.destZone;
        }
    }

    /**
     * List of supported Qi denominations.
     *
     * @category Transaction
     */
    const denominations = [
        BigInt(1),
        BigInt(5),
        BigInt(10),
        BigInt(50),
        BigInt(100),
        BigInt(500),
        BigInt(1000),
        BigInt(5000),
        BigInt(10000),
        BigInt(20000),
        BigInt(100000),
        BigInt(1000000),
        BigInt(10000000),
        BigInt(100000000),
        BigInt(1000000000), // 1,000,000 Qi (1,000,000,000 Qit)
    ];
    /**
     * Checks if the provided denomination index is valid.
     *
     * @category Transaction
     * @param {number} index - The denomination index to check.
     * @returns {boolean} True if the denomination index is valid, false otherwise.
     */
    function isValidDenominationIndex(index) {
        return index >= 0 && index < denominations.length;
    }
    /**
     * Given a value, returns an array of supported denominations that sum to the value.
     *
     * @category Transaction
     * @param {bigint} value - The value to denominate.
     * @returns {bigint[]} An array of denominations that sum to the value.
     * @throws {Error} If the value is less than or equal to 0 or cannot be matched with available denominations.
     */
    function denominate(value, maxDenomination) {
        if (value <= BigInt(0)) {
            throw new Error('Value must be greater than 0');
        }
        const result = [];
        let remainingValue = BigInt(value);
        // Find the index of the maximum allowed denomination
        let maxDenominationIndex;
        if (maxDenomination != null) {
            maxDenominationIndex = denominations.findIndex((d) => d === maxDenomination);
            if (maxDenominationIndex === -1) {
                throw new Error('Invalid maximum denomination');
            }
        }
        else {
            // No maximum denomination set, use the highest denomination
            maxDenominationIndex = denominations.length - 1;
        }
        // Iterate through denominations in descending order, up to the maximum allowed denomination
        for (let i = maxDenominationIndex; i >= 0; i--) {
            const denomination = denominations[i];
            // Add the denomination to the result array as many times as possible
            while (remainingValue >= denomination) {
                result.push(denomination);
                remainingValue -= BigInt(denomination);
            }
        }
        if (remainingValue > 0) {
            throw new Error('Unable to match the value with available denominations');
        }
        return result;
    }
    /**
     * Represents a UTXO (Unspent Transaction Output).
     *
     * @category Transaction
     * @implements {UTXOLike}
     */
    class UTXO {
        #txhash;
        #index;
        #address;
        #denomination;
        #lock;
        /**
         * Gets the transaction hash.
         *
         * @returns {null | string} The transaction hash.
         */
        get txhash() {
            return this.#txhash;
        }
        /**
         * Sets the transaction hash.
         *
         * @param {null | string} value - The transaction hash.
         */
        set txhash(value) {
            this.#txhash = value;
        }
        /**
         * Gets the index.
         *
         * @returns {null | number} The index.
         */
        get index() {
            return this.#index;
        }
        /**
         * Sets the index.
         *
         * @param {null | number} value - The index.
         */
        set index(value) {
            this.#index = value;
        }
        /**
         * Gets the address.
         *
         * @returns {string} The address.
         */
        get address() {
            return this.#address || '';
        }
        /**
         * Sets the address.
         *
         * @param {string} value - The address.
         * @throws {Error} If the address is invalid.
         */
        set address(value) {
            validateAddress(value);
            this.#address = value;
        }
        /**
         * Gets the denomination.
         *
         * @returns {null | number} The denomination.
         */
        get denomination() {
            return this.#denomination;
        }
        /**
         * Sets the denomination.
         *
         * @param {null | number} value - The denomination.
         * @throws {Error} If the denomination value is invalid.
         */
        set denomination(value) {
            if (value == null) {
                this.#denomination = null;
                return;
            }
            if (!isValidDenominationIndex(value)) {
                throw new Error('Invalid denomination value');
            }
            this.#denomination = value;
        }
        get lock() {
            return this.#lock;
        }
        set lock(value) {
            this.#lock = value;
        }
        /**
         * Constructs a new UTXO instance with null properties.
         */
        constructor() {
            this.#txhash = null;
            this.#index = null;
            this.#address = null;
            this.#denomination = null;
            this.#lock = null;
        }
        /**
         * Converts the UTXO instance to a JSON object.
         *
         * @returns {any} A JSON representation of the UTXO instance.
         */
        toJSON() {
            return {
                txhash: this.txhash,
                index: this.index,
                address: this.address,
                denomination: this.denomination,
            };
        }
        /**
         * Creates a UTXO instance from a UTXOLike object.
         *
         * @param {UTXOLike} utxo - The UTXOLike object to convert.
         * @returns {UTXO} The UTXO instance.
         */
        static from(utxo) {
            if (utxo === null) {
                return new UTXO();
            }
            const result = utxo instanceof UTXO ? utxo : new UTXO();
            if (utxo.txhash != null) {
                result.txhash = utxo.txhash;
            }
            if (utxo.index != null) {
                result.index = utxo.index;
            }
            if (utxo.address != null && utxo.address !== '') {
                result.address = utxo.address;
            }
            if (utxo.denomination != null) {
                result.denomination = utxo.denomination;
            }
            return result;
        }
    }

    class AbstractCoinSelector {
        availableUTXOs;
        totalInputValue = BigInt(0);
        spendOutputs = [];
        changeOutputs = [];
        selectedUTXOs = [];
        target = null;
        /**
         * Constructs a new AbstractCoinSelector instance with an empty UTXO array.
         *
         * @param {UTXO[]} [availableUXTOs=[]] - The initial available UTXOs. Default is `[]`
         */
        constructor(availableUTXOs = []) {
            this.availableUTXOs = availableUTXOs.map((utxo) => {
                this._validateUTXO(utxo);
                return utxo;
            });
            this.spendOutputs = [];
            this.changeOutputs = [];
        }
        /**
         * Validates the provided UTXO instance. In order to be valid for coin selection, the UTXO must have a valid address
         * and denomination.
         *
         * @param {UTXO} utxo - The UTXO to validate.
         * @throws {Error} If the UTXO is invalid.
         * @protected
         */
        _validateUTXO(utxo) {
            if (utxo.address == null) {
                throw new Error('UTXO address is required');
            }
            if (utxo.denomination == null) {
                throw new Error('UTXO denomination is required');
            }
            if (utxo.txhash == null) {
                throw new Error('UTXO txhash is required');
            }
            if (utxo.index == null) {
                throw new Error('UTXO index is required');
            }
        }
        /**
         * Validates the available UTXOs.
         *
         * @throws Will throw an error if there are no available UTXOs.
         */
        validateUTXOs() {
            if (this.availableUTXOs.length === 0) {
                throw new Error('No UTXOs available');
            }
        }
        /**
         * Sorts UTXOs by their denomination.
         *
         * @param {UTXO[]} utxos - The UTXOs to sort.
         * @param {'asc' | 'desc'} direction - The direction to sort ('asc' for ascending, 'desc' for descending).
         * @returns {UTXO[]} The sorted UTXOs.
         */
        sortUTXOsByDenomination(utxos, direction) {
            if (direction === 'asc') {
                return [...utxos].sort((a, b) => {
                    const diff = BigInt(a.denomination !== null ? denominations[a.denomination] : 0) -
                        BigInt(b.denomination !== null ? denominations[b.denomination] : 0);
                    return diff > BigInt(0) ? 1 : diff < BigInt(0) ? -1 : 0;
                });
            }
            return [...utxos].sort((a, b) => {
                const diff = BigInt(b.denomination !== null ? denominations[b.denomination] : 0) -
                    BigInt(a.denomination !== null ? denominations[a.denomination] : 0);
                return diff > BigInt(0) ? 1 : diff < BigInt(0) ? -1 : 0;
            });
        }
    }

    // import { bigIntAbs } from '../utils/maths.js';
    /**
     * The FewestCoinSelector class provides a coin selection algorithm that selects the fewest UTXOs required to meet the
     * target amount. This algorithm is useful for minimizing the size of the transaction and the fees associated with it.
     *
     * This class is a sub-class of {@link AbstractCoinSelector | **AbstractCoinSelector** } and implements the
     * {@link AbstractCoinSelector.performSelection | **performSelection** } method to provide the actual coin selection
     * logic.
     *
     * @category Transaction
     */
    class FewestCoinSelector extends AbstractCoinSelector {
        /**
         * Performs coin selection to meet the target amount plus fee, using the smallest possible denominations and
         * minimizing the number of inputs and outputs.
         *
         * @param {bigint} target - The target amount to spend.
         * @param {bigint} fee - The fee amount to include in the selection.
         * @returns {SelectedCoinsResult} The selected UTXOs and outputs.
         */
        performSelection(config) {
            const { target = BigInt(0), fee = BigInt(0) } = config;
            if (target <= BigInt(0)) {
                throw new Error('Target amount must be greater than 0');
            }
            if (fee < BigInt(0)) {
                throw new Error('Fee amount cannot be negative');
            }
            this.validateUTXOs();
            this.target = target;
            const totalRequired = BigInt(target) + BigInt(fee);
            // Initialize selection state
            this.selectedUTXOs = [];
            this.totalInputValue = BigInt(0);
            // Sort available UTXOs by denomination in ascending order
            const sortedUTXOs = this.sortUTXOsByDenomination(this.availableUTXOs, 'asc');
            // Attempt to find a single UTXO that can cover the total required amount
            const singleUTXO = sortedUTXOs.find((utxo) => BigInt(denominations[utxo.denomination]) >= totalRequired);
            if (singleUTXO) {
                // Use the smallest UTXO that can cover the total required amount
                this.selectedUTXOs.push(singleUTXO);
                this.totalInputValue = BigInt(denominations[singleUTXO.denomination]);
            }
            else {
                // If no single UTXO can cover the total required amount, find the minimal set
                this.selectedUTXOs = this.findMinimalUTXOSet(sortedUTXOs, totalRequired);
                if (this.selectedUTXOs.length === 0) {
                    throw new Error('Insufficient funds');
                }
                // Calculate total input value
                this.totalInputValue = this.selectedUTXOs.reduce((sum, utxo) => sum + BigInt(denominations[utxo.denomination]), BigInt(0));
            }
            // Create outputs
            const changeAmount = this.totalInputValue - BigInt(target) - BigInt(fee);
            // Create spend outputs (to the recipient)
            this.spendOutputs = this.createSpendOutputs(target);
            // Create change outputs (to ourselves), if any
            this.changeOutputs = this.createChangeOutputs(changeAmount);
            // Verify that sum of outputs does not exceed sum of inputs
            const totalOutputValue = this.calculateTotalOutputValue();
            if (totalOutputValue > this.totalInputValue) {
                throw new Error('Total output value exceeds total input value');
            }
            return {
                inputs: this.selectedUTXOs,
                spendOutputs: this.spendOutputs,
                changeOutputs: this.changeOutputs,
            };
        }
        /**
         * Finds the minimal set of UTXOs that can cover the total required amount.
         *
         * @param {UTXO[]} sortedUTXOs - Available UTXOs sorted by denomination (ascending).
         * @param {bigint} totalRequired - The total amount required (target + fee).
         * @returns {UTXO[]} The minimal set of UTXOs.
         */
        findMinimalUTXOSet(sortedUTXOs, totalRequired) {
            // First, try to find the smallest single UTXO that covers the total required amount
            const singleUTXO = sortedUTXOs.find((utxo) => BigInt(denominations[utxo.denomination]) >= totalRequired);
            if (singleUTXO) {
                return [singleUTXO];
            }
            // If no single UTXO is sufficient, use a greedy algorithm starting from the largest denominations
            const utxos = [...sortedUTXOs].reverse(); // Largest to smallest
            let totalValue = BigInt(0);
            const selectedUTXOs = [];
            for (const utxo of utxos) {
                if (totalValue >= totalRequired) {
                    break;
                }
                selectedUTXOs.push(utxo);
                totalValue += BigInt(denominations[utxo.denomination]);
            }
            if (totalValue >= totalRequired) {
                return selectedUTXOs;
            }
            else {
                return []; // Insufficient funds
            }
        }
        /**
         * Creates spend outputs based on the target amount and input denominations.
         *
         * @param {bigint} amount - The target amount to spend.
         * @param {UTXO[]} inputs - The selected inputs.
         * @returns {UTXO[]} The spend outputs.
         */
        createSpendOutputs(amount) {
            const maxInputDenomination = this.getMaxInputDenomination();
            // Denominate the amount using available denominations up to the max input denomination
            const spendDenominations = denominate(amount, maxInputDenomination);
            return spendDenominations.map((denominationValue) => {
                const utxo = new UTXO();
                utxo.denomination = denominations.indexOf(denominationValue);
                return utxo;
            });
        }
        /**
         * Creates change outputs based on the change amount and input denominations.
         *
         * @param {bigint} change - The change amount to return.
         * @param {UTXO[]} inputs - The selected inputs.
         * @returns {UTXO[]} The change outputs.
         */
        createChangeOutputs(change) {
            if (change <= BigInt(0)) {
                return [];
            }
            const maxInputDenomination = this.getMaxInputDenomination();
            // Denominate the change amount using available denominations up to the max input denomination
            const changeDenominations = denominate(change, maxInputDenomination);
            return changeDenominations.map((denominationValue) => {
                const utxo = new UTXO();
                utxo.denomination = denominations.indexOf(denominationValue);
                return utxo;
            });
        }
        /**
         * Calculates the total value of outputs (spend + change).
         *
         * @returns {bigint} The total output value.
         */
        calculateTotalOutputValue() {
            const spendValue = this.spendOutputs.reduce((sum, output) => sum + BigInt(denominations[output.denomination]), BigInt(0));
            const changeValue = this.changeOutputs.reduce((sum, output) => sum + BigInt(denominations[output.denomination]), BigInt(0));
            return spendValue + changeValue;
        }
        /**
         * Gets the maximum denomination value from the selected UTXOs.
         *
         * @returns {bigint} The maximum input denomination value.
         */
        getMaxInputDenomination() {
            const inputs = [...this.selectedUTXOs];
            return this.getMaxDenomination(inputs);
        }
        /**
         * Gets the maximum denomination value from the spend and change outputs.
         *
         * @returns {bigint} The maximum output denomination value.
         */
        getMaxOutputDenomination() {
            const outputs = [...this.spendOutputs, ...this.changeOutputs];
            return this.getMaxDenomination(outputs);
        }
        /**
         * Gets the maximum denomination value from a list of UTXOs.
         *
         * @param {UTXO[]} utxos - The list of UTXOs.
         * @returns {bigint} The maximum denomination value.
         */
        getMaxDenomination(utxos) {
            return utxos.reduce((max, utxo) => {
                const denomValue = BigInt(denominations[utxo.denomination]);
                return denomValue > max ? denomValue : max;
            }, BigInt(0));
        }
        /**
         * Increases the total fee by first reducing change outputs, then selecting additional inputs if necessary.
         *
         * @param {bigint} additionalFeeNeeded - The additional fee needed.
         * @returns {boolean} Returns true if successful, false if insufficient funds.
         */
        increaseFee(additionalFeeNeeded) {
            let remainingFee = BigInt(additionalFeeNeeded);
            // First, try to cover the fee by reducing change outputs
            const totalChange = this.changeOutputs.reduce((sum, output) => BigInt(sum) + BigInt(denominations[output.denomination]), BigInt(0));
            if (totalChange >= remainingFee) {
                // We can cover the fee by reducing change outputs
                this.adjustChangeOutputs(totalChange - remainingFee);
                return {
                    inputs: this.selectedUTXOs,
                    spendOutputs: this.spendOutputs,
                    changeOutputs: this.changeOutputs,
                };
            }
            // If we can't cover the entire fee with change, reduce change to zero and calculate remaining fee
            remainingFee -= BigInt(totalChange);
            this.changeOutputs = [];
            // Now, select additional inputs to cover the remaining fee
            const unusedUTXOs = this.availableUTXOs.filter((utxo) => !this.selectedUTXOs.includes(utxo));
            const sortedUTXOs = this.sortUTXOsByDenomination(unusedUTXOs, 'asc');
            for (const utxo of sortedUTXOs) {
                this.selectedUTXOs.push(utxo);
                this.totalInputValue += BigInt(denominations[utxo.denomination]);
                remainingFee -= BigInt(denominations[utxo.denomination]);
                if (remainingFee <= BigInt(0)) {
                    // If we have excess, create a new change output
                    if (remainingFee < BigInt(0)) {
                        const change = BigInt(this.totalInputValue) - BigInt(this.target) - BigInt(additionalFeeNeeded);
                        this.adjustChangeOutputs(change);
                    }
                }
            }
            return {
                inputs: this.selectedUTXOs,
                spendOutputs: this.spendOutputs,
                changeOutputs: this.changeOutputs,
            };
        }
        /**
         * Decreases the fee by removing inputs if possible and adjusting change outputs.
         *
         * @param {bigint} feeReduction - The amount by which the fee has decreased.
         * @returns {void}
         */
        decreaseFee(feeReduction) {
            let excessValue = feeReduction;
            // First, try to remove inputs
            const sortedInputs = this.sortUTXOsByDenomination(this.selectedUTXOs, 'desc');
            const inputsToRemove = [];
            for (const input of sortedInputs) {
                const inputValue = BigInt(denominations[input.denomination]);
                if (excessValue >= inputValue && this.totalInputValue - inputValue >= this.target) {
                    inputsToRemove.push(input);
                    excessValue -= BigInt(inputValue);
                    this.totalInputValue -= BigInt(inputValue);
                }
                if (excessValue === BigInt(0))
                    break;
            }
            // Remove the identified inputs
            this.selectedUTXOs = this.selectedUTXOs.filter((utxo) => !inputsToRemove.includes(utxo));
            // If there's still excess value, add it to change outputs
            if (excessValue > BigInt(0)) {
                this.adjustChangeOutputs(excessValue);
            }
            return {
                inputs: this.selectedUTXOs,
                spendOutputs: this.spendOutputs,
                changeOutputs: this.changeOutputs,
            };
        }
        /**
         * Helper method to adjust change outputs.
         *
         * @param {bigint} changeAmount - The amount to adjust change outputs by.
         */
        adjustChangeOutputs(changeAmount) {
            if (changeAmount <= BigInt(0)) {
                this.changeOutputs = [];
                return;
            }
            this.changeOutputs = this.createChangeOutputs(changeAmount);
        }
    }

    /**
     * A coin selector that aggregates multiple UTXOs into larger denominations. It attempts to combine smaller denomination
     * UTXOs into the largest possible denominations.
     */
    class AggregateCoinSelector extends AbstractCoinSelector {
        /**
         * Performs coin selection by aggregating UTXOs into larger denominations. This implementation combines smaller
         * denomination UTXOs into the largest possible denominations up to maxDenomination, while ensuring enough value
         * remains to cover the transaction fee.
         *
         * @param {CoinSelectionConfig} config - The configuration object containing:
         * @param {boolean} [config.includeLocked=false] - Whether to include locked UTXOs in the selection. Default is
         *   `false`
         * @param {bigint} [config.fee=0n] - The fee amount to account for. Default is `0n`
         * @param {number} [config.maxDenomination=6] - The maximum denomination to aggregate up to (default 6 = 1 Qi).
         *   Default is `6`
         * @returns {SelectedCoinsResult} The selected UTXOs and aggregated outputs
         * @throws {Error} If no eligible UTXOs are available for aggregation
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        performSelection(config) {
            const { includeLocked = false, fee = BigInt(0), maxDenomination = 6, // Default to denomination[6] (1 Qi)
             } = config;
            this.validateUTXOs();
            // Filter UTXOs based on lock status if needed
            const eligibleUTXOs = includeLocked
                ? this.availableUTXOs
                : this.availableUTXOs.filter((utxo) => utxo.lock === null || utxo.lock === 0);
            // totalInputValue is the sum of the denominations of the eligible UTXOsregardless of maxDenomination
            this.totalInputValue = eligibleUTXOs.reduce((sum, utxo) => sum + BigInt(denominations[utxo.denomination]), BigInt(0));
            // get the UTXOs that are below maxDenomination
            const smallDenominationsUTXOs = eligibleUTXOs.filter((utxo) => utxo.denomination < maxDenomination);
            if (smallDenominationsUTXOs.length === 0) {
                throw new Error('No eligible UTXOs available for aggregation');
            }
            // get the UTXOs that are above or equal to maxDenomination
            const bigDenominationUTXOs = eligibleUTXOs.filter((utxo) => utxo.denomination >= maxDenomination);
            // calculate the sum of the denominations of the big denomination UTXOs
            const totalInputValueAboveMaxDenomination = bigDenominationUTXOs.reduce((sum, utxo) => sum + BigInt(denominations[utxo.denomination]), BigInt(0));
            // calculate the sum of the denominations of the small denomination UTXOs
            const totalInputValueBelowMaxDenomination = this.totalInputValue - totalInputValueAboveMaxDenomination;
            // The valueToAggregate value is calculated as:
            // 1. If the total value of bigDenominationsUTXOs is greater than the fee, then the fee is covered by bigDenominationsUTXOs, and
            //    the valueToAggregate is the value of small denomination UTXOs, i.e.:
            //    valueToAggregate = totalInputValueBelowMaxDenomination
            // 2. Otherwise, the valueToAggregate equals the value of small denomination UTXOs minus
            //    the difference between the fee and the value of the big denomination UTXOs, i.e.:
            //    valueToAggregate = totalInputValueBelowMaxDenomination - (fee - totalInputValueAboveMaxDenomination)
            const valueToAggregate = totalInputValueAboveMaxDenomination >= fee
                ? totalInputValueBelowMaxDenomination
                : totalInputValueBelowMaxDenomination - (fee - totalInputValueAboveMaxDenomination);
            if (valueToAggregate <= BigInt(0)) {
                throw new Error('Insufficient funds to cover fee');
            }
            this.spendOutputs = this.createOptimalDenominations(valueToAggregate);
            // get the inputs to cover the valueToAggregate
            const inputsToAggregate = this.getInputsToAggregate(smallDenominationsUTXOs, valueToAggregate);
            // get UTXOs inputs not included in inputsToAggregate to cover the fee.
            const feeInputs = this.getInputsForFee(inputsToAggregate, eligibleUTXOs, fee);
            // calculate the value of the feeInputs
            const feeInputsValue = feeInputs.reduce((sum, utxo) => sum + BigInt(denominations[utxo.denomination]), BigInt(0));
            // if the feeInputs value is higher than the fee, add the difference to the outputs to compensate the fee
            if (feeInputsValue > fee) {
                const difference = feeInputsValue - fee;
                const additionalOutputs = this.createOptimalDenominations(difference);
                this.spendOutputs.push(...additionalOutputs);
            }
            this.selectedUTXOs = [...feeInputs, ...inputsToAggregate];
            // if the number of outputs is greater than or equal to the number of inputs to aggregate, throw an error
            if (this.spendOutputs.length >= inputsToAggregate.length) {
                throw new Error('Aggregation would not reduce number of UTXOs');
            }
            this.changeOutputs = [];
            return {
                inputs: this.selectedUTXOs,
                spendOutputs: this.spendOutputs,
                changeOutputs: this.changeOutputs,
            };
        }
        /**
         * Helper method to calculate the optimal denomination distribution for a given value.
         *
         * @param {bigint} value - The value to optimize denominations for
         * @returns {UTXO[]} Array of UTXOs with optimal denomination distribution
         */
        createOptimalDenominations(value) {
            const outputs = [];
            let remaining = value;
            for (let i = denominations.length - 1; i >= 0 && remaining > BigInt(0); i--) {
                const denomination = denominations[i];
                while (remaining >= denomination) {
                    const output = new UTXO();
                    output.denomination = i;
                    outputs.push(output);
                    remaining -= denomination;
                }
            }
            if (remaining > BigInt(0)) {
                throw new Error('Unable to create optimal denominations');
            }
            return outputs;
        }
        // gets the input UTXOs to cover the fee
        getInputsForFee(inputsToAggregate, eligibleUTXOs, fee) {
            // get the input UTXOs that are not included in inputsToAggregate
            const eligiblefeeInputs = eligibleUTXOs.filter((utxo) => !inputsToAggregate.some((input) => input.txhash === utxo.txhash && input.index === utxo.index));
            const sortedUTXOs = this.sortUTXOsByDenomination(eligiblefeeInputs, 'asc');
            // loop through sortedUTXOs and sum the denominations until the sum is greater than or equal to the fee
            let sum = BigInt(0);
            const feeInputs = [];
            for (const utxo of sortedUTXOs) {
                sum += BigInt(denominations[utxo.denomination]);
                feeInputs.push(utxo);
                if (sum >= fee) {
                    return feeInputs;
                }
            }
            throw new Error('Unable to find inputs to cover fee');
        }
        // gets the input UTXOs whose value equals the amount to aggregate, i.e. valueToAggregate
        getInputsToAggregate(smallDenominationsUTXOs, valueToAggregate) {
            const sortedUTXOs = this.sortUTXOsByDenomination(smallDenominationsUTXOs, 'asc');
            const inputsToAggregate = [];
            for (const utxo of sortedUTXOs) {
                inputsToAggregate.push(utxo);
                if (inputsToAggregate.reduce((sum, utxo) => sum + BigInt(denominations[utxo.denomination]), BigInt(0)) ===
                    valueToAggregate) {
                    return inputsToAggregate;
                }
            }
            throw new Error('Unable to find inputs to aggregate');
        }
    }

    /**
     * @ignore
     */
    const BN_0$2 = BigInt(0);
    function allowNull(format, nullValue) {
        return function (value) {
            if (value == null) {
                return nullValue;
            }
            return format(value);
        };
    }
    function arrayOf(format) {
        return (array) => {
            if (!Array.isArray(array)) {
                throw new Error('not an array');
            }
            return array.map((i) => format(i));
        };
    }
    // Requires an object which matches a fleet of other formatters
    // Any FormatFunc may return `undefined` to have the value omitted
    // from the result object. Calls preserve `this`.
    function object(format, altNames) {
        return (value) => {
            const result = {};
            for (const key in format) {
                let srcKey = key;
                if (altNames && key in altNames && !(srcKey in value)) {
                    for (const altKey of altNames[key]) {
                        if (altKey in value) {
                            srcKey = altKey;
                            break;
                        }
                    }
                }
                try {
                    const nv = format[key](value[srcKey]);
                    if (nv !== undefined) {
                        result[key] = nv;
                    }
                }
                catch (error) {
                    const message = error instanceof Error ? error.message : 'not-an-error';
                    assert$1(false, `invalid value for value.${key} (${message})`, 'BAD_DATA', { value });
                }
            }
            return result;
        };
    }
    function formatBoolean(value) {
        switch (value) {
            case true:
            case 'true':
                return true;
            case false:
            case 'false':
                return false;
        }
        assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, 'value', value);
    }
    function formatData(value) {
        assertArgument(isHexString(value), 'invalid data', 'value', value);
        return value;
    }
    function formatHash(value) {
        assertArgument(isHexString(value, 32), 'invalid hash', 'value', value);
        return value;
    }
    function handleNumber(_value, param) {
        if (_value === '0x') {
            return 0;
        }
        return getNumber(_value, param);
    }
    function formatNumber(_value, name) {
        const value = getBigInt(_value, 'value');
        const result = toBeArray(value);
        assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
        return result;
    }
    const _formatLog = object({
        address: getAddress,
        blockHash: formatHash,
        blockNumber: getNumber,
        data: formatData,
        index: getNumber,
        removed: allowNull(formatBoolean, false),
        topics: arrayOf(formatHash),
        transactionHash: formatHash,
        transactionIndex: getNumber,
    }, {
        index: ['logIndex'],
    });
    function formatLog(value) {
        return _formatLog(value);
    }
    const _formatHeader = object({
        baseFeePerGas: getBigInt,
        efficiencyScore: getBigInt,
        etxEligibleSlices: formatHash,
        etxSetRoot: formatHash,
        evmRoot: formatHash,
        expansionNumber: getNumber,
        etxRollupRoot: formatHash,
        outboundEtxsRoot: formatHash,
        extraData: formatData,
        gasLimit: getBigInt,
        gasUsed: getBigInt,
        interlinkRootHash: formatHash,
        manifestHash: arrayOf(formatHash),
        number: arrayOf(getNumber),
        parentDeltaEntropy: arrayOf(getBigInt),
        parentEntropy: arrayOf(getBigInt),
        parentHash: arrayOf(formatHash),
        parentUncledDeltaEntropy: arrayOf(getBigInt),
        primeTerminusHash: formatHash,
        quaiStateSize: getBigInt,
        receiptsRoot: formatHash,
        uncleHash: formatHash,
        size: getBigInt,
        stateLimit: getBigInt,
        stateUsed: getBigInt,
        thresholdCount: getBigInt,
        transactionsRoot: formatHash,
        uncledEntropy: getBigInt,
        utxoRoot: formatHash,
        secondaryCoinbase: allowNull(getAddress),
        exchangeRate: getBigInt,
        quaiToQi: getBigInt,
        qiToQuai: getBigInt,
    });
    const _formatUncle = object({
        primaryCoinbase: allowNull(getAddress),
        difficulty: getNumber,
        headerHash: formatHash,
        location: formatData,
        mixHash: formatHash,
        nonce: formatData,
        number: getNumber,
        parentHash: formatHash,
        primeTerminusNumber: getNumber,
        timestamp: getNumber,
        txHash: formatHash,
        lock: getNumber,
    });
    const _formatBlock = object({
        outboundEtxs: arrayOf((tx) => {
            if (typeof tx === 'string') {
                return formatHash(tx);
            }
            return formatExternalTransactionResponse(tx);
        }),
        hash: formatHash,
        header: _formatHeader,
        interlinkHashes: arrayOf(formatHash),
        size: getBigInt,
        subManifest: arrayOf(formatData),
        totalEntropy: getBigInt,
        transactions: arrayOf((tx) => {
            if (typeof tx === 'string') {
                return formatHash(tx);
            }
            return formatTransactionResponse(tx);
        }),
        uncles: arrayOf(_formatUncle),
        woHeader: _formatUncle,
        workShares: allowNull(arrayOf(_formatUncle), []),
    });
    function formatBlock(value) {
        const result = _formatBlock(value);
        result.transactions = value.transactions.map((tx) => {
            if (typeof tx === 'string') {
                return tx;
            }
            if ('originatingTxHash' in tx) {
                return formatExternalTransactionResponse(tx);
            }
            return formatTransactionResponse(tx);
        });
        result.outboundEtxs = value.outboundEtxs.map((tx) => {
            if (typeof tx === 'string') {
                return tx;
            }
            return formatExternalTransactionResponse(tx);
        });
        return result;
    }
    const _formatReceiptLog = object({
        transactionIndex: getNumber,
        blockNumber: getNumber,
        transactionHash: formatHash,
        address: getAddress,
        topics: arrayOf(formatHash),
        data: formatData,
        index: getNumber,
        blockHash: formatHash,
    }, {
        index: ['logIndex'],
    });
    function formatReceiptLog(value) {
        return _formatReceiptLog(value);
    }
    const _formatEtx = object({
        type: allowNull(getNumber, 0),
        nonce: allowNull(getNumber),
        gasPrice: allowNull(getBigInt),
        minerTip: allowNull(getBigInt),
        gas: allowNull(getBigInt),
        value: allowNull(getBigInt, BN_0$2),
        input: allowNull(formatData),
        to: allowNull(getAddress, null),
        accessList: allowNull(accessListify, null),
        from: getAddress,
        originatingTxHash: formatHash,
        etxIndex: getNumber,
        chainId: allowNull(getBigInt, null),
        etxType: getNumber,
        hash: formatHash,
    }, {
        from: ['from'],
    });
    function formatEtx(value) {
        return _formatEtx(value);
    }
    const _formatTransactionReceipt = object({
        to: allowNull(getAddress, null),
        from: allowNull(getAddress, null),
        contractAddress: allowNull(getAddress, null),
        index: getNumber,
        gasUsed: getBigInt,
        logsBloom: allowNull(formatData),
        blockHash: formatHash,
        hash: formatHash,
        logs: arrayOf(formatReceiptLog),
        blockNumber: getNumber,
        cumulativeGasUsed: getBigInt,
        effectiveGasPrice: allowNull(getBigInt),
        status: allowNull(getNumber),
        type: allowNull(getNumber, 0),
        outboundEtxs: (value) => (value ? arrayOf(formatEtx)(value) : value),
        originatingTxHash: allowNull(formatHash),
        etxType: allowNull(getNumber),
    }, {
        hash: ['transactionHash'],
        index: ['transactionIndex'],
    });
    function formatTransactionReceipt(value) {
        const result = _formatTransactionReceipt(value);
        return result;
    }
    function formatTransactionResponse(value) {
        // Determine if it is a Quai or Qi transaction based on the type
        const transactionType = parseInt(value.type, 16);
        switch (transactionType) {
            case 0x0:
                return formatQuaiTransactionResponse(value);
            case 0x1:
                return formatExternalTransactionResponse(value);
            case 0x2:
                return formatQiTransactionResponse(value);
            default:
                throw new Error('Unknown transaction type');
        }
    }
    function formatExternalTransactionResponse(value) {
        const result = object({
            hash: formatHash,
            type: (value) => {
                if (value === '0x' || value == null) {
                    return 0;
                }
                return parseInt(value, 16);
            },
            accessList: allowNull(accessListify, null),
            blockHash: allowNull(formatHash, null),
            blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
            index: allowNull((value) => (value ? BigInt(value) : null), null),
            from: allowNull(getAddress, null),
            minerTip: allowNull((value) => (value ? BigInt(value) : null)),
            gasPrice: allowNull((value) => (value ? BigInt(value) : null)),
            gasLimit: allowNull((value) => (value ? BigInt(value) : null), null),
            to: allowNull(getAddress, null),
            value: allowNull((value) => (value ? BigInt(value) : null), null),
            nonce: allowNull((value) => (value ? parseInt(value, 10) : null), null),
            creates: allowNull(getAddress, null),
            chainId: allowNull((value) => (value ? BigInt(value) : null), null),
            originatingTxHash: allowNull(formatHash, null),
            etxIndex: allowNull((value) => (value ? parseInt(value, 10) : null), null),
            etxType: allowNull((value) => value, null),
            data: (value) => value,
        }, {
            data: ['input'],
            gasLimit: ['gas'],
            index: ['transactionIndex'],
        })(value);
        // 0x0000... should actually be null
        if (result.blockHash && getBigInt(result.blockHash) === BN_0$2) {
            result.blockHash = null;
        }
        return result;
    }
    function formatQuaiTransactionResponse(value) {
        const result = object({
            hash: formatHash,
            type: (value) => {
                if (value === '0x' || value == null) {
                    return 0;
                }
                return parseInt(value, 16);
            },
            accessList: allowNull(accessListify, null),
            blockHash: allowNull(formatHash, null),
            blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
            index: allowNull((value) => (value ? BigInt(value) : null), null),
            from: allowNull(getAddress, null),
            minerTip: allowNull((value) => (value ? BigInt(value) : null)),
            gasPrice: allowNull((value) => (value ? BigInt(value) : null)),
            gasLimit: allowNull((value) => (value ? BigInt(value) : null), null),
            to: allowNull(getAddress, null),
            value: allowNull((value) => (value ? BigInt(value) : null), null),
            nonce: allowNull((value) => (value ? parseInt(value, 10) : null), null),
            creates: allowNull(getAddress, null),
            chainId: allowNull((value) => (value ? BigInt(value) : null), null),
            etxType: allowNull((value) => parseInt(value, 16), null),
            data: (value) => value,
        }, {
            data: ['input'],
            gasLimit: ['gas'],
            index: ['transactionIndex'],
        })(value);
        // Add an access list if missing
        if (value.accessList == null) {
            result.accessList = [];
        }
        // Compute the signature
        if (value.signature) {
            result.signature = Signature.from(value.signature);
            // Some backends omit ChainId on legacy transactions, but we can compute it
            if (result.chainId == null) {
                const chainId = result.signature.legacyChainId;
                if (chainId != null) {
                    result.chainId = chainId;
                }
            }
        }
        // 0x0000... should actually be null
        if (result.blockHash && getBigInt(result.blockHash) === BN_0$2) {
            result.blockHash = null;
        }
        return result;
    }
    function formatQiTransactionResponse(value) {
        return object({
            hash: formatHash,
            type: (value) => {
                if (value === '0x' || value == null) {
                    return 0;
                }
                return parseInt(value, 16);
            },
            blockHash: allowNull(formatHash, null),
            blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
            chainId: allowNull((value) => (value ? BigInt(value) : null), null),
            signature: (value) => value,
            txInputs: allowNull(formatTxInputs, []),
            txOutputs: allowNull(formatTxOutputs, []),
        }, {
            index: ['transactionIndex'],
            signature: ['utxoSignature'],
            txInputs: ['inputs'],
            txOutputs: ['outputs'],
        })(value);
    }
    const formatTxInputs = (value) => {
        return value?.map(_formatTxInput);
    };
    const _formatTxInput = (value) => {
        return {
            txhash: formatHash(value.previousOutPoint.txHash),
            index: getNumber(value.previousOutPoint.index),
            pubkey: hexlify(value.pubKey),
        };
    };
    const formatTxOutputs = (value) => {
        return value?.map(_formatTxOutput);
    };
    const _formatTxOutput = (value) => {
        return {
            denomination: getNumber(value.denomination),
            lock: getNumber(value.lock),
            address: getAddress(value.address),
        };
    };
    const _formatOutpoint = object({
        denomination: (value) => getNumber(value),
        index: (value) => getNumber(value),
        lock: (value) => getNumber(value),
        txhash: formatHash,
    }, {
        txhash: ['txHash'],
    });
    function formatOutpoints(outpoints) {
        return outpoints.map(_formatOutpoint);
    }
    function formatOutpointDeltas(deltas) {
        const result = {};
        for (const [address, delta] of Object.entries(deltas)) {
            const created = [];
            const deleted = [];
            // Process created outpoints
            for (const [txHash, outputs] of Object.entries(delta.created)) {
                outputs.forEach((output) => {
                    created.push({
                        txHash,
                        index: output.index,
                        denomination: output.denomination,
                        lock: output.lock,
                    });
                });
            }
            // Process deleted outpoints
            for (const [txHash, outputs] of Object.entries(delta.deleted)) {
                outputs.forEach((output) => {
                    deleted.push({
                        txHash,
                        index: output.index,
                        denomination: output.denomination,
                        lock: output.lock,
                    });
                });
            }
            result[address] = {
                created: formatOutpoints(created),
                deleted: formatOutpoints(deleted),
            };
        }
        return result;
    }

    /**
     * Class representing a QiTransaction.
     *
     * @category Transaction
     * @extends {AbstractTransaction<string>}
     * @implements {QiTransactionLike}
     */
    class QiTransaction extends AbstractTransaction {
        #txInputs;
        #txOutputs;
        /**
         * Get transaction inputs.
         *
         * @returns {TxInput[]} The transaction inputs.
         */
        get txInputs() {
            return (this.#txInputs ?? []).map((entry) => ({ ...entry }));
        }
        /**
         * Set transaction inputs.
         *
         * @param {TxInput[] | null} value - The transaction inputs.
         * @throws {Error} If the value is not an array.
         */
        set txInputs(value) {
            if (!Array.isArray(value)) {
                throw new Error('txInputs must be an array');
            }
            this.#txInputs = value.map((entry) => ({ ...entry }));
        }
        /**
         * Get transaction outputs.
         *
         * @returns {TxOutput[]} The transaction outputs.
         */
        get txOutputs() {
            return (this.#txOutputs ?? []).map((output) => ({ ...output }));
        }
        /**
         * Set transaction outputs.
         *
         * @param {TxOutput[] | null} value - The transaction outputs.
         * @throws {Error} If the value is not an array.
         */
        set txOutputs(value) {
            if (!Array.isArray(value)) {
                throw new Error('txOutputs must be an array');
            }
            this.#txOutputs = value.map((output) => ({ ...output }));
        }
        /**
         * Get the permuted hash of the transaction as specified by QIP-0010.
         *
         * @returns {string | null} The transaction hash.
         * @throws {Error} If the transaction has no inputs or outputs, or if cross-zone & cross-ledger transactions are not
         *   supported.
         * @see {@link [QIP0010](https://github.com/quai-network/qips/blob/master/qip-0010.md)}
         */
        get hash() {
            if (this.signature == null) {
                return null;
            }
            if (this.txInputs.length < 1 || this.txOutputs.length < 1) {
                throw new Error('Transaction must have at least one input and one output');
            }
            const senderAddr = computeAddress(this.txInputs[0].pubkey || '');
            if (!this.destZone || !this.originZone) {
                throw new Error(`Invalid zones: origin ${this.originZone} ->  destination ${this.destZone} (address: ${senderAddr})`);
            }
            const isSameLedger = isQiAddress(senderAddr) === isQiAddress(hexlify(this.txOutputs[0].address) || '');
            if (this.isExternal && !isSameLedger) {
                throw new Error('Cross-zone & cross-ledger transactions are not supported');
            }
            const hexString = this.serialized.startsWith('0x') ? this.serialized.substring(2) : this.serialized;
            const dataBuffer = Buffer.from(hexString, 'hex');
            const hashHex = keccak256(dataBuffer);
            const hashBuffer = Buffer.from(hashHex.substring(2), 'hex');
            const prevTxHash = this.txInputs[0].txhash;
            const prevTxHashBytes = getBytes(prevTxHash);
            const origin = prevTxHashBytes[2]; // Get the third byte (0-based index)
            hashBuffer[0] = origin;
            hashBuffer[1] |= 0x80;
            hashBuffer[2] = origin;
            hashBuffer[3] |= 0x80;
            return '0x' + hashBuffer.toString('hex');
        }
        /**
         * Get the zone of the sender address.
         *
         * @returns {Zone | undefined} The origin zone.
         */
        get originZone() {
            const senderAddr = computeAddress(this.txInputs[0].pubkey || '');
            const zone = getZoneForAddress(senderAddr);
            return zone ?? undefined;
        }
        /**
         * Get the zone of the recipient address.
         *
         * @returns {Zone | undefined} The destination zone.
         */
        get destZone() {
            const zone = getZoneForAddress(this.txOutputs[0].address);
            return zone ?? undefined;
        }
        /**
         * Creates a new Transaction with default values.
         */
        constructor() {
            super();
            this.#txInputs = [];
            this.#txOutputs = [];
        }
        /**
         * Validates the explicit properties and returns a list of compatible transaction types.
         *
         * @returns {number[]} The compatible transaction types.
         */
        inferTypes() {
            const types = [];
            // Explicit type
            if (this.type != null) {
                types.push(this.type);
            }
            else {
                types.push(2);
            }
            types.sort();
            return types;
        }
        /**
         * Create a copy of this transaction.
         *
         * @returns {QiTransaction} The cloned transaction.
         */
        clone() {
            return QiTransaction.from(this);
        }
        /**
         * Return a JSON-friendly object.
         *
         * @returns {QiTransactionLike} The JSON-friendly object.
         */
        toJSON() {
            const s = (v) => {
                if (v == null) {
                    return null;
                }
                return v.toString();
            };
            return {
                type: this.type,
                chainId: s(this.chainId),
                signature: this.signature ? this.signature : null,
                hash: this.hash,
                txInputs: this.txInputs,
                txOutputs: this.txOutputs,
            };
        }
        /**
         * Return a protobuf-friendly JSON object.
         *
         * @param {boolean} [includeSignature=true] - Whether to include the signature. Default is `true`
         * @returns {ProtoTransaction} The protobuf-friendly JSON object.
         */
        toProtobuf(includeSignature = true) {
            const protoTx = {
                type: this.type || 2,
                chain_id: formatNumber(this.chainId || 0, 'chainId'),
                tx_ins: {
                    tx_ins: this.txInputs.map((input) => ({
                        previous_out_point: {
                            hash: { value: getBytes(input.txhash) },
                            index: input.index,
                        },
                        pub_key: getBytes(input.pubkey),
                    })),
                },
                tx_outs: {
                    tx_outs: this.txOutputs.map((output) => ({
                        address: getBytes(output.address),
                        denomination: output.denomination,
                        lock: new Uint8Array(),
                    })),
                },
            };
            if (this.signature && includeSignature) {
                protoTx.signature = getBytes(this.signature);
            }
            return protoTx;
        }
        /**
         * Create a Transaction from a serialized transaction or a Transaction-like object.
         *
         * @param {string | QiTransactionLike} tx - The transaction to decode.
         * @returns {QiTransaction} The decoded transaction.
         * @throws {Error} If the transaction is unsigned and defines a hash.
         */
        static from(tx) {
            if (typeof tx === 'string') {
                const decodedProtoTx = decodeProtoTransaction(getBytes(tx));
                return QiTransaction.fromProto(decodedProtoTx);
            }
            const result = new QiTransaction();
            if (tx.type != null) {
                result.type = tx.type;
            }
            if (tx.chainId != null) {
                result.chainId = tx.chainId;
            }
            if (tx.signature != null && tx.signature !== '') {
                result.signature = tx.signature;
            }
            if (tx.txInputs != null) {
                result.txInputs = tx.txInputs;
            }
            if (tx.txOutputs != null) {
                result.txOutputs = tx.txOutputs;
            }
            if (tx.hash != null) {
                assertArgument(result.isSigned(), 'unsigned transaction cannot define hash', 'tx', tx);
            }
            return result;
        }
        /**
         * Create a Transaction from a ProtoTransaction object.
         *
         * @param {ProtoTransaction} protoTx - The transaction to decode.
         * @returns {QiTransaction} The decoded transaction.
         */
        static fromProto(protoTx) {
            const tx = new QiTransaction();
            tx.type = protoTx.type;
            tx.chainId = toBigInt(protoTx.chain_id);
            tx.txInputs =
                protoTx.tx_ins?.tx_ins.map((input) => ({
                    txhash: hexlify(input.previous_out_point.hash.value),
                    index: input.previous_out_point.index,
                    pubkey: hexlify(input.pub_key),
                })) ?? [];
            tx.txOutputs =
                protoTx.tx_outs?.tx_outs.map((output) => ({
                    address: hexlify(output.address),
                    denomination: output.denomination,
                    lock: output.lock ? hexlify(output.lock) : '',
                })) ?? [];
            if (protoTx.signature) {
                tx.signature = hexlify(protoTx.signature);
            }
            return tx;
        }
    }

    /**
     * Parses a signature from an array of fields.
     *
     * @ignore
     * @param {string[]} fields - The fields to parse.
     * @returns {Signature} The parsed signature.
     */
    function _parseSignature(fields) {
        let yParity;
        try {
            yParity = handleNumber(fields[0], 'yParity');
            if (yParity !== 0 && yParity !== 1) {
                throw new Error('bad yParity');
            }
        }
        catch (error) {
            assertArgument(false, 'invalid yParity', 'yParity', fields[0]);
        }
        const r = zeroPadValue(fields[1], 32);
        const s = zeroPadValue(fields[2], 32);
        return Signature.from({ r, s, yParity });
    }
    /**
     * Represents a Quai transaction.
     *
     * @category Transaction
     */
    class QuaiTransaction extends AbstractTransaction {
        #to;
        #data;
        #nonce;
        #gasLimit;
        #gasPrice;
        #minerTip;
        #value;
        #accessList;
        from;
        /**
         * The `to` address for the transaction or `null` if the transaction is an `init` transaction.
         *
         * @type {null | string}
         */
        get to() {
            return this.#to;
        }
        set to(value) {
            if (value !== null)
                validateAddress(value);
            this.#to = value;
        }
        /**
         * The permuted hash of the transaction as specified by
         * [QIP-0010](https://github.com/quai-network/qips/blob/master/qip-0010.md).
         *
         * @type {null | string}
         * @throws {Error} If the transaction is not signed.
         */
        get hash() {
            if (this.signature == null)
                return null;
            if (!this.originZone) {
                throw new Error('Invalid Zone for from address');
            }
            if (!this.from) {
                throw new Error('Missing from address');
            }
            const isSameLedger = !this.to || isQuaiAddress(this.from) === isQuaiAddress(this.to);
            if (this.isExternal && !isSameLedger) {
                throw new Error('Cross-zone & cross-ledger transactions are not supported');
            }
            const hexString = this.serialized.startsWith('0x') ? this.serialized.substring(2) : this.serialized;
            const dataBuffer = Buffer.from(hexString, 'hex');
            const hashHex = keccak256(dataBuffer);
            const hashBuffer = Buffer.from(hashHex.substring(2), 'hex');
            const origin = this.originZone ? parseInt(this.originZone.slice(2), 16) : 0;
            hashBuffer[0] = origin;
            hashBuffer[1] &= 0x7f;
            hashBuffer[2] = origin;
            hashBuffer[3] &= 0x7f;
            return '0x' + hashBuffer.toString('hex');
        }
        /**
         * The zone of the sender address
         *
         * @type {Zone | undefined}
         */
        get originZone() {
            const zone = this.from ? getZoneForAddress(this.from) : undefined;
            return zone ?? undefined;
        }
        /**
         * The zone of the recipient address
         *
         * @type {Zone | undefined}
         */
        get destZone() {
            const zone = this.to !== null ? getZoneForAddress(this.to || '') : undefined;
            return zone ?? undefined;
        }
        /**
         * The transaction nonce.
         *
         * @type {number}
         */
        get nonce() {
            return this.#nonce;
        }
        set nonce(value) {
            this.#nonce = getNumber(value, 'value');
        }
        /**
         * The gas limit.
         *
         * @type {bigint}
         */
        get gasLimit() {
            return this.#gasLimit;
        }
        set gasLimit(value) {
            this.#gasLimit = getBigInt(value);
        }
        /**
         * The maximum priority fee per unit of gas to pay. On legacy networks this should be `null`.
         *
         * @type {null | bigint}
         */
        get minerTip() {
            const value = this.#minerTip;
            if (value == null) {
                return null;
            }
            return value;
        }
        set minerTip(value) {
            this.#minerTip = value == null ? null : getBigInt(value, 'minerTip');
        }
        /**
         * The maximum total fee per unit of gas to pay. On legacy networks this should be `null`.
         *
         * @type {null | bigint}
         */
        get gasPrice() {
            const value = this.#gasPrice;
            if (value == null) {
                return null;
            }
            return value;
        }
        set gasPrice(value) {
            this.#gasPrice = value == null ? null : getBigInt(value, 'gasPrice');
        }
        /**
         * The transaction data. For `init` transactions this is the deployment code.
         *
         * @type {string}
         */
        get data() {
            return this.#data;
        }
        set data(value) {
            this.#data = hexlify(value);
        }
        /**
         * The amount of ether to send in this transactions.
         *
         * @type {bigint}
         */
        get value() {
            return this.#value;
        }
        set value(value) {
            this.#value = getBigInt(value, 'value');
        }
        /**
         * The access list.
         *
         * An access list permits discounted (but pre-paid) access to bytecode and state variable access within contract
         * execution.
         *
         * @type {null | AccessList}
         */
        get accessList() {
            const value = this.#accessList || null;
            if (value == null) {
                return null;
            }
            return value;
        }
        set accessList(value) {
            this.#accessList = value == null ? null : accessListify(value);
        }
        /**
         * Creates a new Transaction with default values.
         *
         * @param {string} [from] - The sender address.
         */
        constructor(from) {
            super();
            this.#to = null;
            this.#nonce = 0;
            this.#gasLimit = BigInt(0);
            this.#gasPrice = null;
            this.#minerTip = null;
            this.#gasPrice = null;
            this.#data = '0x';
            this.#value = BigInt(0);
            this.#accessList = null;
            this.from = from;
        }
        /**
         * Validates the explicit properties and returns a list of compatible transaction types.
         *
         * @returns {number[]} The compatible transaction types.
         */
        inferTypes() {
            if (this.gasPrice != null && this.minerTip != null) {
                assert$1(this.gasPrice >= this.minerTip, 'priorityFee cannot be more than maxFee', 'BAD_DATA', {
                    value: this,
                });
            }
            assert$1(this.type !== 0 && this.type !== 1, 'transaction type cannot have externalGasLimit, externalGasTip, externalGasPrice, externalData, or externalAccessList', 'BAD_DATA', { value: this });
            const types = [];
            // Explicit type
            if (this.type != null) {
                types.push(this.type);
            }
            else {
                types.push(0);
            }
            types.sort();
            return types;
        }
        /**
         * Create a copy of this transaction.
         *
         * @returns {QuaiTransaction} The cloned transaction.
         */
        clone() {
            return QuaiTransaction.from(this);
        }
        /**
         * Return a JSON-friendly object.
         *
         * @returns {QuaiTransactionLike} The JSON-friendly object.
         */
        toJSON() {
            const s = (v) => {
                if (v == null) {
                    return null;
                }
                return v.toString();
            };
            return {
                type: this.type,
                to: this.to,
                from: this.from,
                data: this.data,
                nonce: this.nonce,
                gasLimit: s(this.gasLimit),
                gasPrice: s(this.gasPrice),
                minerTip: s(this.minerTip),
                value: s(this.value),
                chainId: s(this.chainId),
                signature: this.signature ? this.signature.toJSON() : null,
                hash: this.hash,
                accessList: this.accessList,
            };
        }
        /**
         * Return a protobuf-friendly JSON object.
         *
         * @param {boolean} [includeSignature=true] - Whether to include the signature. Default is `true`
         * @returns {ProtoTransaction} The protobuf-friendly JSON object.
         */
        toProtobuf(includeSignature = true) {
            const protoTx = {
                type: this.type || 0,
                chain_id: formatNumber(this.chainId || 0, 'chainId'),
                nonce: this.nonce || 0,
                miner_tip: formatNumber(this.minerTip || 0, 'minerTip'),
                gas_price: formatNumber(this.gasPrice || 0, 'gasPrice'),
                gas: Number(this.gasLimit || 0),
                to: this.to != null ? getBytes(this.to) : null,
                value: formatNumber(this.value || 0, 'value'),
                data: getBytes(this.data || '0x'),
                access_list: {
                    access_tuples: this.accessList?.map((it) => {
                        return {
                            address: getBytes(it.address),
                            storage_key: it.storageKeys.map((key) => {
                                return { value: getBytes(key) };
                            }),
                        };
                    }) || [],
                },
            };
            if (this.signature && includeSignature) {
                protoTx.v = formatNumber(this.signature.yParity, 'yParity');
                protoTx.r = toBeArray(this.signature.r);
                protoTx.s = toBeArray(this.signature.s);
            }
            return protoTx;
        }
        /**
         * Create a **Transaction** from a serialized transaction or a Transaction-like object.
         *
         * @param {string | QuaiTransactionLike} tx - The transaction to decode.
         * @returns {QuaiTransaction} The decoded transaction.
         */
        static from(tx) {
            if (typeof tx === 'string') {
                const decodedProtoTx = decodeProtoTransaction(getBytes(tx));
                return QuaiTransaction.fromProto(decodedProtoTx);
            }
            const result = new QuaiTransaction(tx.from);
            if (tx.type != null) {
                result.type = tx.type;
            }
            if (tx.to != null) {
                validateAddress(tx.to);
                result.to = tx.to;
            }
            if (tx.nonce != null) {
                result.nonce = tx.nonce;
            }
            if (tx.gasLimit != null) {
                result.gasLimit = tx.gasLimit;
            }
            if (tx.minerTip != null) {
                result.minerTip = tx.minerTip;
            }
            if (tx.gasPrice != null) {
                result.gasPrice = tx.gasPrice;
            }
            if (tx.data != null && tx.data !== '') {
                result.data = tx.data;
            }
            if (tx.value != null) {
                result.value = tx.value;
            }
            if (tx.chainId != null) {
                result.chainId = tx.chainId;
            }
            if (tx.signature != null) {
                result.signature = Signature.from(tx.signature);
            }
            if (tx.accessList != null) {
                result.accessList = tx.accessList;
            }
            if (tx.hash != null) {
                assertArgument(result.isSigned(), 'unsigned transaction cannot define hash', 'tx', tx);
            }
            if (tx.from != null) {
                assertArgument(isQuaiAddress(tx.from), 'from address must be a Quai address', 'tx.from', tx.from);
                assertArgument((result.from || '').toLowerCase() === (tx.from || '').toLowerCase(), 'from mismatch', 'tx', tx);
                result.from = tx.from;
            }
            return result;
        }
        /**
         * Create a **Transaction** from a ProtoTransaction object.
         *
         * @param {ProtoTransaction} protoTx - The transaction to decode.
         * @returns {QuaiTransaction} The decoded transaction.
         */
        static fromProto(protoTx) {
            //  TODO: Fix this because new tx instance requires a 'from' address
            let signature = null;
            let address = '';
            delete protoTx.etx_sender;
            delete protoTx.etx_index;
            delete protoTx.work_nonce;
            delete protoTx.etx_type;
            const protoTxCopy = deepCopyProtoTransaction(protoTx);
            if (protoTx.v && protoTx.r && protoTx.s) {
                // check if protoTx.r is zero
                if (protoTx.r.reduce((acc, val) => (acc += val), 0) == 0) {
                    throw new Error('Proto decoding only supported for signed transactions');
                }
                const signatureFields = [hexlify(protoTx.v), hexlify(protoTx.r), hexlify(protoTx.s)];
                signature = _parseSignature(signatureFields);
                delete protoTxCopy.v;
                delete protoTxCopy.r;
                delete protoTxCopy.s;
                delete protoTxCopy.signature;
                address = recoverAddress(keccak256(encodeProtoTransaction(protoTxCopy)), signature);
            }
            const tx = new QuaiTransaction(address);
            if (signature) {
                tx.signature = signature;
            }
            if (protoTx.to !== null) {
                const toAddr = hexlify(protoTx.to);
                tx.to = getAddress(toAddr);
            }
            tx.type = protoTx.type;
            tx.chainId = toBigInt(protoTx.chain_id);
            tx.nonce = Number(protoTx.nonce);
            tx.minerTip = toBigInt(protoTx.miner_tip);
            tx.gasPrice = toBigInt(protoTx.gas_price);
            tx.gasLimit = toBigInt(protoTx.gas);
            tx.value = protoTx.value !== null ? toBigInt(protoTx.value) : BigInt(0);
            tx.data = hexlify(protoTx.data);
            tx.accessList = protoTx.access_list.access_tuples.map((tuple) => ({
                address: formatMixedCaseChecksumAddress(hexlify(tuple.address)),
                storageKeys: tuple.storage_key.map((key) => hexlify(key.value)),
            }));
            return tx;
        }
    }
    /**
     * Deeply copies a ProtoTransaction object.
     *
     * @param {ProtoTransaction} proto - The ProtoTransaction object to copy.
     * @returns {ProtoTransaction} The copied ProtoTransaction object.
     */
    function deepCopyProtoTransaction(proto) {
        if (proto == null)
            return proto;
        const copy = {
            type: proto.type,
            chain_id: new Uint8Array(proto.chain_id),
            nonce: proto.nonce,
        };
        // Handle optional Uint8Array fields
        if (proto.to)
            copy.to = new Uint8Array(proto.to);
        if (proto.value)
            copy.value = new Uint8Array(proto.value);
        if (proto.data)
            copy.data = new Uint8Array(proto.data);
        if (proto.gas_price)
            copy.gas_price = new Uint8Array(proto.gas_price);
        if (proto.miner_tip)
            copy.miner_tip = new Uint8Array(proto.miner_tip);
        if (proto.v)
            copy.v = new Uint8Array(proto.v);
        if (proto.r)
            copy.r = new Uint8Array(proto.r);
        if (proto.s)
            copy.s = new Uint8Array(proto.s);
        if (proto.signature)
            copy.signature = new Uint8Array(proto.signature);
        if (proto.etx_sender)
            copy.etx_sender = new Uint8Array(proto.etx_sender);
        // Handle numeric fields
        if (proto.gas !== undefined)
            copy.gas = proto.gas;
        if (proto.etx_index !== undefined)
            copy.etx_index = proto.etx_index;
        if (proto.work_nonce !== undefined)
            copy.work_nonce = proto.work_nonce;
        if (proto.etx_type !== undefined)
            copy.etx_type = proto.etx_type;
        // Handle access list
        if (proto.access_list) {
            copy.access_list = {
                access_tuples: proto.access_list.access_tuples.map((tuple) => ({
                    address: new Uint8Array(tuple.address),
                    storage_key: tuple.storage_key.map((key) => ({
                        value: new Uint8Array(key.value),
                    })),
                })),
            };
        }
        return copy;
    }

    const BN_0$1 = BigInt(0);
    /**
     * Get the value if it is not null or undefined.
     *
     * @ignore
     * @param {undefined | null | T} value - The value to check.
     * @returns {null | T} The value if not null or undefined, otherwise null.
     */
    function getValue(value) {
        if (value == null) {
            return null;
        }
        return value;
    }
    /**
     * Convert a value to a JSON-friendly string.
     *
     * @ignore
     * @param {null | bigint | string} value - The value to convert.
     * @returns {null | string} The JSON-friendly string or null.
     */
    function toJson(value) {
        if (value == null) {
            return null;
        }
        return value.toString();
    }
    /**
     * A **FeeData** wraps all the fee-related values associated with the network.
     *
     * @category Providers
     */
    class FeeData {
        /**
         * The gas price for legacy networks.
         */
        gasPrice;
        /**
         * The additional amount to pay per gas to encourage a validator to include the transaction.
         *
         * The purpose of this is to compensate the validator for the adjusted risk for including a given transaction.
         *
         * This will be `null` on legacy networks (i.e. [pre-EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
         */
        minerTip;
        /**
         * Creates a new FeeData for `gasPrice`, `gasPrice` and `minerTip`.
         *
         * @param {null | bigint} [gasPrice] - The gas price.
         * @param {null | bigint} [gasPrice] - The maximum fee per gas.
         * @param {null | bigint} [minerTip] - The maximum priority fee per gas.
         */
        constructor(gasPrice, minerTip) {
            defineProperties(this, {
                gasPrice: getValue(gasPrice),
                minerTip: getValue(minerTip),
            });
        }
        /**
         * Returns a JSON-friendly value.
         *
         * @returns {any} The JSON-friendly value.
         */
        toJSON() {
            const { gasPrice, minerTip } = this;
            return {
                _type: 'FeeData',
                gasPrice: toJson(gasPrice),
                minerTip: toJson(minerTip),
            };
        }
    }
    /**
     * Determines the address from a transaction request.
     *
     * @param {TransactionRequest} tx - The transaction request.
     * @returns {AddressLike} The address from the transaction request.
     * @throws {Error} If unable to determine the address.
     */
    function addressFromTransactionRequest(tx) {
        if ('from' in tx && !!tx.from) {
            if (tx.from !== ZeroAddress) {
                return tx.from;
            }
        }
        if ('to' in tx && !!tx.to) {
            if (tx.to !== ZeroAddress) {
                return tx.to;
            }
        }
        if ('txInputs' in tx && !!tx.txInputs) {
            const inputs = tx.txInputs;
            return computeAddress(inputs[0].pubkey);
        }
        if ('txIn' in tx && !!tx.txIn) {
            const inputs = tx.txIn;
            return computeAddress(inputs[0].pubkey);
        }
        throw new Error('Unable to determine address from transaction inputs, from or to field');
    }
    /**
     * Returns a copy of `req` with all properties coerced to their strict types.
     *
     * @category Providers
     * @param {TransactionRequest} req - The transaction request to copy.
     * @returns {PreparedTransactionRequest} The prepared transaction request.
     * @throws {Error} If the request is invalid.
     */
    function copyRequest(req) {
        const result = {};
        // These could be addresses or Addressables
        if ('to' in req && req.to) {
            result.to = req.to;
        }
        if ('from' in req && req.from) {
            result.from = req.from;
        }
        if ('data' in req && req.data) {
            result.data = hexlify(req.data);
        }
        const bigIntKeys = 'chainId,gasLimit,gasPrice,minerTip,value'.split(/,/);
        for (const key of bigIntKeys) {
            if (!(key in req) || req[key] == null) {
                continue;
            }
            result[key] = getBigInt(req[key], `request.${key}`);
        }
        const numberKeys = 'type,nonce'.split(/,/);
        for (const key of numberKeys) {
            if (!(key in req) || req[key] == null) {
                continue;
            }
            result[key] = getNumber(req[key], `request.${key}`);
        }
        if ('accessList' in req && req.accessList) {
            result.accessList = accessListify(req.accessList);
        }
        if ('blockTag' in req) {
            result.blockTag = req.blockTag;
        }
        if ('customData' in req) {
            result.customData = req.customData;
        }
        if ('txInputs' in req && req.txInputs) {
            result.txInputs = req.txInputs.map((entry) => ({ ...entry }));
        }
        if ('txOutputs' in req && req.txOutputs) {
            result.txOutputs = req.txOutputs.map((entry) => ({ ...entry }));
        }
        return result;
    }
    /**
     * Represents the header of a block.
     *
     * @category Providers
     */
    class BlockHeader {
        baseFeePerGas;
        efficiencyScore;
        etxEligibleSlices;
        etxSetRoot;
        evmRoot;
        expansionNumber;
        etxRollupRoot;
        outboundEtxsRoot;
        extraData;
        gasLimit;
        gasUsed;
        interlinkRootHash;
        manifestHash;
        number;
        parentDeltaEntropy;
        parentEntropy;
        parentHash;
        parentUncledDeltaEntropy;
        primeTerminusHash;
        quaiStateSize;
        receiptsRoot;
        uncleHash;
        size;
        stateLimit;
        stateUsed;
        thresholdCount;
        transactionsRoot;
        uncledEntropy;
        utxoRoot;
        exchangeRate;
        quaiToQi;
        qiToQuai;
        secondaryCoinbase;
        constructor(params) {
            this.baseFeePerGas = params.baseFeePerGas;
            this.efficiencyScore = params.efficiencyScore;
            this.etxEligibleSlices = params.etxEligibleSlices;
            this.etxSetRoot = params.etxSetRoot;
            this.evmRoot = params.evmRoot;
            this.expansionNumber = params.expansionNumber;
            this.etxRollupRoot = params.etxRollupRoot;
            this.outboundEtxsRoot = params.outboundEtxsRoot;
            this.extraData = params.extraData;
            this.gasLimit = params.gasLimit;
            this.gasUsed = params.gasUsed;
            this.interlinkRootHash = params.interlinkRootHash;
            this.manifestHash = params.manifestHash;
            this.number = params.number;
            this.parentDeltaEntropy = params.parentDeltaEntropy;
            this.parentEntropy = params.parentEntropy;
            this.parentHash = params.parentHash;
            this.parentUncledDeltaEntropy = params.parentUncledDeltaEntropy;
            this.primeTerminusHash = params.primeTerminusHash;
            this.quaiStateSize = params.quaiStateSize;
            this.receiptsRoot = params.receiptsRoot;
            this.uncleHash = params.uncleHash;
            this.size = params.size;
            this.stateLimit = params.stateLimit;
            this.stateUsed = params.stateUsed;
            this.thresholdCount = params.thresholdCount;
            this.transactionsRoot = params.transactionsRoot;
            this.uncledEntropy = params.uncledEntropy;
            this.utxoRoot = params.utxoRoot;
            this.exchangeRate = params.exchangeRate;
            this.quaiToQi = params.quaiToQi;
            this.qiToQuai = params.qiToQuai;
            this.secondaryCoinbase = params.secondaryCoinbase;
        }
        toJSON() {
            return {
                ...this,
            };
        }
    }
    /**
     * Represents the header of a work object.
     *
     * @category Providers
     */
    class Uncle {
        primaryCoinbase;
        difficulty;
        headerHash;
        location;
        mixHash;
        nonce;
        number;
        parentHash;
        timestamp;
        txHash;
        lock;
        /**
         * Creates a new Uncle instance.
         *
         * @param {UncleParams} params - The parameters for the Uncle.
         */
        constructor(params) {
            this.primaryCoinbase = params.primaryCoinbase;
            this.difficulty = params.difficulty;
            this.headerHash = params.headerHash;
            this.location = params.location;
            this.mixHash = params.mixHash;
            this.nonce = params.nonce;
            this.number = params.number;
            this.parentHash = params.parentHash;
            this.timestamp = params.timestamp;
            this.txHash = params.txHash;
            this.lock = params.lock;
        }
        toJSON() {
            return {
                primaryCoinbase: this.primaryCoinbase,
                difficulty: this.difficulty,
                headerHash: this.headerHash,
                location: this.location,
                mixHash: this.mixHash,
                nonce: this.nonce,
                number: this.number,
                parentHash: this.parentHash,
                timestamp: this.timestamp,
                txHash: this.txHash,
                lock: this.lock,
            };
        }
    }
    /**
     * A **Block** represents the data associated with a full block on Ethereum.
     *
     * @category Providers
     */
    class Block {
        #outboundEtxs;
        hash;
        header;
        interlinkHashes; // New parameter
        size;
        subManifest;
        totalEntropy;
        #transactions;
        uncles;
        woHeader;
        workShares;
        /**
         * The provider connected to the block used to fetch additional details if necessary.
         */
        provider;
        /**
         * Create a new **Block** object.
         *
         * This should generally not be necessary as the unless implementing a low-level library.
         *
         * @param {BlockParams} block - The block parameters.
         * @param {Provider} provider - The provider.
         */
        constructor(block, provider) {
            this.#transactions = block.transactions.map((tx) => {
                if (typeof tx === 'string') {
                    return tx;
                }
                if ('originatingTxHash' in tx) {
                    return new ExternalTransactionResponse(tx, provider);
                }
                if ('from' in tx) {
                    return new QuaiTransactionResponse(tx, provider);
                }
                return new QiTransactionResponse(tx, provider);
            });
            this.#outboundEtxs = block.outboundEtxs.map((tx) => {
                if (typeof tx !== 'string') {
                    return new ExternalTransactionResponse(tx, provider);
                }
                return tx;
            });
            this.hash = block.hash;
            this.header = new BlockHeader(block.header);
            this.interlinkHashes = block.interlinkHashes;
            this.size = block.size;
            this.subManifest = block.subManifest;
            this.totalEntropy = block.totalEntropy;
            this.uncles = block.uncles.map((uncle) => {
                if (typeof uncle === 'string') {
                    return uncle;
                }
                return new Uncle(uncle);
            });
            this.woHeader = new Uncle(block.woHeader);
            this.workShares = block.workShares.map((workShare) => {
                if (typeof workShare === 'string') {
                    return workShare;
                }
                return new Uncle(workShare);
            });
            this.provider = provider;
        }
        /**
         * Returns the list of transaction hashes, in the order they were executed within the block.
         *
         * @returns {ReadonlyArray<string>} The list of transaction hashes.
         */
        get transactions() {
            return this.#transactions.map((tx) => {
                if (typeof tx === 'string') {
                    return tx;
                }
                return tx.hash;
            });
        }
        /**
         * Returns the list of extended transaction hashes, in the order they were executed within the block.
         *
         * @returns {ReadonlyArray<string>} The list of extended transaction hashes.
         */
        get outboundEtxs() {
            return this.#outboundEtxs.map((tx) => {
                if (typeof tx === 'string') {
                    return tx;
                }
                return tx.hash;
            });
        }
        /**
         * Returns the complete transactions, in the order they were executed within the block.
         *
         * This is only available for blocks which prefetched transactions, by passing `true` to `prefetchTxs` into
         * {@link Provider.getBlock | **getBlock**}.
         *
         * @returns {TransactionResponse[]} The list of prefetched transactions.
         * @throws {Error} If the transactions were not prefetched.
         */
        get prefetchedTransactions() {
            const txs = this.#transactions.slice();
            // Doesn't matter...
            if (txs.length === 0) {
                return [];
            }
            // Make sure we prefetched the transactions
            assert$1(typeof txs[0] === 'object', 'transactions were not prefetched with block request', 'UNSUPPORTED_OPERATION', {
                operation: 'transactionResponses()',
            });
            return txs;
        }
        /**
         * Returns the complete extended transactions, in the order they were executed within the block.
         *
         * This is only available for blocks which prefetched transactions, by passing `true` to `prefetchTxs` into
         * {@link Provider.getBlock | **getBlock**}.
         *
         * @returns {TransactionResponse[]} The list of prefetched extended transactions.
         * @throws {Error} If the transactions were not prefetched.
         */
        get prefetchedExtTransactions() {
            const txs = this.#outboundEtxs.slice();
            // Doesn't matter...
            if (txs.length === 0) {
                return [];
            }
            // Make sure we prefetched the transactions
            assert$1(typeof txs[0] === 'object', 'transactions were not prefetched with block request', 'UNSUPPORTED_OPERATION', {
                operation: 'transactionResponses()',
            });
            return txs;
        }
        /**
         * Returns a JSON-friendly value.
         *
         * @returns {any} The JSON-friendly value.
         */
        toJSON() {
            const { hash, header, interlinkHashes, size, subManifest, totalEntropy, uncles, woHeader, workShares } = this;
            // Using getters to retrieve the transactions and extTransactions
            const transactions = this.transactions;
            const outboundEtxs = this.outboundEtxs;
            return {
                outboundEtxs,
                hash,
                header: header.toJSON(),
                interlinkHashes,
                transactions,
                size: size,
                subManifest,
                totalEntropy: totalEntropy,
                uncles: uncles.map((uncle) => {
                    if (typeof uncle === 'string') {
                        return uncle;
                    }
                    return uncle.toJSON();
                }),
                woHeader: woHeader.toJSON(),
                workShares: workShares.map((workShare) => {
                    if (typeof workShare === 'string') {
                        return workShare;
                    }
                    return workShare.toJSON();
                }),
            };
        }
        [Symbol.iterator]() {
            let index = 0;
            const txs = this.transactions;
            return {
                next: () => {
                    if (index < this.length) {
                        return {
                            value: txs[index++],
                            done: false,
                        };
                    }
                    return { value: undefined, done: true };
                },
            };
        }
        /**
         * The number of transactions in this block.
         *
         * @returns {number} The number of transactions.
         */
        get length() {
            return this.#transactions.length;
        }
        /**
         * The [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) this block was
         * included at.
         *
         * @returns {null | Date} The date this block was included at, or null if the timestamp is not available.
         */
        get date() {
            const timestampHex = this.woHeader.timestamp;
            if (!timestampHex) {
                return null;
            }
            const timestamp = parseInt(timestampHex, 16);
            return new Date(timestamp * 1000);
        }
        /**
         * Get the transaction at `index` within this block.
         *
         * @param {number | string} indexOrHash - The index or hash of the transaction.
         * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
         * @throws {Error} If the transaction is not found.
         */
        async getTransaction(indexOrHash) {
            // Find the internal value by its index or hash
            let tx = undefined;
            if (typeof indexOrHash === 'number') {
                tx = this.#transactions[indexOrHash];
            }
            else {
                const hash = indexOrHash.toLowerCase();
                for (const v of this.#transactions) {
                    if (typeof v === 'string') {
                        if (v !== hash) {
                            continue;
                        }
                        tx = v;
                        break;
                    }
                    else {
                        if (v.hash === hash) {
                            continue;
                        }
                        tx = v;
                        break;
                    }
                }
            }
            if (tx == null) {
                throw new Error('no such tx');
            }
            if (typeof tx === 'string') {
                return await this.provider.getTransaction(tx);
            }
            else {
                return tx;
            }
        }
        /**
         * Get the extended transaction at `index` within this block.
         *
         * @param {number | string} indexOrHash - The index or hash of the extended transaction.
         * @returns {Promise<TransactionResponse>} A promise resolving to the extended transaction.
         * @throws {Error} If the extended transaction is not found.
         */
        async getExtTransaction(indexOrHash) {
            // Find the internal value by its index or hash
            let tx = undefined;
            if (typeof indexOrHash === 'number') {
                tx = this.#outboundEtxs[indexOrHash];
            }
            else {
                const hash = indexOrHash.toLowerCase();
                for (const v of this.#outboundEtxs) {
                    if (typeof v === 'string') {
                        if (v !== hash) {
                            continue;
                        }
                        tx = v;
                        break;
                    }
                    else {
                        if (v.hash === hash) {
                            continue;
                        }
                        tx = v;
                        break;
                    }
                }
            }
            if (tx == null) {
                throw new Error('no such tx');
            }
            if (typeof tx === 'string') {
                throw new Error("External Transaction isn't prefetched");
            }
            else {
                return tx;
            }
        }
        /**
         * If a **Block** was fetched with a request to include the transactions this will allow synchronous access to those
         * transactions.
         *
         * If the transactions were not prefetched, this will throw.
         *
         * @param {number | string} indexOrHash - The index or hash of the transaction.
         * @returns {TransactionResponse} The transaction.
         * @throws {Error} If the transaction is not found.
         */
        getPrefetchedTransaction(indexOrHash) {
            const txs = this.prefetchedTransactions;
            if (typeof indexOrHash === 'number') {
                return txs[indexOrHash];
            }
            indexOrHash = indexOrHash.toLowerCase();
            for (const tx of txs) {
                if (tx.hash === indexOrHash) {
                    return tx;
                }
            }
            assertArgument(false, 'no matching transaction', 'indexOrHash', indexOrHash);
        }
        /**
         * Returns true if this block been mined. This provides a type guard for all properties on a
         * {@link MinedBlock | **MinedBlock**}.
         *
         * @returns {boolean} True if the block has been mined.
         */
        isMined() {
            return !!this.hash;
        }
        /**
         * @ignore
         */
        orphanedEvent() {
            if (!this.isMined() || !this.woHeader.number) {
                throw new Error('');
            }
            return createOrphanedBlockFilter({
                hash: this.hash,
                number: this.woHeader.number,
            });
        }
    }
    //////////////////////
    // Log
    /**
     * A **Log** in Ethereum represents an event that has been included in a transaction using the `LOG*` opcodes, which are
     * most commonly used by Solidity's emit for announcing events.
     *
     * @category Providers
     */
    class Log {
        /**
         * The provider connected to the log used to fetch additional details if necessary.
         */
        provider;
        /**
         * The transaction hash of the transaction this log occurred in. Use the
         * {@link Log.getTransaction | **Log.getTransaction**} to get the
         * {@link TransactionResponse | **TransactionResponse}.
         */
        transactionHash;
        /**
         * The block hash of the block this log occurred in. Use the {@link Log.getBlock | **Log.getBlock**} to get the
         * {@link Block | **Block**}.
         */
        blockHash;
        /**
         * The block number of the block this log occurred in. It is preferred to use the {@link Block.hash | **Block.hash**}
         * when fetching the related {@link Block | **Block**}, since in the case of an orphaned block, the block at that
         * height may have changed.
         */
        blockNumber;
        /**
         * If the **Log** represents a block that was removed due to an orphaned block, this will be true.
         *
         * This can only happen within an orphan event listener.
         */
        removed;
        /**
         * The address of the contract that emitted this log.
         */
        address;
        /**
         * The data included in this log when it was emitted.
         */
        data;
        /**
         * The indexed topics included in this log when it was emitted.
         *
         * All topics are included in the bloom filters, so they can be efficiently filtered using the
         * {@link Provider.getLogs | **Provider.getLogs**} method.
         */
        topics;
        /**
         * The index within the block this log occurred at. This is generally not useful to developers, but can be used with
         * the various roots to proof inclusion within a block.
         */
        index;
        /**
         * The index within the transaction of this log.
         */
        transactionIndex;
        /**
         * @ignore
         */
        constructor(log, provider) {
            this.provider = provider;
            const topics = Object.freeze(log.topics.slice());
            defineProperties(this, {
                transactionHash: log.transactionHash,
                blockHash: log.blockHash,
                blockNumber: log.blockNumber,
                removed: log.removed,
                address: log.address,
                data: log.data,
                topics,
                index: log.index,
                transactionIndex: log.transactionIndex,
            });
        }
        /**
         * Returns a JSON-compatible object.
         */
        toJSON() {
            const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
            return {
                _type: 'log',
                address,
                blockHash,
                blockNumber,
                data,
                index,
                removed,
                topics,
                transactionHash,
                transactionIndex,
            };
        }
        /**
         * Returns the block that this log occurred in.
         *
         * @param {Shard} shard - The shard to fetch the block from.
         * @returns {Promise<Block>} A promise resolving to the block.
         */
        async getBlock(shard) {
            const block = await this.provider.getBlock(shard, this.blockHash);
            assert$1(!!block, 'failed to find transaction', 'UNKNOWN_ERROR', {});
            return block;
        }
        /**
         * Returns the transaction that this log occurred in.
         *
         * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
         */
        async getTransaction() {
            const tx = await this.provider.getTransaction(this.transactionHash);
            assert$1(!!tx, 'failed to find transaction', 'UNKNOWN_ERROR', {});
            return tx;
        }
        /**
         * Returns the transaction receipt fot the transaction that this log occurred in.
         *
         * @returns {Promise<TransactionReceipt>} A promise resolving to the transaction receipt.
         */
        async getTransactionReceipt() {
            const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
            assert$1(!!receipt, 'failed to find transaction receipt', 'UNKNOWN_ERROR', {});
            return receipt;
        }
        /**
         * @ignore
         */
        removedEvent() {
            return createRemovedLogFilter(this);
        }
    }
    //////////////////////
    // Transaction Receipt
    function zoneFromHash(hash) {
        return toZone(hash.slice(0, 4));
    }
    /**
     * A **TransactionReceipt** includes additional information about a transaction that is only available after it has been
     * mined.
     *
     * @category Providers
     */
    class TransactionReceipt {
        /**
         * The provider connected to the log used to fetch additional details if necessary.
         */
        provider;
        /**
         * The address the transaction was sent to.
         */
        to;
        /**
         * The sender of the transaction.
         */
        from;
        /**
         * The address of the contract if the transaction was directly responsible for deploying one.
         *
         * This is non-null **only** if the `to` is empty and the `data` was successfully executed as initcode.
         */
        contractAddress;
        /**
         * The transaction hash.
         */
        hash;
        /**
         * The index of this transaction within the block transactions.
         */
        index;
        /**
         * The block hash of the {@link Block | **Block**} this transaction was included in.
         */
        blockHash;
        /**
         * The block number of the {@link Block | **Block**} this transaction was included in.
         */
        blockNumber;
        /**
         * The bloom filter bytes that represent all logs that occurred within this transaction. This is generally not
         * useful for most developers, but can be used to validate the included logs.
         */
        logsBloom;
        /**
         * The actual amount of gas used by this transaction.
         *
         * When creating a transaction, the amount of gas that will be used can only be approximated, but the sender must
         * pay the gas fee for the entire gas limit. After the transaction, the difference is refunded.
         */
        gasUsed;
        /**
         * The amount of gas used by all transactions within the block for this and all transactions with a lower `index`.
         *
         * This is generally not useful for developers but can be used to validate certain aspects of execution.
         */
        cumulativeGasUsed;
        /**
         * The actual gas price used during execution.
         *
         * Due to the complexity of [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) this value can only be caluclated
         * after the transaction has been mined, snce the base fee is protocol-enforced.
         */
        gasPrice;
        /**
         * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction type.
         */
        type;
        //readonly byzantium!: boolean;
        /**
         * The status of this transaction, indicating success (i.e. `1`) or a revert (i.e. `0`).
         *
         * This is available in post-byzantium blocks, but some backends may backfill this value.
         */
        status;
        /**
         * The root hash of this transaction.
         *
         * This is no present and was only included in pre-byzantium blocks, but could be used to validate certain parts of
         * the receipt.
         */
        #logs;
        outboundEtxs = [];
        etxType;
        originatingTxHash;
        /**
         * @ignore
         */
        constructor(tx, provider) {
            this.#logs = Object.freeze(Array.isArray(tx.logs) ? tx.logs.map((log) => new Log(log, provider)) : []);
            let gasPrice = BN_0$1;
            if (tx.effectiveGasPrice != null) {
                gasPrice = tx.effectiveGasPrice;
            }
            else if (tx.gasPrice != null) {
                gasPrice = tx.gasPrice;
            }
            const outboundEtxs = tx.outboundEtxs
                ? tx.outboundEtxs.map((etx) => {
                    const safeConvert = (value, name) => {
                        try {
                            if (value != null) {
                                return BigInt(value);
                            }
                            return null;
                        }
                        catch (error) {
                            console.error(`Conversion to BigInt failed for ${name}: ${value}, error: ${error}`);
                            return null;
                        }
                    };
                    return {
                        type: etx.type,
                        nonce: etx.nonce,
                        gasPrice: safeConvert(etx.gasPrice, 'gasPrice'),
                        minerTip: safeConvert(etx.minerTip, 'minerTip'),
                        gas: safeConvert(etx.gas, 'gas'),
                        value: safeConvert(etx.value, 'value'),
                        input: etx.input,
                        to: etx.to,
                        accessList: etx.accessList,
                        chainId: safeConvert(etx.chainId, 'chainId'),
                        from: etx.from,
                        hash: etx.hash,
                        originatingTxHash: etx.originatingTxHash,
                        etxIndex: etx.etxIndex,
                    };
                })
                : [];
            defineProperties(this, {
                provider,
                to: tx.to,
                from: tx.from,
                contractAddress: tx.contractAddress,
                hash: tx.hash,
                index: tx.index,
                blockHash: tx.blockHash,
                blockNumber: tx.blockNumber,
                logsBloom: tx.logsBloom,
                gasUsed: tx.gasUsed,
                cumulativeGasUsed: tx.cumulativeGasUsed,
                gasPrice,
                outboundEtxs: outboundEtxs,
                type: tx.type,
                status: tx.status,
                etxType: tx.etxType,
                originatingTxHash: tx.originatingTxHash,
            });
        }
        /**
         * The logs for this transaction.
         */
        get logs() {
            return this.#logs;
        }
        /**
         * Returns a JSON-compatible representation.
         */
        toJSON() {
            const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium,
            status, outboundEtxs, } = this;
            return {
                _type: 'TransactionReceipt',
                blockHash,
                blockNumber,
                contractAddress,
                cumulativeGasUsed: toJson(this.cumulativeGasUsed),
                from,
                gasPrice: toJson(this.gasPrice),
                gasUsed: toJson(this.gasUsed),
                hash,
                index,
                logs,
                logsBloom,
                status,
                to,
                outboundEtxs: outboundEtxs ?? [],
            };
        }
        /**
         * @ignore
         */
        get length() {
            return this.logs.length;
        }
        [Symbol.iterator]() {
            let index = 0;
            return {
                next: () => {
                    if (index < this.length) {
                        return { value: this.logs[index++], done: false };
                    }
                    return { value: undefined, done: true };
                },
            };
        }
        /**
         * The total fee for this transaction, in wei.
         */
        get fee() {
            return this.gasUsed * this.gasPrice;
        }
        /**
         * Resolves to the block this transaction occurred in.
         *
         * @param {Shard} shard - The shard to fetch the block from.
         * @returns {Promise<Block>} A promise resolving to the block.
         * @throws {Error} If the block is not found.
         */
        async getBlock(shard) {
            const block = await this.provider.getBlock(shard, this.blockHash);
            if (block == null) {
                throw new Error('TODO');
            }
            return block;
        }
        /**
         * Resolves to the transaction this transaction occurred in.
         *
         * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
         * @throws {Error} If the transaction is not found.
         */
        async getTransaction() {
            const tx = await this.provider.getTransaction(this.hash);
            if (tx == null) {
                throw new Error('TODO');
            }
            return tx;
        }
        /**
         * Resolves to the return value of the execution of this transaction.
         *
         * Support for this feature is limited, as it requires an archive node with the `debug_` or `trace_` API enabled.
         *
         * @returns {Promise<string>} A promise resolving to the return value of the transaction.
         * @throws {Error} If the transaction is not found.
         */
        async getResult() {
            return await this.provider.getTransactionResult(this.hash);
        }
        /**
         * Resolves to the number of confirmations this transaction has.
         *
         * @returns {Promise<number>} A promise resolving to the number of confirmations.
         * @throws {Error} If the block is not found.
         */
        async confirmations() {
            const zone = zoneFromHash(this.hash);
            return (await this.provider.getBlockNumber(toShard(zone))) - this.blockNumber + 1;
        }
        /**
         * @ignore
         */
        removedEvent() {
            return createRemovedTransactionFilter(this);
        }
        /**
         * @ignore
         */
        reorderedEvent(other) {
            assert$1(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", 'UNSUPPORTED_OPERATION', {
                operation: 'reorderedEvent(other)',
            });
            return createReorderedTransactionFilter(this, other);
        }
    }
    class ExternalTransactionResponse {
        /**
         * The provider this is connected to, which will influence how its methods will resolve its async inspection
         * methods.
         */
        provider;
        /**
         * The block number of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockNumber;
        /**
         * The blockHash of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockHash;
        /**
         * The index within the block that this transaction resides at.
         */
        index;
        /**
         * The transaction hash.
         */
        hash;
        /**
         * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
         * transactions types.
         */
        type;
        /**
         * The receiver of this transaction.
         *
         * If `null`, then the transaction is an initcode transaction. This means the result of executing the
         * {@link ExternalTransactionResponse.data | **data** } will be deployed as a new contract on chain (assuming it does
         * not revert) and the address may be computed using [getCreateAddress](../functions/getCreateAddress).
         */
        to;
        /**
         * The sender of this transaction. It is implicitly computed from the transaction pre-image hash (as the digest) and
         * the {@link QuaiTransactionResponse.signature | **signature** } using ecrecover.
         */
        from;
        /**
         * The nonce, which is used to prevent replay attacks and offer a method to ensure transactions from a given sender
         * are explicitly ordered.
         *
         * When sending a transaction, this must be equal to the number of transactions ever sent by
         * {@link ExternalTransactionResponse.from | **from** }.
         */
        nonce;
        /**
         * The maximum units of gas this transaction can consume. If execution exceeds this, the entries transaction is
         * reverted and the sender is charged for the full amount, despite not state changes being made.
         */
        gasLimit;
        /**
         * The data.
         */
        data;
        /**
         * The value, in wei. Use [formatEther](../functions/formatEther) to format this value as ether.
         */
        value;
        /**
         * The chain ID.
         */
        chainId;
        /**
         * The signature.
         */
        signature;
        /**
         * The [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list for transaction types that support it,
         * otherwise `null`.
         */
        accessList;
        etxType;
        originatingTxHash;
        sender;
        etxIndex;
        startBlock;
        /**
         * @ignore
         */
        constructor(tx, provider) {
            this.provider = provider;
            this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
            this.blockHash = tx.blockHash != null ? tx.blockHash : null;
            this.hash = tx.hash;
            this.index = tx.index;
            this.type = tx.type;
            this.from = tx.from;
            this.to = tx.to || null;
            this.gasLimit = tx.gasLimit;
            this.nonce = tx.nonce;
            this.data = tx.data;
            this.value = tx.value;
            this.chainId = tx.chainId;
            this.signature = tx.signature;
            this.accessList = tx.accessList != null ? tx.accessList : null;
            this.startBlock = -1;
            this.originatingTxHash = tx.originatingTxHash != null ? tx.originatingTxHash : null;
            this.etxType = tx.etxType != null ? tx.etxType : null;
            this.etxIndex = tx.etxIndex;
        }
        /**
         * Returns a JSON-compatible representation of this transaction.
         */
        toJSON() {
            const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, etxType, originatingTxHash, etxIndex, } = this;
            const result = {
                _type: 'TransactionReceipt',
                accessList,
                blockNumber,
                blockHash,
                chainId: toJson(this.chainId),
                data,
                from,
                gasLimit: toJson(this.gasLimit),
                hash,
                nonce,
                signature,
                to,
                index,
                type,
                etxType,
                originatingTxHash,
                etxIndex,
                value: toJson(this.value),
            };
            return result;
        }
        replaceableTransaction(startBlock) {
            assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
            const tx = new ExternalTransactionResponse(this, this.provider);
            tx.startBlock = startBlock;
            return tx;
        }
    }
    /**
     * A **QuaiTransactionResponse** includes all properties about a Quai transaction that was sent to the network, which
     * may or may not be included in a block.
     *
     * The {@link TransactionResponse.isMined | **TransactionResponse.isMined**} can be used to check if the transaction has
     * been mined as well as type guard that the otherwise possibly `null` properties are defined.
     *
     * @category Providers
     */
    class QuaiTransactionResponse {
        /**
         * The provider this is connected to, which will influence how its methods will resolve its async inspection
         * methods.
         */
        provider;
        /**
         * The block number of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockNumber;
        /**
         * The blockHash of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockHash;
        /**
         * The index within the block that this transaction resides at.
         */
        index;
        /**
         * The transaction hash.
         */
        hash;
        /**
         * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
         * transactions types.
         */
        type;
        /**
         * The receiver of this transaction.
         *
         * If `null`, then the transaction is an initcode transaction. This means the result of executing the
         * {@link QuaiTransactionResponse.data | **data** } will be deployed as a new contract on chain (assuming it does not
         * revert) and the address may be computed using [getCreateAddress](../functions/getCreateAddress).
         */
        to;
        /**
         * The sender of this transaction. It is implicitly computed from the transaction pre-image hash (as the digest) and
         * the {@link QuaiTransactionResponse.signature | **signature** } using ecrecover.
         */
        from;
        /**
         * The nonce, which is used to prevent replay attacks and offer a method to ensure transactions from a given sender
         * are explicitly ordered.
         *
         * When sending a transaction, this must be equal to the number of transactions ever sent by
         * {@link QuaiTransactionResponse.from | **from** }.
         */
        nonce;
        /**
         * The maximum units of gas this transaction can consume. If execution exceeds this, the entries transaction is
         * reverted and the sender is charged for the full amount, despite not state changes being made.
         */
        gasLimit;
        /**
         * The maximum priority fee (per unit of gas) to allow a validator to charge the sender. This is inclusive of the
         * {@link QuaiTransactionResponse.gasPrice | **gasPrice** }.
         */
        minerTip;
        /**
         * The maximum fee (per unit of gas) to allow this transaction to charge the sender.
         */
        gasPrice;
        /**
         * The data.
         */
        data;
        /**
         * The value, in wei. Use [formatEther](../functions/formatEther) to format this value as ether.
         */
        value;
        /**
         * The chain ID.
         */
        chainId;
        /**
         * The signature.
         */
        signature;
        /**
         * The [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list for transaction types that support it,
         * otherwise `null`.
         */
        accessList;
        etxType;
        sender;
        originatingTxHash;
        startBlock;
        /**
         * @ignore
         */
        constructor(tx, provider) {
            this.provider = provider;
            this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
            this.blockHash = tx.blockHash != null ? tx.blockHash : null;
            this.hash = tx.hash;
            this.index = tx.index;
            this.type = tx.type;
            this.from = tx.from;
            this.to = tx.to || null;
            this.gasLimit = tx.gasLimit;
            this.nonce = tx.nonce;
            this.data = tx.data;
            this.value = tx.value;
            this.minerTip = tx.minerTip != null ? tx.minerTip : null;
            this.gasPrice = tx.gasPrice != null ? tx.gasPrice : null;
            this.chainId = tx.chainId;
            this.signature = tx.signature;
            this.accessList = tx.accessList != null ? tx.accessList : null;
            this.startBlock = -1;
            this.etxType = tx.etxType != null ? tx.etxType : null;
        }
        /**
         * Returns a JSON-compatible representation of this transaction.
         */
        toJSON() {
            const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;
            const result = {
                _type: 'TransactionReceipt',
                accessList,
                blockNumber,
                blockHash,
                chainId: toJson(this.chainId),
                data,
                from,
                gasLimit: toJson(this.gasLimit),
                hash,
                gasPrice: toJson(this.gasPrice),
                minerTip: toJson(this.minerTip),
                nonce,
                signature,
                to,
                index,
                type,
                value: toJson(this.value),
            };
            return result;
        }
        /**
         * Resolves to the Block that this transaction was included in.
         *
         * This will return null if the transaction has not been included yet.
         *
         * @param {Shard} shard - The shard to fetch the block from.
         * @returns {null | Promise<Block>} A promise resolving to the block.
         */
        async getBlock(shard) {
            let blockNumber = this.blockNumber;
            if (blockNumber == null) {
                const tx = await this.getTransaction();
                if (tx) {
                    blockNumber = tx.blockNumber;
                }
            }
            if (blockNumber == null) {
                return null;
            }
            const block = this.provider.getBlock(shard, blockNumber);
            if (block == null) {
                throw new Error('TODO');
            }
            return block;
        }
        /**
         * Resolves to this transaction being re-requested from the provider. This can be used if you have an unmined
         * transaction and wish to get an up-to-date populated instance.
         *
         * @returns {null | Promise<TransactionResponse>} A promise resolving to the transaction, or null if not found.
         */
        async getTransaction() {
            const transaction = this.provider.getTransaction(this.hash);
            if (transaction instanceof QuaiTransactionResponse) {
                return transaction;
            }
            else {
                return null;
            }
        }
        /**
         * Resolve to the number of confirmations this transaction has.
         *
         * @returns {Promise<number>} A promise resolving to the number of confirmations.
         * @throws {Error} If the block is not found.
         */
        async confirmations() {
            const zone = zoneFromHash(this.hash);
            if (this.blockNumber == null) {
                const { tx, blockNumber } = await resolveProperties({
                    tx: this.getTransaction(),
                    blockNumber: this.provider.getBlockNumber(toShard(zone)),
                });
                // Not mined yet...
                if (tx == null || tx.blockNumber == null) {
                    return 0;
                }
                return blockNumber - tx.blockNumber + 1;
            }
            const blockNumber = await this.provider.getBlockNumber(toShard(zone));
            return blockNumber - this.blockNumber + 1;
        }
        /**
         * Resolves once this transaction has been mined and has `confirms` blocks including it (default: `1`) with an
         * optional `timeout`.
         *
         * This can resolve to `null` only if `confirms` is `0` and the transaction has not been mined, otherwise this will
         * wait until enough confirmations have completed.
         *
         * @param {number} [_confirms] - The number of confirmations to wait for.
         * @param {number} [_timeout] - The number of milliseconds to wait before rejecting.
         * @returns {Promise<null | TransactionReceipt>} A promise resolving to the transaction receipt.
         * @throws {Error} If the transaction was replaced, repriced, or cancelled.
         */
        async wait(_confirms, _timeout) {
            const confirms = _confirms == null ? 1 : _confirms;
            const timeout = _timeout == null ? 0 : _timeout;
            let startBlock = this.startBlock;
            let nextScan = -1;
            let stopScanning = startBlock === -1 ? true : false;
            const zone = zoneFromHash(this.hash);
            const checkReplacement = async () => {
                // Get the current transaction count for this sender
                if (stopScanning) {
                    return null;
                }
                const { blockNumber, nonce } = await resolveProperties({
                    blockNumber: this.provider.getBlockNumber(toShard(zone)),
                    nonce: this.provider.getTransactionCount(this.from),
                });
                // No transaction or our nonce has not been mined yet; but we
                // can start scanning later when we do start
                if (nonce < this.nonce) {
                    startBlock = blockNumber;
                    return;
                }
                // We were mined; no replacement
                if (stopScanning) {
                    return null;
                }
                const mined = await this.getTransaction();
                if (mined && mined.blockNumber != null) {
                    return;
                }
                // We were replaced; start scanning for that transaction
                // Starting to scan; look back a few extra blocks for safety
                if (nextScan === -1) {
                    nextScan = startBlock - 3;
                    if (nextScan < this.startBlock) {
                        nextScan = this.startBlock;
                    }
                }
                while (nextScan <= blockNumber) {
                    // Get the next block to scan
                    if (stopScanning) {
                        return null;
                    }
                    const block = await this.provider.getBlock(toShard(zone), nextScan, true);
                    // This should not happen; but we'll try again shortly
                    if (block == null) {
                        return;
                    }
                    // We were mined; no replacement
                    for (const hash of block) {
                        if (hash === this.hash) {
                            return;
                        }
                    }
                    // Search for the transaction that replaced us
                    for (let i = 0; i < block.length; i++) {
                        const tx = await block.getTransaction(i);
                        if ('from' in tx && tx.from === this.from && tx.nonce === this.nonce) {
                            // Get the receipt
                            if (stopScanning) {
                                return null;
                            }
                            const receipt = await this.provider.getTransactionReceipt(tx.hash);
                            // This should not happen; but we'll try again shortly
                            if (receipt == null) {
                                return;
                            }
                            // We will retry this on the next block (this case could be optimized)
                            if (blockNumber - receipt.blockNumber + 1 < confirms) {
                                return;
                            }
                            // The reason we were replaced
                            let reason = 'replaced';
                            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                                reason = 'repriced';
                            }
                            else if (tx.data === '0x' && tx.from === tx.to && tx.value === BN_0$1) {
                                reason = 'cancelled';
                            }
                            assert$1(false, 'transaction was replaced', 'TRANSACTION_REPLACED', {
                                cancelled: reason === 'replaced' || reason === 'cancelled',
                                reason,
                                replacement: tx.replaceableTransaction(startBlock),
                                hash: tx.hash,
                                receipt,
                            });
                        }
                    }
                    nextScan++;
                }
                return;
            };
            const checkReceipt = (receipt) => {
                if (receipt == null || receipt.status !== 0) {
                    return receipt;
                }
                assert$1(false, 'transaction execution reverted', 'CALL_EXCEPTION', {
                    action: 'sendTransaction',
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: {
                        to: receipt.to,
                        from: receipt.from,
                        data: '', // @TODO: in v7, split out sendTransaction properties
                    },
                    receipt,
                });
            };
            const receipt = await this.provider.getTransactionReceipt(this.hash);
            if (confirms === 0) {
                return checkReceipt(receipt);
            }
            if (receipt) {
                if ((await receipt.confirmations()) >= confirms) {
                    return checkReceipt(receipt);
                }
            }
            else {
                // Check for a replacement; throws if a replacement was found
                await checkReplacement();
                // Allow null only when the confirms is 0
                if (confirms === 0) {
                    return null;
                }
            }
            const waiter = new Promise((resolve, reject) => {
                // List of things to cancel when we have a result (one way or the other)
                const cancellers = [];
                const cancel = () => {
                    cancellers.forEach((c) => c());
                };
                // On cancel, stop scanning for replacements
                cancellers.push(() => {
                    stopScanning = true;
                });
                // Set up any timeout requested
                if (timeout > 0) {
                    const timer = setTimeout(() => {
                        cancel();
                        reject(makeError('wait for transaction timeout', 'TIMEOUT'));
                    }, timeout);
                    cancellers.push(() => {
                        clearTimeout(timer);
                    });
                }
                const txListener = async (receipt) => {
                    // Done; return it!
                    if ((await receipt.confirmations()) >= confirms) {
                        cancel();
                        try {
                            resolve(checkReceipt(receipt));
                        }
                        catch (error) {
                            reject(error);
                        }
                    }
                };
                cancellers.push(() => {
                    this.provider.off(this.hash, txListener);
                });
                this.provider.on(this.hash, txListener);
                // We support replacement detection; start checking
                if (startBlock >= 0) {
                    const replaceListener = async () => {
                        try {
                            // Check for a replacement; this throws only if one is found
                            await checkReplacement();
                        }
                        catch (error) {
                            // We were replaced (with enough confirms); re-throw the error
                            if (isError(error, 'TRANSACTION_REPLACED')) {
                                cancel();
                                reject(error);
                                return;
                            }
                        }
                        // Rescheudle a check on the next block
                        if (!stopScanning) {
                            this.provider.once('block', replaceListener, zone);
                        }
                    };
                    cancellers.push(() => {
                        this.provider.off('block', replaceListener, zone);
                    });
                    this.provider.once('block', replaceListener, zone);
                }
            });
            return await waiter;
        }
        /**
         * Returns `true` if this transaction has been included.
         *
         * This is effective only as of the time the TransactionResponse was instantiated. To get up-to-date information,
         * use {@link QuaiTransactionResponse.getTransaction | **getTransaction**}.
         *
         * This provides a Type Guard that this transaction will have non-null property values for properties that are null
         * for unmined transactions.
         *
         * @returns {QuaiMinedTransactionResponse} True if the transaction has been mined.
         * @throws {Error} If the transaction was replaced, repriced, or cancelled.
         */
        isMined() {
            return this.blockHash != null;
        }
        /**
         * Returns a filter which can be used to listen for orphan events that evict this transaction.
         *
         * @returns {OrphanFilter} The orphan filter.
         */
        removedEvent() {
            assert$1(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            return createRemovedTransactionFilter(this);
        }
        /**
         * Returns a filter which can be used to listen for orphan events that re-order this event against `other`.
         *
         * @param {TransactionResponse} [other] - The other transaction to compare against.
         * @returns {OrphanFilter} The orphan filter.
         */
        reorderedEvent(other) {
            assert$1(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            assert$1(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            return createReorderedTransactionFilter(this, other);
        }
        /**
         * Returns a new TransactionResponse instance which has the ability to detect (and throw an error) if the
         * transaction is replaced, which will begin scanning at `startBlock`.
         *
         * This should generally not be used by developers and is intended primarily for internal use. Setting an incorrect
         * `startBlock` can have devastating performance consequences if used incorrectly.
         *
         * @param {number} startBlock - The block number to start scanning for replacements.
         * @returns {QuaiTransactionResponse} The replaceable transaction.
         */
        replaceableTransaction(startBlock) {
            assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
            const tx = new QuaiTransactionResponse(this, this.provider);
            tx.startBlock = startBlock;
            return tx;
        }
    }
    /**
     * A **QiTransactionResponse** includes all properties about a Qi transaction that was sent to the network, which may or
     * may not be included in a block.
     *
     * The {@link TransactionResponse.isMined | **TransactionResponse.isMined**} can be used to check if the transaction has
     * been mined as well as type guard that the otherwise possibly `null` properties are defined.
     *
     * @category Providers
     */
    class QiTransactionResponse {
        /**
         * The provider this is connected to, which will influence how its methods will resolve its async inspection
         * methods.
         */
        provider;
        /**
         * The block number of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockNumber;
        /**
         * The blockHash of the block that this transaction was included in.
         *
         * This is `null` for pending transactions.
         */
        blockHash;
        /**
         * The index within the block that this transaction resides at.
         */
        index;
        /**
         * The transaction hash.
         */
        hash;
        /**
         * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
         * transactions types.
         */
        type;
        /**
         * The chain ID.
         */
        chainId;
        /**
         * The signature.
         */
        signature;
        txInputs;
        txOutputs;
        startBlock;
        /**
         * @ignore
         */
        constructor(tx, provider) {
            this.provider = provider;
            this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
            this.blockHash = tx.blockHash != null ? tx.blockHash : null;
            this.hash = tx.hash;
            this.index = tx.index;
            this.type = tx.type;
            this.chainId = tx.chainId;
            this.signature = tx.signature;
            this.startBlock = -1;
            this.txInputs = tx.txInputs;
            this.txOutputs = tx.txOutputs;
        }
        /**
         * Returns a JSON-compatible representation of this transaction.
         */
        toJSON() {
            const { blockNumber, blockHash, index, hash, type, signature, txInputs, txOutputs } = this;
            const result = {
                _type: 'TransactionReceipt',
                blockNumber,
                blockHash,
                chainId: toJson(this.chainId),
                hash,
                signature,
                index,
                type,
                txInputs: JSON.parse(JSON.stringify(txInputs)),
                txOutputs: JSON.parse(JSON.stringify(txOutputs)),
            };
            return result;
        }
        /**
         * Resolves to the Block that this transaction was included in.
         *
         * This will return null if the transaction has not been included yet.
         *
         * @param {Shard} shard - The shard to fetch the block from.
         * @returns {null | Promise<Block>} A promise resolving to the block or null if not found.
         */
        async getBlock(shard) {
            let blockNumber = this.blockNumber;
            if (blockNumber == null) {
                const tx = await this.getTransaction();
                if (tx) {
                    blockNumber = tx.blockNumber;
                }
            }
            if (blockNumber == null) {
                return null;
            }
            const block = this.provider.getBlock(shard, blockNumber);
            if (block == null) {
                throw new Error('TODO');
            }
            return block;
        }
        /**
         * Resolves to this transaction being re-requested from the provider. This can be used if you have an unmined
         * transaction and wish to get an up-to-date populated instance.
         *
         * @returns {null | Promise<TransactionResponse>} A promise resolving to the transaction, or null if not found.
         * @throws {Error} If the transaction is not found.
         */
        async getTransaction() {
            const transaction = this.provider.getTransaction(this.hash);
            if (transaction instanceof QiTransactionResponse) {
                return transaction;
            }
            else {
                return null;
            }
        }
        /**
         * Resolve to the number of confirmations this transaction has.
         *
         * @returns {Promise<number>} A promise resolving to the number of confirmations.
         */
        async confirmations() {
            const zone = zoneFromHash(this.hash);
            if (this.blockNumber == null) {
                const { tx, blockNumber } = await resolveProperties({
                    tx: this.getTransaction(),
                    blockNumber: this.provider.getBlockNumber(toShard(zone)),
                });
                // Not mined yet...
                if (tx == null || tx.blockNumber == null || tx.blockHash == null) {
                    return 0;
                }
                return blockNumber - tx.blockNumber + 1;
            }
            const blockNumber = await this.provider.getBlockNumber(toShard(zone));
            return blockNumber - this.blockNumber + 1;
        }
        async wait(_confirms, _timeout) {
            const confirms = _confirms == null ? 1 : _confirms;
            const timeout = _timeout == null ? 0 : _timeout;
            const tx = await this.provider.getTransaction(this.hash);
            if (confirms === 0 && tx?.blockHash != null) {
                return tx;
            }
            const waiter = new Promise((resolve, reject) => {
                // List of things to cancel when we have a result (one way or the other)
                const cancellers = [];
                const cancel = () => {
                    cancellers.forEach((c) => c());
                };
                // Set up any timeout requested
                if (timeout > 0) {
                    const timer = setTimeout(() => {
                        cancel();
                        reject(makeError('wait for transaction timeout', 'TIMEOUT'));
                    }, timeout);
                    cancellers.push(() => {
                        clearTimeout(timer);
                    });
                }
                const txListener = async (tx) => {
                    // Done; return it!
                    if ((await tx.confirmations()) >= confirms) {
                        cancel();
                        try {
                            resolve(tx);
                        }
                        catch (error) {
                            reject(error);
                        }
                    }
                };
                cancellers.push(() => {
                    this.provider.off(this.hash, txListener);
                });
                this.provider.on(this.hash, txListener);
            });
            return await waiter;
        }
        /**
         * Returns `true` if this transaction has been included.
         *
         * This is effective only as of the time the TransactionResponse was instantiated. To get up-to-date information,
         * use {@link QiTransactionResponse.getTransaction | **getTransaction**}.
         *
         * This provides a Type Guard that this transaction will have non-null property values for properties that are null
         * for unmined transactions.
         *
         * @returns {QiMinedTransactionResponse} True if the transaction has been mined or false otherwise.
         */
        isMined() {
            return this.blockHash != null;
        }
        /**
         * Returns a filter which can be used to listen for orphan events that evict this transaction.
         *
         * @returns {OrphanFilter} The orphan filter.
         */
        removedEvent() {
            assert$1(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            return createRemovedTransactionFilter(this);
        }
        /**
         * Returns a filter which can be used to listen for orphan events that re-order this event against `other`.
         *
         * @param {TransactionResponse} [other] - The other transaction to compare against.
         * @returns {OrphanFilter} The orphan filter.
         */
        reorderedEvent(other) {
            assert$1(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            assert$1(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", 'UNSUPPORTED_OPERATION', {
                operation: 'removeEvent()',
            });
            return createReorderedTransactionFilter(this, other);
        }
        /**
         * Returns a new TransactionResponse instance which has the ability to detect (and throw an error) if the
         * transaction is replaced, which will begin scanning at `startBlock`.
         *
         * This should generally not be used by developers and is intended primarily for internal use. Setting an incorrect
         * `startBlock` can have devastating performance consequences if used incorrectly.
         *
         * @param {number} startBlock - The block number to start scanning for replacements.
         * @returns {QiTransactionResponse} The replaceable transaction.
         */
        replaceableTransaction(startBlock) {
            assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
            const tx = new QiTransactionResponse(this, this.provider);
            tx.startBlock = startBlock;
            return tx;
        }
    }
    function createOrphanedBlockFilter(block) {
        return { orphan: 'drop-block', hash: block.hash, number: block.number };
    }
    function createReorderedTransactionFilter(tx, other) {
        return { orphan: 'reorder-transaction', tx, other };
    }
    function createRemovedTransactionFilter(tx) {
        return { orphan: 'drop-transaction', tx };
    }
    function createRemovedLogFilter(log) {
        return {
            orphan: 'drop-log',
            log: {
                transactionHash: log.transactionHash,
                blockHash: log.blockHash,
                blockNumber: log.blockNumber,
                address: log.address,
                data: log.data,
                topics: Object.freeze(log.topics.slice()),
                index: log.index,
            },
        };
    }
    function getZoneFromEventFilter(filter) {
        let zone = null;
        if (filter.nodeLocation) {
            zone = getZoneFromNodeLocation(filter.nodeLocation);
        }
        else if (filter.address) {
            let address;
            if (Array.isArray(filter.address)) {
                address = filter.address[0];
            }
            else {
                address = filter.address;
            }
            const addressZone = getZoneForAddress(address);
            if (addressZone) {
                zone = toZone(addressZone);
            }
            else {
                return null;
            }
        }
        return zone;
    }

    // import from provider.ts instead of index.ts to prevent circular dep
    // from quaiscanProvider
    /**
     * An **EventLog** contains additional properties parsed from the {@link Log | **Log**}.
     *
     * @category Contract
     */
    class EventLog extends Log {
        /**
         * The Contract Interface.
         */
        interface;
        /**
         * The matching event.
         */
        fragment;
        /**
         * The parsed arguments passed to the event by `emit`.
         */
        args;
        /**
         * @ignore
         */
        constructor(log, iface, fragment) {
            super(log, log.provider);
            const args = iface.decodeEventLog(fragment, log.data, log.topics);
            defineProperties(this, { args, fragment, interface: iface });
        }
        /**
         * The name of the event.
         */
        get eventName() {
            return this.fragment.name;
        }
        /**
         * The signature of the event.
         */
        get eventSignature() {
            return this.fragment.format();
        }
    }
    /**
     * An **EventLog** contains additional properties parsed from the {@link Log | **Log**}.
     *
     * @category Contract
     */
    class UndecodedEventLog extends Log {
        /**
         * The error encounted when trying to decode the log.
         */
        error;
        /**
         * @ignore
         */
        constructor(log, error) {
            super(log, log.provider);
            defineProperties(this, { error });
        }
    }
    /**
     * A **ContractTransactionReceipt** includes the parsed logs from a {@link TransactionReceipt | **TransactionReceipt**}.
     *
     * @category Contract
     */
    class ContractTransactionReceipt extends TransactionReceipt {
        #iface;
        /**
         * @ignore
         */
        constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
        }
        /**
         * The parsed logs for any {@link Log | **Log**} which has a matching event in the Contract ABI.
         */
        get logs() {
            return super.logs.map((log) => {
                const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
                if (fragment) {
                    try {
                        return new EventLog(log, this.#iface, fragment);
                    }
                    catch (error) {
                        return new UndecodedEventLog(log, error);
                    }
                }
                return log;
            });
        }
    }
    /**
     * A **ContractTransactionResponse** will return a {@link ContractTransactionReceipt | **ContractTransactionReceipt**}
     * when waited on.
     *
     * @category Contract
     */
    class ContractTransactionResponse extends QuaiTransactionResponse {
        #iface;
        /**
         * @ignore
         */
        constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
        }
        /**
         * Resolves once this transaction has been mined and has `confirms` blocks including it (default: `1`) with an
         * optional `timeout`.
         *
         * This can resolve to `null` only if `confirms` is `0` and the transaction has not been mined, otherwise this will
         * wait until enough confirmations have completed.
         *
         * @param {number} confirms - The number of confirmations to wait for.
         * @returns {Promise<ContractTransactionReceipt | null>} The transaction receipt, or `null` if `confirms` is `0`.
         */
        async wait(confirms) {
            const receipt = await super.wait(confirms);
            if (receipt == null) {
                return null;
            }
            return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
        }
    }
    /**
     * A **ContractUnknownEventPayload** is included as the last parameter to Contract Events when the event does not match
     * any events in the ABI.
     *
     * @category Contract
     */
    class ContractUnknownEventPayload extends EventPayload {
        /**
         * The log with no matching events.
         */
        log;
        /**
         * @ignore
         */
        constructor(contract, listener, filter, log) {
            super(contract, listener, filter);
            defineProperties(this, { log });
        }
        /**
         * Resolves to the block the event occured in.
         *
         * @param {Shard} shard - The shard to get the block from.
         * @returns {Promise<Block>} A promise resolving to the block the event occured in.
         */
        async getBlock(shard) {
            return await this.log.getBlock(shard);
        }
        /**
         * Resolves to the transaction the event occured in.
         *
         * @returns {Promise<TransactionResponse>} A promise resolving to the transaction the event occured in.
         */
        async getTransaction() {
            return await this.log.getTransaction();
        }
        /**
         * Resolves to the transaction receipt the event occured in.
         *
         * @returns {Promise<TransactionReceipt>} A promise resolving to the transaction receipt the event occured in.
         */
        async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
        }
    }
    /**
     * A **ContractEventPayload** is included as the last parameter to Contract Events when the event is known.
     *
     * @category Contract
     */
    class ContractEventPayload extends ContractUnknownEventPayload {
        /**
         * @ignore
         */
        constructor(contract, listener, filter, fragment, _log) {
            super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
            const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
            defineProperties(this, { args, fragment });
        }
        /**
         * The event name.
         */
        get eventName() {
            return this.fragment.name;
        }
        /**
         * The event signature.
         */
        get eventSignature() {
            return this.fragment.format();
        }
    }

    const BN_0 = BigInt(0);
    /**
     * Check if the value can call transactions.
     *
     * @param {any} value - The value to check.
     * @returns {value is ContractRunnerCaller} True if the value can call transactions.
     */
    function canCall(value) {
        return value && typeof value.call === 'function';
    }
    /**
     * Check if the value can estimate gas.
     *
     * @param {any} value - The value to check.
     * @returns {value is ContractRunnerEstimater} True if the value can estimate gas.
     */
    function canEstimate(value) {
        return value && typeof value.estimateGas === 'function';
    }
    /**
     * Check if the value can send transactions.
     *
     * @param {any} value - The value to check.
     * @returns {value is ContractRunnerSender} True if the value can send transactions.
     */
    function canSend(value) {
        return value && typeof value.sendTransaction === 'function';
    }
    /**
     * Class representing a prepared topic filter.
     *
     * @implements {DeferredTopicFilter}
     */
    class PreparedTopicFilter {
        #filter;
        fragment;
        /**
         * @ignore
         */
        constructor(contract, fragment, args) {
            defineProperties(this, { fragment });
            if (fragment.inputs.length < args.length) {
                throw new Error('too many arguments');
            }
            this.#filter = (async function () {
                const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
                    const arg = args[index];
                    if (arg == null) {
                        return null;
                    }
                    return param.walkAsync(args[index], (type, value) => {
                        if (type === 'address') {
                            if (Array.isArray(value)) {
                                return Promise.all(value.map((v) => resolveAddress(v)));
                            }
                            return resolveAddress(value);
                        }
                        return value;
                    });
                }));
                return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
            })();
        }
        /**
         * Get the topic filter.
         *
         * @returns {Promise<TopicFilter>} The topic filter.
         */
        getTopicFilter() {
            return this.#filter;
        }
    }
    /**
     * Get the runner for a specific feature.
     *
     * @param {any} value - The value to check.
     * @param {keyof ContractRunner} feature - The feature to check for.
     * @returns {null | T} The runner if available, otherwise null.
     */
    function getRunner(value, feature) {
        if (value == null) {
            return null;
        }
        if (typeof value[feature] === 'function') {
            return value;
        }
        if (value.provider && typeof value.provider[feature] === 'function') {
            return value.provider;
        }
        return null;
    }
    /**
     * Get the provider from a contract runner.
     *
     * @param {null | ContractRunner} value - The contract runner.
     * @returns {null | Provider} The provider if available, otherwise null.
     */
    function getProvider(value) {
        if (value == null) {
            return null;
        }
        return value.provider || null;
    }
    /**
     * @ignore Copy Overrides and validate them.
     * @param {any} arg - The argument containing overrides.
     * @param {string[]} [allowed] - The allowed override keys.
     * @returns {Promise<Omit<ContractTransaction, O>>} The copied and validated overrides.
     * @throws {Error} If the overrides are invalid.
     */
    async function copyOverrides(arg, allowed) {
        // Make sure the overrides passed in are a valid overrides object
        const _overrides = Typed.dereference(arg, 'overrides');
        assertArgument(typeof _overrides === 'object', 'invalid overrides parameter', 'overrides', arg);
        // Create a shallow copy (we'll deep-ify anything needed during normalizing)
        const overrides = copyRequest(_overrides);
        assertArgument(!('to' in overrides) || overrides.to == null || (allowed || []).indexOf('to') >= 0, 'cannot override to', 'overrides.to', overrides);
        assertArgument(!('data' in overrides) || overrides.data == null || (allowed || []).indexOf('data') >= 0, 'cannot override data', 'overrides.data', overrides);
        // Resolve any from
        if ('from' in overrides && overrides.from) {
            overrides.from = await overrides.from;
        }
        return overrides;
    }
    /**
     * @ignore Resolve Arguments for a contract runner.
     * @param {null | ContractRunner} _runner - The contract runner.
     * @param {ReadonlyArray<ParamType>} inputs - The input parameter types.
     * @param {any[]} args - The arguments to resolve.
     * @returns {Promise<any[]>} The resolved arguments.
     */
    async function resolveArgs(_runner, inputs, args) {
        // Recursively descend into args and resolve any addresses
        return await Promise.all(inputs.map((param, index) => {
            return param.walkAsync(args[index], (type, value) => {
                value = Typed.dereference(value, type);
                if (type === 'address') {
                    return resolveAddress(value);
                }
                return value;
            });
        }));
    }
    /**
     * Build a wrapped fallback method for a contract.
     *
     * @param {BaseContract} contract - The contract instance.
     * @returns {WrappedFallback} The wrapped fallback method.
     */
    function buildWrappedFallback(contract) {
        /**
         * Populate a transaction with overrides.
         *
         * @param {Omit<QuaiTransactionRequest, 'to'>} [overrides] - The transaction overrides.
         * @returns {Promise<ContractTransaction>} The populated transaction.
         * @throws {Error} If the overrides are invalid.
         */
        const populateTransaction = async function (overrides) {
            // If an overrides was passed in, copy it and normalize the values
            const tx = await copyOverrides(overrides, ['data']);
            tx.to = await contract.getAddress();
            validateAddress(tx.to);
            if (tx.from) {
                tx.from = await resolveAddress(tx.from);
                validateAddress(tx.from);
            }
            const iface = contract.interface;
            const noValue = getBigInt(tx.value || BN_0, 'overrides.value') === BN_0;
            const noData = (tx.data || '0x') === '0x';
            if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
                assertArgument(false, 'cannot send data to receive or send value to non-payable fallback', 'overrides', overrides);
            }
            assertArgument(iface.fallback || noData, 'cannot send data to receive-only contract', 'overrides.data', tx.data);
            // Only allow payable contracts to set non-zero value
            const payable = iface.receive || (iface.fallback && iface.fallback.payable);
            assertArgument(payable || noValue, 'cannot send value to non-payable fallback', 'overrides.value', tx.value);
            // Only allow fallback contracts to set non-empty data
            assertArgument(iface.fallback || noData, 'cannot send data to receive-only contract', 'overrides.data', tx.data);
            return tx;
        };
        /**
         * Perform a static call with the given overrides.
         *
         * @param {Omit<QuaiTransactionRequest, 'to'>} [overrides] - The transaction overrides.
         * @returns {Promise<string>} The result of the static call.
         * @throws {Error} If the call fails.
         */
        const staticCall = async function (overrides) {
            const runner = getRunner(contract.runner, 'call');
            assert$1(canCall(runner), 'contract runner does not support calling', 'UNSUPPORTED_OPERATION', {
                operation: 'call',
            });
            const tx = await populateTransaction(overrides);
            try {
                return await runner.call(tx);
            }
            catch (error) {
                if (isCallException(error) && error.data) {
                    throw contract.interface.makeError(error.data, tx);
                }
                throw error;
            }
        };
        /**
         * Send a transaction with the given overrides.
         *
         * @param {Omit<QuaiTransactionRequest, 'to'>} [overrides] - The transaction overrides.
         * @returns {Promise<ContractTransactionResponse>} The transaction response.
         * @throws {Error} If the transaction fails.
         */
        const send = async function (overrides) {
            const runner = contract.runner;
            assert$1(canSend(runner), 'contract runner does not support sending transactions', 'UNSUPPORTED_OPERATION', {
                operation: 'sendTransaction',
            });
            const tx = (await runner.sendTransaction(await populateTransaction(overrides)));
            const provider = getProvider(contract.runner);
            // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            return new ContractTransactionResponse(contract.interface, provider, tx);
        };
        /**
         * Estimate the gas required for a transaction with the given overrides.
         *
         * @param {Omit<QuaiTransactionRequest, 'to'>} [overrides] - The transaction overrides.
         * @returns {Promise<bigint>} The estimated gas.
         * @throws {Error} If the gas estimation fails.
         */
        const estimateGas = async function (overrides) {
            const runner = getRunner(contract.runner, 'estimateGas');
            assert$1(canEstimate(runner), 'contract runner does not support gas estimation', 'UNSUPPORTED_OPERATION', {
                operation: 'estimateGas',
            });
            return await runner.estimateGas(await populateTransaction(overrides));
        };
        /**
         * Send a transaction with the given overrides.
         *
         * @param {Omit<QuaiTransactionRequest, 'to'>} [overrides] - The transaction overrides.
         * @returns {Promise<ContractTransactionResponse>} The transaction response.
         * @throws {Error} If the transaction fails.
         */
        const method = async (overrides) => {
            return await send(overrides);
        };
        defineProperties(method, {
            _contract: contract,
            estimateGas,
            populateTransaction,
            send,
            staticCall,
        });
        return method;
    }
    /**
     * Build a wrapped method for a contract.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {string} key - The method key.
     * @returns {BaseContractMethod<A, R, D>} The wrapped method.
     */
    function buildWrappedMethod(contract, key) {
        /**
         * Get the function fragment for the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {FunctionFragment} The function fragment.
         * @throws {Error} If no matching fragment is found.
         */
        const getFragment = function (...args) {
            const fragment = contract.interface.getFunction(key, args);
            assert$1(fragment, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
                operation: 'fragment',
                info: { key, args },
            });
            return fragment;
        };
        /**
         * Populate a transaction with the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<ContractTransaction>} The populated transaction.
         * @throws {Error} If the arguments are invalid.
         */
        const populateTransaction = async function (...args) {
            const fragment = getFragment(...args);
            // If an overrides was passed in, copy it and normalize the values
            let overrides;
            if (fragment.inputs.length + 1 === args.length) {
                overrides = await copyOverrides(args.pop());
                const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
                return Object.assign({}, overrides, await resolveProperties({
                    to: contract.getAddress(),
                    data: contract.interface.encodeFunctionData(fragment, resolvedArgs),
                }));
            }
            if (fragment.inputs.length !== args.length) {
                throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            }
            const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
            return await resolveProperties({
                to: contract.getAddress(),
                from: args.pop()?.from,
                data: contract.interface.encodeFunctionData(fragment, resolvedArgs),
            });
        };
        /**
         * Perform a static call with the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<R>} The result of the static call.
         * @throws {Error} If the call fails.
         */
        const staticCall = async function (...args) {
            const result = await staticCallResult(...args);
            if (result.length === 1) {
                return result[0];
            }
            return result;
        };
        /**
         * Send a transaction with the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<ContractTransactionResponse>} The transaction response.
         * @throws {Error} If the transaction fails.
         */
        const send = async function (...args) {
            const runner = contract.runner;
            assert$1(canSend(runner), 'contract runner does not support sending transactions', 'UNSUPPORTED_OPERATION', {
                operation: 'sendTransaction',
            });
            const pop = await populateTransaction(...args);
            if (!pop.from && 'address' in runner && typeof runner.address === 'string') {
                pop.from = await resolveAddress(runner.address);
            }
            const tx = (await runner.sendTransaction(await pop));
            const provider = getProvider(contract.runner);
            // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            return new ContractTransactionResponse(contract.interface, provider, tx);
        };
        /**
         * Estimate the gas required for a transaction with the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<bigint>} The estimated gas.
         * @throws {Error} If the gas estimation fails.
         */
        const estimateGas = async function (...args) {
            const runner = getRunner(contract.runner, 'estimateGas');
            assert$1(canEstimate(runner), 'contract runner does not support gas estimation', 'UNSUPPORTED_OPERATION', {
                operation: 'estimateGas',
            });
            return await runner.estimateGas(await populateTransaction(...args));
        };
        /**
         * Perform a static call and return the result with the given arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<Result>} The result of the static call.
         * @throws {Error} If the call fails.
         */
        const staticCallResult = async function (...args) {
            const runner = getRunner(contract.runner, 'call');
            assert$1(canCall(runner), 'contract runner does not support calling', 'UNSUPPORTED_OPERATION', {
                operation: 'call',
            });
            const tx = await populateTransaction(...args);
            if (!tx.from && 'address' in runner && typeof runner.address === 'string') {
                tx.from = await resolveAddress(runner.address);
            }
            let result = '0x';
            try {
                result = await runner.call(tx);
            }
            catch (error) {
                if (isCallException(error) && error.data) {
                    throw contract.interface.makeError(error.data, tx);
                }
                throw error;
            }
            const fragment = getFragment(...args);
            return contract.interface.decodeFunctionResult(fragment, result);
        };
        /**
         * Send a transaction or perform a static call based on the method arguments.
         *
         * @param {...ContractMethodArgs<A>} args - The method arguments.
         * @returns {Promise<R | ContractTransactionResponse>} The result of the method call.
         * @throws {Error} If the method call fails.
         */
        const method = async (...args) => {
            const fragment = getFragment(...args);
            if (fragment.constant) {
                return await staticCall(...args);
            }
            return await send(...args);
        };
        defineProperties(method, {
            name: contract.interface.getFunctionName(key),
            _contract: contract,
            _key: key,
            getFragment,
            estimateGas,
            populateTransaction,
            send,
            staticCall,
            staticCallResult,
        });
        // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
        Object.defineProperty(method, 'fragment', {
            configurable: false,
            enumerable: true,
            get: () => {
                const fragment = contract.interface.getFunction(key);
                assert$1(fragment, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
                    operation: 'fragment',
                    info: { key },
                });
                return fragment;
            },
        });
        return method;
    }
    /**
     * Build a wrapped event for a contract.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {string} key - The event key.
     * @returns {ContractEvent<A>} The wrapped event.
     */
    function buildWrappedEvent(contract, key) {
        /**
         * Get the event fragment for the given arguments.
         *
         * @param {...ContractEventArgs<A>} args - The event arguments.
         * @returns {EventFragment} The event fragment.
         * @throws {Error} If no matching fragment is found.
         */
        const getFragment = function (...args) {
            const fragment = contract.interface.getEvent(key, args);
            assert$1(fragment, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
                operation: 'fragment',
                info: { key, args },
            });
            return fragment;
        };
        /**
         * Create a prepared topic filter for the event.
         *
         * @param {...ContractMethodArgs<A>} args - The event arguments.
         * @returns {PreparedTopicFilter} The prepared topic filter.
         */
        const method = function (...args) {
            return new PreparedTopicFilter(contract, getFragment(...args), args);
        };
        defineProperties(method, {
            name: contract.interface.getEventName(key),
            _contract: contract,
            _key: key,
            getFragment,
        });
        // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
        Object.defineProperty(method, 'fragment', {
            configurable: false,
            enumerable: true,
            get: () => {
                const fragment = contract.interface.getEvent(key);
                assert$1(fragment, 'no matching fragment', 'UNSUPPORTED_OPERATION', {
                    operation: 'fragment',
                    info: { key },
                });
                return fragment;
            },
        });
        return method;
    }
    // The combination of TypeScrype, Private Fields and Proxies makes
    // the world go boom; so we hide variables with some trickery keeping
    // a symbol attached to each BaseContract which its sub-class (even
    // via a Proxy) can reach and use to look up its internal values.
    const internal = Symbol.for('_quaisInternal_contract');
    const internalValues = new WeakMap();
    /**
     * Set internal values for a contract.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {Internal} values - The internal values.
     */
    function setInternal(contract, values) {
        internalValues.set(contract[internal], values);
    }
    /**
     * Get internal values for a contract.
     *
     * @param {BaseContract} contract - The contract instance.
     * @returns {Internal} The internal values.
     */
    function getInternal(contract) {
        return internalValues.get(contract[internal]);
    }
    /**
     * Check if a value is a deferred topic filter.
     *
     * @param {any} value - The value to check.
     * @returns {value is DeferredTopicFilter} True if the value is a deferred topic filter.
     */
    function isDeferred(value) {
        return (value &&
            typeof value === 'object' &&
            'getTopicFilter' in value &&
            typeof value.getTopicFilter === 'function' &&
            value.fragment);
    }
    /**
     * Get subscription information for an event.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {ContractEventName} event - The event name.
     * @returns {Promise<{ fragment: null | EventFragment; tag: string; topics: TopicFilter }>} The subscription
     *   information.
     * @throws {Error} If the event name is unknown.
     */
    async function getSubInfo(contract, event) {
        let topics;
        let fragment = null;
        // Convert named events to topicHash and get the fragment for
        // events which need deconstructing.
        if (Array.isArray(event)) {
            const topicHashify = function (name) {
                if (isHexString(name, 32)) {
                    return name;
                }
                const fragment = contract.interface.getEvent(name);
                assertArgument(fragment, 'unknown fragment', 'name', name);
                return fragment.topicHash;
            };
            // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
            topics = event.map((e) => {
                if (e == null) {
                    return null;
                }
                if (Array.isArray(e)) {
                    return e.map(topicHashify);
                }
                return topicHashify(e);
            });
        }
        else if (event === '*') {
            topics = [null];
        }
        else if (typeof event === 'string') {
            if (isHexString(event, 32)) {
                // Topic Hash
                topics = [event];
            }
            else {
                // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
                fragment = contract.interface.getEvent(event);
                assertArgument(fragment, 'unknown fragment', 'event', event);
                topics = [fragment.topicHash];
            }
        }
        else if (isDeferred(event)) {
            // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`
            topics = await event.getTopicFilter();
        }
        else if (event && 'fragment' in event) {
            // ContractEvent; e.g. `contract.filter.Transfer`
            fragment = event.fragment;
            topics = [fragment.topicHash];
        }
        else {
            assertArgument(false, 'unknown event name', 'event', event);
        }
        // Normalize topics and sort TopicSets
        topics = topics.map((t) => {
            if (t == null) {
                return null;
            }
            if (Array.isArray(t)) {
                const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());
                if (items.length === 1) {
                    return items[0];
                }
                items.sort();
                return items;
            }
            return t.toLowerCase();
        });
        const tag = topics
            .map((t) => {
            if (t == null) {
                return 'null';
            }
            if (Array.isArray(t)) {
                return t.join('|');
            }
            return t;
        })
            .join('&');
        return { fragment, tag, topics };
    }
    /**
     * Check if a contract has a subscription for an event.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {ContractEventName} event - The event name.
     * @returns {Promise<null | Sub>} The subscription if available, otherwise null.
     */
    async function hasSub(contract, event) {
        const { subs } = getInternal(contract);
        return subs.get((await getSubInfo(contract, event)).tag) || null;
    }
    /**
     * Get a subscription for an event.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {string} operation - The operation name.
     * @param {ContractEventName} event - The event name.
     * @returns {Promise<Sub>} The subscription.
     * @throws {Error} If the contract runner does not support subscribing.
     */
    async function getSub(contract, operation, event) {
        // Make sure our runner can actually subscribe to events
        const provider = getProvider(contract.runner);
        assert$1(provider, 'contract runner does not support subscribing', 'UNSUPPORTED_OPERATION', { operation });
        const { fragment, tag, topics } = await getSubInfo(contract, event);
        const { addr, subs } = getInternal(contract);
        let sub = subs.get(tag);
        if (!sub) {
            const address = addr ? addr : contract;
            const filter = { address, topics };
            const listener = (log) => {
                let foundFragment = fragment;
                if (foundFragment == null) {
                    try {
                        foundFragment = contract.interface.getEvent(log.topics[0]);
                        // eslint-disable-next-line no-empty
                    }
                    catch (error) { }
                }
                // If fragment is null, we do not deconstruct the args to emit
                if (foundFragment) {
                    const _foundFragment = foundFragment;
                    const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
                    emit(contract, event, args, (listener) => {
                        return new ContractEventPayload(contract, listener, event, _foundFragment, log);
                    });
                }
                else {
                    emit(contract, event, [], (listener) => {
                        return new ContractUnknownEventPayload(contract, listener, event, log);
                    });
                }
            };
            const zone = getZoneForAddress(await resolveAddress(address));
            let starting = [];
            const start = () => {
                if (starting.length) {
                    return;
                }
                starting.push(provider.on(filter, listener, zone));
            };
            const stop = async () => {
                if (starting.length == 0) {
                    return;
                }
                const started = starting;
                starting = [];
                await Promise.all(started);
                provider.off(filter, listener, zone);
            };
            sub = { tag, listeners: [], start, stop };
            subs.set(tag, sub);
        }
        return sub;
    }
    /**
     * We use this to ensure one emit resolves before firing the next to ensure correct ordering (note this cannot throw and
     * just adds the notice to the event queue using setTimeout).
     */
    let lastEmit = Promise.resolve();
    /**
     * Emit an event with the given arguments and payload function.
     *
     * @ignore
     * @param {BaseContract} contract - The contract instance.
     * @param {ContractEventName} event - The event name.
     * @param {any[]} args - The arguments to pass to the listeners.
     * @param {null | PayloadFunc} payloadFunc - The payload function.
     * @returns {Promise<boolean>} Resolves to true if any listeners were called.
     */
    async function _emit(contract, event, args, payloadFunc) {
        await lastEmit;
        const sub = await hasSub(contract, event);
        if (!sub) {
            return false;
        }
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const passArgs = Array.from(args);
            if (payloadFunc) {
                passArgs.push(payloadFunc(once ? null : listener));
            }
            try {
                listener.call(contract, ...passArgs);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            return !once;
        });
        if (sub.listeners.length === 0) {
            sub.stop();
            getInternal(contract).subs.delete(sub.tag);
        }
        return count > 0;
    }
    /**
     * Emit an event with the given arguments and payload function.
     *
     * @param {BaseContract} contract - The contract instance.
     * @param {ContractEventName} event - The event name.
     * @param {any[]} args - The arguments to pass to the listeners.
     * @param {null | PayloadFunc} payloadFunc - The payload function.
     * @returns {Promise<boolean>} Resolves to true if any listeners were called.
     */
    async function emit(contract, event, args, payloadFunc) {
        try {
            await lastEmit;
            // eslint-disable-next-line no-empty
        }
        catch (error) { }
        const resultPromise = _emit(contract, event, args, payloadFunc);
        lastEmit = resultPromise;
        return await resultPromise;
    }
    const passProperties = ['then'];
    /**
     * Creates a new contract connected to target with the abi and optionally connected to a runner to perform operations on
     * behalf of.
     *
     * @category Contract
     */
    class BaseContract {
        /**
         * The target to connect to.
         *
         * This can be an address or any [Addressable](../interfaces/Addressable), such as another contract. To get the
         * resolved address, use the `getAddress` method.
         */
        target;
        /**
         * The contract Interface.
         */
        interface;
        /**
         * The connected runner. This is generally a [**Provider**](../interfaces/Provider) or a
         * [**Signer**](../interfaces/Signer), which dictates what operations are supported.
         *
         * For example, a **Contract** connected to a [**Provider**](../interfaces/Provider) may only execute read-only
         * operations.
         */
        runner;
        /**
         * All the Events available on this contract.
         */
        filters;
        /**
         * @ignore
         */
        [internal];
        /**
         * The fallback or receive function if any.
         */
        fallback;
        /**
         * Creates a new contract connected to `target` with the `abi` and optionally connected to a `runner` to perform
         * operations on behalf of.
         *
         * @ignore
         */
        constructor(target, abi, runner, _deployTx) {
            assertArgument(typeof target === 'string' || isAddressable(target), 'invalid value for Contract target', 'target', target);
            if (runner == null) {
                runner = null;
            }
            const iface = Interface.from(abi);
            defineProperties(this, { target, runner, interface: iface });
            Object.defineProperty(this, internal, { value: {} });
            let addrPromise;
            let addr = null;
            let deployTx = null;
            if (_deployTx) {
                const provider = getProvider(runner);
                // @TODO: the provider can be null; make a custom dummy provider that will throw a
                // meaningful error
                deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
            }
            const subs = new Map();
            // Resolve the target as the address
            if (typeof target === 'string') {
                addr = target;
                addrPromise = Promise.resolve(target);
            }
            else {
                addrPromise = target.getAddress().then((addr) => {
                    if (addr == null) {
                        throw new Error('TODO');
                    }
                    getInternal(this).addr = addr;
                    return addr;
                });
            }
            // Set our private values
            setInternal(this, { addrPromise, addr, deployTx, subs });
            // Add the event filters
            const filters = new Proxy({}, {
                get: (target, prop, receiver) => {
                    // Pass important checks (like `then` for Promise) through
                    if (typeof prop === 'symbol' || passProperties.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    try {
                        return this.getEvent(prop);
                    }
                    catch (error) {
                        if (!isError(error, 'INVALID_ARGUMENT') || error.argument !== 'key') {
                            throw error;
                        }
                    }
                    return undefined;
                },
                has: (target, prop) => {
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties.indexOf(prop) >= 0) {
                        return Reflect.has(target, prop);
                    }
                    return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));
                },
            });
            defineProperties(this, { filters });
            defineProperties(this, {
                fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null,
            });
            // Return a Proxy that will respond to functions
            return new Proxy(this, {
                get: (target, prop, receiver) => {
                    if (typeof prop === 'symbol' || prop in target || passProperties.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    // Undefined properties should return undefined
                    try {
                        return target.getFunction(prop);
                    }
                    catch (error) {
                        if (!isError(error, 'INVALID_ARGUMENT') || error.argument !== 'key') {
                            throw error;
                        }
                    }
                    return undefined;
                },
                has: (target, prop) => {
                    if (typeof prop === 'symbol' || prop in target || passProperties.indexOf(prop) >= 0) {
                        return Reflect.has(target, prop);
                    }
                    return target.interface.hasFunction(prop);
                },
            });
        }
        /**
         * Return a new Contract instance with the same target and ABI, but a different `runner`.
         *
         * @param {null | ContractRunner} runner - The runner to use.
         * @returns {BaseContract} The new contract instance.
         */
        connect(runner) {
            return new BaseContract(this.target, this.interface, runner);
        }
        /**
         * Return a new Contract instance with the same ABI and runner, but a different `target`.
         *
         * @param {string | Addressable} target - The target to connect to.
         * @returns {BaseContract} The new contract instance.
         */
        attach(target) {
            return new BaseContract(target, this.interface, this.runner);
        }
        /**
         * Return the resolved address of this Contract.
         *
         * @returns {Promise<string>} The resolved address.
         */
        async getAddress() {
            return await getInternal(this).addrPromise;
        }
        /**
         * Return the deployed bytecode or null if no bytecode is found.
         *
         * @returns {Promise<null | string>} The deployed bytecode or null.
         * @throws {Error} If the runner does not support .provider.
         */
        async getDeployedCode() {
            const provider = getProvider(this.runner);
            assert$1(provider, 'runner does not support .provider', 'UNSUPPORTED_OPERATION', {
                operation: 'getDeployedCode',
            });
            const code = await provider.getCode(await this.getAddress());
            if (code === '0x') {
                return null;
            }
            return code;
        }
        /**
         * Resolve to this Contract once the bytecode has been deployed, or resolve immediately if already deployed.
         *
         * @returns {Promise<this>} The contract instance.
         * @throws {Error} If the contract runner does not support .provider.
         */
        async waitForDeployment() {
            // We have the deployment transaction; just use that (throws if deployment fails)
            const deployTx = this.deploymentTransaction();
            if (deployTx) {
                await deployTx.wait();
                return this;
            }
            // Check for code
            const code = await this.getDeployedCode();
            if (code != null) {
                return this;
            }
            // Make sure we can subscribe to a provider event
            const provider = getProvider(this.runner);
            assert$1(provider != null, 'contract runner does not support .provider', 'UNSUPPORTED_OPERATION', {
                operation: 'waitForDeployment',
            });
            return new Promise((resolve, reject) => {
                const checkCode = async () => {
                    try {
                        const code = await this.getDeployedCode();
                        if (code != null) {
                            return resolve(this);
                        }
                        provider.once('block', checkCode);
                    }
                    catch (error) {
                        reject(error);
                    }
                };
                checkCode();
            });
        }
        /**
         * Return the transaction used to deploy this contract.
         *
         * This is only available if this instance was returned from a [**ContractFactor**](../classes/ContractFactory).
         *
         * @returns The transaction used to deploy this contract or `null`.
         */
        deploymentTransaction() {
            return getInternal(this).deployTx;
        }
        /**
         * Return the function for a given name. This is useful when a contract method name conflicts with a JavaScript name
         * such as `prototype` or when using a Contract programatically.
         *
         * @param {string | FunctionFragment} key - The name of the function to return.
         * @returns The function for the given name.
         */
        getFunction(key) {
            if (typeof key !== 'string') {
                key = key.format();
            }
            const func = buildWrappedMethod(this, key);
            return func;
        }
        /**
         * Return the event for a given name. This is useful when a contract event name conflicts with a JavaScript name
         * such as `prototype` or when using a Contract programatically.
         *
         * @param {string | EventFragment} key - The name of the event to return.
         * @returns The event for the given name.
         */
        getEvent(key) {
            if (typeof key !== 'string') {
                key = key.format();
            }
            return buildWrappedEvent(this, key);
        }
        /**
         * @ignore
         */
        // TODO: implement
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async queryTransaction(hash) {
            throw new Error('@TODO');
        }
        /**
         * Provide historic access to event data for `event` in the range `fromBlock` (default: `0`) to `toBlock` (default:
         * `"latest"`) inclusive.
         *
         * @param {Zone} zone - The zone to query.
         * @param {ContractEventName} event - The event to query.
         * @param {BlockTag} fromBlock - The block to start querying from.
         * @param {BlockTag} toBlock - The block to stop querying at.
         * @returns An array of event logs.
         */
        async queryFilter(event, fromBlock, toBlock) {
            if (fromBlock == null) {
                fromBlock = 0;
            }
            if (toBlock == null) {
                toBlock = 'latest';
            }
            const { addr, addrPromise } = getInternal(this);
            const address = addr ? addr : await addrPromise;
            const { fragment, topics } = await getSubInfo(this, event);
            const zone = getZoneForAddress(address);
            const filter = { address, topics, fromBlock, toBlock, nodeLocation: getNodeLocationFromZone(zone) };
            const provider = getProvider(this.runner);
            assert$1(provider, 'contract runner does not have a provider', 'UNSUPPORTED_OPERATION', {
                operation: 'queryFilter',
            });
            return (await provider.getLogs(filter)).map((log) => {
                let foundFragment = fragment;
                if (foundFragment == null) {
                    try {
                        foundFragment = this.interface.getEvent(log.topics[0]);
                        // eslint-disable-next-line no-empty
                    }
                    catch (error) { }
                }
                if (foundFragment) {
                    try {
                        return new EventLog(log, this.interface, foundFragment);
                    }
                    catch (error) {
                        return new UndecodedEventLog(log, error);
                    }
                }
                return new Log(log, provider);
            });
        }
        /**
         * Add an event `listener` for the `event`.
         *
         * @param {ContractEventName} event - The event to listen for.
         * @param {Listener} listener - The listener to call when the event is emitted.
         * @returns This contract instance.
         */
        async on(event, listener) {
            const sub = await getSub(this, 'on', event);
            sub.listeners.push({ listener, once: false });
            sub.start();
            return this;
        }
        /**
         * Add an event `listener` for the `event`, but remove the listener after it is fired once.
         *
         * @param {ContractEventName} event - The event to listen for.
         * @param {Listener} listener - The listener to call when the event is emitted.
         */
        async once(event, listener) {
            const sub = await getSub(this, 'once', event);
            sub.listeners.push({ listener, once: true });
            sub.start();
            return this;
        }
        /**
         * Emit an `event` calling all listeners with `args`.
         *
         * Resolves to `true` if any listeners were called.
         *
         * @param {ContractEventName} event - The event to emit.
         * @param {any[]} args - The arguments to pass to the listeners.
         * @returns `true` if any listeners were called.
         */
        async emit(event, ...args) {
            return await emit(this, event, args, null);
        }
        /**
         * Resolves to the number of listeners of `event` or the total number of listeners if unspecified.
         *
         * @param {ContractEventName} event - The event to count listeners for.
         * @returns {number} The number of listeners.
         */
        async listenerCount(event) {
            if (event) {
                const sub = await hasSub(this, event);
                if (!sub) {
                    return 0;
                }
                return sub.listeners.length;
            }
            const { subs } = getInternal(this);
            let total = 0;
            for (const { listeners } of subs.values()) {
                total += listeners.length;
            }
            return total;
        }
        /**
         * Resolves to the listeners subscribed to `event` or all listeners if unspecified.
         *
         * @param {ContractEventName} event - The event to get listeners for.
         * @returns {Listener[]} The listeners.
         */
        async listeners(event) {
            if (event) {
                const sub = await hasSub(this, event);
                if (!sub) {
                    return [];
                }
                return sub.listeners.map(({ listener }) => listener);
            }
            const { subs } = getInternal(this);
            let result = [];
            for (const { listeners } of subs.values()) {
                result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
        }
        /**
         * Remove the `listener` from the listeners for `event` or remove all listeners if unspecified.
         *
         * @param {ContractEventName} event - The event to remove the listener from.
         * @param {Listener} listener - The listener to remove.
         * @returns This contract instance.
         */
        async off(event, listener) {
            const sub = await hasSub(this, event);
            if (!sub) {
                return this;
            }
            if (listener) {
                const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
                if (index >= 0) {
                    sub.listeners.splice(index, 1);
                }
            }
            if (listener == null || sub.listeners.length === 0) {
                sub.stop();
                getInternal(this).subs.delete(sub.tag);
            }
            return this;
        }
        /**
         * Remove all the listeners for `event` or remove all listeners if unspecified.
         *
         * @param {ContractEventName} event - The event to remove the listeners from.
         * @returns This contract instance.
         */
        async removeAllListeners(event) {
            if (event) {
                const sub = await hasSub(this, event);
                if (!sub) {
                    return this;
                }
                sub.stop();
                getInternal(this).subs.delete(sub.tag);
            }
            else {
                const { subs } = getInternal(this);
                for (const { tag, stop } of subs.values()) {
                    stop();
                    subs.delete(tag);
                }
            }
            return this;
        }
        /**
         * Alias for {@link BaseContract.on | **on**}.
         *
         * @param {ContractEventName} event - The event to listen for.
         * @param {Listener} listener - The listener to call when the event is emitted.
         */
        async addListener(event, listener) {
            return await this.on(event, listener);
        }
        /**
         * Alias for {@link BaseContract.off | **off**}.
         *
         * @param {ContractEventName} event - The event to remove the listener from.
         * @param {Listener} listener - The listener to remove.
         */
        async removeListener(event, listener) {
            return await this.off(event, listener);
        }
        /**
         * Create a new Class for the `abi`.
         *
         * @param {Interface | InterfaceAbi} abi - The ABI to create the class from.
         * @returns The new Class for the ABI.
         */
        static buildClass(abi) {
            class CustomContract extends BaseContract {
                constructor(address, runner = null) {
                    super(address, abi, runner);
                }
            }
            return CustomContract;
        }
        /**
         * Create a new BaseContract with a specified Interface.
         *
         * @param {string} target - The target to connect to.
         * @param {Interface | InterfaceAbi} abi - The ABI to use.
         * @param {null | ContractRunner} runner - The runner to use.
         * @returns The new BaseContract.
         */
        static from(target, abi, runner) {
            if (runner == null) {
                runner = null;
            }
            const contract = new this(target, abi, runner);
            return contract;
        }
    }
    function _ContractBase() {
        return BaseContract;
    }
    /**
     * A {@link BaseContract | **BaseContract**} with no type guards on its methods or events.
     *
     * @category Contract
     */
    class Contract extends _ContractBase() {
    }

    /**
     * Generally the [Wallet](../classes/Wallet) and [JsonRpcSigner](../classes/JsonRpcSigner) and their sub-classes are
     * sufficent for most developers, but this is provided to fascilitate more complex Signers.
     */
    function checkProvider(signer, operation) {
        if (signer.provider) {
            return signer.provider;
        }
        assert$1(false, 'missing provider', 'UNSUPPORTED_OPERATION', { operation });
    }
    async function populate(signer, tx) {
        const pop = copyRequest(tx);
        if (pop.to != null) {
            pop.to = resolveAddress(pop.to);
            validateAddress(pop.to);
        }
        if (pop.from != null) {
            const from = pop.from;
            pop.from = await Promise.all([signer.getAddress(), resolveAddress(from)]).then(([address, from]) => {
                assertArgument(address.toLowerCase() === from.toLowerCase(), 'transaction from mismatch', 'tx.from', from);
                return address;
            });
        }
        else {
            pop.from = await signer.getAddress();
        }
        validateAddress(pop.from);
        return await resolveProperties(pop);
    }
    /**
     * An **AbstractSigner** includes most of teh functionality required to get a {@link Signer | **Signer**} working as
     * expected, but requires a few Signer-specific methods be overridden.
     *
     * @category Signers
     */
    class AbstractSigner {
        /**
         * The provider this signer is connected to.
         */
        provider;
        /**
         * Creates a new Signer connected to `provider`.
         */
        constructor(provider) {
            defineProperties(this, { provider: provider || null });
        }
        /**
         * @ignore
         */
        _getAddress(address) {
            return resolveAddress(address);
        }
        async zoneFromAddress(_address) {
            const address = this._getAddress(_address);
            return toZone((await address).slice(0, 4));
        }
        async getNonce(blockTag) {
            return checkProvider(this, 'getTransactionCount').getTransactionCount(await this.getAddress(), blockTag);
        }
        async populateCall(tx) {
            const pop = await populate(this, tx);
            return pop;
        }
        async populateQuaiTransaction(tx) {
            const provider = checkProvider(this, 'populateTransaction');
            const zone = await this.zoneFromAddress(tx.from);
            const pop = (await populate(this, tx));
            if (pop.type == null) {
                pop.type = getTxType(pop.from ?? null, pop.to ?? null);
            }
            if (pop.nonce == null || pop.nonce === 0) {
                pop.nonce = await this.getNonce('pending');
            }
            // Populate the chain ID
            const network = await this.provider.getNetwork();
            if (pop.chainId != null && pop.chainId !== 0n) {
                const chainId = getBigInt(pop.chainId);
                assertArgument(chainId === network.chainId, 'transaction chainId mismatch', 'tx.chainId', zone);
            }
            else {
                pop.chainId = network.chainId;
            }
            // Create a base transaction object to be used for gas estimation and access list creation
            const baseTx = {
                chainId: pop.chainId,
                type: pop.type,
                from: pop.from,
                nonce: pop.nonce,
            };
            if (pop.to)
                baseTx.to = pop.to;
            if (pop.data)
                baseTx.data = pop.data;
            if (pop.value)
                baseTx.value = pop.value;
            if (pop.gasLimit == null || pop.gasLimit === 0n) {
                if (pop.type == 0) {
                    pop.gasLimit = await this.estimateGas(baseTx);
                }
                else {
                    //Special cases for type 2 tx to bypass address out of scope in the node
                    baseTx.to = '0x0000000000000000000000000000000000000000';
                    pop.gasLimit = getBigInt(2 * Number(await this.estimateGas(baseTx)));
                    baseTx.to = pop.to;
                }
            }
            if (pop.gasPrice == null || pop.minerTip == null) {
                const feeData = await provider.getFeeData(zone, true);
                if (pop.gasPrice == null) {
                    pop.gasPrice = feeData.gasPrice;
                }
                if (pop.minerTip == null) {
                    pop.minerTip = feeData.minerTip || 10n;
                }
            }
            if (pop.data) {
                if (tx.accessList) {
                    pop.accessList = tx.accessList;
                }
                else {
                    pop.accessList = await this.createAccessList(baseTx);
                }
            }
            //@TOOD: Don't await all over the place; save them up for
            // the end for better batching
            return await resolveProperties(pop);
        }
        async estimateGas(tx) {
            return checkProvider(this, 'estimateGas').estimateGas(await this.populateCall(tx));
        }
        async createAccessList(tx) {
            return checkProvider(this, 'createAccessList').createAccessList((await this.populateCall(tx)));
        }
        async call(tx) {
            return checkProvider(this, 'call').call(await this.populateCall(tx));
        }
        async sendTransaction(tx) {
            const provider = checkProvider(this, 'sendTransaction');
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(tx));
            const pop = await this.populateQuaiTransaction(tx);
            const txObj = QuaiTransaction.from(pop);
            const sender = await this.getAddress();
            const signedTx = await this.signTransaction(txObj);
            return await provider.broadcastTransaction(zone, signedTx, sender);
        }
    }
    /**
     * A **VoidSigner** is a class deisgned to allow an address to be used in any API which accepts a Signer, but for which
     * there are no credentials available to perform any actual signing.
     *
     * This for example allow impersonating an account for the purpose of static calls or estimating gas, but does not allow
     * sending transactions.
     *
     * @category Signers
     */
    class VoidSigner extends AbstractSigner {
        /**
         * The signer address.
         */
        address;
        /**
         * Creates a new **VoidSigner** with `address` attached to `provider`.
         */
        constructor(address, provider) {
            super(provider);
            defineProperties(this, { address });
        }
        async getAddress() {
            return this.address;
        }
        connect(provider) {
            return new VoidSigner(this.address, provider);
        }
        #throwUnsupported(suffix, operation) {
            assert$1(false, `VoidSigner cannot sign ${suffix}`, 'UNSUPPORTED_OPERATION', { operation });
        }
        // TODO: `domain`, `types` and `value` are not used, remove?
        // TODO: this function only throws, remove?
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async signTransaction(tx) {
            this.#throwUnsupported('transactions', 'signTransaction');
        }
        // TODO: `domain`, `types` and `value` are not used, remove?
        // TODO: this function only throws, remove?
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async signMessage(message) {
            this.#throwUnsupported('messages', 'signMessage');
        }
        // TODO: `domain`, `types` and `value` are not used, remove?
        // TODO: this function only throws, remove?
        async signTypedData(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        domain, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        types, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        value) {
            this.#throwUnsupported('typed-data', 'signTypedData');
        }
    }

    /**
     * The **BaseWallet** is a stream-lined implementation of a {@link AbstractSigner} that operates with a private key.
     *
     * It is preferred to use the {@link Wallet} class, as it offers additional functionality and simplifies loading a
     * variety of JSON formats, Mnemonic Phrases, etc.
     *
     * This class may be of use for those attempting to implement a minimal Signer.
     *
     * @category Wallet
     */
    class BaseWallet extends AbstractSigner {
        /**
         * The wallet address.
         *
         * @type {string}
         * @readonly
         */
        #address;
        /**
         * The signing key used for signing payloads.
         *
         * @type {SigningKey}
         * @readonly
         */
        #signingKey;
        /**
         * Creates a new BaseWallet for `privateKey`, optionally connected to `provider`.
         *
         * If `provider` is not specified, only offline methods can be used.
         *
         * @param {SigningKey} privateKey - The private key for the wallet.
         * @param {null | Provider} [provider] - The provider to connect to.
         */
        constructor(privateKey, provider) {
            super(provider);
            assertArgument(privateKey && typeof privateKey.sign === 'function', 'invalid private key', 'privateKey', '[ REDACTED ]');
            this.#signingKey = privateKey;
            this.#address = computeAddress(this.signingKey.publicKey);
        }
        // Store private values behind getters to reduce visibility
        /**
         * The address of this wallet.
         *
         * @type {string}
         * @readonly
         */
        get address() {
            return this.#address;
        }
        /**
         * The {@link SigningKey | **SigningKey**} used for signing payloads.
         *
         * @type {SigningKey}
         * @readonly
         */
        get signingKey() {
            return this.#signingKey;
        }
        /**
         * The private key for this wallet.
         *
         * @type {string}
         * @readonly
         */
        get privateKey() {
            return this.signingKey.privateKey;
        }
        // TODO: `_zone` is not used, should it be removed?
        /**
         * Returns the address of this wallet.
         *
         * @param {string} [_zone] - The zone (optional).
         * @returns {Promise<string>} The wallet address.
         */
        // eslint-disable-next-line
        async getAddress(_zone) {
            return this.#address;
        }
        /**
         * Connects the wallet to a provider.
         *
         * @param {null | Provider} provider - The provider to connect to.
         * @returns {BaseWallet} The connected wallet.
         */
        connect(provider) {
            return new BaseWallet(this.#signingKey, provider);
        }
        /**
         * Signs a transaction.
         *
         * @param {QuaiTransactionRequest} tx - The transaction request.
         * @returns {Promise<string>} The signed transaction.
         */
        async signTransaction(tx) {
            // Replace any Addressable with an address
            const { to, from } = await resolveProperties({
                to: tx.to ? resolveAddress(tx.to) : undefined,
                from: tx.from ? resolveAddress(tx.from) : undefined,
            });
            if (to !== undefined) {
                validateAddress(to);
                tx.to = to;
            }
            if (from !== undefined) {
                assertArgument(getAddress(from) === this.#address, 'transaction from address mismatch', 'tx.from', from);
            }
            else {
                // No `from` specified, use the wallet's address
                tx.from = this.#address;
            }
            const btx = QuaiTransaction.from(tx);
            const digest = keccak256(btx.unsignedSerialized);
            btx.signature = this.signingKey.sign(digest);
            return btx.serialized;
        }
        /**
         * Signs a message.
         *
         * @async
         * @param {string | Uint8Array} message - The message to sign.
         * @returns {Promise<string>} The signed message.
         */
        async signMessage(message) {
            return this.signMessageSync(message);
        }
        // @TODO: Add a secialized signTx and signTyped sync that enforces
        // all parameters are known?
        /**
         * Returns the signature for `message` signed with this wallet.
         *
         * @param {string | Uint8Array} message - The message to sign.
         * @returns {string} The serialized signature.
         */
        signMessageSync(message) {
            return this.signingKey.sign(hashMessage(message)).serialized;
        }
        /**
         * Signs typed data.
         *
         * @async
         * @param {TypedDataDomain} domain - The domain of the typed data.
         * @param {Record<string, TypedDataField[]>} types - The types of the typed data.
         * @param {Record<string, any>} value - The value of the typed data.
         * @returns {Promise<string>} The signed typed data.
         */
        async signTypedData(domain, types, value) {
            return this.signingKey.sign(TypedDataEncoder.hash(domain, types, value)).serialized;
        }
    }

    const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
    const Word = /^[a-z]*$/i;
    function unfold(words, sep) {
        let initial = 97;
        return words.reduce((accum, word) => {
            if (word === sep) {
                initial++;
            }
            else if (word.match(Word)) {
                accum.push(String.fromCharCode(initial) + word);
            }
            else {
                initial = 97;
                accum.push(word);
            }
            return accum;
        }, []);
    }
    /**
     * @ignore
     */
    function decode(data, subs) {
        // Replace all the substitutions with their expanded form
        for (let i = subsChrs.length - 1; i >= 0; i--) {
            data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
        }
        // Get all tle clumps; each suffix, first-increment and second-increment
        const clumps = [];
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
            if (semi) {
                for (let i = parseInt(semi); i >= 0; i--) {
                    clumps.push(';');
                }
            }
            else {
                clumps.push(item.toLowerCase());
            }
            return '';
        });
        /* c8 ignore start */
        if (leftover) {
            throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
        }
        /* c8 ignore stop */
        return unfold(unfold(clumps, ';'), ':');
    }
    /**
     * @ignore
     */
    function decodeOwl(data) {
        assertArgument(data[0] === '0', 'unsupported auwl data', 'data', data);
        return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
    }

    /**
     * A Wordlist represents a collection of language-specific words used to encode and devoce
     * [BIP-39](https://en.bitcoin.it/wiki/BIP_0039) encoded data by mapping words to 11-bit values and vice versa.
     *
     * @category Wordlists
     */
    class Wordlist {
        locale;
        /**
         * Creates a new Wordlist instance.
         *
         * Sub-classes MUST call this if they provide their own constructor, passing in the locale string of the language.
         *
         * Generally there is no need to create instances of a Wordlist, since each language-specific Wordlist creates an
         * instance and there is no state kept internally, so they are safe to share.
         */
        constructor(locale) {
            defineProperties(this, { locale });
        }
        /**
         * Sub-classes may override this to provide a language-specific method for spliting `phrase` into individual words.
         *
         * By default, `phrase` is split using any sequences of white-space as defined by regular expressions (i.e.
         * `/\s+/`).
         *
         * @param {string} phrase - The phrase to split.
         * @returns {string[]} The split words in the phrase.
         */
        split(phrase) {
            return phrase.toLowerCase().split(/\s+/g);
        }
        /**
         * Sub-classes may override this to provider a language-specific method for joining `words` into a phrase.
         *
         * By default, `words` are joined by a single space.
         *
         * @param {string[]} words - The words to join.
         * @returns {string} The joined phrase.
         */
        join(words) {
            return words.join(' ');
        }
    }

    // Use the encode-latin.js script to create the necessary
    // data files to be consumed by this class
    /**
     * An OWL format Wordlist is an encoding method that exploits the general locality of alphabetically sorted words to
     * achieve a simple but effective means of compression.
     *
     * This class is generally not useful to most developers as it is used mainly internally to keep Wordlists for languages
     * based on ASCII-7 small.
     *
     * If necessary, there are tools within the `generation/` folder to create the necessary data.
     *
     * @category Wordlists
     */
    class WordlistOwl extends Wordlist {
        #data;
        #checksum;
        /**
         * Creates a new Wordlist for `locale` using the OWL `data` and validated against the `checksum`.
         */
        constructor(locale, data, checksum) {
            super(locale);
            this.#data = data;
            this.#checksum = checksum;
            this.#words = null;
        }
        /**
         * The OWL-encoded data.
         *
         * @ignore
         */
        get _data() {
            return this.#data;
        }
        /**
         * Decode all the words for the wordlist.
         */
        _decodeWords() {
            return decodeOwl(this.#data);
        }
        #words;
        #loadWords() {
            if (this.#words == null) {
                const words = this._decodeWords();
                // Verify the computed list matches the official list
                const checksum = id(words.join('\n') + '\n');
                /* c8 ignore start */
                if (checksum !== this.#checksum) {
                    throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
                }
                /* c8 ignore stop */
                this.#words = words;
            }
            return this.#words;
        }
        getWord(index) {
            const words = this.#loadWords();
            assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, 'index', index);
            return words[index];
        }
        getWordIndex(word) {
            return this.#loadWords().indexOf(word);
        }
    }

    const words$1 = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
    const checksum$2 = '0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60';
    let wordlist$1 = null;
    /**
     * The [English wordlist](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt) for [mnemonic
     * phrases](https://en.bitcoin.it/wiki/BIP_0039).
     *
     * @category Wordlists
     */
    class LangEn extends WordlistOwl {
        /**
         * Creates a new instance of the English language Wordlist.
         *
         * This should be unnecessary most of the time as the exported {@link langEn} should suffice.
         *
         * @ignore
         */
        constructor() {
            super('en', words$1, checksum$2);
        }
        /**
         * Returns a singleton instance of a `LangEn`, creating it if this is the first time being called.
         */
        static wordlist() {
            if (wordlist$1 == null) {
                wordlist$1 = new LangEn();
            }
            return wordlist$1;
        }
    }

    /**
     * Returns a byte with the MSB bits set.
     *
     * @param {number} bits - The number of bits to set.
     * @returns {number} The byte with the MSB bits set.
     */
    function getUpperMask(bits) {
        return (((1 << bits) - 1) << (8 - bits)) & 0xff;
    }
    /**
     * Returns a byte with the LSB bits set.
     *
     * @param {number} bits - The number of bits to set.
     * @returns {number} The byte with the LSB bits set.
     */
    function getLowerMask(bits) {
        return ((1 << bits) - 1) & 0xff;
    }
    /**
     * Converts a mnemonic phrase to entropy.
     *
     * @param {string} mnemonic - The mnemonic phrase.
     * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
     * @returns {string} The entropy.
     */
    function mnemonicToEntropy(mnemonic, wordlist) {
        assertNormalize('NFKD');
        if (wordlist == null) {
            wordlist = LangEn.wordlist();
        }
        const words = wordlist.split(mnemonic);
        assertArgument(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, 'invalid mnemonic length', 'mnemonic', '[ REDACTED ]');
        const entropy = new Uint8Array(Math.ceil((11 * words.length) / 8));
        let offset = 0;
        for (let i = 0; i < words.length; i++) {
            const index = wordlist.getWordIndex(words[i].normalize('NFKD'));
            assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, 'mnemonic', '[ REDACTED ]');
            for (let bit = 0; bit < 11; bit++) {
                if (index & (1 << (10 - bit))) {
                    entropy[offset >> 3] |= 1 << (7 - (offset % 8));
                }
                offset++;
            }
        }
        const entropyBits = (32 * words.length) / 3;
        const checksumBits = words.length / 3;
        const checksumMask = getUpperMask(checksumBits);
        const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
        assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), 'invalid mnemonic checksum', 'mnemonic', '[ REDACTED ]');
        return hexlify(entropy.slice(0, entropyBits / 8));
    }
    /**
     * Converts entropy to a mnemonic phrase.
     *
     * @param {Uint8Array} entropy - The entropy.
     * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
     * @returns {string} The mnemonic phrase.
     */
    function entropyToMnemonic(entropy, wordlist) {
        assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, 'invalid entropy size', 'entropy', '[ REDACTED ]');
        if (wordlist == null) {
            wordlist = LangEn.wordlist();
        }
        const indices = [0];
        let remainingBits = 11;
        for (let i = 0; i < entropy.length; i++) {
            // Consume the whole byte (with still more to go)
            if (remainingBits > 8) {
                indices[indices.length - 1] <<= 8;
                indices[indices.length - 1] |= entropy[i];
                remainingBits -= 8;
                // This byte will complete an 11-bit index
            }
            else {
                indices[indices.length - 1] <<= remainingBits;
                indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
                // Start the next word
                indices.push(entropy[i] & getLowerMask(8 - remainingBits));
                remainingBits += 3;
            }
        }
        // Compute the checksum bits
        const checksumBits = entropy.length / 4;
        const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
        // Shift the checksum into the word indices
        indices[indices.length - 1] <<= checksumBits;
        indices[indices.length - 1] |= checksum >> (8 - checksumBits);
        return wordlist.join(indices.map((index) => wordlist.getWord(index)));
    }
    const _guard$2 = {};
    /**
     * A **Mnemonic** wraps all properties required to compute [BIP-39](https://en.bitcoin.it/wiki/BIP_0039) seeds and
     * convert between phrases and entropy.
     *
     * @category Wallet
     */
    class Mnemonic {
        /**
         * The mnemonic phrase of 12, 15, 18, 21 or 24 words.
         *
         * Use the {@link wordlist | **wordlist**} `split` method to get the individual words.
         */
        phrase;
        /**
         * The password used for this mnemonic. If no password is used this is the empty string (i.e. `""`) as per the
         * specification.
         */
        password;
        /**
         * The wordlist for this mnemonic.
         */
        wordlist;
        /**
         * The underlying entropy which the mnemonic encodes.
         */
        entropy;
        /**
         * @param {any} guard - The guard object.
         * @param {string} entropy - The entropy.
         * @param {string} phrase - The mnemonic phrase.
         * @param {string} [password] - The password for the mnemonic.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         */
        constructor(guard, entropy, phrase, password, wordlist) {
            if (password == null) {
                password = '';
            }
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            assertPrivate(guard, _guard$2, 'Mnemonic');
            defineProperties(this, { phrase, password, wordlist, entropy });
        }
        /**
         * Returns the seed for the mnemonic.
         *
         * @returns {string} The seed.
         */
        computeSeed() {
            const salt = toUtf8Bytes('mnemonic' + this.password, 'NFKD');
            return pbkdf2(toUtf8Bytes(this.phrase, 'NFKD'), salt, 2048, 64, 'sha512');
        }
        /**
         * Creates a new Mnemonic for the `phrase`.
         *
         * The default `password` is the empty string and the default wordlist is the {@link LangEn | **English wordlist**}.
         *
         * @param {string} phrase - The mnemonic phrase.
         * @param {string} [password] - The password for the mnemonic.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         * @returns {Mnemonic} The new Mnemonic object.
         */
        static fromPhrase(phrase, password, wordlist) {
            // Normalize the case and space; throws if invalid
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            if (password == null) {
                password = '';
            }
            const entropy = mnemonicToEntropy(phrase, wordlist);
            phrase = entropyToMnemonic(getBytes(entropy), wordlist);
            return new Mnemonic(_guard$2, entropy, phrase, password, wordlist);
        }
        /**
         * Create a new **Mnemonic** from the `entropy`.
         *
         * The default `password` is the empty string and the default wordlist is the [{@link LangEn | **English wordlist**}.
         *
         * @param {BytesLike} _entropy - The entropy for the mnemonic.
         * @param {string} [password] - The password for the mnemonic.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         * @returns {Mnemonic} The new Mnemonic object.
         */
        static fromEntropy(_entropy, password, wordlist) {
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            if (password == null) {
                password = '';
            }
            const entropy = getBytes(_entropy, 'entropy');
            const phrase = entropyToMnemonic(entropy, wordlist);
            return new Mnemonic(_guard$2, hexlify(entropy), phrase, password, wordlist);
        }
        /**
         * Returns the phrase for `mnemonic`.
         *
         * @param {BytesLike} _entropy - The entropy for the mnemonic.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         * @returns {string} The mnemonic phrase.
         */
        static entropyToPhrase(_entropy, wordlist) {
            const entropy = getBytes(_entropy, 'entropy');
            return entropyToMnemonic(entropy, wordlist);
        }
        /**
         * Returns the entropy for `phrase`.
         *
         * @param {string} phrase - The mnemonic phrase.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         * @returns {string} The entropy.
         */
        static phraseToEntropy(phrase, wordlist) {
            return mnemonicToEntropy(phrase, wordlist);
        }
        /**
         * Returns true if `phrase` is a valid [BIP-39](https://en.bitcoin.it/wiki/BIP_0039) phrase.
         *
         * This checks all the provided words belong to the `wordlist`, that the length is valid and the checksum is
         * correct.
         *
         * @param {string} phrase - The mnemonic phrase.
         * @param {Wordlist} [wordlist] - The wordlist for the mnemonic.
         * @returns {boolean} True if the phrase is valid.
         * @throws {Error} If the phrase is invalid.
         */
        static isValidMnemonic(phrase, wordlist) {
            try {
                mnemonicToEntropy(phrase, wordlist);
                return true;
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            return false;
        }
    }

    /*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
    var __classPrivateFieldGet$1 = (__$G && __$G.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$1 = (__$G && __$G.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _AES_key, _AES_Kd, _AES_Ke;
    // Number of rounds by keysize
    const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    // Round constant words
    const rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
    // S-box and Inverse S-box (S is for Substitution)
    const S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    const Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
    // Transformations for encryption
    const T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    const T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    const T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    const T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
    // Transformations for decryption
    const T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    const T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    const T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    const T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
    // Transformations for decryption key expansion
    const U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    const U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    const U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    const U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
    function convertToInt32(bytes) {
        const result = [];
        for (let i = 0; i < bytes.length; i += 4) {
            result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);
        }
        return result;
    }
    class AES {
        get key() { return __classPrivateFieldGet$1(this, _AES_key, "f").slice(); }
        constructor(key) {
            _AES_key.set(this, void 0);
            _AES_Kd.set(this, void 0);
            _AES_Ke.set(this, void 0);
            if (!(this instanceof AES)) {
                throw Error('AES must be instanitated with `new`');
            }
            __classPrivateFieldSet$1(this, _AES_key, new Uint8Array(key), "f");
            const rounds = numberOfRounds[this.key.length];
            if (rounds == null) {
                throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
            }
            // encryption round keys
            __classPrivateFieldSet$1(this, _AES_Ke, [], "f");
            // decryption round keys
            __classPrivateFieldSet$1(this, _AES_Kd, [], "f");
            for (let i = 0; i <= rounds; i++) {
                __classPrivateFieldGet$1(this, _AES_Ke, "f").push([0, 0, 0, 0]);
                __classPrivateFieldGet$1(this, _AES_Kd, "f").push([0, 0, 0, 0]);
            }
            const roundKeyCount = (rounds + 1) * 4;
            const KC = this.key.length / 4;
            // convert the key into ints
            const tk = convertToInt32(this.key);
            // copy values into round key arrays
            let index;
            for (let i = 0; i < KC; i++) {
                index = i >> 2;
                __classPrivateFieldGet$1(this, _AES_Ke, "f")[index][i % 4] = tk[i];
                __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
            }
            // key expansion (fips-197 section 5.2)
            let rconpointer = 0;
            let t = KC, tt;
            while (t < roundKeyCount) {
                tt = tk[KC - 1];
                tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                    (S[(tt >> 8) & 0xFF] << 16) ^
                    (S[tt & 0xFF] << 8) ^
                    S[(tt >> 24) & 0xFF] ^
                    (rcon[rconpointer] << 24));
                rconpointer += 1;
                // key expansion (for non-256 bit)
                if (KC != 8) {
                    for (let i = 1; i < KC; i++) {
                        tk[i] ^= tk[i - 1];
                    }
                    // key expansion for 256-bit keys is "slightly different" (fips-197)
                }
                else {
                    for (let i = 1; i < (KC / 2); i++) {
                        tk[i] ^= tk[i - 1];
                    }
                    tt = tk[(KC / 2) - 1];
                    tk[KC / 2] ^= (S[tt & 0xFF] ^
                        (S[(tt >> 8) & 0xFF] << 8) ^
                        (S[(tt >> 16) & 0xFF] << 16) ^
                        (S[(tt >> 24) & 0xFF] << 24));
                    for (let i = (KC / 2) + 1; i < KC; i++) {
                        tk[i] ^= tk[i - 1];
                    }
                }
                // copy values into round key arrays
                let i = 0, r, c;
                while (i < KC && t < roundKeyCount) {
                    r = t >> 2;
                    c = t % 4;
                    __classPrivateFieldGet$1(this, _AES_Ke, "f")[r][c] = tk[i];
                    __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
                    t++;
                }
            }
            // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
            for (let r = 1; r < rounds; r++) {
                for (let c = 0; c < 4; c++) {
                    tt = __classPrivateFieldGet$1(this, _AES_Kd, "f")[r][c];
                    __classPrivateFieldGet$1(this, _AES_Kd, "f")[r][c] = (U1[(tt >> 24) & 0xFF] ^
                        U2[(tt >> 16) & 0xFF] ^
                        U3[(tt >> 8) & 0xFF] ^
                        U4[tt & 0xFF]);
                }
            }
        }
        encrypt(plaintext) {
            if (plaintext.length != 16) {
                throw new TypeError('invalid plaintext size (must be 16 bytes)');
            }
            const rounds = __classPrivateFieldGet$1(this, _AES_Ke, "f").length - 1;
            const a = [0, 0, 0, 0];
            // convert plaintext to (ints ^ key)
            let t = convertToInt32(plaintext);
            for (let i = 0; i < 4; i++) {
                t[i] ^= __classPrivateFieldGet$1(this, _AES_Ke, "f")[0][i];
            }
            // apply round transforms
            for (let r = 1; r < rounds; r++) {
                for (let i = 0; i < 4; i++) {
                    a[i] = (T1[(t[i] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >> 8) & 0xff] ^
                        T4[t[(i + 3) % 4] & 0xff] ^
                        __classPrivateFieldGet$1(this, _AES_Ke, "f")[r][i]);
                }
                t = a.slice();
            }
            // the last round is special
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
                tt = __classPrivateFieldGet$1(this, _AES_Ke, "f")[rounds][i];
                result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
                result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
            }
            return result;
        }
        decrypt(ciphertext) {
            if (ciphertext.length != 16) {
                throw new TypeError('invalid ciphertext size (must be 16 bytes)');
            }
            const rounds = __classPrivateFieldGet$1(this, _AES_Kd, "f").length - 1;
            const a = [0, 0, 0, 0];
            // convert plaintext to (ints ^ key)
            let t = convertToInt32(ciphertext);
            for (let i = 0; i < 4; i++) {
                t[i] ^= __classPrivateFieldGet$1(this, _AES_Kd, "f")[0][i];
            }
            // apply round transforms
            for (let r = 1; r < rounds; r++) {
                for (let i = 0; i < 4; i++) {
                    a[i] = (T5[(t[i] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >> 8) & 0xff] ^
                        T8[t[(i + 1) % 4] & 0xff] ^
                        __classPrivateFieldGet$1(this, _AES_Kd, "f")[r][i]);
                }
                t = a.slice();
            }
            // the last round is special
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
                tt = __classPrivateFieldGet$1(this, _AES_Kd, "f")[rounds][i];
                result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
                result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
            }
            return result;
        }
    }
    _AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();

    class ModeOfOperation {
        constructor(name, key, cls) {
            if (cls && !(this instanceof cls)) {
                throw new Error(`${name} must be instantiated with "new"`);
            }
            Object.defineProperties(this, {
                aes: { enumerable: true, value: new AES(key) },
                name: { enumerable: true, value: name }
            });
        }
    }

    // Counter Mode
    var __classPrivateFieldSet = (__$G && __$G.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet = (__$G && __$G.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
    class CTR extends ModeOfOperation {
        constructor(key, initialValue) {
            super("CTR", key, CTR);
            // Remaining bytes for the one-time pad
            _CTR_remaining.set(this, void 0);
            _CTR_remainingIndex.set(this, void 0);
            // The current counter
            _CTR_counter.set(this, void 0);
            __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
            __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
            __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f"); // This will be discarded immediately
            __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
            if (initialValue == null) {
                initialValue = 1;
            }
            if (typeof (initialValue) === "number") {
                this.setCounterValue(initialValue);
            }
            else {
                this.setCounterBytes(initialValue);
            }
        }
        get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f")); }
        setCounterValue(value) {
            if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
                throw new TypeError("invalid counter initial integer value");
            }
            for (let index = 15; index >= 0; --index) {
                __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
                value = Math.floor(value / 256);
            }
        }
        setCounterBytes(value) {
            if (value.length !== 16) {
                throw new TypeError("invalid counter initial Uint8Array value length");
            }
            __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
        }
        increment() {
            for (let i = 15; i >= 0; i--) {
                if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
                    __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
                }
                else {
                    __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
                    break;
                }
            }
        }
        encrypt(plaintext) {
            var _a, _b;
            const crypttext = new Uint8Array(plaintext);
            for (let i = 0; i < crypttext.length; i++) {
                if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
                    __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
                    __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
                    this.increment();
                }
                crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
            }
            return crypttext;
        }
        decrypt(ciphertext) {
            return this.encrypt(ciphertext);
        }
    }
    _CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();

    /**
     * @module wallet/utils
     */
    /**
     * Converts a hex string to a Uint8Array. If the string does not start with '0x', it adds it.
     *
     * @param {string} hexString - The hex string to convert.
     * @returns {Uint8Array} The resulting byte array.
     */
    function looseArrayify(hexString) {
        if (typeof hexString === 'string' && !hexString.startsWith('0x')) {
            hexString = '0x' + hexString;
        }
        return getBytesCopy(hexString);
    }
    /**
     * Converts a password to a Uint8Array. If the password is a string, it converts it to UTF-8 bytes.
     *
     * @param {string | Uint8Array} password - The password to convert.
     * @returns {Uint8Array} The resulting byte array.
     */
    function getPassword(password) {
        if (typeof password === 'string') {
            return toUtf8Bytes(password, 'NFKC');
        }
        return getBytesCopy(password);
    }
    /**
     * Traverses an object based on a path and returns the value at that path.
     *
     * @param {any} object - The object to traverse.
     * @param {string} _path - The path to traverse.
     * @returns {T} The value at the specified path.
     */
    function spelunk(object, _path) {
        const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
        assertArgument(match != null, 'invalid path', 'path', _path);
        const path = match[1];
        const type = match[3];
        const reqd = match[4] === '!';
        let cur = object;
        for (const comp of path.toLowerCase().split('.')) {
            // Search for a child object with a case-insensitive matching key
            if (Array.isArray(cur)) {
                if (!comp.match(/^[0-9]+$/)) {
                    break;
                }
                cur = cur[parseInt(comp)];
            }
            else if (typeof cur === 'object') {
                let found = null;
                for (const key in cur) {
                    if (key.toLowerCase() === comp) {
                        found = cur[key];
                        break;
                    }
                }
                cur = found;
            }
            else {
                cur = null;
            }
            if (cur == null) {
                break;
            }
        }
        assertArgument(!reqd || cur != null, 'missing required value', 'path', path);
        if (type && cur != null) {
            if (type === 'int') {
                if (typeof cur === 'string' && cur.match(/^-?[0-9]+$/)) {
                    return parseInt(cur);
                }
                else if (Number.isSafeInteger(cur)) {
                    return cur;
                }
            }
            if (type === 'number') {
                if (typeof cur === 'string' && cur.match(/^-?[0-9.]*$/)) {
                    return parseFloat(cur);
                }
            }
            if (type === 'data') {
                if (typeof cur === 'string') {
                    return looseArrayify(cur);
                }
            }
            if (type === 'array' && Array.isArray(cur)) {
                return cur;
            }
            if (type === typeof cur) {
                return cur;
            }
            assertArgument(false, `wrong type found for ${type} `, 'path', path);
        }
        return cur;
    }
    /**
     * Constant N used in cryptographic operations
     */
    BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    /**
     * Pads a value with leading zeros to a specified length.
     *
     * @param {string | number} value - The value to pad.
     * @param {number} length - The desired length.
     * @returns {string} The padded value.
     */
    function zpad$1(value, length) {
        // Determine if the value is hexadecimal
        const isHex = typeof value === 'string' && value.startsWith('0x');
        // Handle hexadecimal values
        if (isHex) {
            let hexValue = value.substring(2); // Remove the "0x" prefix
            while (hexValue.length < length * 2) {
                // Hexadecimal characters count double
                hexValue = '0' + hexValue;
            }
            return '0x' + hexValue;
        }
        // Handle numbers or non-hexadecimal strings
        let result = String(value);
        while (result.length < length) {
            result = '0' + result;
        }
        return result;
    }

    /**
     * The JSON Wallet formats allow a simple way to store the private keys needed in Ethereum along with related
     * information and allows for extensible forms of encryption.
     *
     * These utilities facilitate decrypting and encrypting the most common JSON Wallet formats.
     */
    const defaultPath = "m/44'/994'/0'/0/0";
    /**
     * Returns true if `json` is a valid JSON Keystore Wallet.
     *
     * @category Wallet
     * @param {string} json - The JSON data to check.
     * @returns {boolean} True if the JSON data is a valid Keystore Wallet.
     */
    function isKeystoreJson(json) {
        try {
            const data = JSON.parse(json);
            const version = data.version != null ? parseInt(data.version) : 0;
            if (version === 3) {
                return true;
            }
            // eslint-disable-next-line no-empty
        }
        catch (error) { }
        return false;
    }
    /**
     * Decrypts the given ciphertext using the provided key and data.
     *
     * @param {any} data - The data containing encryption parameters.
     * @param {Uint8Array} key - The key to use for decryption.
     * @param {Uint8Array} ciphertext - The ciphertext to decrypt.
     * @returns {string} The decrypted data as a hex string.
     */
    function decrypt(data, key, ciphertext) {
        const cipher = spelunk(data, 'crypto.cipher:string');
        if (cipher === 'aes-128-ctr') {
            const iv = spelunk(data, 'crypto.cipherparams.iv:data!');
            const aesCtr = new CTR(key, iv);
            return hexlify(aesCtr.decrypt(ciphertext));
        }
        assert$1(false, 'unsupported cipher', 'UNSUPPORTED_OPERATION', {
            operation: 'decrypt',
        });
    }
    /**
     * Retrieves the account details from the given data and key.
     *
     * @param {any} data - The data containing account information.
     * @param {string} _key - The key to use for decryption.
     * @returns {KeystoreAccount} The decrypted account details.
     */
    function getAccount(data, _key) {
        const key = getBytes(_key);
        const ciphertext = spelunk(data, 'crypto.ciphertext:data!');
        const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
        assertArgument(computedMAC === spelunk(data, 'crypto.mac:string!').toLowerCase(), 'incorrect password', 'password', '[ REDACTED ]');
        const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
        const address = computeAddress(privateKey);
        if (data.address) {
            let check = data.address.toLowerCase();
            if (!check.startsWith('0x')) {
                check = '0x' + check;
            }
            assertArgument(getAddress(check) === address, 'keystore address/privateKey mismatch', 'address', data.address);
        }
        const account = { address, privateKey };
        // Version 0.1 x-quais metadata must contain an encrypted mnemonic phrase
        const version = spelunk(data, 'x-quais.version:string');
        if (version === '0.1') {
            const mnemonicKey = key.slice(32, 64);
            const mnemonicCiphertext = spelunk(data, 'x-quais.mnemonicCiphertext:data!');
            const mnemonicIv = spelunk(data, 'x-quais.mnemonicCounter:data!');
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            account.mnemonic = {
                path: spelunk(data, 'x-quais.path:string') || defaultPath,
                locale: spelunk(data, 'x-quais.locale:string') || 'en',
                entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext))),
            };
        }
        return account;
    }
    /**
     * Retrieves the key derivation function parameters from the given data.
     *
     * @param {any} data - The data containing KDF parameters.
     * @returns {KdfParams} The key derivation function parameters.
     */
    function getDecryptKdfParams(data) {
        const kdf = spelunk(data, 'crypto.kdf:string');
        if (kdf && typeof kdf === 'string') {
            if (kdf.toLowerCase() === 'scrypt') {
                const salt = spelunk(data, 'crypto.kdfparams.salt:data!');
                const N = spelunk(data, 'crypto.kdfparams.n:int!');
                const r = spelunk(data, 'crypto.kdfparams.r:int!');
                const p = spelunk(data, 'crypto.kdfparams.p:int!');
                // Make sure N is a power of 2
                assertArgument(N > 0 && (N & (N - 1)) === 0, 'invalid kdf.N', 'kdf.N', N);
                assertArgument(r > 0 && p > 0, 'invalid kdf', 'kdf', kdf);
                const dkLen = spelunk(data, 'crypto.kdfparams.dklen:int!');
                assertArgument(dkLen === 32, 'invalid kdf.dklen', 'kdf.dflen', dkLen);
                return { name: 'scrypt', salt, N, r, p, dkLen: 64 };
            }
            else if (kdf.toLowerCase() === 'pbkdf2') {
                const salt = spelunk(data, 'crypto.kdfparams.salt:data!');
                const prf = spelunk(data, 'crypto.kdfparams.prf:string!');
                const algorithm = prf.split('-').pop();
                assertArgument(algorithm === 'sha256' || algorithm === 'sha512', 'invalid kdf.pdf', 'kdf.pdf', prf);
                const count = spelunk(data, 'crypto.kdfparams.c:int!');
                const dkLen = spelunk(data, 'crypto.kdfparams.dklen:int!');
                assertArgument(dkLen === 32, 'invalid kdf.dklen', 'kdf.dklen', dkLen);
                return { name: 'pbkdf2', salt, count, dkLen, algorithm };
            }
        }
        assertArgument(false, 'unsupported key-derivation function', 'kdf', kdf);
    }
    /**
     * Returns the account details for the JSON Keystore Wallet `json` using `password`.
     *
     * It is preferred to use the {@link decryptKeystoreJson | **async version**} instead, which allows a
     * {@link ProgressCallback | **ProgressCallback} to keep the user informed as to the decryption status.
     *
     * This method will block the event loop (freezing all UI) until decryption is complete, which can take quite some time,
     * depending on the wallet paramters and platform.
     *
     * @category Wallet
     * @param {string} json - The JSON data to decrypt.
     * @param {string | Uint8Array} _password - The password to decrypt the JSON data.
     * @returns {KeystoreAccount} The decrypted account.
     */
    function decryptKeystoreJsonSync(json, _password) {
        const data = JSON.parse(json);
        const password = getPassword(_password);
        const params = getDecryptKdfParams(data);
        if (params.name === 'pbkdf2') {
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            return getAccount(data, key);
        }
        assert$1(params.name === 'scrypt', 'cannot be reached', 'UNKNOWN_ERROR', { params });
        const { salt, N, r, p, dkLen } = params;
        const key = scryptSync(password, salt, N, r, p, dkLen);
        return getAccount(data, key);
    }
    /**
     * Pauses execution for the specified duration.
     *
     * @param {number} duration - The duration to stall in milliseconds.
     * @returns {Promise<void>} A promise that resolves after the specified duration.
     */
    function stall$1(duration) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, duration);
        });
    }
    /**
     * Resolves to the decrypted JSON Keystore Wallet `json` using the `password`.
     *
     * If provided, `progress` will be called periodically during the decrpytion to provide feedback, and if the function
     * returns `false` will halt decryption.
     *
     * The `progressCallback` will **always** receive `0` before decryption begins and `1` when complete.
     *
     * @category Wallet
     * @param {string} json - The JSON data to decrypt.
     * @param {string | Uint8Array} _password - The password to decrypt the JSON data.
     * @param {ProgressCallback} [progress] - The callback to receive progress updates.
     * @returns {Promise<KeystoreAccount>} The decrypted account.
     */
    async function decryptKeystoreJson(json, _password, progress) {
        const data = JSON.parse(json);
        const password = getPassword(_password);
        const params = getDecryptKdfParams(data);
        if (params.name === 'pbkdf2') {
            if (progress) {
                progress(0);
                await stall$1(0);
            }
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            if (progress) {
                progress(1);
                await stall$1(0);
            }
            return getAccount(data, key);
        }
        assert$1(params.name === 'scrypt', 'cannot be reached', 'UNKNOWN_ERROR', { params });
        const { salt, N, r, p, dkLen } = params;
        const key = await scrypt(password, salt, N, r, p, dkLen, progress);
        return getAccount(data, key);
    }
    /**
     * Retrieves the key derivation function parameters for encryption.
     *
     * @param {EncryptOptions} options - The encryption options.
     * @returns {ScryptParams} The key derivation function parameters.
     */
    function getEncryptKdfParams(options) {
        // Check/generate the salt
        const salt = options.salt != null ? getBytes(options.salt, 'options.salt') : randomBytes(32);
        // Override the scrypt password-based key derivation function parameters
        let N = 1 << 17, r = 8, p = 1;
        if (options.scrypt) {
            if (options.scrypt.N) {
                N = options.scrypt.N;
            }
            if (options.scrypt.r) {
                r = options.scrypt.r;
            }
            if (options.scrypt.p) {
                p = options.scrypt.p;
            }
        }
        assertArgument(typeof N === 'number' && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), 'invalid scrypt N parameter', 'options.N', N);
        assertArgument(typeof r === 'number' && r > 0 && Number.isSafeInteger(r), 'invalid scrypt r parameter', 'options.r', r);
        assertArgument(typeof p === 'number' && p > 0 && Number.isSafeInteger(p), 'invalid scrypt p parameter', 'options.p', p);
        return { name: 'scrypt', dkLen: 32, salt, N, r, p };
    }
    /**
     * Encrypts the keystore with the given key, KDF parameters, account, and options.
     *
     * @ignore
     * @param {Uint8Array} key - The key to use for encryption.
     * @param {ScryptParams} kdf - The key derivation function parameters.
     * @param {KeystoreAccount} account - The account to encrypt.
     * @param {EncryptOptions} options - The encryption options.
     * @returns {any} The encrypted keystore data.
     */
    function _encryptKeystore(key, kdf, account, options) {
        const privateKey = getBytes(account.privateKey, 'privateKey');
        // Override initialization vector
        const iv = options.iv != null ? getBytes(options.iv, 'options.iv') : randomBytes(16);
        assertArgument(iv.length === 16, 'invalid options.iv length', 'options.iv', options.iv);
        // Override the uuid
        const uuidRandom = options.uuid != null ? getBytes(options.uuid, 'options.uuid') : randomBytes(16);
        assertArgument(uuidRandom.length === 16, 'invalid options.uuid length', 'options.uuid', options.iv);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
        // - 32 bytes   AES key to encrypt mnemonic with (required here to be quais Wallet)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // Encrypt the private key
        const aesCtr = new CTR(derivedKey, iv);
        const ciphertext = getBytes(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = keccak256(concat([macPrefix, ciphertext]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: uuidV4(uuidRandom),
            version: 3,
            Crypto: {
                cipher: 'aes-128-ctr',
                cipherparams: {
                    iv: hexlify(iv).substring(2),
                },
                ciphertext: hexlify(ciphertext).substring(2),
                kdf: 'scrypt',
                kdfparams: {
                    salt: hexlify(kdf.salt).substring(2),
                    n: kdf.N,
                    dklen: 32,
                    p: kdf.p,
                    r: kdf.r,
                },
                mac: mac.substring(2),
            },
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (account.mnemonic) {
            const client = options.client != null ? options.client : `quais/${version}`;
            const path = account.mnemonic.path || defaultPath;
            const locale = account.mnemonic.locale || 'en';
            const mnemonicKey = key.slice(32, 64);
            const entropy = getBytes(account.mnemonic.entropy, 'account.mnemonic.entropy');
            const mnemonicIv = randomBytes(16);
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = now.getUTCFullYear() +
                '-' +
                zpad$1(now.getUTCMonth() + 1, 2) +
                '-' +
                zpad$1(now.getUTCDate(), 2) +
                'T' +
                zpad$1(now.getUTCHours(), 2) +
                '-' +
                zpad$1(now.getUTCMinutes(), 2) +
                '-' +
                zpad$1(now.getUTCSeconds(), 2) +
                '.0Z';
            const gethFilename = 'UTC--' + timestamp + '--' + data.address;
            data['x-quais'] = {
                client,
                gethFilename,
                path,
                locale,
                mnemonicCounter: hexlify(mnemonicIv).substring(2),
                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
                version: '0.1',
            };
        }
        return JSON.stringify(data);
    }
    /**
     * Return the JSON Keystore Wallet for `account` encrypted with `password`.
     *
     * The `options` can be used to tune the password-based key derivation function parameters, explicitly set the random
     * values used. Any provided {@link ProgressCallback | **ProgressCallback**} is ignored.
     *
     * @category Wallet
     * @param {KeystoreAccount} account - The account to encrypt.
     * @param {string | Uint8Array} password - The password to encrypt the JSON data.
     * @param {EncryptOptions} [options] - The options to use when encrypting the JSON data.
     * @returns {string} The encrypted JSON data.
     */
    function encryptKeystoreJsonSync(account, password, options) {
        if (options == null) {
            options = {};
        }
        const passwordBytes = getPassword(password);
        const kdf = getEncryptKdfParams(options);
        const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
        return _encryptKeystore(getBytes(key), kdf, account, options);
    }
    /**
     * Resolved to the JSON Keystore Wallet for `account` encrypted with `password`.
     *
     * The `options` can be used to tune the password-based key derivation function parameters, explicitly set the random
     * values used and provide a {@link ProgressCallback | **ProgressCallback**} to receive periodic updates on the
     * completion status..
     *
     * @category Wallet
     * @param {KeystoreAccount} account - The account to encrypt.
     * @param {string | Uint8Array} password - The password to encrypt the JSON data.
     * @param {EncryptOptions} [options] - The options to use when encrypting the JSON data.
     * @returns {Promise<string>} The encrypted JSON data.
     */
    async function encryptKeystoreJson(account, password, options) {
        if (options == null) {
            options = {};
        }
        const passwordBytes = getPassword(password);
        const kdf = getEncryptKdfParams(options);
        const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
        return _encryptKeystore(getBytes(key), kdf, account, options);
    }

    // "Bitcoin seed"
    const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
    const HardenedBit = 0x80000000;
    const N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    const Nibbles = '0123456789abcdef';
    function zpad(value, length) {
        let result = '';
        while (value) {
            result = Nibbles[value % 16] + result;
            value = Math.trunc(value / 16);
        }
        while (result.length < length * 2) {
            result = '0' + result;
        }
        return '0x' + result;
    }
    function encodeBase58Check(_value) {
        const value = getBytes(_value);
        const check = dataSlice(sha256(sha256(value)), 0, 4);
        const bytes = concat([value, check]);
        return encodeBase58(bytes);
    }
    const _guard$1 = {};
    function ser_I(index, chainCode, publicKey, privateKey) {
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
            assert$1(privateKey != null, 'cannot derive child of neutered node', 'UNSUPPORTED_OPERATION', {
                operation: 'deriveChild',
            });
            // Data = 0x00 || ser_256(k_par)
            data.set(getBytes(privateKey), 1);
        }
        else {
            // Data = ser_p(point(k_par))
            data.set(getBytes(publicKey));
        }
        // Data += ser_32(i)
        for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = (index >> (24 - i)) & 0xff;
        }
        const I = getBytes(computeHmac('sha512', chainCode, data));
        return { IL: I.slice(0, 32), IR: I.slice(32) };
    }
    function derivePath(node, path) {
        const components = path.split('/');
        assertArgument(components.length > 0, 'invalid path', 'path', path);
        if (components[0] === 'm') {
            assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, 'path', path);
            components.shift();
        }
        let result = node;
        for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
                const index = parseInt(component.substring(0, component.length - 1));
                assertArgument(index < HardenedBit, 'invalid path index', `path[${i}]`, component);
                result = result.deriveChild(HardenedBit + index);
            }
            else if (component.match(/^[0-9]+$/)) {
                const index = parseInt(component);
                assertArgument(index < HardenedBit, 'invalid path index', `path[${i}]`, component);
                result = result.deriveChild(index);
            }
            else {
                assertArgument(false, 'invalid path component', `path[${i}]`, component);
            }
        }
        return result;
    }
    /**
     * An **HDNodeWallet** is a [[Signer]] backed by the private key derived from an HD Node using the [[link-bip-32]]
     * standard.
     *
     * An HD Node forms a hierarchical structure with each HD Node having a private key and the ability to derive child HD
     * Nodes, defined by a path indicating the index of each child.
     */
    class HDNodeWallet extends BaseWallet {
        /**
         * The compressed public key.
         *
         * @type {string}
         */
        publicKey;
        /**
         * The fingerprint.
         *
         * A fingerprint allows a quick way to detect parent and child nodes, but developers should be prepared to deal with
         * collisions as it is only 4 bytes.
         *
         * @type {string}
         */
        fingerprint;
        /**
         * The parent fingerprint.
         *
         * @type {string}
         */
        parentFingerprint;
        /**
         * The mnemonic used to create this HD Node, if available.
         *
         * Sources such as extended keys do not encode the mnemonic, in which case this will be `null`.
         *
         * @type {null | Mnemonic}
         */
        mnemonic;
        /**
         * The chaincode, which is effectively a public key used to derive children.
         *
         * @type {string}
         */
        chainCode;
        /**
         * The derivation path of this wallet.
         *
         * Since extended keys do not provide full path details, this may be `null`, if instantiated from a source that does
         * not encode it.
         *
         * @type {null | string}
         */
        path;
        /**
         * The child index of this wallet. Values over `2 ** 31` indicate the node is hardened.
         *
         * @type {number}
         */
        index;
        /**
         * The depth of this wallet, which is the number of components in its path.
         *
         * @type {number}
         */
        depth;
        /**
         * @ignore
         * @param {any} guard
         * @param {SigningKey} signingKey
         * @param {string} parentFingerprint
         * @param {string} chainCode
         * @param {null | string} path
         * @param {number} index
         * @param {number} depth
         * @param {null | Mnemonic} mnemonic
         * @param {null | Provider} provider
         */
        constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
            super(signingKey, provider);
            assertPrivate(guard, _guard$1, 'HDNodeWallet');
            defineProperties(this, { publicKey: signingKey.compressedPublicKey });
            const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);
            defineProperties(this, {
                parentFingerprint,
                fingerprint,
                chainCode,
                path,
                index,
                depth,
            });
            defineProperties(this, { mnemonic });
        }
        /**
         * Connects the wallet to a provider.
         *
         * @param {null | Provider} provider
         * @returns {HDNodeWallet}
         */
        connect(provider) {
            return new HDNodeWallet(_guard$1, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
        }
        /**
         * @ignore
         * @returns {KeystoreAccount}
         */
        #account() {
            const account = { address: this.address, privateKey: this.privateKey };
            const m = this.mnemonic;
            if (this.path && m && m.wordlist.locale === 'en' && m.password === '') {
                account.mnemonic = {
                    path: this.path,
                    locale: 'en',
                    entropy: m.entropy,
                };
            }
            return account;
        }
        /**
         * Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with `password`.
         *
         * If `progressCallback` is specified, it will receive periodic updates as the encryption process progresses.
         *
         * @param {Uint8Array | string} password
         * @param {ProgressCallback} [progressCallback]
         * @returns {Promise<string>}
         */
        async encrypt(password, progressCallback) {
            return await encryptKeystoreJson(this.#account(), password, { progressCallback });
        }
        /**
         * Returns a [JSON Keystore Wallet](json-wallets) encrypted with `password`.
         *
         * It is preferred to use the [async version](encrypt) instead, which allows a `ProgressCallback` to keep the user
         * informed.
         *
         * This method will block the event loop (freezing all UI) until it is complete, which may be a non-trivial
         * duration.
         *
         * @param {Uint8Array | string} password
         * @returns {string}
         */
        encryptSync(password) {
            return encryptKeystoreJsonSync(this.#account(), password);
        }
        /**
         * The extended key.
         *
         * This key will begin with the prefix `xpriv` and can be used to reconstruct this HD Node to derive its children.
         *
         * @returns {string}
         */
        get extendedKey() {
            // We only support the mainnet values for now, but if anyone needs
            // testnet values, let me know. I believe current sentiment is that
            // we should always use mainnet, and use BIP-44 to derive the network
            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
            //   - Testnet: public=0x043587CF, private=0x04358394
            assert$1(this.depth < 256, 'Depth too deep', 'UNSUPPORTED_OPERATION', {
                operation: 'extendedKey',
            });
            return encodeBase58Check(concat([
                '0x0488ADE4',
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                concat(['0x00', this.privateKey]),
            ]));
        }
        /**
         * Returns true if this wallet has a path, providing a Type Guard that the path is non-null.
         *
         * @returns {boolean}
         */
        hasPath() {
            return this.path != null;
        }
        /**
         * Returns a neutered HD Node, which removes the private details of an HD Node.
         *
         * A neutered node has no private key, but can be used to derive child addresses and other public data about the HD
         * Node.
         *
         * @returns {HDNodeVoidWallet}
         */
        neuter() {
            return new HDNodeVoidWallet(_guard$1, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
        }
        /**
         * Return the child for `index`.
         *
         * @param {Numeric} _index
         * @returns {HDNodeWallet}
         */
        deriveChild(_index) {
            const index = getNumber(_index, 'index');
            assertArgument(index <= 0xffffffff, 'invalid index', 'index', index);
            // Base path
            let path = this.path;
            if (path) {
                path += '/' + (index & ~HardenedBit);
                if (index & HardenedBit) {
                    path += "'";
                }
            }
            const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
            const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
            return new HDNodeWallet(_guard$1, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
        }
        /**
         * Return the HDNode for `path` from this node.
         *
         * @param {string} path
         * @returns {HDNodeWallet}
         */
        derivePath(path) {
            return derivePath(this, path);
        }
        /**
         * @ignore
         * @param {BytesLike} _seed
         * @param {null | Mnemonic} mnemonic
         * @returns {HDNodeWallet}
         */
        static #fromSeed(_seed, mnemonic) {
            assertArgument(isBytesLike(_seed), 'invalid seed', 'seed', '[REDACTED]');
            const seed = getBytes(_seed, 'seed');
            assertArgument(seed.length >= 16 && seed.length <= 64, 'invalid seed', 'seed', '[REDACTED]');
            const I = getBytes(computeHmac('sha512', MasterSecret, seed));
            const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
            return new HDNodeWallet(_guard$1, signingKey, '0x00000000', hexlify(I.slice(32)), 'm', 0, 0, mnemonic, null);
        }
        /**
         * Creates a new HD Node from `extendedKey`.
         *
         * If the `extendedKey` will either have a prefix or `xpub` or `xpriv`, returning a neutered HD Node
         * ([[HDNodeVoidWallet]]) or full HD Node ([[HDNodeWallet]]) respectively.
         *
         * @param {string} extendedKey
         * @returns {HDNodeWallet | HDNodeVoidWallet}
         */
        static fromExtendedKey(extendedKey) {
            const bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact
            assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, 'invalid extended key', 'extendedKey', '[ REDACTED ]');
            const depth = bytes[4];
            const parentFingerprint = hexlify(bytes.slice(5, 9));
            const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
            const chainCode = hexlify(bytes.slice(13, 45));
            const key = bytes.slice(45, 78);
            switch (hexlify(bytes.slice(0, 4))) {
                // Public Key
                case '0x0488b21e':
                case '0x043587cf': {
                    const publicKey = hexlify(key);
                    return new HDNodeVoidWallet(_guard$1, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
                }
                // Private Key
                case '0x0488ade4':
                case '0x04358394 ':
                    if (key[0] !== 0) {
                        break;
                    }
                    return new HDNodeWallet(_guard$1, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
            }
            assertArgument(false, 'invalid extended key prefix', 'extendedKey', '[ REDACTED ]');
        }
        /**
         * Creates a new random HDNode.
         *
         * @param {string} path
         * @param {string} [password]
         * @param {Wordlist} [wordlist]
         * @returns {HDNodeWallet}
         */
        static createRandom(path, password, wordlist) {
            if (password == null) {
                password = '';
            }
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);
            return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         * Create an HD Node from `mnemonic`.
         *
         * @param {Mnemonic} mnemonic
         * @param {string} path
         * @returns {HDNodeWallet}
         */
        static fromMnemonic(mnemonic, path) {
            return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         * Creates an HD Node from a mnemonic `phrase`.
         *
         * @param {string} phrase
         * @param {string} path
         * @param {string} [password]
         * @param {Wordlist} [wordlist]
         * @returns {HDNodeWallet}
         */
        static fromPhrase(phrase, path, password, wordlist) {
            if (password == null) {
                password = '';
            }
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
            return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         * Creates an HD Node from a `seed`.
         *
         * @param {BytesLike} seed
         * @returns {HDNodeWallet}
         */
        static fromSeed(seed) {
            return HDNodeWallet.#fromSeed(seed, null);
        }
    }
    /**
     * A **HDNodeVoidWallet** cannot sign, but provides access to the children nodes of a [[link-bip-32]] HD wallet
     * addresses.
     *
     * They can be created by using an extended `xpub` key to [[HDNodeWallet_fromExtendedKey]] or by
     * [neutering](HDNodeWallet-neuter) a [[HDNodeWallet]].
     */
    class HDNodeVoidWallet extends VoidSigner {
        /**
         * The compressed public key.
         *
         * @type {string}
         */
        publicKey;
        /**
         * The fingerprint.
         *
         * A fingerprint allows a quick way to detect parent and child nodes, but developers should be prepared to deal with
         * collisions as it is only 4 bytes.
         *
         * @type {string}
         */
        fingerprint;
        /**
         * The parent node fingerprint.
         *
         * @type {string}
         */
        parentFingerprint;
        /**
         * The chaincode, which is effectively a public key used to derive children.
         *
         * @type {string}
         */
        chainCode;
        /**
         * The derivation path of this wallet.
         *
         * Since extended keys do not provide full path details, this may be `null`, if instantiated from a source that does
         * not encode it.
         *
         * @type {null | string}
         */
        path;
        /**
         * The child index of this wallet. Values over `2 ** 31` indicate the node is hardened.
         *
         * @type {number}
         */
        index;
        /**
         * The depth of this wallet, which is the number of components in its path.
         *
         * @type {number}
         */
        depth;
        /**
         * @ignore
         * @param {any} guard
         * @param {string} address
         * @param {string} publicKey
         * @param {string} parentFingerprint
         * @param {string} chainCode
         * @param {null | string} path
         * @param {number} index
         * @param {number} depth
         * @param {null | Provider} provider
         */
        constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
            super(address, provider);
            assertPrivate(guard, _guard$1, 'HDNodeVoidWallet');
            defineProperties(this, { publicKey });
            const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
            defineProperties(this, {
                publicKey,
                fingerprint,
                parentFingerprint,
                chainCode,
                path,
                index,
                depth,
            });
        }
        /**
         * Connects the wallet to a provider.
         *
         * @param {null | Provider} provider
         * @returns {HDNodeVoidWallet}
         */
        connect(provider) {
            return new HDNodeVoidWallet(_guard$1, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
        }
        /**
         * The extended key.
         *
         * This key will begin with the prefix `xpub` and can be used to reconstruct this neutered key to derive its
         * children addresses.
         *
         * @returns {string}
         */
        get extendedKey() {
            // We only support the mainnet values for now, but if anyone needs
            // testnet values, let me know. I believe current sentiment is that
            // we should always use mainnet, and use BIP-44 to derive the network
            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
            //   - Testnet: public=0x043587CF, private=0x04358394
            assert$1(this.depth < 256, 'Depth too deep', 'UNSUPPORTED_OPERATION', { operation: 'extendedKey' });
            return encodeBase58Check(concat([
                '0x0488B21E',
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                this.publicKey,
            ]));
        }
        /**
         * Returns true if this wallet has a path, providing a Type Guard that the path is non-null.
         *
         * @returns {boolean}
         */
        hasPath() {
            return this.path != null;
        }
        /**
         * Return the child for `index`.
         *
         * @param {Numeric} _index
         * @returns {HDNodeVoidWallet}
         */
        deriveChild(_index) {
            const index = getNumber(_index, 'index');
            assertArgument(index <= 0xffffffff, 'invalid index', 'index', index);
            // Base path
            let path = this.path;
            if (path) {
                path += '/' + (index & ~HardenedBit);
                if (index & HardenedBit) {
                    path += "'";
                }
            }
            const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
            const Ki = SigningKey.addPoints(IL, this.publicKey, true);
            const address = computeAddress(Ki);
            return new HDNodeVoidWallet(_guard$1, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
        }
        /**
         * Return the signer for `path` from this node.
         *
         * @param {string} path
         * @returns {HDNodeVoidWallet}
         */
        derivePath(path) {
            return derivePath(this, path);
        }
    }

    const HARDENED_OFFSET = 2 ** 31;
    /**
     * Constant to represent the maximum attempt to derive an address.
     */
    const MAX_ADDRESS_DERIVATION_ATTEMPTS = 10000000;
    const _guard = {};
    /**
     * Abstract class representing a Hierarchical Deterministic (HD) wallet.
     */
    class AbstractHDWallet {
        static _version = 1;
        static _coinType;
        // Map of addresses to address info
        _addresses = new Map();
        /**
         * Root node of the HD wallet.
         */
        _root;
        provider;
        /**
         * @param {HDNodeWallet} root - The root node of the HD wallet.
         * @param {Provider} [provider] - The provider for the HD wallet.
         */
        constructor(guard, root, provider) {
            assertPrivate(guard, _guard, 'AbstractHDWallet');
            this._root = root;
            this.provider = provider;
        }
        /**
         * Returns the parent path for a given coin type.
         *
         * @param {number} coinType - The coin type.
         * @returns {string} The parent path.
         */
        static parentPath(coinType) {
            return `m/44'/${coinType}'`;
        }
        /**
         * Returns the coin type of the wallet.
         *
         * @returns {AllowedCoinType} The coin type.
         */
        coinType() {
            return this.constructor._coinType;
        }
        /**
         * Returns the extended public key of the root node of the HD wallet.
         *
         * @returns {string} The extended public key.
         */
        get xPub() {
            return this._root.extendedKey;
        }
        // helper method to check if an address is valid for a given zone
        isValidAddressForZone(address, zone) {
            const addressZone = getZoneForAddress(address);
            if (!addressZone) {
                return false;
            }
            const isCorrectShard = addressZone === zone;
            const isCorrectLedger = this.coinType() === 969 ? isQiAddress(address) : !isQiAddress(address);
            return isCorrectShard && isCorrectLedger;
        }
        /**
         * Gets the BIP44 change node for a given account and change flag.
         *
         * @param {number} account - The account number.
         * @param {boolean} change - Whether to get the change node.
         * @returns {HDNodeWallet} The change node.
         */
        _getChangeNode(account, change) {
            const changeIndex = change ? 1 : 0;
            return this._root.deriveChild(account + HARDENED_OFFSET).deriveChild(changeIndex);
        }
        /**
         * Gets the BIP44 address node for a given account, change flag, and address index.
         *
         * @param {number} account - The account number.
         * @param {boolean} change - Whether to get the change node.
         * @param {number} addressIndex - The address index.
         * @returns {HDNodeWallet} The address node.
         */
        _getAddressNode(account, change, addressIndex) {
            return this._getChangeNode(account, change).deriveChild(addressIndex);
        }
        /**
         * Derives the next valid address node for a specified account, starting index, and zone. The method ensures the
         * derived address belongs to the correct shard and ledger, as defined by the Quai blockchain specifications.
         *
         * @param {number} account - The account number from which to derive the address node.
         * @param {number} startingIndex - The index from which to start deriving addresses.
         * @param {Zone} zone - The zone (shard) for which the address should be valid.
         * @param {boolean} [isChange=false] - Whether to derive a change address. Default is `false`
         * @returns {HDNodeWallet} - The derived HD node wallet containing a valid address for the specified zone.
         * @throws {Error} If a valid address for the specified zone cannot be derived within the allowed attempts.
         */
        deriveNextAddressNode(account, startingIndex, zone, isChange = false) {
            const changeNode = this._getChangeNode(account, isChange);
            let addrIndex = startingIndex;
            let addressNode;
            for (let attempts = 0; attempts < MAX_ADDRESS_DERIVATION_ATTEMPTS; attempts++) {
                addressNode = changeNode.deriveChild(addrIndex++);
                if (this.isValidAddressForZone(addressNode.address, zone)) {
                    return addressNode;
                }
            }
            throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`);
        }
        /**
         * Creates an instance of the HD wallet.
         *
         * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
         * @param {Mnemonic} mnemonic - The mnemonic.
         * @returns {T} The created instance.
         */
        static createInstance(mnemonic) {
            const coinType = this._coinType;
            const root = HDNodeWallet.fromMnemonic(mnemonic, this.parentPath(coinType));
            return new this(_guard, root);
        }
        /**
         * Creates an HD wallet from a mnemonic.
         *
         * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
         * @param {Mnemonic} mnemonic - The mnemonic.
         * @returns {T} The created instance.
         */
        static fromMnemonic(mnemonic) {
            return this.createInstance(mnemonic);
        }
        /**
         * Creates a random HD wallet.
         *
         * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
         * @param {string} [password] - The password.
         * @param {Wordlist} [wordlist] - The wordlist.
         * @returns {T} The created instance.
         */
        static createRandom(password, wordlist) {
            if (password == null) {
                password = '';
            }
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);
            return this.createInstance(mnemonic);
        }
        /**
         * Creates an HD wallet from a phrase.
         *
         * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
         * @param {string} phrase - The phrase.
         * @param {string} [password] - The password.
         * @param {Wordlist} [wordlist] - The wordlist.
         * @returns {T} The created instance.
         */
        static fromPhrase(phrase, password, wordlist) {
            if (password == null) {
                password = '';
            }
            if (wordlist == null) {
                wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
            return this.createInstance(mnemonic);
        }
        /**
         * Connects the wallet to a provider.
         *
         * @param {Provider} provider - The provider.
         */
        connect(provider) {
            this.provider = provider;
        }
        /**
         * Validates the zone.
         *
         * @param {Zone} zone - The zone.
         * @throws {Error} If the zone is invalid.
         */
        validateZone(zone) {
            if (!Object.values(exports.Zone).includes(zone)) {
                throw new Error(`Invalid zone: ${zone}`);
            }
        }
        /**
         * Serializes the HD wallet state into a format suitable for storage or transmission.
         *
         * @returns {SerializedHDWallet} An object representing the serialized state of the HD wallet, including version,
         *   mnemonic phrase, coin type, and addresses.
         */
        serialize() {
            return {
                version: this.constructor._version,
                phrase: this._root.mnemonic.phrase,
                coinType: this.coinType(),
            };
        }
        /**
         * Deserializes a serialized HD wallet object and reconstructs the wallet instance. This method must be implemented
         * in the subclass.
         *
         * @param {SerializedHDWallet} _serialized - The serialized object representing the state of an HD wallet.
         * @returns {AbstractHDWallet} An instance of AbstractHDWallet.
         * @throws {Error} This method must be implemented in the subclass.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        static async deserialize(_serialized) {
            throw new Error('deserialize method must be implemented in the subclass');
        }
        /**
         * Validates an address info object, including basic properties and address derivation.
         *
         * @param {T} info - The address info to validate
         * @throws {Error} If validation fails
         * @protected
         */
        validateAddressInfo(info) {
            // Basic property validation
            this.validateBaseAddressInfo(info);
            // Validate address derivation
            this.validateAddressDerivation(info);
            // Allow subclasses to add their own validation
            this.validateExtendedProperties(info);
        }
        /**
         * Validates the NeuteredAddressInfo object.
         *
         * @param {NeuteredAddressInfo} info - The NeuteredAddressInfo object to be validated.
         * @throws {Error} If the NeuteredAddressInfo object is invalid.
         * @protected
         */
        validateBaseAddressInfo(info) {
            if (!/^(0x)?[0-9a-fA-F]{40}$/.test(info.address)) {
                throw new Error(`Invalid NeuteredAddressInfo: address must be a 40-character hexadecimal string prefixed with 0x: ${info.address}`);
            }
            if (!/^0x[0-9a-fA-F]{66}$/.test(info.pubKey)) {
                throw new Error(`Invalid NeuteredAddressInfo: pubKey must be a 66-character hexadecimal string prefixed with 0x: ${info.pubKey}`);
            }
            if (!Number.isInteger(info.account) || info.account < 0) {
                throw new Error(`Invalid NeuteredAddressInfo: account must be a non-negative integer: ${info.account}`);
            }
            if (!Number.isInteger(info.index) || info.index < 0) {
                throw new Error(`Invalid NeuteredAddressInfo: index must be a non-negative integer: ${info.index}`);
            }
            if (!Object.values(exports.Zone).includes(info.zone)) {
                throw new Error(`Invalid NeuteredAddressInfo: zone '${info.zone}' is not a valid Zone`);
            }
        }
        /**
         * Hook for subclasses to add their own validation logic. Base implementation does nothing.
         *
         * @param {T} _info - The address info to validate
         * @protected
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        validateExtendedProperties(_info) {
            // Base implementation does nothing
        }
        /**
         * Validates the version and coinType of the serialized wallet.
         *
         * @param {SerializedHDWallet} serialized - The serialized wallet data to be validated.
         * @throws {Error} If the version or coinType of the serialized wallet does not match the expected values.
         * @protected
         * @static
         */
        static validateSerializedWallet(serialized) {
            if (serialized.version !== this._version) {
                throw new Error(`Invalid version ${serialized.version} for wallet (expected ${this._version})`);
            }
            if (serialized.coinType !== this._coinType) {
                throw new Error(`Invalid coinType ${serialized.coinType} for wallet (expected ${this._coinType})`);
            }
        }
    }

    /**
     * The Quai HD wallet is a BIP44-compliant hierarchical deterministic wallet used for managing a set of addresses in the
     * Quai ledger. This is the easiest way to manage the interaction of managing accounts and addresses on the Quai
     * network, however, if your use case requires a single address Quai address, you can use the {@link Wallet} class.
     *
     * The Quai HD wallet supports:
     *
     * - Adding accounts to the wallet heierchy
     * - Generating addresses for a specific account in any {@link Zone}
     * - Signing and sending transactions for any address in the wallet
     * - Signing and verifying EIP1193 typed data for any address in the wallet.
     * - Serializing the wallet to JSON and deserializing it back to a wallet instance.
     *
     * @category Wallet
     * @example
     *
     * ```ts
     * import { QuaiHDWallet, Zone } from 'quais';
     *
     * const wallet = new QuaiHDWallet();
     * const cyrpus1Address = await wallet.getNextAddress(0, Zone.Cyrpus1); // get the first address in the Cyrpus1 zone
     * await wallet.sendTransaction({ from: address, to: '0x...', value: 100 }); // send a transaction
     * const serializedWallet = wallet.serialize(); // serialize current (account/address) state of the wallet
     * .
     * .
     * .
     * const deserializedWallet = QuaiHDWallet.deserialize(serializedWallet); // create a new wallet instance from the serialized data
     * ```
     */
    class QuaiHDWallet extends AbstractHDWallet {
        /**
         * The version of the wallet.
         *
         * @type {number}
         * @static
         */
        static _version = 1;
        /**
         * The coin type for the wallet.
         *
         * @type {AllowedCoinType}
         * @static
         */
        static _coinType = 994;
        /**
         * Create a QuaiHDWallet instance.
         *
         * @param {HDNodeWallet} root - The root HD node wallet.
         * @param {Provider} [provider] - The provider.
         */
        constructor(guard, root, provider) {
            super(guard, root, provider);
        }
        /**
         * Sign a transaction.
         *
         * @param {QuaiTransactionRequest} tx - The transaction request.
         * @returns {Promise<string>} A promise that resolves to the signed transaction.
         */
        async signTransaction(tx) {
            const from = await resolveAddress(tx.from);
            const fromNode = this._getHDNodeForAddress(from);
            const signedTx = await fromNode.signTransaction(tx);
            return signedTx;
        }
        /**
         * Send a transaction.
         *
         * @param {QuaiTransactionRequest} tx - The transaction request.
         * @returns {Promise<TransactionResponse>} A promise that resolves to the transaction response.
         * @throws {Error} If the provider is not set.
         */
        async sendTransaction(tx) {
            if (!this.provider) {
                throw new Error('Provider is not set');
            }
            const from = await resolveAddress(tx.from);
            const fromNode = this._getHDNodeForAddress(from);
            const fromNodeConnected = fromNode.connect(this.provider);
            return await fromNodeConnected.sendTransaction(tx);
        }
        /**
         * Sign a message.
         *
         * @param {string} address - The address.
         * @param {string | Uint8Array} message - The message to sign.
         * @returns {Promise<string>} A promise that resolves to the signed message.
         */
        async signMessage(address, message) {
            const addrNode = this._getHDNodeForAddress(address);
            return await addrNode.signMessage(message);
        }
        /**
         * Serializes the QuaiHDWallet state into a format suitable for storage or transmission.
         *
         * This method extends the serialization from the parent class (AbstractHDWallet) and includes additional
         * QuaiHDWallet-specific data, such as the addresses.
         *
         * @example Const wallet = new QuaiHDWallet(); const serializedData = wallet.serialize(); // serializedData can now
         * be stored or transmitted
         *
         * @returns {SerializedQuaiHDWallet} An object representing the serialized state of the QuaiHDWallet, including
         *   addresses and other inherited properties from the parent wallet.
         */
        serialize() {
            const hdwalletSerialized = super.serialize();
            return {
                ...hdwalletSerialized,
                addresses: Array.from(this._addresses.values()),
            };
        }
        validateAddressDerivation(info) {
            const addressNode = this._getAddressNode(info.account, false, info.index);
            // Validate derived address matches
            if (addressNode.address !== info.address) {
                throw new Error(`Address mismatch: derived ${addressNode.address} but got ${info.address}`);
            }
            // Validate derived public key matches
            if (addressNode.publicKey !== info.pubKey) {
                throw new Error(`Public key mismatch: derived ${addressNode.publicKey} but got ${info.pubKey}`);
            }
            // Validate zone
            const zone = getZoneForAddress(addressNode.address);
            if (!zone || zone !== info.zone) {
                throw new Error(`Zone mismatch: derived ${zone} but got ${info.zone}`);
            }
            // Validate it's a valid Quai address
            if (!isQuaiAddress(addressNode.address)) {
                throw new Error(`Address ${addressNode.address} is not a valid Quai address`);
            }
        }
        /**
         * Deserializes the given serialized HD wallet data into an instance of QuaiHDWallet.
         *
         * @async
         * @param {SerializedHDWallet} serialized - The serialized wallet data to be deserialized.
         * @returns {Promise<QuaiHDWallet>} A promise that resolves to an instance of QuaiHDWallet.
         * @throws {Error} If validation of the serialized wallet data fails or if deserialization fails.
         * @public
         * @static
         */
        static async deserialize(serialized) {
            super.validateSerializedWallet(serialized);
            // create the wallet instance
            const mnemonic = Mnemonic.fromPhrase(serialized.phrase);
            const path = this.parentPath(serialized.coinType);
            const root = HDNodeWallet.fromMnemonic(mnemonic, path);
            const wallet = new this(_guard, root);
            // import the addresses
            for (const addressInfo of serialized.addresses) {
                wallet.validateAddressInfo(addressInfo);
                // if the address is already in the map, we don't need to add it again
                if (!wallet._addresses.has(addressInfo.address)) {
                    wallet._addresses.set(addressInfo.address, addressInfo);
                }
            }
            return wallet;
        }
        /**
         * Signs typed data using the private key associated with the given address.
         *
         * @param {string} address - The address for which the typed data is to be signed.
         * @param {TypedDataDomain} domain - The domain information of the typed data, defining the scope of the signature.
         * @param {Record<string, TypedDataField[]>} types - The types of the data to be signed, mapping each data type name
         *   to its fields.
         * @param {Record<string, unknown>} value - The actual data to be signed.
         * @returns {Promise<string>} A promise that resolves to the signed data in string format.
         * @throws {Error} If the address does not correspond to a valid HD node or if signing fails.
         */
        async signTypedData(address, domain, types, value) {
            const addrNode = this._getHDNodeForAddress(address);
            return addrNode.signTypedData(domain, types, value);
        }
        /**
         * Adds an address to the wallet.
         *
         * @param {number} account - The account number.
         * @param {number} addressIndex - The address index.
         * @returns {NeuteredAddressInfo} The added address info.
         */
        addAddress(account, addressIndex) {
            if (account < 0 || addressIndex < 0) {
                throw new Error('Account and address index must be non-negative integers');
            }
            return this._addAddress(account, addressIndex);
        }
        /**
         * Helper method to add an address to the wallet address map.
         *
         * @param {Map<string, NeuteredAddressInfo>} addressMap - The address map.
         * @param {number} account - The account number.
         * @param {number} addressIndex - The address index.
         * @returns {NeuteredAddressInfo} The added address info.
         * @throws {Error} If the address for the index already exists.
         */
        _addAddress(account, addressIndex) {
            // check if address already exists for the index
            this._addresses.forEach((addressInfo) => {
                if (addressInfo.index === addressIndex) {
                    throw new Error(`Address for index ${addressIndex} already exists`);
                }
            });
            // derive the address node and validate the zone
            const addressNode = this._getAddressNode(account, false, addressIndex);
            const zone = getZoneForAddress(addressNode.address);
            if (!zone) {
                throw new Error(`Failed to derive a valid address zone for the index ${addressIndex}`);
            }
            if (!isQuaiAddress(addressNode.address)) {
                throw new Error(`Address ${addressNode.address} is not a valid Quai address`);
            }
            return this._createAndStoreNeuteredAddressInfo(addressNode, account, zone);
        }
        /**
         * Promise that resolves to the next address for the specified account and zone.
         *
         * @param {number} account - The index of the account for which to retrieve the next address.
         * @param {Zone} zone - The zone in which to retrieve the next address.
         * @returns {Promise<T>} The next neutered address information.
         */
        async getNextAddress(account, zone) {
            return Promise.resolve(this._getNextAddress(account, zone));
        }
        /**
         * Synchronously retrieves the next address for the specified account and zone.
         *
         * @param {number} account - The index of the account for which to retrieve the next address.
         * @param {Zone} zone - The zone in which to retrieve the next address.
         * @returns {T} The next neutered address information.
         */
        getNextAddressSync(account, zone) {
            return this._getNextAddress(account, zone);
        }
        /**
         * Derives and returns the next address information for the specified account and zone.
         *
         * @param {number} accountIndex - The index of the account for which the address is being generated.
         * @param {Zone} zone - The zone in which the address is to be used.
         * @param {Map<string, NeuteredAddressInfo>} addressMap - A map storing the neutered address information.
         * @returns {T} The derived neutered address information.
         * @throws {Error} If the zone is invalid.
         */
        _getNextAddress(accountIndex, zone) {
            this.validateZone(zone);
            const lastIndex = this._findLastUsedIndex(Array.from(this._addresses.values()), accountIndex, zone);
            const addressNode = this.deriveNextAddressNode(accountIndex, lastIndex + 1, zone, false);
            return this._createAndStoreNeuteredAddressInfo(addressNode, accountIndex, zone);
        }
        /**
         * Creates and stores address information in the address map for a specified account, zone, and change type.
         *
         * This method constructs a NeuteredAddressInfo object using the provided HDNodeWallet and other parameters, then
         * stores this information in the provided address map.
         *
         * @param {HDNodeWallet} addressNode - The HDNodeWallet object containing the address and public key information.
         * @param {number} account - The account number to associate with the address.
         * @param {Zone} zone - The specific zone to associate with the address.
         * @param {Map<string, NeuteredAddressInfo>} addressMap - The map to store the created NeuteredAddressInfo, with the
         *   address as the key.
         * @returns {NeuteredAddressInfo} - The created NeuteredAddressInfo object.
         * @protected
         */
        _createAndStoreNeuteredAddressInfo(addressNode, account, zone) {
            const neuteredAddressInfo = {
                pubKey: addressNode.publicKey,
                address: addressNode.address,
                account,
                index: addressNode.index,
                zone,
            };
            this._addresses.set(neuteredAddressInfo.address, neuteredAddressInfo);
            return neuteredAddressInfo;
        }
        /**
         * Gets the address info for a given address.
         *
         * @param {string} address - The address.
         * @returns {T | null} The address info or null if not found.
         */
        getAddressInfo(address) {
            const addressInfo = this._addresses.get(address);
            if (!addressInfo) {
                return null;
            }
            return addressInfo;
        }
        /**
         * Returns the private key for a given address. This method should be used with caution as it exposes the private
         * key to the user.
         *
         * @param {string} address - The address associated with the desired private key.
         * @returns {string} The private key.
         */
        getPrivateKey(address) {
            const hdNode = this._getHDNodeForAddress(address);
            return hdNode.privateKey;
        }
        /**
         * Derives and returns the Hierarchical Deterministic (HD) node wallet associated with a given address.
         *
         * This method fetches the account and address information from the wallet's internal storage, derives the
         * appropriate change node based on whether the address is a change address, and further derives the final HD node
         * using the address index.
         *
         * @param {string} addr - The address for which to derive the HD node.
         * @returns {HDNodeWallet} The derived HD node wallet corresponding to the given address.
         * @throws {Error} If the given address is not known to the wallet.
         * @throws {Error} If the account associated with the address is not found.
         */
        _getHDNodeForAddress(addr) {
            const addressInfo = this._addresses.get(addr);
            if (!addressInfo) {
                throw new Error(`Address ${addr} is not known to this wallet`);
            }
            return this._getAddressNode(addressInfo.account, false, addressInfo.index);
        }
        /**
         * Gets the addresses for a given zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {NeuteredAddressInfo[]} The addresses for the zone.
         */
        getAddressesForZone(zone) {
            this.validateZone(zone);
            const addresses = this._addresses.values();
            return Array.from(addresses).filter((addressInfo) => addressInfo.zone === zone);
        }
        /**
         * Gets the addresses for a given account.
         *
         * @param {number} account - The account number.
         * @returns {NeuteredAddressInfo[]} The addresses for the account.
         */
        getAddressesForAccount(account) {
            const addresses = this._addresses.values();
            return Array.from(addresses).filter((addressInfo) => addressInfo.account === account);
        }
        _findLastUsedIndex(addresses, account, zone) {
            const filteredAddresses = addresses?.filter((addressInfo) => addressInfo.account === account && addressInfo.zone === zone);
            return filteredAddresses?.reduce((maxIndex, addressInfo) => Math.max(maxIndex, addressInfo.index), -1) || -1;
        }
    }

    /**
     * A **Wallet** manages a single private key which is used to sign transactions, messages and other common payloads.
     *
     * This class is generally the main entry point for developers that wish to use a private key directly, as it can create
     * instances from a large variety of common sources, including raw private key,
     * [BIP-39](https://en.bitcoin.it/wiki/BIP_0039) mnemonics and encrypted JSON wallets.
     *
     * @category Wallet
     */
    class Wallet extends BaseWallet {
        /**
         * Create a new wallet for the private `key`, optionally connected to `provider`.
         *
         * @param {string | SigningKey} key - The private key.
         * @param {null | Provider} [provider] - The provider to connect to.
         */
        constructor(key, provider) {
            if (typeof key === 'string' && !key.startsWith('0x')) {
                key = '0x' + key;
            }
            const signingKey = typeof key === 'string' ? new SigningKey(key) : key;
            super(signingKey, provider);
        }
        /**
         * Connects the wallet to a provider.
         *
         * @param {null | Provider} provider - The provider to connect to.
         * @returns {Wallet} The connected wallet.
         */
        connect(provider) {
            return new Wallet(this.signingKey, provider);
        }
        /**
         * Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with `password`.
         *
         * If `progressCallback` is specified, it will receive periodic updates as the encryption process progresses.
         *
         * @param {Uint8Array | string} password - The password to encrypt the wallet with.
         * @param {ProgressCallback} [progressCallback] - An optional callback to keep the user informed.
         * @returns {Promise<string>} The encrypted JSON wallet.
         */
        async encrypt(password, progressCallback) {
            const account = { address: this.address, privateKey: this.privateKey };
            return await encryptKeystoreJson(account, password, { progressCallback });
        }
        /**
         * Returns a [JSON Keystore Wallet](json-wallets) encrypted with `password`.
         *
         * It is preferred to use the [async version](encrypt) instead, which allows a
         * {@link ProgressCallback | **ProgressCallback**} to keep the user informed.
         *
         * This method will block the event loop (freezing all UI) until it is complete, which may be a non-trivial
         * duration.
         *
         * @param {Uint8Array | string} password - The password to encrypt the wallet with.
         * @returns {string} The encrypted JSON wallet.
         */
        encryptSync(password) {
            const account = { address: this.address, privateKey: this.privateKey };
            return encryptKeystoreJsonSync(account, password);
        }
        /**
         * Creates a wallet from a keystore account.
         *
         * @ignore
         * @param {KeystoreAccount} account - The keystore account.
         * @returns {Wallet} The wallet instance.
         */
        static #fromAccount(account) {
            assertArgument(account, 'invalid JSON wallet', 'json', '[ REDACTED ]');
            const wallet = new Wallet(account.privateKey);
            assertArgument(wallet.address === account.address, 'address/privateKey mismatch', 'json', '[ REDACTED ]');
            return wallet;
        }
        /**
         * Creates (asynchronously) a **Wallet** by decrypting the `json` with `password`.
         *
         * If `progress` is provided, it is called periodically during decryption so that any UI can be updated.
         *
         * @param {string} json - The JSON data to decrypt.
         * @param {Uint8Array | string} password - The password to decrypt the JSON data.
         * @param {ProgressCallback} [progress] - An optional callback to keep the user informed.
         * @returns {Promise<QuaiHDWallet | Wallet>} The decrypted wallet.
         */
        static async fromEncryptedJson(json, password, progress) {
            let account;
            if (isKeystoreJson(json)) {
                account = await decryptKeystoreJson(json, password, progress);
                return Wallet.#fromAccount(account);
            }
            throw new Error('invalid JSON wallet');
        }
        /**
         * Creates a **Wallet** by decrypting the `json` with `password`.
         *
         * The {@link Wallet.fromEncryptedJson | **fromEncryptedJson**} method is preferred, as this method will lock up and
         * freeze the UI during decryption, which may take some time.
         *
         * @param {string} json - The JSON data to decrypt.
         * @param {Uint8Array | string} password - The password to decrypt the JSON data.
         * @returns {QuaiHDWallet | Wallet} The decrypted wallet.
         */
        static fromEncryptedJsonSync(json, password) {
            let account = null;
            if (isKeystoreJson(json)) {
                account = decryptKeystoreJsonSync(json, password);
            }
            else {
                assertArgument(false, 'invalid JSON wallet', 'json', '[ REDACTED ]');
            }
            return Wallet.#fromAccount(account);
        }
    }

    /*! musig-js - MIT License (c) 2022 Brandon Black */
    const TAGS = {
      challenge: 'BIP0340/challenge',
      keyagg_list: 'KeyAgg list',
      keyagg_coef: 'KeyAgg coefficient',
      musig_aux: 'MuSig/aux',
      musig_nonce: 'MuSig/nonce',
      musig_deterministic_nonce: 'MuSig/deterministic/nonce',
      musig_noncecoef: 'MuSig/noncecoef',
    };
    function compare32b(a, b) {
      if (a.length !== 32 || b.length !== 32) throw new Error('Invalid array');
      const aD = new DataView(a.buffer, a.byteOffset, a.length);
      const bD = new DataView(b.buffer, b.byteOffset, b.length);
      for (let i = 0; i < 8; i++) {
        const cmp = aD.getUint32(i * 4) - bD.getUint32(i * 4);
        if (cmp !== 0) return cmp;
      }
      return 0;
    }
    function compare33b(a, b) {
      if (a.length !== 33 || b.length !== 33) throw new Error('Invalid array');
      const cmp = a[0] - b[0];
      if (cmp !== 0) return cmp;
      return compare32b(a.subarray(1), b.subarray(1));
    }
    const makeSessionId =
      typeof self === 'object' && (self.crypto || self.msCrypto)
        ? () => (self.crypto || self.msCrypto).getRandomValues(new Uint8Array(32))
        : () => require('crypto').randomBytes(32);
    const _keyAggCache = new WeakMap();
    const _coefCache = new WeakMap();
    const _nonceCache = new WeakMap();
    const _sessionCache = new WeakMap();
    function MuSigFactory(ecc) {
      const CPOINT_INF = new Uint8Array(33);
      const SCALAR_0 = new Uint8Array(32);
      const SCALAR_1 = new Uint8Array(32);
      SCALAR_1[31] = 1;
      ecc.scalarNegate(SCALAR_1);
      function keyAggCoeff(publicKeys, publicKey) {
        let coefCache = _coefCache.get(publicKeys);
        if (coefCache === undefined) {
          coefCache = new Map();
          _coefCache.set(publicKeys, coefCache);
        }
        let coefficient = coefCache.get(publicKey);
        if (coefficient) return coefficient;
        coefficient = SCALAR_1;
        let secondPublicKey;
        let publicKeyHash;
        let keyAggCache = _keyAggCache.get(publicKeys);
        if (keyAggCache === undefined) {
          const pkIdx2 = publicKeys.findIndex((pk) => compare33b(pk, publicKeys[0]) !== 0);
          secondPublicKey = publicKeys[pkIdx2];
          publicKeyHash = ecc.taggedHash(TAGS.keyagg_list, ...publicKeys);
          keyAggCache = { publicKeyHash, secondPublicKey };
          _keyAggCache.set(publicKeys, keyAggCache);
        } else {
          ({ publicKeyHash, secondPublicKey } = keyAggCache);
        }
        if (secondPublicKey === undefined || compare33b(publicKey, secondPublicKey) !== 0)
          coefficient = ecc.taggedHash(TAGS.keyagg_coef, publicKeyHash, publicKey);
        coefCache.set(publicKey, coefficient);
        return coefficient;
      }
      function addTweak(ctx, t) {
        const tweak = 'tweak' in t ? t : { tweak: t };
        if (!ecc.isScalar(tweak.tweak))
          throw new TypeError('Expected tweak to be a valid scalar with curve order');
        let { gacc, tacc } = ctx;
        let aggPublicKey = ctx.aggPublicKey;
        if (!ecc.hasEvenY(aggPublicKey) && tweak.xOnly) {
          gacc = ecc.scalarNegate(gacc);
          tacc = ecc.scalarNegate(tacc);
          aggPublicKey = ecc.pointNegate(aggPublicKey);
        }
        aggPublicKey = ecc.pointAddTweak(aggPublicKey, tweak.tweak, false);
        if (aggPublicKey === null) throw new Error('Unexpected point at infinity during tweaking');
        tacc = ecc.scalarAdd(tweak.tweak, tacc);
        return { aggPublicKey, gacc, tacc };
      }
      function keyAgg(publicKeys, ...tweaks) {
        checkArgs({ publicKeys });
        const multipliedPublicKeys = publicKeys.map((publicKey) => {
          const coefficient = keyAggCoeff(publicKeys, publicKey);
          let multipliedPublicKey;
          if (compare32b(coefficient, SCALAR_1) === 0) {
            multipliedPublicKey = publicKey;
          } else {
            multipliedPublicKey = ecc.pointMultiplyUnsafe(publicKey, coefficient, false);
          }
          if (multipliedPublicKey === null) throw new Error('Point at infinity during aggregation');
          return multipliedPublicKey;
        });
        const aggPublicKey = multipliedPublicKeys.reduce((a, b) => {
          const next = ecc.pointAdd(a, b, false);
          if (next === null) throw new Error('Point at infinity during aggregation');
          return next;
        });
        return tweaks.reduce((ctx, tweak) => addTweak(ctx, tweak), {
          aggPublicKey,
          gacc: SCALAR_1,
          tacc: SCALAR_0,
        });
      }
      function getSessionValues(sessionKey) {
        const sessionValues = _sessionCache.get(sessionKey);
        if (!sessionValues) throw new Error('Invalid session key, please call `startSigningSession`');
        return sessionValues;
      }
      function nonceAgg(publicNonces) {
        checkArgs({ publicNonces });
        const aggNonces = [publicNonces[0].subarray(0, 33), publicNonces[0].subarray(33)];
        for (let i = 1; i < publicNonces.length; i++) {
          if (aggNonces[0] !== null)
            aggNonces[0] = ecc.pointAdd(aggNonces[0], publicNonces[i].subarray(0, 33), false);
          if (aggNonces[1] !== null)
            aggNonces[1] = ecc.pointAdd(aggNonces[1], publicNonces[i].subarray(33), false);
        }
        const aggNonce = new Uint8Array(66);
        if (aggNonces[0] !== null) aggNonce.set(ecc.pointCompress(aggNonces[0]), 0);
        if (aggNonces[1] !== null) aggNonce.set(ecc.pointCompress(aggNonces[1]), 33);
        return aggNonce;
      }
      function startSigningSessionInner(aggNonce, msg, publicKeys, ctx) {
        const pubKeyX = ecc.pointX(ctx.aggPublicKey);
        const coefficient = ecc.taggedHash(TAGS.musig_noncecoef, aggNonce, pubKeyX, msg);
        const aggNonces = [aggNonce.subarray(0, 33), aggNonce.subarray(33)];
        let r = null;
        if (compare33b(aggNonces[1], CPOINT_INF) !== 0 && compare33b(aggNonces[0], CPOINT_INF) !== 0) {
          r = ecc.pointMultiplyAndAddUnsafe(aggNonces[1], coefficient, aggNonces[0], false);
        } else if (compare33b(aggNonces[0], CPOINT_INF) !== 0) {
          r = ecc.pointCompress(aggNonces[0], false);
        } else if (compare33b(aggNonces[1], CPOINT_INF) !== 0) {
          r = ecc.pointMultiplyUnsafe(aggNonces[1], coefficient, false);
        }
        if (r === null) r = ecc.getPublicKey(SCALAR_1, false);
        if (r === null) throw new Error('Failed to get G');
        const challenge = ecc.scalarMod(ecc.taggedHash(TAGS.challenge, ecc.pointX(r), pubKeyX, msg));
        const key = { publicKey: ctx.aggPublicKey, aggNonce, msg };
        _sessionCache.set(key, { ...ctx, coefficient, challenge, finalNonce: r, publicKeys });
        return key;
      }
      function partialVerifyInner({ sig, publicKey, publicNonces, sessionKey }) {
        const { aggPublicKey, gacc, challenge, coefficient, finalNonce, publicKeys } =
          getSessionValues(sessionKey);
        const rePrime = ecc.pointMultiplyAndAddUnsafe(
          publicNonces[1],
          coefficient,
          publicNonces[0],
          false
        );
        if (rePrime === null) throw new Error('Unexpected public nonce at infinity');
        const re = ecc.hasEvenY(finalNonce) ? rePrime : ecc.pointNegate(rePrime);
        const a = keyAggCoeff(publicKeys, publicKey);
        const g = ecc.hasEvenY(aggPublicKey) ? gacc : ecc.scalarNegate(gacc);
        const ea = ecc.scalarMultiply(challenge, a);
        const eag = ecc.scalarMultiply(ea, g);
        const ver = ecc.pointMultiplyAndAddUnsafe(publicKey, eag, re, true);
        if (ver === null) throw new Error('Unexpected verification point at infinity');
        const sG = ecc.getPublicKey(sig, true);
        if (sG === null) throw new Error('Unexpected signature point at infinity');
        return compare33b(ver, sG) === 0;
      }
      function partialSignInner({ secretKey, publicKey, secretNonces, sessionKey }) {
        const { aggPublicKey, gacc, challenge, coefficient, finalNonce, publicKeys } =
          getSessionValues(sessionKey);
        const [k1, k2] = secretNonces.map((k) => (ecc.hasEvenY(finalNonce) ? k : ecc.scalarNegate(k)));
        const a = keyAggCoeff(publicKeys, publicKey);
        const g = ecc.hasEvenY(aggPublicKey) ? gacc : ecc.scalarNegate(gacc);
        const d = ecc.scalarMultiply(g, secretKey);
        const bk2 = ecc.scalarMultiply(coefficient, k2);
        const k1bk2 = ecc.scalarAdd(k1, bk2);
        const ea = ecc.scalarMultiply(challenge, a);
        const ead = ecc.scalarMultiply(ea, d);
        const sig = ecc.scalarAdd(k1bk2, ead);
        return sig;
      }
      function partialSign({ secretKey, publicNonce, sessionKey, verify = true }) {
        checkArgs({ publicNonce, secretKey });
        const secretNonce = _nonceCache.get(publicNonce);
        if (secretNonce === undefined)
          throw new Error('No secret nonce found for specified public nonce');
        _nonceCache.delete(publicNonce);
        const publicKey = ecc.getPublicKey(secretKey, true);
        if (publicKey === null) throw new Error('Invalid secret key, no corresponding public key');
        if (compare33b(publicKey, secretNonce.subarray(64)) !== 0)
          throw new Error('Secret nonce pubkey mismatch');
        const secretNonces = [secretNonce.subarray(0, 32), secretNonce.subarray(32, 64)];
        const sig = partialSignInner({
          secretKey,
          publicKey,
          secretNonces,
          sessionKey,
        });
        if (verify) {
          const publicNonces = [publicNonce.subarray(0, 33), publicNonce.subarray(33)];
          const valid = partialVerifyInner({
            sig,
            publicKey,
            publicNonces,
            sessionKey,
          });
          if (!valid) throw new Error('Partial signature failed verification');
        }
        return sig;
      }
      function deterministicSign({
        secretKey,
        aggOtherNonce,
        publicKeys,
        tweaks = [],
        msg,
        rand,
        verify = true,
        nonceOnly = false,
      }) {
        checkArgs({ rand, secretKey, aggOtherNonce });
        const publicKey = ecc.getPublicKey(secretKey, true);
        if (publicKey === null) throw new Error('Secret key has no corresponding public key');
        let secretKeyPrime;
        if (rand !== undefined) {
          secretKeyPrime = ecc.taggedHash(TAGS.musig_aux, rand);
          for (let i = 0; i < 32; i++) {
            secretKeyPrime[i] = secretKeyPrime[i] ^ secretKey[i];
          }
        } else {
          secretKeyPrime = secretKey;
        }
        const ctx = keyAgg(publicKeys, ...tweaks);
        const aggPublicKey = ecc.pointX(ctx.aggPublicKey);
        const mLength = new Uint8Array(8);
        new DataView(mLength.buffer).setBigUint64(0, BigInt(msg.length));
        const secretNonce = new Uint8Array(97);
        const publicNonce = new Uint8Array(66);
        for (let i = 0; i < 2; i++) {
          const kH = ecc.taggedHash(
            TAGS.musig_deterministic_nonce,
            ...[secretKeyPrime, aggOtherNonce, aggPublicKey, mLength, msg, Uint8Array.of(i)]
          );
          const k = ecc.scalarMod(kH);
          if (compare32b(SCALAR_0, k) === 0) throw new Error('0 secret nonce');
          const pub = ecc.getPublicKey(k, true);
          if (pub === null) throw new Error('Secret nonce has no corresponding public nonce');
          secretNonce.set(k, i * 32);
          publicNonce.set(pub, i * 33);
        }
        secretNonce.set(publicKey, 64);
        if (nonceOnly) return { publicNonce };
        _nonceCache.set(publicNonce, secretNonce);
        const aggNonce = nonceAgg([aggOtherNonce, publicNonce]);
        const sessionKey = startSigningSessionInner(aggNonce, msg, publicKeys, ctx);
        const sig = partialSign({
          secretKey,
          publicNonce,
          sessionKey,
          verify,
        });
        return { sig, sessionKey, publicNonce };
      }
      const pubKeyArgs = ['publicKey', 'publicKeys'];
      const scalarArgs = ['tweak', 'sig', 'sigs', 'tacc', 'gacc'];
      const otherArgs32b = ['xOnlyPublicKey', 'rand', 'sessionId'];
      const args32b = ['secretKey', ...scalarArgs, ...otherArgs32b];
      const pubNonceArgs = ['publicNonce', 'publicNonces', 'aggNonce', 'aggOtherNonce', 'finalNonce'];
      const argLengths = new Map();
      args32b.forEach((a) => argLengths.set(a, 32));
      pubKeyArgs.forEach((a) => argLengths.set(a, 33));
      pubNonceArgs.forEach((a) => argLengths.set(a, 66));
      argLengths.set('secretNonce', 97);
      argLengths.set('aggPublicKey', 65);
      const scalarNames = new Set();
      scalarArgs.forEach((n) => scalarNames.add(n));
      function checkArgs(args) {
        for (let [name, values] of Object.entries(args)) {
          if (values === undefined) continue;
          values = Array.isArray(values) ? values : [values];
          if (values.length === 0) throw new TypeError(`0-length ${name}s not supported`);
          for (const value of values) {
            if (argLengths.get(name) !== value.length)
              throw new TypeError(`Invalid ${name} length (${value.length})`);
            if (name === 'secretKey') {
              if (!ecc.isSecret(value)) throw new TypeError(`Invalid secretKey`);
            } else if (name === 'secretNonce') {
              for (let i = 0; i < 64; i += 32)
                if (!ecc.isSecret(value.subarray(i, i + 32)))
                  throw new TypeError(`Invalid secretNonce`);
            } else if (scalarNames.has(name)) {
              for (let i = 0; i < value.length; i += 32)
                if (!ecc.isScalar(value.subarray(i, i + 32))) throw new TypeError(`Invalid ${name}`);
            }
          }
        }
      }
      return {
        getXOnlyPubkey: (ctx) => {
          if ('aggPublicKey' in ctx) return ecc.pointX(ctx.aggPublicKey);
          return ecc.pointX(getSessionValues(ctx).aggPublicKey);
        },
        getPlainPubkey: (ctx) => {
          if ('aggPublicKey' in ctx) return ecc.pointCompress(ctx.aggPublicKey);
          return ecc.pointCompress(getSessionValues(ctx).aggPublicKey);
        },
        keySort: (publicKeys) => {
          checkArgs({ publicKeys });
          return [...publicKeys].sort((a, b) => compare33b(a, b));
        },
        keyAgg,
        addTweaks: (ctx, ...tweaks) => {
          checkArgs(ctx);
          return tweaks.reduce((c, tweak) => addTweak(c, tweak), ctx);
        },
        nonceGen: ({
          sessionId = makeSessionId(),
          secretKey,
          publicKey,
          xOnlyPublicKey,
          msg,
          extraInput,
        }) => {
          if (extraInput !== undefined && extraInput.length > Math.pow(2, 32) - 1)
            throw new TypeError('extraInput is limited to 2^32-1 bytes');
          checkArgs({ sessionId, secretKey, publicKey, xOnlyPublicKey });
          let rand;
          if (secretKey !== undefined) {
            rand = ecc.taggedHash(TAGS.musig_aux, sessionId);
            for (let i = 0; i < 32; i++) {
              rand[i] = rand[i] ^ secretKey[i];
            }
          } else {
            rand = sessionId;
          }
          if (xOnlyPublicKey === undefined) xOnlyPublicKey = new Uint8Array();
          const mPrefixed = [Uint8Array.of(0)];
          if (msg !== undefined) {
            mPrefixed[0][0] = 1;
            mPrefixed.push(new Uint8Array(8));
            new DataView(mPrefixed[1].buffer).setBigUint64(0, BigInt(msg.length));
            mPrefixed.push(msg);
          }
          if (extraInput === undefined) extraInput = new Uint8Array();
          const eLength = new Uint8Array(4);
          new DataView(eLength.buffer).setUint32(0, extraInput.length);
          const secretNonce = new Uint8Array(97);
          const publicNonce = new Uint8Array(66);
          for (let i = 0; i < 2; i++) {
            const kH = ecc.taggedHash(
              TAGS.musig_nonce,
              rand,
              Uint8Array.of(publicKey.length),
              publicKey,
              Uint8Array.of(xOnlyPublicKey.length),
              xOnlyPublicKey,
              ...mPrefixed,
              eLength,
              extraInput,
              Uint8Array.of(i)
            );
            const k = ecc.scalarMod(kH);
            if (compare32b(SCALAR_0, k) === 0) throw new Error('0 secret nonce');
            const pub = ecc.getPublicKey(k, true);
            if (pub === null) throw new Error('Secret nonce has no corresponding public nonce');
            secretNonce.set(k, i * 32);
            publicNonce.set(pub, i * 33);
          }
          secretNonce.set(publicKey, 64);
          _nonceCache.set(publicNonce, secretNonce);
          return publicNonce;
        },
        addExternalNonce: (publicNonce, secretNonce) => {
          checkArgs({ publicNonce, secretNonce });
          _nonceCache.set(publicNonce, secretNonce);
        },
        deterministicNonceGen: (args) => deterministicSign({ ...args, nonceOnly: true }),
        deterministicSign,
        nonceAgg,
        startSigningSession: (aggNonce, msg, publicKeys, ...tweaks) => {
          checkArgs({ aggNonce });
          const ctx = keyAgg(publicKeys, ...tweaks);
          return startSigningSessionInner(aggNonce, msg, publicKeys, ctx);
        },
        partialSign,
        partialVerify: ({ sig, publicKey, publicNonce, sessionKey }) => {
          checkArgs({ sig, publicKey, publicNonce });
          const publicNonces = [publicNonce.subarray(0, 33), publicNonce.subarray(33)];
          const valid = partialVerifyInner({
            sig,
            publicKey,
            publicNonces,
            sessionKey,
          });
          return valid;
        },
        signAgg: (sigs, sessionKey) => {
          checkArgs({ sigs });
          const { aggPublicKey, tacc, challenge, finalNonce } = getSessionValues(sessionKey);
          let sPart = ecc.scalarMultiply(challenge, tacc);
          if (!ecc.hasEvenY(aggPublicKey)) {
            sPart = ecc.scalarNegate(sPart);
          }
          const aggS = sigs.reduce((a, b) => ecc.scalarAdd(a, b), sPart);
          const sig = new Uint8Array(64);
          sig.set(ecc.pointX(finalNonce), 0);
          sig.set(aggS, 32);
          return sig;
        },
      };
    }

    /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Utilities

    function isBytes(a) {
        return (a instanceof Uint8Array ||
            (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
    }
    /**
     * @__NO_SIDE_EFFECTS__
     */
    function chain(...args) {
        const id = (a) => a;
        // Wrap call in closure so JIT can inline calls
        const wrap = (a, b) => (c) => a(b(c));
        // Construct chain of args[-1].encode(args[-2].encode([...]))
        const encode = args.map((x) => x.encode).reduceRight(wrap, id);
        // Construct chain of args[0].decode(args[1].decode(...))
        const decode = args.map((x) => x.decode).reduce(wrap, id);
        return { encode, decode };
    }
    /**
     * Encodes integer radix representation to array of strings using alphabet and back
     * @__NO_SIDE_EFFECTS__
     */
    function alphabet(alphabet) {
        return {
            encode: (digits) => {
                if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                    throw new Error('alphabet.encode input should be an array of numbers');
                return digits.map((i) => {
                    if (i < 0 || i >= alphabet.length)
                        throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                    return alphabet[i];
                });
            },
            decode: (input) => {
                if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                    throw new Error('alphabet.decode input should be array of strings');
                return input.map((letter) => {
                    if (typeof letter !== 'string')
                        throw new Error(`alphabet.decode: not string element=${letter}`);
                    const index = alphabet.indexOf(letter);
                    if (index === -1)
                        throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                    return index;
                });
            },
        };
    }
    /**
     * @__NO_SIDE_EFFECTS__
     */
    function join(separator = '') {
        if (typeof separator !== 'string')
            throw new Error('join separator should be string');
        return {
            encode: (from) => {
                if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                    throw new Error('join.encode input should be array of strings');
                for (let i of from)
                    if (typeof i !== 'string')
                        throw new Error(`join.encode: non-string input=${i}`);
                return from.join(separator);
            },
            decode: (to) => {
                if (typeof to !== 'string')
                    throw new Error('join.decode input should be string');
                return to.split(separator);
            },
        };
    }
    /**
     * Slow: O(n^2) time complexity
     * @__NO_SIDE_EFFECTS__
     */
    function convertRadix(data, from, to) {
        // base 1 is impossible
        if (from < 2)
            throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
        if (to < 2)
            throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
        if (!Array.isArray(data))
            throw new Error('convertRadix: data should be array');
        if (!data.length)
            return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data);
        digits.forEach((d) => {
            if (d < 0 || d >= from)
                throw new Error(`Wrong integer: ${d}`);
        });
        while (true) {
            let carry = 0;
            let done = true;
            for (let i = pos; i < digits.length; i++) {
                const digit = digits[i];
                const digitBase = from * carry + digit;
                if (!Number.isSafeInteger(digitBase) ||
                    (from * carry) / from !== carry ||
                    digitBase - digit !== from * carry) {
                    throw new Error('convertRadix: carry overflow');
                }
                carry = digitBase % to;
                const rounded = Math.floor(digitBase / to);
                digits[i] = rounded;
                if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                    throw new Error('convertRadix: carry overflow');
                if (!done)
                    continue;
                else if (!rounded)
                    pos = i;
                else
                    done = false;
            }
            res.push(carry);
            if (done)
                break;
        }
        for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
            res.push(0);
        return res.reverse();
    }
    /**
     * @__NO_SIDE_EFFECTS__
     */
    function radix(num) {
        return {
            encode: (bytes) => {
                if (!isBytes(bytes))
                    throw new Error('radix.encode input should be Uint8Array');
                return convertRadix(Array.from(bytes), 2 ** 8, num);
            },
            decode: (digits) => {
                if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                    throw new Error('radix.decode input should be array of numbers');
                return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
            },
        };
    }
    /**
     * @__NO_SIDE_EFFECTS__
     */
    function checksum$1(len, fn) {
        if (typeof fn !== 'function')
            throw new Error('checksum fn should be function');
        return {
            encode(data) {
                if (!isBytes(data))
                    throw new Error('checksum.encode: input should be Uint8Array');
                const checksum = fn(data).slice(0, len);
                const res = new Uint8Array(data.length + len);
                res.set(data);
                res.set(checksum, data.length);
                return res;
            },
            decode(data) {
                if (!isBytes(data))
                    throw new Error('checksum.decode: input should be Uint8Array');
                const payload = data.slice(0, -len);
                const newChecksum = fn(payload).slice(0, len);
                const oldChecksum = data.slice(-len);
                for (let i = 0; i < len; i++)
                    if (newChecksum[i] !== oldChecksum[i])
                        throw new Error('Invalid checksum');
                return payload;
            },
        };
    }
    // base58 code
    // -----------
    const genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));
    const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
    const createBase58check = (sha256) => chain(checksum$1(4, (data) => sha256(sha256(data))), base58);
    // legacy export, bad name
    const base58check = createBase58check;

    const bs58check = base58check(sha256$1);
    function hash160(buffer) {
        return ripemd160$1(sha256$1(buffer));
    }
    function hmacSHA512(key, data) {
        return hmac(sha512$1, key, data);
    }

    const PC_VERSION = 0x47;
    class PaymentCodePublic {
        ecc;
        bip32;
        buf;
        root;
        hasPrivKeys;
        /**
         * Constructor for the PaymentCode class.
         *
         * @param {TinySecp256k1Interface} ecc - Implementation of secp256k1 elliptic curve
         * @param {BIP32API} bip32 - Bip32 instance
         * @param {Uint8Array} buf - The buffer representing the payment code.
         * @throws {Error} Invalid buffer length - If the length of the buffer is not 80.
         * @throws {Error} Only payment codes version 1 are supported - If the version of the payment code is not 1.
         */
        constructor(ecc, bip32, buf) {
            this.ecc = ecc;
            this.bip32 = bip32;
            this.hasPrivKeys = false;
            if (buf.length !== 80)
                throw new Error('Invalid buffer length');
            if (buf[0] !== 1)
                throw new Error('Only payment codes version 1 are supported');
            this.buf = buf;
            this.root = bip32.fromPublicKey(this.pubKey, this.chainCode);
        }
        /**
         * Get the features of PaymentCode.
         *
         * @returns {Uint8Array} The features as a Uint8Array object.
         */
        get features() {
            return this.buf.subarray(1, 2);
        }
        /**
         * Returns the public key.
         *
         * @returns {Uint8Array} The public key as a Uint8Array.
         */
        get pubKey() {
            return this.buf.subarray(2, 2 + 33);
        }
        /**
         * Retrieves the chain code of the payment code.
         *
         * @returns {Uint8Array} - The extracted chain code as a Uint8Array.
         */
        get chainCode() {
            return this.buf.subarray(35, 35 + 32);
        }
        /**
         * Retrieves the payment code buffer.
         *
         * @returns {Uint8Array} The payment code buffer.
         */
        get paymentCode() {
            return this.buf;
        }
        /**
         * Creates a base58 representation of the payment code.
         *
         * @returns {string} - The Base58 representation of PaymentCode.
         */
        toBase58() {
            const version = new Uint8Array([PC_VERSION]);
            const buf = new Uint8Array(version.length + this.buf.length);
            buf.set(version);
            buf.set(this.buf, version.length);
            return bs58check.encode(buf);
        }
        /**
         * Derives a child from the root BIP32 node at the specified index.
         *
         * @param {number} index - The index of the child BIP32Interface object to be derived.
         * @returns {BIP32Interface} - The derived child BIP32Interface object.
         */
        derive(index) {
            return this.root.derive(index);
        }
        /**
         * Retrieves the public key for notification.
         *
         * @returns {Uint8Array} The public key for notification.
         */
        getNotificationPublicKey() {
            return getBytes(this.derive(0).publicKey);
        }
        /**
         * Derives a public key from the shared secret.
         *
         * @param {Uint8Array} B - Public key
         * @param {Uint8Array} S - Shared secret point
         * @returns {Uint8Array} The derived public key.
         * @throws {Error} If the shared secret is invalid or unable to derive the public key.
         */
        derivePublicKeyFromSharedSecret(B, S) {
            const Sx = S.subarray(1, 33);
            const s = sha256$1(Sx);
            if (!this.ecc.isPrivate(s))
                throw new Error('Invalid shared secret');
            const P = this.ecc.pointAddScalar(B, s, true);
            if (!P)
                throw new Error('Unable to derive public key');
            return P;
        }
        /**
         * Derives a payment public key based on the given public payment code.
         *
         * @param {PaymentCodePublic} paymentCode - The public payment code to derive the payment public key from.
         * @param {number} idx - The index used for derivation.
         * @returns {Uint8Array} The derived payment public key.
         * @throws {Error} If the payment code does not contain a valid public key, or if any step in the derivation process
         *   fails.
         */
        derivePaymentPublicKey(paymentCode, idx) {
            const a = paymentCode.getNotificationPrivateKey();
            if (!this.ecc.isPrivate(a))
                throw new Error('Received invalid private key');
            const B = this.derive(idx).publicKey;
            const S = this.ecc.pointMultiply(B, a);
            if (!S)
                throw new Error('Unable to compute secret point');
            return this.derivePublicKeyFromSharedSecret(B, S);
        }
        /**
         * Retrieves the address from a given public key.
         *
         * @param {Uint8Array} pubKey - The public key.
         * @returns {string} The generated address.
         * @throws {Error} - When unsupported address type is passed
         * @protected
         */
        getAddressFromPubkey(pubKey) {
            return computeAddress(hexlify(pubKey));
        }
        /**
         * Retrieves a payment address based on the provided parameters.
         *
         * @param {PaymentCodePublic} paymentCode - The public payment code to derive the payment address from.
         * @param {number} idx - The index used in the derivation process.
         * @returns {string} - The generated payment address.
         * @throws {Error} - If unable to derive public key or if an unknown address type is specified.
         */
        getPaymentAddress(paymentCode, idx) {
            const pubkey = this.derivePaymentPublicKey(paymentCode, idx);
            return this.getAddressFromPubkey(pubkey);
        }
    }
    class PaymentCodePrivate extends PaymentCodePublic {
        /**
         * Constructor for the PaymentCodePrivate class.
         *
         * @param {HDNodeBIP32Adapter} root - The root HDNodeWallet as a HDNodeBIP32Adapter.
         * @param {TinySecp256k1Interface} ecc - Implementation of secp256k1 elliptic curve.
         * @param {BIP32API} bip32 - An instance implementing the bip32 API methods.
         * @param {Uint8Array} buf - The buffer representing the payment code.
         */
        constructor(root, ecc, bip32, buf) {
            super(ecc, bip32, buf);
            this.root = root;
            this.hasPrivKeys = true;
        }
        /**
         * Derives a payment public key based on the given public payment code.
         *
         * @param {PaymentCodePublic} paymentCode - The public payment code to derive the payment public key from.
         * @param {number} idx - The index used for derivation.
         * @returns {Uint8Array} The derived payment public key.
         * @throws {Error} If the payment code does not contain a valid public key or unable to derive the node with private
         *   key.
         */
        derivePaymentPublicKey(paymentCode, idx) {
            const A = paymentCode.getNotificationPublicKey();
            if (!this.ecc.isPoint(A))
                throw new Error('Received invalid public key');
            const b_node = this.derive(idx);
            if (!b_node.privateKey)
                throw new Error('Unable to derive node with private key');
            const b = getBytes(b_node.privateKey);
            const B = getBytes(b_node.publicKey);
            const S = this.ecc.pointMultiply(A, b);
            if (!S)
                throw new Error('Unable to compute resulting point');
            return this.derivePublicKeyFromSharedSecret(B, S);
        }
        /**
         * Retrieves a payment address based on the provided parameters.
         *
         * @param {PaymentCodePublic} paymentCode - The public payment code to derive the payment address from.
         * @param {number} idx - The index used in the derivation process.
         * @returns {string} - The generated payment address.
         * @throws {Error} - If unable to derive public key or if an unknown address type is specified.
         */
        getPaymentAddress(paymentCode, idx) {
            const pubKey = this.derivePaymentPublicKey(paymentCode, idx);
            return this.getAddressFromPubkey(pubKey);
        }
        /**
         * Derives a payment private key based on the given public payment code.
         *
         * @param {PaymentCodePublic} paymentCodePublic - The public payment code to derive the payment private key from.
         * @param {number} idx - The index used for derivation.
         * @returns {Uint8Array} The derived payment private key.
         * @throws {Error} If the payment code does not contain a valid public key, unable to derive the node without
         *   private key, unable to compute the resulting point, or invalid shared secret.
         */
        derivePaymentPrivateKey(paymentCodePublic, idx) {
            const A = paymentCodePublic.getNotificationPublicKey();
            if (!this.ecc.isPoint(A))
                throw new Error('Argument is not a valid public key');
            const b_node = this.derive(idx);
            if (!b_node.privateKey)
                throw new Error('Unable to derive node without private key');
            const b = getBytes(b_node.privateKey);
            const S = this.ecc.pointMultiply(A, b);
            if (!S)
                throw new Error('Unable to compute resulting point');
            const Sx = S.subarray(1, 33);
            const s = sha256$1(Sx);
            if (!this.ecc.isPrivate(s))
                throw new Error('Invalid shared secret');
            const paymentPrivateKey = this.ecc.privateAdd(b, s);
            if (!paymentPrivateKey)
                throw new Error('Unable to compute payment private key');
            return paymentPrivateKey;
        }
        /**
         * Retrieves the notification private key.
         *
         * @returns {Uint8Array} The notification private key.
         */
        getNotificationPrivateKey() {
            const child = this.derive(0);
            return child.privateKey;
        }
    }
    /**
     * Validates a payment code base58 encoded string.
     *
     * @param {string} paymentCode - The payment code to validate.
     * @throws {Error} If the payment code is invalid.
     */
    function validatePaymentCode(paymentCode) {
        const VERSION_BYTE = 0x47;
        const FEATURE_BYTE = 0x00;
        try {
            const decoded = bs58check.decode(paymentCode);
            if (decoded.length !== 81) {
                return false;
            }
            if (decoded[0] !== VERSION_BYTE) {
                return false;
            }
            const paymentCodeBytes = decoded.slice(1);
            if (paymentCodeBytes[0] !== 0x01) {
                return false;
            }
            // Check if the second byte is 0 (features byte)
            if (paymentCodeBytes[1] !== FEATURE_BYTE) {
                return false;
            }
            // Check if the public key starts with 0x02 or 0x03
            if (paymentCodeBytes[2] !== 0x02 && paymentCodeBytes[2] !== 0x03) {
                return false;
            }
            const pubKey = paymentCodeBytes.slice(2, 35);
            try {
                secp256k1.ProjectivePoint.fromHex(Buffer.from(pubKey).toString('hex')).assertValidity();
            }
            catch (error) {
                return false;
            }
            if (!paymentCodeBytes.slice(67).every((byte) => byte === 0)) {
                return false;
            }
            return true;
        }
        catch (error) {
            return false;
        }
    }

    /**
     * Uint8Array comparison
     */
    function areUint8ArraysEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (let index = 0; index < a.length; index++) {
            if (a[index] !== b[index]) {
                return false;
            }
        }
        return true;
    }

    const h = (hex) => hexToBytes$1(hex);
    function testEcc(ecc) {
        assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
        assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
        assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
        // order - 1
        assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
        // 0
        assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
        // order
        assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
        // order + 1
        assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
        assert(areUint8ArraysEqual(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')));
        if (ecc.xOnlyPointAddTweak) {
            assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
            let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
            assert(areUint8ArraysEqual(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) && xOnlyRes.parity === 1);
            xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
        }
        assert(areUint8ArraysEqual(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')));
        assert(areUint8ArraysEqual(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
        if (ecc.privateNegate) {
            assert(areUint8ArraysEqual(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
            assert(areUint8ArraysEqual(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')));
            assert(areUint8ArraysEqual(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')));
        }
        assert(areUint8ArraysEqual(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
        assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
        if (ecc.signSchnorr) {
            assert(areUint8ArraysEqual(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
        }
        if (ecc.verifySchnorr) {
            assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
        }
    }
    function assert(bool) {
        if (!bool)
            throw new Error('ecc library invalid');
    }

    function BIP32Factory(ecc) {
        testEcc(ecc);
        // const UINT256_TYPE = ow.uint8Array.length(32);
        // const NETWORK_TYPE = ow.object.partialShape({
        //     wif: ow.number.uint8,
        //     bip32: ow.object.exactShape({
        //         public: ow.number.uint32,
        //         private: ow.number.uint32,
        //     }),
        // });
        const BITCOIN = {
            bip32: {
                public: 0x0488b21e,
                private: 0x0488ade4,
            },
            wif: 0x80,
        };
        const HIGHEST_BIT = 0x80000000;
        // const UINT31_MAX = Math.pow(2, 31) - 1;
        function toXOnly(pubKey) {
            return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
        }
        class Bip32Signer {
            __D;
            __Q;
            lowR;
            constructor({ __D, __Q }) {
                this.__D = __D;
                this.__Q = __Q;
                this.lowR = false;
            }
            get publicKey() {
                if (this.__Q === undefined)
                    this.__Q = ecc.pointFromScalar(this.__D, true);
                return this.__Q;
            }
            get privateKey() {
                return this.__D;
            }
            sign(hash, lowR) {
                if (!this.privateKey)
                    throw new Error('Missing private key');
                if (lowR === undefined)
                    lowR = this.lowR;
                if (lowR === false) {
                    return ecc.sign(hash, this.privateKey);
                }
                else {
                    let sig = ecc.sign(hash, this.privateKey);
                    const extraData = new Uint8Array(32);
                    const extraDataView = new DataView(extraData.buffer);
                    let counter = 0;
                    // if first try is lowR, skip the loop
                    // for second try and on, add extra entropy counting up
                    while (sig[0] > 0x7f) {
                        counter++;
                        extraDataView.setUint32(0, counter, true);
                        sig = ecc.sign(hash, this.privateKey, extraData);
                    }
                    return sig;
                }
            }
            signSchnorr(hash) {
                if (!this.privateKey)
                    throw new Error('Missing private key');
                if (!ecc.signSchnorr)
                    throw new Error('signSchnorr not supported by ecc library');
                return ecc.signSchnorr(hash, this.privateKey);
            }
            verify(hash, signature) {
                return ecc.verify(hash, this.publicKey, signature);
            }
            verifySchnorr(hash, signature) {
                if (!ecc.verifySchnorr)
                    throw new Error('verifySchnorr not supported by ecc library');
                return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
            }
        }
        class BIP32 extends Bip32Signer {
            chainCode;
            network;
            __DEPTH;
            __INDEX;
            __PARENT_FINGERPRINT;
            constructor({ __D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000, }) {
                super({ __D, __Q });
                this.chainCode = chainCode;
                this.network = network;
                this.__DEPTH = __DEPTH;
                this.__INDEX = __INDEX;
                this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
                // ow(network, NETWORK_TYPE);
            }
            get depth() {
                return this.__DEPTH;
            }
            get index() {
                return this.__INDEX;
            }
            get parentFingerprint() {
                return this.__PARENT_FINGERPRINT;
            }
            get identifier() {
                return hash160(this.publicKey);
            }
            get fingerprint() {
                return this.identifier.subarray(0, 4);
            }
            get compressed() {
                return true;
            }
            isNeutered() {
                return this.__D === undefined;
            }
            neutered() {
                return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
            }
            toBase58() {
                const network = this.network;
                const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
                const buffer = new Uint8Array(78);
                const bufferView = new DataView(buffer.buffer);
                // 4 bytes: version bytes
                bufferView.setUint32(0, version, false);
                // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
                bufferView.setUint8(4, this.depth);
                // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
                bufferView.setUint32(5, this.parentFingerprint, false);
                // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
                // This is encoded in big endian. (0x00000000 if master key)
                bufferView.setUint32(9, this.index, false);
                // 32 bytes: the chain code
                buffer.set(this.chainCode, 13);
                // 33 bytes: the public key or private key data
                if (!this.isNeutered()) {
                    // 0x00 + k for private keys
                    bufferView.setUint8(45, 0);
                    buffer.set(this.privateKey, 46);
                    // 33 bytes: the public key
                }
                else {
                    // X9.62 encoding for public keys
                    buffer.set(this.publicKey, 45);
                }
                return bs58check.encode(buffer);
            }
            derive(index) {
                // ow(index, ow.number.message('Expected UInt32').uint32.message('Expected UInt32'));
                const isHardened = index >= HIGHEST_BIT;
                const data = new Uint8Array(37);
                const dataView = new DataView(data.buffer);
                // Hardened child
                if (isHardened) {
                    if (this.isNeutered())
                        throw new TypeError('Missing private key for hardened child key');
                    // data = 0x00 || ser256(kpar) || ser32(index)
                    data[0] = 0x00;
                    data.set(this.privateKey, 1);
                    dataView.setUint32(33, index, false);
                    // Normal child
                }
                else {
                    // data = serP(point(kpar)) || ser32(index)
                    //      = serP(Kpar) || ser32(index)
                    data.set(this.publicKey, 0);
                    dataView.setUint32(33, index, false);
                }
                const I = hmacSHA512(this.chainCode, data);
                const IL = I.slice(0, 32);
                const IR = I.slice(32);
                // if parse256(IL) >= n, proceed with the next value for i
                if (!ecc.isPrivate(IL))
                    return this.derive(index + 1);
                // Private parent key -> private child key
                let hd;
                if (!this.isNeutered()) {
                    // ki = parse256(IL) + kpar (mod n)
                    const ki = ecc.privateAdd(this.privateKey, IL);
                    // In case ki == 0, proceed with the next value for i
                    if (ki == null)
                        return this.derive(index + 1);
                    hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, new DataView(this.fingerprint.buffer).getUint32(0, false));
                    // Public parent key -> public child key
                }
                else {
                    // Ki = point(parse256(IL)) + Kpar
                    //    = G*IL + Kpar
                    const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
                    // In case Ki is the point at infinity, proceed with the next value for i
                    if (Ki === null)
                        return this.derive(index + 1);
                    hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, new DataView(this.fingerprint.buffer).getUint32(0, false));
                }
                return hd;
            }
            deriveHardened(index) {
                // ow(index, ow.number
                //     .message('Expected UInt31')
                //     .uint32.message('Expected UInt31')
                //     .is(value => value <= UINT31_MAX)
                //     .message('Expected UInt31'));
                // Only derives hardened private keys by default
                return this.derive(index + HIGHEST_BIT);
            }
            derivePath(path) {
                // ow(path, ow.string
                //     .is(value => value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null)
                //     .message(value => `Expected BIP32Path, got ${value}`));
                let splitPath = path.split('/');
                if (splitPath[0] === 'm') {
                    if (this.parentFingerprint)
                        throw new TypeError('Expected master, got child');
                    splitPath = splitPath.slice(1);
                }
                return splitPath.reduce((prevHd, indexStr) => {
                    let index;
                    if (indexStr.slice(-1) === `'`) {
                        index = parseInt(indexStr.slice(0, -1), 10);
                        return prevHd.deriveHardened(index);
                    }
                    else {
                        index = parseInt(indexStr, 10);
                        return prevHd.derive(index);
                    }
                }, this);
            }
            tweak(t) {
                if (this.privateKey)
                    return this.tweakFromPrivateKey(t);
                return this.tweakFromPublicKey(t);
            }
            tweakFromPublicKey(t) {
                const xOnlyPubKey = toXOnly(this.publicKey);
                if (!ecc.xOnlyPointAddTweak)
                    throw new Error('xOnlyPointAddTweak not supported by ecc library');
                const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
                if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
                    throw new Error('Cannot tweak public key!');
                const parityByte = Uint8Array.from([tweakedPublicKey.parity === 0 ? 0x02 : 0x03]);
                const tweakedPublicKeyCompresed = new Uint8Array(tweakedPublicKey.xOnlyPubkey.length + 1);
                tweakedPublicKeyCompresed.set(parityByte);
                tweakedPublicKeyCompresed.set(tweakedPublicKey.xOnlyPubkey, 1);
                return new Bip32Signer({ __Q: tweakedPublicKeyCompresed });
            }
            tweakFromPrivateKey(t) {
                const hasOddY = this.publicKey[0] === 3 || (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
                const privateKey = (() => {
                    if (!hasOddY)
                        return this.privateKey;
                    else if (!ecc.privateNegate)
                        throw new Error('privateNegate not supported by ecc library');
                    else
                        return ecc.privateNegate(this.privateKey);
                })();
                const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
                if (!tweakedPrivateKey)
                    throw new Error('Invalid tweaked private key!');
                return new Bip32Signer({ __D: tweakedPrivateKey });
            }
        }
        function fromBase58(inString, network) {
            const buffer = bs58check.decode(inString);
            const bufferView = new DataView(buffer.buffer);
            if (buffer.length !== 78)
                throw new TypeError('Invalid buffer length');
            network = network || BITCOIN;
            // 4 bytes: version bytes
            const version = bufferView.getUint32(0, false);
            if (version !== network.bip32.private && version !== network.bip32.public)
                throw new TypeError('Invalid network version');
            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
            const depth = buffer[4];
            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
            const parentFingerprint = bufferView.getUint32(5, false);
            if (depth === 0) {
                if (parentFingerprint !== 0x00000000)
                    throw new TypeError('Invalid parent fingerprint');
            }
            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
            // This is encoded in MSB order. (0x00000000 if master key)
            const index = bufferView.getUint32(9, false);
            if (depth === 0 && index !== 0)
                throw new TypeError('Invalid index');
            // 32 bytes: the chain code
            const chainCode = buffer.subarray(13, 45);
            let hd;
            // 33 bytes: private key data (0x00 + k)
            if (version === network.bip32.private) {
                if (bufferView.getUint8(45) !== 0x00)
                    throw new TypeError('Invalid private key');
                const k = buffer.subarray(46, 78);
                hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
                // 33 bytes: public key data (0x02 + X or 0x03 + X)
            }
            else {
                const X = buffer.subarray(45, 78);
                hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
            }
            return hd;
        }
        function fromPrivateKey(privateKey, chainCode, network) {
            return fromPrivateKeyLocal(privateKey, chainCode, network || BITCOIN, 0, 0, 0);
        }
        function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
            // ow({ privateKey, chainCode }, ow.object.exactShape({
            //     privateKey: UINT256_TYPE,
            //     chainCode: UINT256_TYPE,
            // }));
            network = network || BITCOIN;
            if (!ecc.isPrivate(privateKey))
                throw new TypeError('Private key not in range [1, n)');
            return new BIP32({
                __D: privateKey,
                chainCode,
                network,
                __DEPTH: depth,
                __INDEX: index,
                __PARENT_FINGERPRINT: parentFingerprint,
            });
        }
        function fromPublicKey(publicKey, chainCode, network) {
            return fromPublicKeyLocal(publicKey, chainCode, network || BITCOIN, 0, 0, 0);
        }
        function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
            // ow({ publicKey, chainCode }, ow.object.exactShape({
            //     publicKey: ow.uint8Array.length(33),
            //     chainCode: UINT256_TYPE,
            // }));
            network = network || BITCOIN;
            // verify the X coordinate is a point on the curve
            if (!ecc.isPoint(publicKey))
                throw new TypeError('Point is not on the curve');
            return new BIP32({
                __Q: publicKey,
                chainCode,
                network,
                __DEPTH: depth,
                __INDEX: index,
                __PARENT_FINGERPRINT: parentFingerprint,
            });
        }
        function fromSeed(seed, network) {
            // ow(seed, ow.uint8Array);
            if (seed.length < 16)
                throw new TypeError('Seed should be at least 128 bits');
            if (seed.length > 64)
                throw new TypeError('Seed should be at most 512 bits');
            network = network || BITCOIN;
            const encoder = new TextEncoder();
            const I = hmacSHA512(encoder.encode('Bitcoin seed'), seed);
            const IL = I.slice(0, 32);
            const IR = I.slice(32);
            return fromPrivateKey(IL, IR, network);
        }
        return {
            fromSeed,
            fromBase58,
            fromPublicKey,
            fromPrivateKey,
        };
    }

    class HDNodeBIP32Adapter {
        hdNodeWallet;
        constructor(hdNodeWallet) {
            this.hdNodeWallet = hdNodeWallet;
        }
        get chainCode() {
            return getBytes(this.hdNodeWallet.chainCode);
        }
        get network() {
            throw 'Not implemented';
        }
        get depth() {
            return this.hdNodeWallet.depth;
        }
        get index() {
            return this.hdNodeWallet.index;
        }
        get parentFingerprint() {
            return parseInt(this.hdNodeWallet.parentFingerprint);
        }
        get privateKey() {
            return getBytes(this.hdNodeWallet.privateKey);
        }
        get identifier() {
            throw 'Not implemented';
        }
        get fingerprint() {
            throw 'Not implemented';
        }
        isNeutered() {
            throw 'Not implemented';
        }
        neutered() {
            throw 'Not implemented';
        }
        toBase58() {
            throw 'Not implemented';
        }
        // Map `derive` to `deriveChild`
        derive(index) {
            const derivedNode = this.hdNodeWallet.deriveChild(index);
            return new HDNodeBIP32Adapter(derivedNode);
        }
        deriveHardened(index) {
            throw 'Not implemented';
        }
        derivePath(path) {
            const derivedNode = this.hdNodeWallet.derivePath(path);
            return new HDNodeBIP32Adapter(derivedNode);
        }
        tweak(t) {
            throw 'Not implemented';
        }
        get publicKey() {
            return getBytes(this.hdNodeWallet.publicKey);
        }
        get lowR() {
            throw 'Not implemented';
        }
        sign(hash) {
            const sig = this.hdNodeWallet.signingKey.sign(hash);
            return getBytes(sig.serialized);
        }
        verify(hash, signature) {
            throw 'Not implemented';
        }
        signSchnorr(hash) {
            throw 'Not implemented';
        }
        verifySchnorr(hash, signature) {
            throw 'Not implemented';
        }
    }

    /**
     * The ConversionSelector class provides a coin selection algorithm that selects the fewest UTXOs required to meet the
     * target amount. This algorithm is useful for minimizing the size of the transaction and the fees associated with it.
     *
     * This class is a modified version of {@link FewestCoinSelector | **FewestCoinSelector** } and implements the
     * {@link FewestCoinSelector.createSpendOutputs | **createSpendOutputs** } method to provide the actual coin selection
     * logic.
     *
     * @category Transaction
     */
    class ConversionCoinSelector extends FewestCoinSelector {
        /**
         * Creates spend outputs based on the target amount and input denominations.
         *
         * @param {bigint} amount - The target amount to spend.
         * @returns {UTXO[]} The spend outputs.
         */
        createSpendOutputs(amount) {
            // Spend outpoints are not limited to max input denomination
            const spendDenominations = denominate(amount);
            return spendDenominations.map((denominationValue) => {
                const utxo = new UTXO();
                utxo.denomination = denominations.indexOf(denominationValue);
                return utxo;
            });
        }
    }

    /* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
    /**
     * Enum representing the status of an address in the wallet.
     *
     * @enum {string}
     */
    exports.AddressStatus = void 0;
    (function (AddressStatus) {
        AddressStatus["USED"] = "USED";
        AddressStatus["UNUSED"] = "UNUSED";
        AddressStatus["ATTEMPTED_USE"] = "ATTEMPTED_USE";
        AddressStatus["UNKNOWN"] = "UNKNOWN";
    })(exports.AddressStatus || (exports.AddressStatus = {}));
    /**
     * Current known issues:
     *
     * - When generating send addresses we are not checking if the address has already been used before
     * - When syncing is seems like we are adding way too many change addresses
     * - Bip44 external and change address maps also have gap addresses in them
     * - It is unclear if we have checked if addresses have been used and if they are used
     * - We should always check all addresses that were previously included in a transaction to see if they have been used
     */
    /**
     * The Qi HD wallet is a BIP44-compliant hierarchical deterministic wallet used for managing a set of addresses in the
     * Qi ledger. This is wallet implementation is the primary way to interact with the Qi UTXO ledger on the Quai network.
     *
     * The Qi HD wallet supports:
     *
     * - Adding accounts to the wallet heierchy
     * - Generating addresses for a specific account in any {@link Zone}
     * - Signing and sending transactions for any address in the wallet
     * - Serializing the wallet to JSON and deserializing it back to a wallet instance.
     *
     * @category Wallet
     * @example
     *
     * ```ts
     * import { QiHDWallet, Zone } from 'quais';
     * import { Outpoint } from '../../lib/commonjs/transaction/utxo';
     *
     * const wallet = new QiHDWallet();
     * const cyrpus1Address = await wallet.getNextAddress(0, Zone.Cyrpus1); // get the first address in the Cyrpus1 zone
     * await wallet.sendTransaction({ txInputs: [...], txOutputs: [...] }); // send a transaction
     * const serializedWallet = wallet.serialize(); // serialize current (account/address) state of the wallet
     * .
     * .
     * .
     * const deserializedWallet = QiHDWallet.deserialize(serializedWallet); // create a new wallet instance from the serialized data
     * ```
     */
    class QiHDWallet extends AbstractHDWallet {
        /**
         * @ignore
         * @type {number}
         */
        static _version = 1;
        /**
         * @ignore
         * @type {number}
         */
        static _GAP_LIMIT = 5;
        /**
         * @ignore
         * @type {AllowedCoinType}
         */
        static _coinType = 969;
        /**
         * @ignore
         * @type {string}
         */
        static PRIVATE_KEYS_PATH = 'privateKeys';
        /**
         * A map containing address information for all addresses known to the wallet. This includes:
         *
         * - BIP44 derived addresses (external)
         * - BIP44 derived change addresses
         * - BIP47 payment code derived addresses for receiving funds
         *
         * The key is the derivation path or payment code, and the value is an array of QiAddressInfo objects.
         *
         * @private
         * @type {Map<DerivationPath, QiAddressInfo[]>}
         */
        _addressesMap = new Map();
        /**
         * Array of outpoint information.
         *
         * @ignore
         * @type {OutpointInfo[]}
         */
        _availableOutpoints = new Map();
        /**
         * @ignore
         * @type {AddressUsageCallback}
         */
        _addressUseChecker;
        /**
         * A map containing address information for sending funds to counterparties using BIP47 payment codes.
         *
         * @remarks
         * The key is the receiver's payment code, and the value is an array of QiAddressInfo objects. These addresses are
         * derived from the receiver's payment code and are used only for sending funds. They are not part of the set of
         * addresses that this wallet can control or spend from. This map is used to keep track of addresses generated for
         * each payment channel to ensure proper address rotation and avoid address reuse when sending funds.
         * @private
         * @type {Map<string, QiAddressInfo[]>}
         */
        _paymentCodeSendAddressMap = new Map();
        /**
         * @ignore
         * @param {HDNodeWallet} root - The root HDNodeWallet.
         * @param {Provider} [provider] - The provider (optional).
         */
        constructor(guard, root, provider) {
            super(guard, root, provider);
            this._addressesMap.set('BIP44:external', []);
            this._addressesMap.set('BIP44:change', []);
            this._addressesMap.set(QiHDWallet.PRIVATE_KEYS_PATH, []);
        }
        /**
         * Gets the payment codes for all open channels.
         *
         * @returns {string[]} The payment codes for all open channels.
         */
        get openChannels() {
            return Array.from(this._addressesMap.keys()).filter((key) => !key.startsWith('BIP44:') && key !== QiHDWallet.PRIVATE_KEYS_PATH);
        }
        /**
         * Sets the address use checker. The provided callback function should accept an address as input and return a
         * boolean indicating whether the address is in use. If the callback returns true, the address is considered used
         * and if it returns false, the address is considered unused.
         *
         * @param {AddressUsageCallback} checker - The address use checker.
         */
        setAddressUseChecker(checker) {
            this._addressUseChecker = checker;
        }
        /**
         * Finds the last used index in an array of QiAddressInfo objects. If no index is found, returns -1.
         *
         * @param {QiAddressInfo[]} addresses - The array of QiAddressInfo objects.
         * @returns {number} The last used index.
         */
        _findLastUsedIndex(addresses, account, zone) {
            if (!addresses)
                return -1;
            return (addresses
                .filter((addressInfo) => addressInfo.account === account && addressInfo.zone === zone)
                .reduce((maxIndex, addressInfo) => Math.max(maxIndex, addressInfo.index), -1) || -1);
        }
        /**
         * Derives the next Qi BIP 44 address for the specified account and zone.
         *
         * @param {number} account - The account number.
         * @param {Zone} zone - The zone.
         * @param {boolean} isChange - Whether to derive a change address.
         * @returns {QiAddressInfo} The next Qi address information.
         */
        _getNextQiAddress(account, zone, isChange) {
            const derivationPath = isChange ? 'BIP44:change' : 'BIP44:external';
            const addresses = this._addressesMap.get(derivationPath) || [];
            const lastIndex = this._findLastUsedIndex(addresses, account, zone);
            const addressNode = this.deriveNextAddressNode(account, lastIndex + 1, zone, isChange);
            const newAddressInfo = this._createAndStoreQiAddressInfo(addressNode, account, zone, isChange);
            const privateKeysArray = this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH) || [];
            const existingPrivateKeyIndex = privateKeysArray.findIndex((info) => info.address === newAddressInfo.address);
            if (existingPrivateKeyIndex !== -1) {
                // Update the newAddressInfo directly with the status and last synced block from the private key address
                const pkAddressInfo = privateKeysArray[existingPrivateKeyIndex];
                newAddressInfo.status = pkAddressInfo.status;
                newAddressInfo.lastSyncedBlock = pkAddressInfo.lastSyncedBlock;
                // Remove the address from the privateKeysArray
                privateKeysArray.splice(existingPrivateKeyIndex, 1);
                this._addressesMap.set(QiHDWallet.PRIVATE_KEYS_PATH, privateKeysArray);
            }
            return newAddressInfo;
        }
        _createAndStoreQiAddressInfo(addressNode, account, zone, isChange) {
            const derivationPath = isChange ? 'BIP44:change' : 'BIP44:external';
            const qiAddressInfo = {
                zone,
                account,
                derivationPath,
                address: addressNode.address,
                pubKey: addressNode.publicKey,
                index: addressNode.index,
                change: isChange,
                status: exports.AddressStatus.UNKNOWN,
                lastSyncedBlock: null,
            };
            this._addressesMap.get(derivationPath).push(qiAddressInfo); // _addressesMap is initialized within the constructor
            return qiAddressInfo;
        }
        /**
         * Promise that resolves to the next address for the specified account and zone.
         *
         * @param {number} account - The account number.
         * @param {Zone} zone - The zone.
         * @returns {Promise<QiAddressInfo>} The next Qi address information.
         */
        async getNextAddress(account, zone) {
            return Promise.resolve(this.getNextAddressSync(account, zone));
        }
        /**
         * Synchronously retrieves the next address for the specified account and zone.
         *
         * @param {number} account - The account number.
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo} The next Qi address information.
         */
        getNextAddressSync(account, zone) {
            return this._getNextQiAddress(account, zone, false);
        }
        /**
         * Promise that resolves to the next change address for the specified account and zone.
         *
         * @param {number} account - The index of the account for which to retrieve the next change address.
         * @param {Zone} zone - The zone in which to retrieve the next change address.
         * @returns {Promise<NeuteredAddressInfo>} The next change neutered address information.
         */
        async getNextChangeAddress(account, zone) {
            return Promise.resolve(this.getNextChangeAddressSync(account, zone));
        }
        /**
         * Synchronously retrieves the next change address for the specified account and zone.
         *
         * @param {number} account - The index of the account for which to retrieve the next change address.
         * @param {Zone} zone - The zone in which to retrieve the next change address.
         * @returns {NeuteredAddressInfo} The next change neutered address information.
         */
        getNextChangeAddressSync(account, zone) {
            return this._getNextQiAddress(account, zone, true);
        }
        /**
         * Imports an array of outpoints.
         *
         * @param {OutpointInfo[]} outpoints - The outpoints to import.
         */
        importOutpoints(outpoints) {
            this.validateOutpointInfo(outpoints);
            for (const outpoint of outpoints) {
                const key = `${outpoint.outpoint.txhash}:${outpoint.outpoint.index}`;
                if (!this._availableOutpoints.has(key)) {
                    this._availableOutpoints.set(key, outpoint);
                }
            }
        }
        /**
         * Gets the outpoints for the specified zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {OutpointInfo[]} The outpoints for the zone.
         */
        getOutpoints(zone) {
            this.validateZone(zone);
            return Array.from(this._availableOutpoints.values()).filter((outpoint) => outpoint.zone === zone);
        }
        /**
         * Signs a Qi transaction and returns the serialized transaction.
         *
         * @param {QiTransactionRequest} tx - The transaction to sign.
         * @returns {Promise<string>} The serialized transaction.
         * @throws {Error} If the UTXO transaction is invalid.
         */
        async signTransaction(tx) {
            const txobj = QiTransaction.from(tx);
            if (!txobj.txInputs || txobj.txInputs.length == 0 || !txobj.txOutputs)
                throw new Error('Invalid UTXO transaction, missing inputs or outputs');
            const hash = getBytes(keccak256(txobj.unsignedSerialized));
            let signature;
            if (txobj.txInputs.length === 1) {
                signature = this.createSchnorrSignature(txobj.txInputs[0], hash);
            }
            else {
                signature = this.createMuSigSignature(txobj, hash);
            }
            txobj.signature = signature;
            return txobj.serialized;
        }
        /**
         * Locates the address information for the given address, searching through standard addresses, change addresses,
         * and payment channel addresses.
         *
         * @param {string} address - The address to locate.
         * @returns {QiAddressInfo | null} The address info or null if not found.
         */
        locateAddressInfo(address) {
            for (const [, addressInfos] of this._addressesMap.entries()) {
                const addressInfo = addressInfos.find((info) => info.address === address);
                if (addressInfo) {
                    return addressInfo;
                }
            }
            return null;
        }
        /**
         * Gets the total balance for the specified zone, including locked UTXOs.
         *
         * @param {Zone} zone - The zone to get the balance for.
         * @param {number} [blockNumber] - The block number to use for the lock check.
         * @param {boolean} useAvailableOutpoints - Whether to use available outpoints to calculate the balance.
         * @returns {Promise<bigint>} The total balance for the zone.
         */
        async getBalanceForZone(zone, blockNumber, useAvailableOutpoints = false) {
            if (!this.provider)
                throw new Error('Provider is not set');
            this.validateZone(zone);
            if (!blockNumber && useAvailableOutpoints) {
                blockNumber = await this.provider.getBlockNumber(toShard(zone));
            }
            return ((await this.getSpendableBalanceForZone(zone, blockNumber, useAvailableOutpoints)) +
                (await this.getLockedBalanceForZone(zone, blockNumber, useAvailableOutpoints)));
        }
        /**
         * Gets the **spendable** balance for the specified zone by calling {@link getBalance} for all known addresses in the
         * zone.
         *
         * @param {Zone} zone - The zone to get the balance for.
         * @param {boolean} useAvailableOutpoints - Whether to use available outpoints to calculate the balance.
         * @returns {bigint} The spendable balance for the zone.
         */
        async getSpendableBalanceForZone(zone, blockNumber, useAvailableOutpoints = false) {
            if (!this.provider)
                throw new Error('Provider is not set');
            this.validateZone(zone);
            if (useAvailableOutpoints) {
                if (!blockNumber) {
                    blockNumber = await this.provider.getBlockNumber(toShard(zone));
                }
                return this._calculateAvailableOutpointSpendableBalanceForZone(zone, blockNumber);
            }
            return this._fetchSpendableBalanceForZone(zone);
        }
        /**
         * Gets the **locked** balance for the specified zone by calling {@link getLockedBalance} for all known addresses in
         * the zone.
         *
         * @param {Zone} zone - The zone to get the balance for.
         * @param {boolean} useAvailableOutpoints - Whether to use available outpoints to calculate the balance.
         * @returns {bigint} The locked balance for the zone.
         */
        async getLockedBalanceForZone(zone, blockNumber, useAvailableOutpoints = false) {
            if (!this.provider)
                throw new Error('Provider is not set');
            this.validateZone(zone);
            if (useAvailableOutpoints) {
                if (!blockNumber) {
                    blockNumber = await this.provider.getBlockNumber(toShard(zone));
                }
                return this._calculateAvailableOutpointLockedBalanceForZone(zone, blockNumber);
            }
            return this._fetchLockedBalanceForZone(zone);
        }
        /**
         * Gets the spendable balance for the specified zone by calling {@link getBalance} for all known addresses in the
         * zone.
         *
         * @param {Zone} zone - The zone to get the spendable balance for.
         * @returns {bigint} The spendable balance for the zone.
         */
        async _fetchSpendableBalanceForZone(zone) {
            const balanceMethod = async (address) => this.provider?.getBalance(address, 'latest') || BigInt(0);
            return this._fetchBalanceForZone(zone, balanceMethod);
        }
        /**
         * Gets the locked balance for the specified zone by calling {@link getLockedBalance} for all known addresses in the
         * zone.
         *
         * @param {Zone} zone - The zone to get the locked balance for.
         * @returns {bigint} The locked balance for the zone.
         */
        async _fetchLockedBalanceForZone(zone) {
            const balanceMethod = async (address) => this.provider?.getLockedBalance(address) || BigInt(0);
            return this._fetchBalanceForZone(zone, balanceMethod);
        }
        /**
         * Fetches the balance for the specified zone by calling the provided balance method for all known addresses in the
         * zone.
         *
         * @param {Zone} zone - The zone to get the balance for.
         * @param {Function} balanceMethod - The method to call to get the balance for each address.
         * @returns {Promise<bigint>} The balance for the zone.
         */
        async _fetchBalanceForZone(zone, balanceMethod) {
            const allAddresses = Array.from(this._addressesMap.values())
                .flat()
                .filter((address) => address.zone === zone);
            const allBalances = await Promise.all(allAddresses.map((address) => balanceMethod(address.address) ?? BigInt(0)));
            return allBalances.reduce((total, balance) => BigInt(total) + BigInt(balance), BigInt(0));
        }
        /**
         * Gets the spendable balance for the specified zone using the available outpoints.
         *
         * @param {Zone} zone - The zone to get the spendable balance for.
         * @param {number} [blockNumber] - The block number to use for the lock check.
         * @returns {bigint} The spendable balance for the zone.
         */
        async _calculateAvailableOutpointSpendableBalanceForZone(zone, blockNumber) {
            return this.getOutpoints(zone)
                .filter((utxo) => utxo.outpoint.lock === 0 || utxo.outpoint.lock < blockNumber)
                .reduce((total, utxo) => {
                const denominationValue = denominations[utxo.outpoint.denomination];
                return total + denominationValue;
            }, BigInt(0));
        }
        /**
         * Gets the locked balance for the specified zone using the available outpoints.
         *
         * @param {Zone} zone - The zone to get the locked balance for.
         * @param {number} [blockNumber] - The block number to use for the lock check.
         * @returns {bigint} The locked balance for the zone.
         */
        async _calculateAvailableOutpointLockedBalanceForZone(zone, blockNumber) {
            return this.getOutpoints(zone)
                .filter((utxo) => utxo.outpoint.lock !== 0 && blockNumber < utxo.outpoint.lock)
                .reduce((total, utxo) => {
                const denominationValue = denominations[utxo.outpoint.denomination];
                return total + denominationValue;
            }, BigInt(0));
        }
        /**
         * Converts outpoints for a specific zone to UTXO format.
         *
         * @param {Zone} zone - The zone to filter outpoints for.
         * @returns {UTXO[]} An array of UTXO objects.
         */
        outpointsToUTXOs(zone) {
            return this.getOutpoints(zone).map((outpointInfo) => {
                const utxo = new UTXO();
                utxo.txhash = outpointInfo.outpoint.txhash;
                utxo.index = outpointInfo.outpoint.index;
                utxo.address = outpointInfo.address;
                utxo.denomination = outpointInfo.outpoint.denomination;
                utxo.lock = outpointInfo.outpoint.lock ?? null;
                return utxo;
            });
        }
        /**
         * Converts an amount of Qi to Quai and sends it to a specified Quai address.
         *
         * @param {string} destinationAddress - The Quai address to send the converted Quai to.
         * @param {bigint} amount - The amount of Qi to convert to Quai.
         * @returns {Promise<TransactionResponse>} A promise that resolves to the transaction response.
         * @throws {Error} If the destination address is invalid, the amount is zero, or the conversion fails.
         */
        async convertToQuai(destinationAddress, amount) {
            const zone = getZoneForAddress(destinationAddress);
            if (!zone) {
                throw new Error(`Invalid zone for Quai address: ${destinationAddress}`);
            }
            if (isQiAddress(destinationAddress)) {
                throw new Error(`Invalid Quai address: ${destinationAddress}`);
            }
            if (amount <= 0) {
                throw new Error('Amount must be greater than 0');
            }
            const getDestinationAddresses = async (count) => {
                return Array(count).fill(destinationAddress);
            };
            return this.prepareAndSendTransaction(amount, zone, getDestinationAddresses, (utxos) => new ConversionCoinSelector(utxos));
        }
        /**
         * Sends a transaction to a specified recipient payment code in a specified zone.
         *
         * @param {string} recipientPaymentCode - The payment code of the recipient.
         * @param {bigint} amount - The amount of Qi to send.
         * @param {Zone} originZone - The zone where the transaction originates.
         * @param {Zone} destinationZone - The zone where the transaction is sent.
         * @returns {Promise<TransactionResponse>} A promise that resolves to the transaction response.
         * @throws {Error} If the payment code is invalid, the amount is zero, or the zones are invalid.
         */
        async sendTransaction(recipientPaymentCode, amount, originZone, destinationZone) {
            if (!validatePaymentCode(recipientPaymentCode)) {
                throw new Error('Invalid payment code');
            }
            if (amount <= 0) {
                throw new Error('Amount must be greater than 0');
            }
            this.validateZone(originZone);
            this.validateZone(destinationZone);
            const getDestinationAddresses = async (count) => {
                const addresses = [];
                while (addresses.length < count) {
                    const address = this.getNextSendAddress(recipientPaymentCode, destinationZone).address;
                    const { isUsed } = await this.checkAddressUse(address);
                    if (!isUsed) {
                        addresses.push(address);
                    }
                }
                return addresses;
            };
            return this.prepareAndSendTransaction(amount, originZone, getDestinationAddresses, (utxos) => new FewestCoinSelector(utxos));
        }
        /**
         * Aggregates all the available UTXOs for the specified zone and account. This method creates a new transaction with
         * all the available UTXOs as inputs and as fewest outputs as possible.
         *
         * @param {Zone} zone - The zone to aggregate the balance for.
         * @returns {Promise<TransactionResponse>} The transaction response.
         */
        async aggregate(zone) {
            this.validateZone(zone);
            if (!this.provider) {
                throw new Error('Provider is not set');
            }
            const zoneUTXOs = this.outpointsToUTXOs(zone);
            if (zoneUTXOs.length === 0) {
                throw new Error('No UTXOs available in zone.');
            }
            const aggregateCoinSelector = new AggregateCoinSelector(zoneUTXOs);
            // TODO: Calculate mempool max fee
            const fee = BigInt(1000); // temporary hardcode fee to 1 Qi
            const selection = aggregateCoinSelector.performSelection({ fee, maxDenomination: 6, includeLocked: false });
            const sendAddressesInfo = this._getUnusedBIP44Addresses(1, 0, 'BIP44:external', zone);
            const sendAddresses = sendAddressesInfo.map((addressInfo) => addressInfo.address);
            const changeAddresses = [];
            const inputPubKeys = selection.inputs.map((input) => {
                const addressInfo = this.locateAddressInfo(input.address);
                if (!addressInfo) {
                    throw new Error(`Could not locate address info for address: ${input.address}`);
                }
                return addressInfo.pubKey;
            });
            // Proceed with creating and signing the transaction
            const chainId = (await this.provider.getNetwork()).chainId;
            const tx = await this.prepareTransaction(selection, inputPubKeys, sendAddresses, changeAddresses, Number(chainId));
            // Sign the transaction
            const signedTx = await this.signTransaction(tx);
            // Broadcast the transaction to the network using the provider
            return this.provider.broadcastTransaction(zone, signedTx);
        }
        /**
         * Prepares and sends a transaction with the specified parameters.
         *
         * @private
         * @param {bigint} amount - The amount of Qi to send.
         * @param {Zone} originZone - The zone where the transaction originates.
         * @param {Function} getDestinationAddresses - A function that returns a promise resolving to an array of
         *   destination addresses.
         * @returns {Promise<TransactionResponse>} A promise that resolves to the transaction response.
         * @throws {Error} If provider is not set, insufficient balance, no available UTXOs, or insufficient spendable
         *   balance.
         */
        async prepareAndSendTransaction(amount, originZone, getDestinationAddresses, coinSelectorCreator) {
            if (!this.provider) {
                throw new Error('Provider is not set');
            }
            // 1. Check the wallet has enough balance in the originating zone to send the transaction
            const currentBlock = await this.provider.getBlock(toShard(originZone), 'latest');
            const balance = await this.getSpendableBalanceForZone(originZone, currentBlock?.woHeader.number, true);
            if (balance < amount) {
                throw new Error(`Insufficient balance in the originating zone: want ${Number(amount) / 1000} Qi got ${balance} Qi`);
            }
            // 2. Select the UXTOs from the specified zone to use as inputs, and generate the spend and change outputs
            const zoneUTXOs = this.outpointsToUTXOs(originZone);
            if (zoneUTXOs.length === 0) {
                throw new Error('No Qi available in zone.');
            }
            const unlockedUTXOs = zoneUTXOs.filter((utxo) => utxo.lock === 0 || utxo.lock < currentBlock?.woHeader.number);
            if (unlockedUTXOs.length === 0) {
                throw new Error('Insufficient spendable balance in zone.');
            }
            const coinSelector = coinSelectorCreator(unlockedUTXOs);
            const spendTarget = amount;
            let selection = coinSelector.performSelection({ target: spendTarget });
            // 3. Generate as many unused addresses as required to populate the spend outputs
            const sendAddresses = await getDestinationAddresses(selection.spendOutputs.length);
            const getChangeAddressesForOutputs = async (count) => {
                const currentChangeAddresses = this._addressesMap.get('BIP44:change') || [];
                const outputChangeAddresses = [];
                for (let i = 0; i < currentChangeAddresses.length; i++) {
                    if (currentChangeAddresses[i].status === exports.AddressStatus.UNUSED) {
                        outputChangeAddresses.push(currentChangeAddresses[i]);
                    }
                    if (outputChangeAddresses.length === count)
                        break;
                }
                // Generate the remaining number of change addresses if needed
                const remainingAddressesNeeded = count - outputChangeAddresses.length;
                if (remainingAddressesNeeded > 0) {
                    outputChangeAddresses.push(...Array(remainingAddressesNeeded)
                        .fill(0)
                        .map(() => this.getNextChangeAddressSync(0, originZone)));
                }
                // Combine the existing change addresses with the newly generated addresses and ensure they are unique and sorted by index
                const mergedChangeAddresses = [
                    // Not updated last synced block because we are not certain of the success of the transaction
                    // so we will want to get deltas from last **checked** block
                    ...outputChangeAddresses.map((address) => ({
                        ...address,
                        status: exports.AddressStatus.ATTEMPTED_USE,
                    })),
                    ...currentChangeAddresses,
                ];
                const sortedAndFilteredChangeAddresses = mergedChangeAddresses
                    .filter((address, index, self) => self.findIndex((t) => t.address === address.address) === index)
                    .sort((a, b) => a.index - b.index);
                // Update the _addressesMap with the modified change addresses and statuses
                this._addressesMap.set('BIP44:change', sortedAndFilteredChangeAddresses);
                return outputChangeAddresses.map((address) => address.address);
            };
            // 4. Get change addresses
            const changeAddresses = await getChangeAddressesForOutputs(selection.changeOutputs.length);
            // 5. Create the transaction and sign it using the signTransaction method
            let inputPubKeys = selection.inputs.map((input) => this.locateAddressInfo(input.address)?.pubKey);
            if (inputPubKeys.some((pubkey) => !pubkey)) {
                throw new Error('Missing public key for input address');
            }
            let attempts = 0;
            const MAX_FEE_ESTIMATION_ATTEMPTS = 5;
            while (attempts < MAX_FEE_ESTIMATION_ATTEMPTS) {
                const feeEstimationTx = this.prepareFeeEstimationTransaction(selection, inputPubKeys.map((pubkey) => pubkey), sendAddresses, changeAddresses);
                const estimatedFee = await this.provider.estimateFeeForQi(feeEstimationTx);
                // Get new selection with updated fee 2x
                selection = coinSelector.performSelection({ target: spendTarget, fee: estimatedFee * 3n });
                // Determine if new addresses are needed for the change outputs
                const changeAddressesNeeded = selection.changeOutputs.length - changeAddresses.length;
                if (changeAddressesNeeded > 0) {
                    // Need more change addresses
                    const newChangeAddresses = await getChangeAddressesForOutputs(changeAddressesNeeded);
                    changeAddresses.push(...newChangeAddresses);
                }
                else if (changeAddressesNeeded < 0) {
                    // Have extra change addresses, remove the excess
                    const addressesToSetToUnused = changeAddresses.slice(changeAddressesNeeded);
                    // Set the status of the addresses back to UNUSED in _addressesMap for removed addresses
                    const changeAddressesMap = this._addressesMap.get('BIP44:change');
                    const updatedChangeAddressesMap = changeAddressesMap.map((a) => {
                        if (addressesToSetToUnused.includes(a.address)) {
                            return { ...a, status: exports.AddressStatus.UNUSED };
                        }
                        return a;
                    });
                    this._addressesMap.set('BIP44:change', updatedChangeAddressesMap);
                }
                // Determine if new addresses are needed for the spend outputs
                const spendAddressesNeeded = selection.spendOutputs.length - sendAddresses.length;
                if (spendAddressesNeeded > 0) {
                    // Need more send addresses
                    const newSendAddresses = await getDestinationAddresses(spendAddressesNeeded);
                    sendAddresses.push(...newSendAddresses);
                }
                else if (spendAddressesNeeded < 0) {
                    // It would be great to reset the status of the addresses to UNUSED in _addressesMap but we do not
                    // know exactly how these addresses are derived, so we just remove them from the array
                    sendAddresses.slice(spendAddressesNeeded);
                }
                inputPubKeys = selection.inputs.map((input) => this.locateAddressInfo(input.address)?.pubKey);
                // Calculate total new outputs needed (absolute value)
                const totalNewOutputsNeeded = Math.abs(changeAddressesNeeded) + Math.abs(spendAddressesNeeded);
                // If we need 5 or fewer new outputs, we can break the loop
                if ((changeAddressesNeeded <= 0 && spendAddressesNeeded <= 0) || totalNewOutputsNeeded <= 5) {
                    break;
                }
                attempts++;
            }
            // Proceed with creating and signing the transaction
            const chainId = (await this.provider.getNetwork()).chainId;
            const tx = await this.prepareTransaction(selection, inputPubKeys.map((pubkey) => pubkey), sendAddresses, changeAddresses, Number(chainId));
            // Sign the transaction
            const signedTx = await this.signTransaction(tx);
            // Broadcast the transaction to the network using the provider
            return this.provider.broadcastTransaction(originZone, signedTx);
        }
        /**
         * Prepares a transaction with the specified parameters.
         *
         * @private
         * @param {SelectedCoinsResult} selection - The selected coins result.
         * @param {string[]} inputPubKeys - The public keys of the inputs.
         * @param {string[]} sendAddresses - The addresses to send to.
         * @param {string[]} changeAddresses - The addresses to change to.
         * @param {number} chainId - The chain ID.
         * @returns {Promise<QiTransaction>} A promise that resolves to the prepared transaction.
         */
        async prepareTransaction(selection, inputPubKeys, sendAddresses, changeAddresses, chainId) {
            const tx = new QiTransaction();
            tx.txInputs = selection.inputs.map((input, index) => ({
                txhash: input.txhash,
                index: input.index,
                pubkey: inputPubKeys[index],
            }));
            // 5.3 Create the "sender" outputs
            const senderOutputs = selection.spendOutputs.map((output, index) => ({
                address: sendAddresses[index],
                denomination: output.denomination,
            }));
            // 5.4 Create the "change" outputs
            const changeOutputs = selection.changeOutputs.map((output, index) => ({
                address: changeAddresses[index],
                denomination: output.denomination,
            }));
            tx.txOutputs = [...senderOutputs, ...changeOutputs].map((output) => ({
                address: output.address,
                denomination: output.denomination,
            }));
            tx.chainId = chainId;
            return tx;
        }
        /**
         * Prepares a fee estimation transaction with the specified parameters.
         *
         * @private
         * @param {SelectedCoinsResult} selection - The selected coins result.
         * @param {string[]} inputPubKeys - The public keys of the inputs.
         * @param {string[]} sendAddresses - The addresses to send to.
         * @param {string[]} changeAddresses - The addresses to change to.
         * @returns {QiPerformActionTransaction} The prepared transaction.
         */
        prepareFeeEstimationTransaction(selection, inputPubKeys, sendAddresses, changeAddresses) {
            const txIn = selection.inputs.map((input, index) => ({
                previousOutpoint: { txHash: input.txhash, index: toQuantity(input.index) },
                pubkey: inputPubKeys[index],
            }));
            // 5.3 Create the "sender" outputs
            const senderOutputs = selection.spendOutputs.map((output, index) => ({
                address: sendAddresses[index],
                denomination: output.denomination,
            }));
            // 5.4 Create the "change" outputs
            const changeOutputs = selection.changeOutputs.map((output, index) => ({
                address: changeAddresses[index],
                denomination: output.denomination,
            }));
            const txOut = [...senderOutputs, ...changeOutputs].map((output) => ({
                address: output.address,
                denomination: toQuantity(output.denomination),
            }));
            return {
                txType: 2,
                txIn,
                txOut,
            };
        }
        /**
         * Gets a set of unused BIP44 addresses from the specified derivation path. It first checks if there are any unused
         * addresses available in the _addressesMap and uses those if possible. If there are not enough unused addresses, it
         * will generate new ones.
         *
         * @param amount - The number of addresses to get.
         * @param path - The derivation path to get addresses from.
         * @param zone - The zone to get addresses from.
         * @returns An array of addresses.
         */
        _getUnusedBIP44Addresses(amount, account, path, zone) {
            const addresses = this._addressesMap.get(path) || [];
            const unusedAddresses = addresses.filter((address) => address.status === exports.AddressStatus.UNUSED && address.account === account && address.zone === zone);
            if (unusedAddresses.length >= amount) {
                return unusedAddresses.slice(0, amount);
            }
            const remainingAddressesNeeded = amount - unusedAddresses.length;
            const isChange = path === 'BIP44:change';
            const newAddresses = Array.from({ length: remainingAddressesNeeded }, () => this._getNextQiAddress(account, zone, isChange));
            return [...unusedAddresses, ...newAddresses];
        }
        /**
         * Returns a schnorr signature for the given message and private key.
         *
         * @ignore
         * @param {TxInput} input - The transaction input.
         * @param {Uint8Array} hash - The hash of the message.
         * @returns {string} The schnorr signature.
         */
        createSchnorrSignature(input, hash) {
            const privKey = this.getPrivateKeyForTxInput(input);
            const signature = schnorr.sign(hash, getBytes(privKey));
            return hexlify(signature);
        }
        /**
         * Returns a MuSig signature for the given message and private keys corresponding to the input addresses.
         *
         * @ignore
         * @param {QiTransaction} tx - The Qi transaction.
         * @param {Uint8Array} hash - The hash of the message.
         * @returns {string} The MuSig signature.
         */
        createMuSigSignature(tx, hash) {
            const musig = MuSigFactory(musigCrypto);
            // Collect private keys corresponding to the pubkeys found on the inputs
            const privKeys = tx.txInputs.map((input) => this.getPrivateKeyForTxInput(input));
            // Create an array of public keys corresponding to the private keys for musig aggregation
            const pubKeys = privKeys
                .map((privKey) => musigCrypto.getPublicKey(getBytes(privKey), true))
                .filter((pubKey) => pubKey !== null);
            // Generate nonces for each public key
            const nonces = pubKeys.map((pk) => musig.nonceGen({ publicKey: getBytes(pk) }));
            const aggNonce = musig.nonceAgg(nonces);
            const signingSession = musig.startSigningSession(aggNonce, hash, pubKeys);
            // Create partial signatures for each private key
            const partialSignatures = privKeys.map((sk, index) => musig.partialSign({
                secretKey: getBytes(sk || ''),
                publicNonce: nonces[index],
                sessionKey: signingSession,
                verify: true,
            }));
            // Aggregate the partial signatures into a final aggregated signature
            const finalSignature = musig.signAgg(partialSignatures, signingSession);
            return hexlify(finalSignature);
        }
        /**
         * Retrieves the private key for a given transaction input.
         *
         * This method derives the private key for a transaction input by locating the address info and then deriving the
         * private key based on where the address info was found:
         *
         * - For BIP44 addresses (standard or change), it uses the HD wallet to derive the private key.
         * - For payment channel addresses (BIP47), it uses PaymentCodePrivate to derive the private key.
         *
         * @param {TxInput} input - The transaction input containing the public key.
         * @returns {string} The private key corresponding to the transaction input.
         * @throws {Error} If the input does not contain a public key or if the address information cannot be found.
         */
        getPrivateKeyForTxInput(input) {
            if (!input.pubkey)
                throw new Error('Missing public key for input');
            const address = computeAddress(input.pubkey);
            return this.getPrivateKey(address);
        }
        /**
         * Returns the private key for a given address. This method should be used with caution as it exposes the private
         * key to the user.
         *
         * @param {string} address - The address associated with the desired private key.
         * @returns {string} The private key.
         */
        getPrivateKey(address) {
            const addressInfo = this.locateAddressInfo(address);
            if (!addressInfo) {
                throw new Error(`Address not found: ${address}`);
            }
            // Handle imported private keys
            if (isHexString(addressInfo.derivationPath, 32)) {
                return addressInfo.derivationPath;
            }
            if (addressInfo.derivationPath === 'BIP44:external' || addressInfo.derivationPath === 'BIP44:change') {
                // (BIP44 addresses)
                const addressNode = this._getAddressNode(addressInfo.account, addressInfo.change, addressInfo.index);
                return addressNode.privateKey;
            }
            else {
                // (BIP47 addresses)
                const pcAddressInfo = addressInfo;
                const account = pcAddressInfo.account;
                const index = pcAddressInfo.index;
                const counterpartyPaymentCode = pcAddressInfo.derivationPath;
                if (!counterpartyPaymentCode) {
                    throw new Error('Counterparty payment code not found for payment channel address');
                }
                const bip32 = BIP32Factory(ecc);
                const buf = bs58check.decode(counterpartyPaymentCode);
                const version = buf[0];
                if (version !== PC_VERSION)
                    throw new Error('Invalid payment code version');
                const counterpartyPCodePublic = new PaymentCodePublic(ecc, bip32, buf.slice(1));
                const paymentCodePrivate = this._getPaymentCodePrivate(account);
                const paymentPrivateKey = paymentCodePrivate.derivePaymentPrivateKey(counterpartyPCodePublic, index);
                return hexlify(paymentPrivateKey);
            }
        }
        /**
         * Scans the specified zone for addresses with unspent outputs. Starting at index 0, it will generate new addresses
         * until the gap limit is reached for external and change BIP44 addresses and payment channel addresses.
         *
         * @param {Zone} zone - The zone in which to scan for addresses.
         * @param {number} [account=0] - The index of the account to scan. Default is `0`
         * @returns {Promise<void>} A promise that resolves when the scan is complete.
         * @throws {Error} If the zone is invalid.
         */
        async scan(zone, account = 0) {
            this.validateZone(zone);
            // set status of all addresses to unknown
            this._addressesMap = new Map(Array.from(this._addressesMap.entries()).map(([key, addresses]) => [
                key,
                addresses.map((addr) => ({ ...addr, status: exports.AddressStatus.UNKNOWN, lastSyncedBlock: null })),
            ]));
            // flush available
            this._availableOutpoints.clear();
            // Reset each map so that all keys have empty array values but keys are preserved
            this._paymentCodeSendAddressMap = new Map(Array.from(this._paymentCodeSendAddressMap.keys()).map((key) => [key, []]));
            await this._scan(zone, account);
        }
        /**
         * Scans the specified zone for addresses with unspent outputs. Starting at the last address index, it will generate
         * new addresses until the gap limit is reached for external and change BIP44 addresses and payment channel
         * addresses.
         *
         * @param {Zone} zone - The zone in which to sync addresses.
         * @param {number} [account=0] - The index of the account to sync. Default is `0`
         * @returns {Promise<void>} A promise that resolves when the sync is complete.
         * @throws {Error} If the zone is invalid.
         */
        async sync(zone, account = 0, onOutpointsCreated, onOutpointsDeleted) {
            this.validateZone(zone);
            await this._scan(zone, account, onOutpointsCreated, onOutpointsDeleted);
        }
        /**
         * Internal method to scan the specified zone for addresses with unspent outputs. This method handles the actual
         * scanning logic, generating new addresses until the gap limit is reached for both gap and change addresses.
         *
         * @param {Zone} zone - The zone in which to scan for addresses.
         * @param {number} [account=0] - The index of the account to scan. Default is `0`
         * @param {Function} [onCreate] - A callback function that is called when a new address is created.
         * @param {Function} [onDelete] - A callback function that is called when an address is deleted.
         * @returns {Promise<void>} A promise that resolves when the scan is complete.
         * @throws {Error} If the provider is not set.
         */
        async _scan(zone, account = 0, onOutpointsCreated, onOutpointsDeleted) {
            if (!this.provider)
                throw new Error('Provider not set');
            const derivationPaths = ['BIP44:external', 'BIP44:change', ...this.openChannels];
            const currentBlock = (await this.provider.getBlock(toShard(zone), 'latest'));
            for (const path of derivationPaths) {
                await this._scanDerivationPath(path, zone, account, currentBlock, false, onOutpointsCreated, onOutpointsDeleted);
                // Yield control back to the event loop
                await new Promise((resolve) => setTimeout(resolve, 0));
            }
            await this._scanDerivationPath(QiHDWallet.PRIVATE_KEYS_PATH, zone, account, currentBlock, true, onOutpointsCreated, onOutpointsDeleted);
        }
        /**
         * Scans for the next address in the specified zone and account, checking for associated outpoints, and updates the
         * address count and gap addresses accordingly.
         *
         * @param {Zone} zone - The zone in which the address is being scanned.
         * @param {number} account - The index of the account for which the address is being scanned.
         * @param {boolean} isChange - A flag indicating whether the address is a change address.
         * @returns {Promise<void>} A promise that resolves when the scan is complete.
         * @throws {Error} If an error occurs during the address scanning or outpoints retrieval process.
         */
        async _scanDerivationPath(path, zone, account, currentBlock, skipGap = false, onOutpointsCreated, onOutpointsDeleted) {
            const addresses = this._addressesMap.get(path) || [];
            const updatedAddresses = [];
            const createdOutpoints = {};
            const deletedOutpoints = {};
            // Addresses with a last synced block are checked for outpoint deltas
            const previouslySyncedAddresses = [];
            const unsyncedAddresses = [];
            for (const addr of addresses) {
                if (addr.lastSyncedBlock !== null) {
                    previouslySyncedAddresses.push(addr);
                }
                else {
                    unsyncedAddresses.push(addr);
                }
            }
            if (previouslySyncedAddresses.length > 0) {
                // get all unique txhashes from used addresses last synced block to current block
                const addressesByLastSyncedTxHash = {};
                for (const addr of previouslySyncedAddresses) {
                    if (addr.lastSyncedBlock?.hash) {
                        if (!addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash]) {
                            addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash] = [addr.address];
                        }
                        else {
                            addressesByLastSyncedTxHash[addr.lastSyncedBlock.hash].push(addr.address);
                        }
                    }
                }
                // Get outpoint deltas for each unique txhash
                const deltasBatches = await Promise.all(Object.entries(addressesByLastSyncedTxHash).map(([txHash, addresses]) => this.provider.getOutpointDeltas(addresses, txHash)));
                // combine deltas into single object
                const deltas = {};
                for (const deltaBatch of deltasBatches) {
                    for (const [address, delta] of Object.entries(deltaBatch)) {
                        if (!deltas[address]) {
                            deltas[address] = { created: delta.created, deleted: delta.deleted };
                        }
                        else {
                            deltas[address].created.push(...delta.created);
                            deltas[address].deleted.push(...delta.deleted);
                        }
                    }
                }
                // Process deltas
                for (const [address, delta] of Object.entries(deltas)) {
                    const addressInfo = addresses.find((a) => a.address === address);
                    const updatedAddressInfo = {
                        ...addressInfo,
                        lastSyncedBlock: {
                            hash: currentBlock.hash,
                            number: currentBlock.woHeader.number,
                        },
                    };
                    // Handle created outpoints
                    if (delta.created && delta.created.length > 0) {
                        this.importOutpoints(delta.created.map((outpoint) => ({
                            outpoint,
                            address,
                            zone,
                            account,
                        })));
                        createdOutpoints[address] = delta.created;
                        // set address status to used even if it may have already has this status
                        updatedAddressInfo.status = exports.AddressStatus.USED;
                    }
                    // Handle deleted outpoints
                    if (delta.deleted && delta.deleted.length > 0) {
                        // Remove corresponding outpoints from availableOutpoints
                        for (const outpoint of delta.deleted) {
                            this._availableOutpoints.delete(`${outpoint.txhash}:${outpoint.index}`);
                        }
                        deletedOutpoints[address] = delta.deleted;
                    }
                    updatedAddresses.push(updatedAddressInfo);
                }
            }
            let consecutiveUnusedCount = 0;
            // Check unsynced addresses for outpoints
            // Batch check unsynced addresses for outpoints
            if (unsyncedAddresses.length > 0) {
                const checkAddressUsePromises = unsyncedAddresses.map((addr) => this.checkAddressUse(addr.address));
                const checkResults = await Promise.all(checkAddressUsePromises);
                for (let i = 0; i < unsyncedAddresses.length; i++) {
                    const addr = unsyncedAddresses[i];
                    const { isUsed, outpoints } = checkResults[i];
                    addr.status = isUsed ? exports.AddressStatus.USED : exports.AddressStatus.UNUSED;
                    addr.lastSyncedBlock = {
                        hash: currentBlock.hash,
                        number: currentBlock.woHeader.number,
                    };
                    // Import outpoints if any are found
                    if (outpoints.length > 0) {
                        this.importOutpoints(outpoints.map((outpoint) => ({
                            outpoint,
                            address: addr.address,
                            zone: addr.zone,
                            account: addr.account,
                        })));
                        createdOutpoints[addr.address] = outpoints;
                    }
                    if (addr.status === exports.AddressStatus.USED) {
                        consecutiveUnusedCount = 0;
                    }
                    else {
                        consecutiveUnusedCount++;
                    }
                    updatedAddresses.push(addr);
                    // If the consecutive unused count has reached the gap limit, break
                    if (consecutiveUnusedCount >= QiHDWallet._GAP_LIMIT)
                        break;
                }
            }
            if (!skipGap) {
                // Generate new addresses if needed until the gap limit is reached
                while (consecutiveUnusedCount < QiHDWallet._GAP_LIMIT) {
                    const isChange = path.endsWith(':change');
                    // Determine how many addresses to generate in this batch
                    const remainingGap = QiHDWallet._GAP_LIMIT - consecutiveUnusedCount;
                    // Generate 'remainingGap' addresses
                    const newAddresses = [];
                    for (let i = 0; i < remainingGap; i++) {
                        const newAddrInfo = path.includes('BIP44')
                            ? this._getNextQiAddress(account, zone, isChange)
                            : this.getNextReceiveAddress(path, zone, account);
                        newAddresses.push(newAddrInfo);
                    }
                    // Batch check the new addresses for use
                    const checkAddressUsePromises = newAddresses.map((addr) => this.checkAddressUse(addr.address));
                    const checkResults = await Promise.all(checkAddressUsePromises);
                    // Process the results
                    for (let i = 0; i < newAddresses.length; i++) {
                        const newAddrInfo = newAddresses[i];
                        const { isUsed, outpoints } = checkResults[i];
                        newAddrInfo.status = isUsed ? exports.AddressStatus.USED : exports.AddressStatus.UNUSED;
                        newAddrInfo.lastSyncedBlock = {
                            hash: currentBlock.hash,
                            number: currentBlock.woHeader.number,
                        };
                        // Import outpoints if any are found
                        if (outpoints.length > 0) {
                            this.importOutpoints(outpoints.map((outpoint) => ({
                                outpoint,
                                address: newAddrInfo.address,
                                zone: newAddrInfo.zone,
                                account: newAddrInfo.account,
                            })));
                            createdOutpoints[newAddrInfo.address] = outpoints;
                        }
                        if (newAddrInfo.status === exports.AddressStatus.USED) {
                            consecutiveUnusedCount = 0;
                        }
                        else {
                            consecutiveUnusedCount++;
                        }
                        addresses.push(newAddrInfo);
                        // Check if the consecutive unused count has reached the gap limit
                        if (consecutiveUnusedCount >= QiHDWallet._GAP_LIMIT) {
                            break;
                        }
                    }
                    // Yield control back to the event loop after each iteration
                    await new Promise((resolve) => setTimeout(resolve, 0));
                }
            }
            // Create a map to track unique addresses
            const uniqueAddressMap = new Map();
            // Process addresses in order, with updated addresses taking precedence
            addresses.forEach((addr) => {
                const updatedAddr = updatedAddresses.find((a) => a.address === addr.address);
                uniqueAddressMap.set(addr.address, updatedAddr || addr);
            });
            // Convert map values back to array
            const updatedAddressesForMap = Array.from(uniqueAddressMap.values());
            this._addressesMap.set(path, updatedAddressesForMap);
            const executeCreatedOutpointsCallback = async () => {
                if (onOutpointsCreated && Object.keys(createdOutpoints).length > 0) {
                    try {
                        await onOutpointsCreated(createdOutpoints);
                    }
                    catch (error) {
                        console.error(`Error in onOutpointsCreated callback: ${error.message}`);
                    }
                }
            };
            const executeDeletedOutpointsCallback = async () => {
                if (onOutpointsDeleted && Object.keys(deletedOutpoints).length > 0) {
                    try {
                        await onOutpointsDeleted(deletedOutpoints);
                    }
                    catch (error) {
                        console.error(`Error in onOutpointsDeleted callback: ${error.message}`);
                    }
                }
            };
            // execute callbacks
            await Promise.all([executeCreatedOutpointsCallback(), executeDeletedOutpointsCallback()]);
        }
        /**
         * Queries the network node for the outpoints of the specified address.
         *
         * @ignore
         * @param {string} address - The address to query.
         * @returns {Promise<Outpoint[]>} The outpoints for the address.
         * @throws {Error} If the query fails.
         */
        async getOutpointsByAddress(address) {
            try {
                return await this.provider.getOutpointsByAddress(address);
            }
            catch (error) {
                throw new Error(`Failed to get outpoints for address: ${address} - error: ${error}`);
            }
        }
        /**
         * Checks if the specified address is used by querying the network node for the outpoints of the address. If the
         * address is used, the outpoints are imported into the wallet.
         *
         * @param {string} address - The address to check.
         * @returns {Promise<{ isUsed: boolean; outpoints: Outpoint[] }>} A promise that resolves to an object containing a
         *   boolean indicating whether the address is used and an array of outpoints.
         * @throws {Error} If the query fails.
         */
        async checkAddressUse(address) {
            let isUsed = false;
            let outpoints = [];
            try {
                outpoints = await this.getOutpointsByAddress(address);
                if (outpoints.length > 0) {
                    isUsed = true;
                }
                else if (this._addressUseChecker !== undefined && (await this._addressUseChecker(address))) {
                    // address checker returned true, so the address is used
                    isUsed = true;
                }
            }
            catch (error) {
                throw new Error(`Failed to get outpoints for address: ${address} - error: ${error}`);
            }
            return { isUsed, outpoints };
        }
        /**
         * Gets the addresses for the specified zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo[]} The addresses for the zone.
         */
        getAddressesForZone(zone) {
            this.validateZone(zone);
            return this._addressesMap.get('BIP44:external')?.filter((addressInfo) => addressInfo.zone === zone) || [];
        }
        /**
         * Gets the change addresses for the specified zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo[]} The change addresses for the zone.
         */
        getChangeAddressesForZone(zone) {
            this.validateZone(zone);
            return this._addressesMap.get('BIP44:change')?.filter((addressInfo) => addressInfo.zone === zone) || [];
        }
        /**
         * Gets the gap addresses for the specified zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo[]} The gap addresses for the zone.
         */
        getGapAddressesForZone(zone) {
            this.validateZone(zone);
            const gapAddresses = this._addressesMap.get('BIP44:external') || [];
            return gapAddresses.filter((addressInfo) => addressInfo.zone === zone && addressInfo.status === exports.AddressStatus.UNUSED);
        }
        /**
         * Gets the gap change addresses for the specified zone.
         *
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo[]} The gap change addresses for the zone.
         */
        getGapChangeAddressesForZone(zone) {
            this.validateZone(zone);
            const gapChangeAddresses = this._addressesMap.get('BIP44:change') || [];
            return gapChangeAddresses.filter((addressInfo) => addressInfo.zone === zone && addressInfo.status === exports.AddressStatus.UNUSED);
        }
        /**
         * Gets the payment channel addresses for the specified zone.
         *
         * @param {string} paymentCode - The payment code.
         * @param {Zone} zone - The zone.
         * @returns {QiAddressInfo[]} The payment channel addresses for the zone.
         */
        getPaymentChannelAddressesForZone(paymentCode, zone) {
            return this._addressesMap.get(paymentCode)?.filter((addressInfo) => addressInfo.zone === zone) || [];
        }
        /**
         * Gets the gap payment channel addresses for the specified payment code.
         *
         * @param {string} paymentCode - The payment code.
         * @returns {QiAddressInfo[]} The gap payment channel addresses for the payment code.
         */
        getGapPaymentChannelAddressesForZone(paymentCode, zone) {
            return (this._addressesMap
                .get(paymentCode)
                ?.filter((addressInfo) => addressInfo.status === exports.AddressStatus.UNUSED && addressInfo.zone === zone) ||
                []);
        }
        /**
         * Signs a message using the private key associated with the given address.
         *
         * @param {string} address - The address for which the message is to be signed.
         * @param {string | Uint8Array} message - The message to be signed, either as a string or Uint8Array.
         * @returns {Promise<string>} A promise that resolves to the signature of the message in hexadecimal string format.
         * @throws {Error} If the address does not correspond to a valid HD node or if signing fails.
         */
        async signMessage(address, message) {
            const privKey = this.getPrivateKey(address);
            const messageBytes = typeof message === 'string'
                ? getBytes(toUtf8Bytes(message)) // Add UTF-8 encoding to support arbitrary strings
                : message;
            const digest = keccak256(messageBytes);
            const digestBytes = getBytes(digest);
            const signature = schnorr.sign(digestBytes, getBytes(privKey));
            return hexlify(signature);
        }
        /**
         * Serializes the HD wallet state into a format suitable for storage or transmission.
         *
         * @returns {SerializedQiHDWallet} An object representing the serialized state of the HD wallet, including
         *   outpoints, change addresses, gap addresses, and other inherited properties.
         */
        serialize() {
            const hdwalletSerialized = super.serialize();
            return {
                ...hdwalletSerialized,
                addresses: Array.from(this._addressesMap.values()).flatMap((addresses) => addresses),
                senderPaymentCodeInfo: Object.fromEntries(Array.from(this._paymentCodeSendAddressMap.entries()).map(([key, value]) => [key, Array.from(value)])),
            };
        }
        /**
         * Deserializes a serialized QiHDWallet object and reconstructs the wallet instance.
         *
         * @param {SerializedQiHDWallet} serialized - The serialized object representing the state of a QiHDWallet.
         * @returns {Promise<QiHDWallet>} A promise that resolves to a reconstructed QiHDWallet instance.
         * @throws {Error} If the serialized data is invalid or if any addresses in the gap addresses or gap change
         *   addresses do not exist in the wallet.
         */
        static async deserialize(serialized) {
            super.validateSerializedWallet(serialized);
            // create the wallet instance
            const mnemonic = Mnemonic.fromPhrase(serialized.phrase);
            const path = this.parentPath(serialized.coinType);
            const root = HDNodeWallet.fromMnemonic(mnemonic, path);
            const wallet = new this(_guard, root);
            // validate and import all the wallet addresses
            for (const addressInfo of serialized.addresses) {
                let key = addressInfo.derivationPath;
                if (isHexString(key, 32)) {
                    key = QiHDWallet.PRIVATE_KEYS_PATH;
                }
                else if (key.includes('BIP44')) {
                    // only validate if it's not a private key or a BIP44 path
                    wallet.validateAddressInfo(addressInfo);
                }
                else {
                    // payment code addresses require different derivation validation
                    wallet.validateBaseAddressInfo(addressInfo);
                    wallet.validateExtendedProperties(addressInfo);
                }
                const existingAddresses = wallet._addressesMap.get(key);
                if (!existingAddresses) {
                    wallet._addressesMap.set(key, [addressInfo]);
                    // if the address is already in the map, we don't need to add it again
                }
                else if (!existingAddresses.some((addr) => addr.address === addressInfo.address)) {
                    existingAddresses.push(addressInfo);
                }
            }
            // validate and import the counter party payment code info
            for (const [paymentCode, paymentCodeInfoArray] of Object.entries(serialized.senderPaymentCodeInfo)) {
                if (!validatePaymentCode(paymentCode)) {
                    throw new Error(`Invalid payment code: ${paymentCode}`);
                }
                for (const pcInfo of paymentCodeInfoArray) {
                    // Basic property validation
                    wallet.validateBaseAddressInfo(pcInfo);
                    wallet.validateExtendedProperties(pcInfo);
                }
                wallet._paymentCodeSendAddressMap.set(paymentCode, paymentCodeInfoArray);
            }
            return wallet;
        }
        validateAddressDerivation(info) {
            const addressNode = this._getAddressNode(info.account, info.change, info.index);
            // Validate derived address matches
            if (addressNode.address !== info.address) {
                throw new Error(`Address mismatch: derived ${addressNode.address} but got ${info.address}`);
            }
            // Validate derived public key matches
            if (addressNode.publicKey !== info.pubKey) {
                throw new Error(`Public key mismatch: derived ${addressNode.publicKey} but got ${info.pubKey}`);
            }
            // Validate zone
            const zone = getZoneForAddress(addressNode.address);
            if (!zone || zone !== info.zone) {
                throw new Error(`Zone mismatch: derived ${zone} but got ${info.zone}`);
            }
            // Validate it's a valid Qi address
            if (!isQiAddress(addressNode.address)) {
                throw new Error(`Address ${addressNode.address} is not a valid Qi address`);
            }
        }
        validateExtendedProperties(info) {
            // Validate status
            if (!Object.values(exports.AddressStatus).includes(info.status)) {
                throw new Error(`Invalid status: ${info.status}`);
            }
            // Validate derivation path
            if (typeof info.derivationPath !== 'string' || !info.derivationPath) {
                throw new Error(`Invalid derivation path: ${info.derivationPath}`);
            }
            // Validate derivation path format
            this.validateDerivationPath(info.derivationPath, info.change);
            // Validate last synced block
            // 1. Validate lastSyncBlock.hash is a valid hash
            if (info.lastSyncedBlock && !isHexString(info.lastSyncedBlock.hash, 32)) {
                throw new Error(`Invalid last synced block hash: ${info.lastSyncedBlock.hash}`);
            }
            // 2. Validate lastSyncBlock.height is a number
            if (info.lastSyncedBlock &&
                (typeof info.lastSyncedBlock.number !== 'number' || info.lastSyncedBlock.number < 0)) {
                throw new Error(`Invalid last synced block number: ${info.lastSyncedBlock.number}`);
            }
        }
        /**
         * Validates that the derivation path is either a BIP44 path or a valid payment code.
         *
         * @private
         * @param {string} path - The derivation path to validate
         * @param {boolean} isChange - Whether this is a change address
         * @throws {Error} If the path is invalid
         */
        validateDerivationPath(path, isChange) {
            // Check if it's a BIP44 path
            if (path === 'BIP44:external' || path === 'BIP44:change') {
                // Validate that the path matches the change flag
                const expectedPath = isChange ? 'BIP44:change' : 'BIP44:external';
                if (path !== expectedPath) {
                    throw new Error(`BIP44 path mismatch: address marked as ${isChange ? 'change' : 'external'} ` +
                        `but has path ${path}`);
                }
                return;
            }
            // Check if it's a private key path
            if (path === QiHDWallet.PRIVATE_KEYS_PATH) {
                if (isChange) {
                    throw new Error('Imported private key addresses cannot be change addresses');
                }
                return;
            }
            // If not a BIP44 path or private key, must be a valid payment code
            if (!validatePaymentCode(path)) {
                throw new Error(`Invalid derivation path: must be 'BIP44:external', 'BIP44:change', ` +
                    `'${QiHDWallet.PRIVATE_KEYS_PATH}', or a valid payment code. Got: ${path}`);
            }
            // Payment code addresses cannot be change addresses
            if (isChange) {
                throw new Error('Payment code addresses cannot be change addresses');
            }
        }
        /**
         * Validates an array of OutpointInfo objects. This method checks the validity of each OutpointInfo object by
         * performing the following validations:
         *
         * - Validates the zone using the `validateZone` method.
         * - Checks if the address exists in the wallet.
         * - Checks if the account (if provided) exists in the wallet.
         * - Validates the Outpoint by ensuring that `Txhash`, `Index`, and `Denomination` are not null.
         *
         * @ignore
         * @param {OutpointInfo[]} outpointInfo - An array of OutpointInfo objects to be validated.
         * @throws {Error} If any of the validations fail, an error is thrown with a descriptive message.
         */
        validateOutpointInfo(outpointInfo) {
            outpointInfo.forEach((info) => {
                // validate zone
                this.validateZone(info.zone);
                // validate address and account
                this.validateAddressAndAccount(info.address, info.account);
                // validate Outpoint
                if (info.outpoint.txhash == null || info.outpoint.index == null || info.outpoint.denomination == null) {
                    throw new Error(`Invalid Outpoint: ${JSON.stringify(info)} `);
                }
            });
        }
        validateAddressAndAccount(address, account) {
            const addressInfo = this.locateAddressInfo(address);
            if (!addressInfo) {
                throw new Error(`Address ${address} not found in wallet`);
            }
            if (account && account !== addressInfo.account) {
                throw new Error(`Address ${address} does not match account ${account}`);
            }
        }
        /**
         * Creates a new BIP47 payment code for the specified account. The payment code is derived from the account's BIP32
         * root key.
         *
         * @param {number} account - The account index to derive the payment code from.
         * @returns {Promise<string>} A promise that resolves to the Base58-encoded BIP47 payment code.
         */
        getPaymentCode(account = 0) {
            const privatePcode = this._getPaymentCodePrivate(account);
            return privatePcode.toBase58();
        }
        /**
         * Generates a BIP47 private payment code for the specified account. The payment code is created by combining the
         * account's public key and chain code.
         *
         * @private
         * @param {number} account - The account index for which to generate the private payment code.
         * @returns {Promise<PaymentCodePrivate>} A promise that resolves to the PaymentCodePrivate instance.
         */
        _getPaymentCodePrivate(account) {
            const bip32 = BIP32Factory(ecc);
            const accountNode = this._root.deriveChild(account + HARDENED_OFFSET);
            // payment code array
            const pc = new Uint8Array(80);
            // set version + options
            pc.set([1, 0]);
            // set the public key
            const pubKey = accountNode.publicKey;
            pc.set(getBytes(pubKey), 2);
            // set the chain code
            const chainCode = accountNode.chainCode;
            pc.set(getBytes(chainCode), 35);
            const adapter = new HDNodeBIP32Adapter(accountNode);
            return new PaymentCodePrivate(adapter, ecc, bip32, pc);
        }
        /**
         * Generates a payment address for sending funds to the specified receiver's BIP47 payment code. Uses Diffie-Hellman
         * key exchange to derive the address from the receiver's public key and sender's private key.
         *
         * @param {string} receiverPaymentCode - The Base58-encoded BIP47 payment code of the receiver.
         * @returns {Promise<string>} A promise that resolves to the payment address for sending funds.
         * @throws {Error} Throws an error if the payment code version is invalid.
         */
        getNextSendAddress(receiverPaymentCode, zone, account = 0) {
            const bip32 = BIP32Factory(ecc);
            const buf = bs58check.decode(receiverPaymentCode);
            const version = buf[0];
            if (version !== PC_VERSION)
                throw new Error('Invalid payment code version');
            const walletPCodePrivate = this._getPaymentCodePrivate(account);
            const receiverPCodePublic = new PaymentCodePublic(ecc, bip32, buf.slice(1));
            const paymentCodeInfoArray = this._paymentCodeSendAddressMap.get(receiverPaymentCode);
            const lastIndex = this._findLastUsedIndex(paymentCodeInfoArray, account, zone);
            let addrIndex = lastIndex + 1;
            for (let attempts = 0; attempts < MAX_ADDRESS_DERIVATION_ATTEMPTS; attempts++) {
                const address = receiverPCodePublic.getPaymentAddress(walletPCodePrivate, addrIndex);
                if (this.isValidAddressForZone(address, zone)) {
                    const pubkey = receiverPCodePublic.derivePaymentPublicKey(walletPCodePrivate, addrIndex);
                    const pcInfo = {
                        address,
                        pubKey: hexlify(pubkey),
                        index: addrIndex,
                        account,
                        zone,
                        change: false,
                        status: exports.AddressStatus.UNKNOWN,
                        derivationPath: receiverPaymentCode,
                        lastSyncedBlock: null,
                    };
                    if (paymentCodeInfoArray) {
                        paymentCodeInfoArray.push(pcInfo);
                    }
                    else {
                        this._paymentCodeSendAddressMap.set(receiverPaymentCode, [pcInfo]);
                    }
                    return pcInfo;
                }
                addrIndex++;
            }
            throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`);
        }
        /**
         * Generates a payment address for receiving funds from the specified sender's BIP47 payment code. Uses
         * Diffie-Hellman key exchange to derive the address from the sender's public key and receiver's private key.
         *
         * @param {string} senderPaymentCode - The Base58-encoded BIP47 payment code of the sender.
         * @returns {Promise<string>} A promise that resolves to the payment address for receiving funds.
         * @throws {Error} Throws an error if the payment code version is invalid.
         */
        getNextReceiveAddress(senderPaymentCode, zone, account = 0) {
            const bip32 = BIP32Factory(ecc);
            const buf = bs58check.decode(senderPaymentCode);
            const version = buf[0];
            if (version !== PC_VERSION)
                throw new Error('Invalid payment code version');
            const senderPCodePublic = new PaymentCodePublic(ecc, bip32, buf.slice(1));
            const walletPCodePrivate = this._getPaymentCodePrivate(account);
            const paymentCodeInfoArray = this._addressesMap.get(senderPaymentCode);
            const lastIndex = this._findLastUsedIndex(paymentCodeInfoArray, account, zone);
            let addrIndex = lastIndex + 1;
            for (let attempts = 0; attempts < MAX_ADDRESS_DERIVATION_ATTEMPTS; attempts++) {
                const address = walletPCodePrivate.getPaymentAddress(senderPCodePublic, addrIndex);
                if (this.isValidAddressForZone(address, zone)) {
                    const pubkey = walletPCodePrivate.derivePaymentPublicKey(senderPCodePublic, addrIndex);
                    const pcInfo = {
                        address,
                        pubKey: hexlify(pubkey),
                        index: addrIndex,
                        account,
                        zone,
                        change: false,
                        status: exports.AddressStatus.UNKNOWN,
                        derivationPath: senderPaymentCode,
                        lastSyncedBlock: null,
                    };
                    if (paymentCodeInfoArray) {
                        paymentCodeInfoArray.push(pcInfo);
                    }
                    else {
                        this._addressesMap.set(senderPaymentCode, [pcInfo]);
                    }
                    return pcInfo;
                }
                addrIndex++;
            }
            throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`);
        }
        /**
         * Receives a payment code and stores it in the wallet for future use. If the payment code is already in the wallet,
         * it will be ignored.
         *
         * @param {string} paymentCode - The payment code to store.
         */
        openChannel(paymentCode) {
            if (!validatePaymentCode(paymentCode)) {
                throw new Error(`Invalid payment code: ${paymentCode}`);
            }
            if (!this._addressesMap.has(paymentCode)) {
                this._addressesMap.set(paymentCode, []);
            }
            if (!this._paymentCodeSendAddressMap.has(paymentCode)) {
                this._paymentCodeSendAddressMap.set(paymentCode, []);
            }
        }
        channelIsOpen(paymentCode) {
            return this._addressesMap.has(paymentCode) && this._paymentCodeSendAddressMap.has(paymentCode);
        }
        /**
         * Gets the address info for a given address.
         *
         * @param {string} address - The address.
         * @returns {QiAddressInfo | null} The address info or null if not found.
         */
        getAddressInfo(address) {
            const externalAddressInfo = this._addressesMap.get('BIP44:external')?.find((addr) => addr.address === address);
            if (!externalAddressInfo) {
                return null;
            }
            return externalAddressInfo;
        }
        /**
         * Gets the address info for a given address.
         *
         * @param {string} address - The address.
         * @returns {QiAddressInfo | null} The address info or null if not found.
         */
        getChangeAddressInfo(address) {
            const changeAddressInfo = this._addressesMap.get('BIP44:change')?.find((addr) => addr.address === address);
            if (!changeAddressInfo) {
                return null;
            }
            return changeAddressInfo;
        }
        /**
         * Imports a private key and adds it to the wallet.
         *
         * @param {string} privateKey - The private key to import (hex string)
         * @returns {Promise<QiAddressInfo>} The address information for the imported key
         * @throws {Error} If the private key is invalid or the address is already in use
         */
        async importPrivateKey(privateKey) {
            if (!isHexString(privateKey, 32)) {
                throw new Error(`Invalid private key format: must be 32-byte hex string (got ${privateKey})`);
            }
            const pubKey = SigningKey.computePublicKey(privateKey, true);
            const address = computeAddress(pubKey);
            // Validate address is for correct zone and ledger
            const addressZone = getZoneForAddress(address);
            if (!addressZone) {
                throw new Error(`Private key does not correspond to a valid address for any zone (got ${address})`);
            }
            if (!isQiAddress(address)) {
                throw new Error(`Private key does not correspond to a valid Qi address (got ${address})`);
            }
            for (const [path, addresses] of this._addressesMap.entries()) {
                if (addresses.some((info) => info.address === address)) {
                    throw new Error(`Address ${address} already exists in wallet under path ${path}`);
                }
            }
            const addressInfo = {
                pubKey,
                address,
                account: 0,
                index: -1,
                change: false,
                zone: addressZone,
                status: exports.AddressStatus.UNUSED,
                derivationPath: privateKey,
                lastSyncedBlock: null,
            };
            this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH).push(addressInfo);
            return addressInfo;
        }
        /**
         * Gets all addresses that were imported via private keys.
         *
         * @param {Zone} [zone] - Optional zone to filter addresses by
         * @returns {QiAddressInfo[]} Array of address info objects for imported addresses
         */
        getImportedAddresses(zone) {
            const importedAddresses = this._addressesMap.get(QiHDWallet.PRIVATE_KEYS_PATH) || [];
            if (zone !== undefined) {
                this.validateZone(zone);
                return importedAddresses.filter((info) => info.zone === zone);
            }
            return [...importedAddresses];
        }
        /**
         * Adds a new address to the wallet.
         *
         * @param {number} account - The account number.
         * @param {number} addressIndex - The address index.
         * @returns {QiAddressInfo} The address info for the new address.
         */
        addAddress(account, addressIndex) {
            if (account < 0 || addressIndex < 0) {
                throw new Error('Account and address index must be non-negative integers');
            }
            return this._addAddress(account, addressIndex, false);
        }
        /**
         * Adds a new change address to the wallet.
         *
         * @param {number} account - The account number.
         * @param {number} addressIndex - The address index.
         * @returns {QiAddressInfo} The address info for the new address.
         */
        addChangeAddress(account, addressIndex) {
            if (account < 0 || addressIndex < 0) {
                throw new Error('Account and address index must be non-negative integers');
            }
            return this._addAddress(account, addressIndex, true);
        }
        _addAddress(account, addressIndex, isChange) {
            const derivationPath = isChange ? 'BIP44:change' : 'BIP44:external';
            const existingAddresses = this._addressesMap.get(derivationPath) || [];
            if (existingAddresses.some((info) => info.index === addressIndex)) {
                throw new Error(`Address index ${addressIndex} already exists in wallet under path ${derivationPath}`);
            }
            const addressNode = this._getAddressNode(account, isChange, addressIndex);
            const zone = getZoneForAddress(addressNode.address);
            if (!zone) {
                throw new Error(`Failed to derive a Qi valid address zone for the index ${addressIndex}`);
            }
            if (!isQiAddress(addressNode.address)) {
                throw new Error(`Address ${addressNode.address} is not a valid Qi address`);
            }
            return this._createAndStoreQiAddressInfo(addressNode, account, zone, isChange);
        }
        /**
         * Gets the addresses for a given account.
         *
         * @param {number} account - The account number.
         * @returns {QiAddressInfo[]} The addresses for the account.
         */
        getAddressesForAccount(account) {
            const addresses = this._addressesMap.values();
            return Array.from(addresses)
                .flat()
                .filter((info) => info.account === account);
        }
    }

    /**
     * A **Network** encapsulates the various properties required to interact with a specific chain.
     *
     * @category Providers
     */
    const Networks = new Map();
    /**
     * A **Network** provides access to a chain's properties and allows for plug-ins to extend functionality.
     *
     * @category Providers
     */
    class Network {
        #name;
        #chainId;
        /**
         * Creates a new **Network** for `name` and `chainId`.
         *
         * @param {string} name - The network name.
         * @param {BigNumberish} chainId - The network chain ID.
         */
        constructor(name, chainId) {
            this.#name = name;
            this.#chainId = getBigInt(chainId);
        }
        /**
         * Returns a JSON-compatible representation of a Network.
         *
         * @returns {Object} The JSON representation of the network.
         */
        toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
        }
        /**
         * The network common name.
         *
         * This is the canonical name, as networks might have multiple names.
         *
         * @returns {string} The network name.
         */
        get name() {
            return this.#name;
        }
        /**
         * Sets the network name.
         *
         * @param {string} value - The new network name.
         */
        set name(value) {
            this.#name = value;
        }
        /**
         * The network chain ID.
         *
         * @returns {bigint} The network chain ID.
         */
        get chainId() {
            return this.#chainId;
        }
        /**
         * Sets the network chain ID.
         *
         * @param {BigNumberish} value - The new network chain ID.
         */
        set chainId(value) {
            this.#chainId = getBigInt(value, 'chainId');
        }
        /**
         * Returns true if `other` matches this network. Any chain ID must match, and if no chain ID is present, the name
         * must match.
         *
         * This method does not currently check for additional properties, such as plug-in compatibility.
         *
         * @ignore
         * @param {Networkish} other - The network to compare.
         * @returns {boolean} True if the networks match.
         */
        matches(other) {
            if (other == null) {
                return false;
            }
            if (typeof other === 'string') {
                try {
                    return this.chainId === getBigInt(other);
                    // eslint-disable-next-line no-empty
                }
                catch (error) { }
                return this.name === other;
            }
            if (typeof other === 'number' || typeof other === 'bigint') {
                try {
                    return this.chainId === getBigInt(other);
                    // eslint-disable-next-line no-empty
                }
                catch (error) { }
                return false;
            }
            if (typeof other === 'object') {
                if (other.chainId != null) {
                    try {
                        return this.chainId === getBigInt(other.chainId);
                        // eslint-disable-next-line no-empty
                    }
                    catch (error) { }
                    return false;
                }
                if (other.name != null) {
                    return this.name === other.name;
                }
                return false;
            }
            return false;
        }
        /**
         * Create a copy of this Network.
         *
         * @returns {Network} A new Network instance.
         */
        clone() {
            const clone = new Network(this.name, this.chainId);
            return clone;
        }
        /**
         * Returns a new Network for the `network` name or chainId.
         *
         * @param {Networkish} [network] - The network to get.
         * @returns {Network} The Network instance.
         * @throws {Error} If the network is invalid.
         */
        static from(network) {
            // Default network
            if (network == null) {
                return Network.from('mainnet');
            }
            // Canonical name or chain ID
            if (typeof network === 'number') {
                network = BigInt(network);
            }
            if (typeof network === 'string' || typeof network === 'bigint') {
                const networkFunc = Networks.get(network);
                if (networkFunc) {
                    return networkFunc();
                }
                if (typeof network === 'bigint') {
                    return new Network('unknown', network);
                }
                assertArgument(false, 'unknown network', 'network', network);
            }
            // Clonable with network-like abilities
            if (typeof network.clone === 'function') {
                const clone = network.clone();
                return clone;
            }
            // Networkish
            if (typeof network === 'object') {
                assertArgument(typeof network.name === 'string' && typeof network.chainId === 'number', 'invalid network object name or chainId', 'network', network);
                const custom = new Network(network.name, network.chainId);
                return custom;
            }
            assertArgument(false, 'invalid network', 'network', network);
        }
        /**
         * Register `nameOrChainId` with a function which returns an instance of a Network representing that chain.
         *
         * @param {string | number | bigint} nameOrChainId - The name or chain ID to register.
         * @param {() => Network} networkFunc - The function to create the Network.
         * @throws {Error} If a network is already registered for `nameOrChainId`.
         */
        static register(nameOrChainId, networkFunc) {
            if (typeof nameOrChainId === 'number') {
                nameOrChainId = BigInt(nameOrChainId);
            }
            const existing = Networks.get(nameOrChainId);
            if (existing) {
                assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, 'nameOrChainId', nameOrChainId);
            }
            Networks.set(nameOrChainId, networkFunc);
        }
    }

    /**
     * Deep copies an object.
     *
     * @param {any} obj - The object to copy.
     * @returns {any} The copied object.
     */
    function copy$2(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * A **PollingBlockSubscriber** polls at a regular interval for a change in the block number.
     *
     * @category Providers
     */
    class PollingBlockSubscriber {
        #provider;
        #poller;
        #interval;
        #zone;
        // The most recent block we have scanned for events. The value -2
        // indicates we still need to fetch an initial block number
        #blockNumber;
        /**
         * Create a new **PollingBlockSubscriber** attached to `provider`.
         *
         * @ignore
         */
        constructor(provider, zone) {
            this.#provider = provider;
            this.#zone = zone;
            this.#poller = null;
            this.#interval = 4000;
            this.#blockNumber = -2;
        }
        /**
         * The polling interval.
         *
         * @returns {number} The current polling interval.
         */
        get pollingInterval() {
            return this.#interval;
        }
        /**
         * Sets the polling interval.
         *
         * @param {number} value - The new polling interval.
         */
        set pollingInterval(value) {
            this.#interval = value;
        }
        /**
         * Polls for new blocks.
         *
         * @ignore
         * @returns {Promise<void>} A promise that resolves when polling is complete.
         */
        async #poll() {
            try {
                const blockNumber = await this.#provider.getBlockNumber(toShard(this.#zone));
                // Bootstrap poll to setup our initial block number
                if (this.#blockNumber === -2) {
                    this.#blockNumber = blockNumber;
                    return;
                }
                // @TODO: Put a cap on the maximum number of events per loop?
                if (blockNumber !== this.#blockNumber) {
                    for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                        // We have been stopped
                        if (this.#poller == null) {
                            return;
                        }
                        await this.#provider.emit('block', this.#zone, b);
                    }
                    this.#blockNumber = blockNumber;
                }
            }
            catch (error) {
                // @TODO: Minor bump, add an "error" event to let subscribers
                //        know things went awry.
            }
            // We have been stopped
            if (this.#poller == null) {
                return;
            }
            this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
        }
        /**
         * Starts the polling process.
         */
        start() {
            if (this.#poller) {
                return;
            }
            this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
            this.#poll();
        }
        /**
         * Stops the polling process.
         */
        stop() {
            if (!this.#poller) {
                return;
            }
            this.#provider._clearTimeout(this.#poller);
            this.#poller = null;
        }
        /**
         * Pauses the polling process.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop the block number while paused.
         */
        pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
                this.#blockNumber = -2;
            }
        }
        /**
         * Resumes the polling process.
         */
        resume() {
            this.start();
        }
    }
    /**
     * An **OnBlockSubscriber** can be sub-classed, with a {@link OnBlockSubscriber._poll | **_poll**} implementation which
     * will be called on every new block.
     *
     * @category Providers
     */
    class OnBlockSubscriber {
        #provider;
        #poll;
        #running;
        #zone;
        /**
         * Create a new **OnBlockSubscriber** attached to `provider`.
         *
         * @ignore
         */
        constructor(provider, zone) {
            this.#provider = provider;
            this.#zone = zone;
            this.#running = false;
            this.#poll = (blockNumber) => {
                this._poll(blockNumber, this.#provider);
            };
        }
        /**
         * Called on every new block.
         *
         * @ignore
         * @param {number} blockNumber - The block number.
         * @param {AbstractProvider} provider - The provider.
         * @returns {Promise<void>} A promise that resolves when the poll is complete.
         * @throws {Error} If the method is not overridden by a subclass.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async _poll(blockNumber, provider) {
            throw new Error('sub-classes must override this');
        }
        /**
         * Starts the subscriber.
         */
        start() {
            if (this.#running) {
                return;
            }
            this.#running = true;
            this.#poll(-2);
            this.#provider.on('block', this.#poll, this.#zone);
        }
        /**
         * Stops the subscriber.
         */
        stop() {
            if (!this.#running) {
                return;
            }
            this.#running = false;
            this.#provider.off('block', this.#poll, this.#zone);
        }
        /**
         * Pauses the subscriber.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop the block number while paused.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        pause(dropWhilePaused) {
            this.stop();
        }
        /**
         * Resumes the subscriber.
         */
        resume() {
            this.start();
        }
    }
    /**
     * @ignore
     */
    class PollingOrphanSubscriber extends OnBlockSubscriber {
        #filter;
        /**
         * Create a new **PollingOrphanSubscriber** attached to `provider`, listening for `filter`.
         *
         * @ignore
         */
        constructor(provider, filter, zone) {
            super(provider, zone);
            this.#filter = copy$2(filter);
        }
        /**
         * Polls for orphaned blocks.
         *
         * @ignore
         * @param {number} blockNumber - The block number.
         * @param {AbstractProvider} provider - The provider.
         * @returns {Promise<void>} A promise that resolves when the poll is complete.
         * @throws {Error} If the method is not implemented.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async _poll(blockNumber, provider) {
            throw new Error('@TODO');
        }
    }
    /**
     * A **PollingTransactionSubscriber** will poll for a given transaction hash for its receipt.
     *
     * @category Providers
     */
    class PollingTransactionSubscriber extends OnBlockSubscriber {
        #hash;
        /**
         * Create a new **PollingTransactionSubscriber** attached to `provider`, listening for `hash`.
         *
         * @ignore
         */
        constructor(provider, hash, zone) {
            super(provider, zone);
            this.#hash = hash;
        }
        /**
         * Polls for the transaction receipt.
         *
         * @ignore
         * @param {number} blockNumber - The block number.
         * @param {AbstractProvider} provider - The provider.
         * @returns {Promise<void>} A promise that resolves when the poll is complete.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async _poll(blockNumber, provider) {
            const tx = await provider.getTransactionReceipt(this.#hash);
            if (tx) {
                provider.emit(this.#hash, toZone(this.#hash.slice(0, 4)), tx);
            }
        }
    }
    class PollingQiTransactionSubscriber extends OnBlockSubscriber {
        #hash;
        constructor(provider, hash, zone) {
            super(provider, zone);
            this.#hash = hash;
        }
        async _poll(blockNumber, provider) {
            const tx = (await provider.getTransaction(this.#hash));
            if (tx && tx.isMined()) {
                provider.emit(this.#hash, toZone(this.#hash.slice(0, 4)), tx);
            }
        }
    }
    /**
     * A **PollingEventSubscriber** will poll for a given filter for its logs.
     *
     * @category Providers
     */
    class PollingEventSubscriber {
        #provider;
        #filter;
        #poller;
        #running;
        #blockNumber;
        #zone;
        /**
         * Create a new **PollingEventSubscriber** attached to `provider`, listening for `filter`.
         *
         * @ignore
         */
        constructor(provider, filter) {
            this.#provider = provider;
            this.#filter = copy$2(filter);
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#blockNumber = -2;
            const zone = getZoneFromEventFilter(this.#filter);
            if (zone) {
                this.#zone = zone;
            }
            else {
                throw new Error('Unable to determine zone for event filter');
            }
        }
        /**
         * Polls for logs based on the filter.
         *
         * @ignore
         * @param {number} blockNumber - The block number.
         * @returns {Promise<void>} A promise that resolves when the poll is complete.
         */
        async #poll(blockNumber) {
            // The initial block hasn't been determined yet
            if (this.#blockNumber === -2) {
                return;
            }
            const filter = copy$2(this.#filter);
            filter.fromBlock = this.#blockNumber + 1;
            filter.toBlock = blockNumber;
            const logs = await this.#provider.getLogs(filter);
            // No logs could just mean the node has not indexed them yet,
            // so we keep a sliding window of 60 blocks to keep scanning
            if (logs.length === 0) {
                if (this.#blockNumber < blockNumber - 60) {
                    this.#blockNumber = blockNumber - 60;
                }
                return;
            }
            for (const log of logs) {
                this.#provider.emit(this.#filter, getZoneFromNodeLocation(this.#filter.nodeLocation), log);
                // Only advance the block number when logs were found to
                // account for networks (like BNB and Polygon) which may
                // sacrifice event consistency for block event speed
                this.#blockNumber = log.blockNumber;
            }
        }
        /**
         * Starts the subscriber.
         */
        start() {
            if (this.#running) {
                return;
            }
            this.#running = true;
            if (this.#blockNumber === -2) {
                this.#provider.getBlockNumber(toShard(this.#zone)).then((blockNumber) => {
                    this.#blockNumber = blockNumber;
                });
            }
            this.#provider.on('block', this.#poller, this.#zone);
        }
        /**
         * Stops the subscriber.
         */
        stop() {
            if (!this.#running) {
                return;
            }
            this.#running = false;
            this.#provider.off('block', this.#poller, this.#zone);
        }
        /**
         * Pauses the subscriber.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop the block number while paused.
         */
        pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
                this.#blockNumber = -2;
            }
        }
        /**
         * Resumes the subscriber.
         */
        resume() {
            this.start();
        }
    }

    /**
     * The available providers should suffice for most developers purposes, but the
     * {@link AbstractProvider | **AbstractProvider**} class has many features which enable sub-classing it for specific
     * purposes.
     */
    /**
     * Event coalescence When we register an event with an async value (e.g. address is a Signer), we need to add it
     * immediately for the Event API, but also need time to resolve the address. Upon resolving the address, we need to
     * migrate the listener to the static event. We also need to maintain a map of Signer to address so we can sync respond
     * to listenerCount.
     */
    /**
     * Check if a value is a Promise.
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is a Promise, false otherwise.
     */
    function isPromise(value) {
        return value && typeof value.then === 'function';
    }
    /**
     * Get a tag string based on a prefix and value.
     *
     * @param {string} prefix - The prefix for the tag.
     * @param {any} value - The value to include in the tag.
     * @returns {string} The generated tag.
     */
    function getTag(prefix, value) {
        return (prefix +
            ':' +
            JSON.stringify(value, (k, v) => {
                if (v == null) {
                    return 'null';
                }
                if (typeof v === 'bigint') {
                    return `bigint:${v.toString()}`;
                }
                if (typeof v === 'string') {
                    return v.toLowerCase();
                }
                // Sort object keys
                if (typeof v === 'object' && !Array.isArray(v)) {
                    const keys = Object.keys(v);
                    keys.sort();
                    return keys.reduce((accum, key) => {
                        accum[key] = v[key];
                        return accum;
                    }, {});
                }
                return v;
            }));
    }
    /**
     * An **UnmanagedSubscriber** is useful for events which do not require any additional management, such as `"debug"`
     * which only requires emit in synchronous event loop triggered calls.
     *
     * @category Providers
     */
    class UnmanagedSubscriber {
        /**
         * The name of the event.
         */
        name;
        /**
         * Create a new UnmanagedSubscriber with `name`.
         *
         * @param {string} name - The name of the event.
         */
        constructor(name) {
            defineProperties(this, { name });
        }
        start() { }
        stop() { }
        // todo `dropWhilePaused` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        pause(dropWhilePaused) { }
        resume() { }
    }
    /**
     * Create a deep copy of a value.
     *
     * @param {T} value - The value to copy.
     * @returns {T} The copied value.
     */
    function copy$1(value) {
        return JSON.parse(JSON.stringify(value));
    }
    /**
     * Remove duplicates and sort an array of strings.
     *
     * @param {string[]} items - The array of strings.
     * @returns {string[]} The concisified array.
     */
    function concisify(items) {
        items = Array.from(new Set(items).values());
        items.sort();
        return items;
    }
    // todo `provider` is not used, remove or re-write
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async function getSubscription(_event, zone) {
        if (_event == null) {
            throw new Error('invalid event');
        }
        // Normalize topic array info an EventFilter
        if (Array.isArray(_event)) {
            _event = { topics: _event };
        }
        if (typeof _event === 'string') {
            if (_event === 'debug') {
                return { type: _event, tag: _event };
            }
            switch (_event) {
                case 'block':
                case 'pending':
                    if (!zone) {
                        throw new Error('zone is required for block and pending events');
                    }
                    return { type: 'block', tag: _event, zone };
                case 'error':
                case 'finalized':
                case 'network':
                case 'safe': {
                    return { type: _event, tag: _event };
                }
            }
        }
        if (isHexString(_event, 32)) {
            const eventBytes = getBytes(_event);
            const ninthBit = (eventBytes[1] & 0x80) === 0x80;
            const hash = _event.toLowerCase();
            zone = toZone(hash.slice(0, 4));
            if (ninthBit) {
                return { type: 'qiTransaction', tag: getTag('Tx', { hash }), hash, zone };
            }
            else {
                return { type: 'transaction', tag: getTag('tx', { hash }), hash, zone };
            }
        }
        if (_event.orphan) {
            const event = _event;
            if (!zone) {
                const hash = event.hash ||
                    event.tx.hash ||
                    event.other?.hash ||
                    event.log.transactionHash ||
                    null;
                if (hash == null) {
                    throw new Error('orphan event must specify a hash');
                }
                zone = toZone(hash.slice(0, 4));
            }
            // @todo Should lowercase and whatnot things here instead of copy...
            return { type: 'orphan', tag: getTag('orphan', event), filter: copy$1(event), zone };
        }
        if (_event.type && _event.address) {
            const address = formatMixedCaseChecksumAddress(isHexString(_event.address) ? _event.address : await resolveAddress(_event.address));
            const filter = {
                type: _event.type,
                address: address,
            };
            if (!zone) {
                zone = toZone(address.slice(0, 4));
            }
            return { filter, tag: getTag('accesses', filter), type: 'accesses', zone };
        }
        else if (_event.topics || _event.address) {
            const event = _event;
            const filter = {
                topics: (event.topics || []).map((t) => {
                    if (t == null) {
                        return null;
                    }
                    if (Array.isArray(t)) {
                        return concisify(t.map((t) => t.toLowerCase()));
                    }
                    return t.toLowerCase();
                }),
            };
            if (event.nodeLocation) {
                filter.nodeLocation = event.nodeLocation;
            }
            if (event.address) {
                const addresses = [];
                const promises = [];
                const addAddress = (addr) => {
                    if (isHexString(addr)) {
                        addresses.push(formatMixedCaseChecksumAddress(addr));
                    }
                    else {
                        promises.push((async () => {
                            addresses.push(formatMixedCaseChecksumAddress(await resolveAddress(addr)));
                        })());
                    }
                };
                if (Array.isArray(event.address)) {
                    event.address.forEach(addAddress);
                }
                else {
                    addAddress(event.address);
                }
                if (promises.length) {
                    await Promise.all(promises);
                }
                if (!zone) {
                    zone = toZone(addresses[0].slice(0, 4));
                }
                filter.address = concisify(addresses.map((a) => a.toLowerCase()));
                if (!filter.nodeLocation) {
                    filter.nodeLocation = getNodeLocationFromZone(zone);
                }
            }
            else {
                if (!zone) {
                    throw new Error('zone is required for event');
                }
            }
            return { filter, tag: getTag('event', filter), type: 'event', zone };
        }
        assertArgument(false, 'unknown ProviderEvent', 'event', _event);
    }
    /**
     * Get the current time in milliseconds.
     *
     * @returns {number} The current time in milliseconds.
     */
    function getTime() {
        return new Date().getTime();
    }
    const defaultOptions$1 = {
        cacheTimeout: 250,
        pollingInterval: 4000,
        usePathing: true,
    };
    /**
     * An **AbstractProvider** provides a base class for other sub-classes to implement the {@link Provider | **Provider**}
     * API by normalizing input arguments and formatting output results as well as tracking events for consistent behaviour
     * on an eventually-consistent network.
     *
     * @category Providers
     */
    class AbstractProvider {
        /**
         * @ignore
         */
        _urlMap;
        #connect;
        #subs;
        // null=unpaused, true=paused+dropWhilePaused, false=paused
        #pausedState;
        #destroyed;
        #networkPromise;
        #anyNetwork;
        #performCache;
        // The most recent block number if running an event or -1 if no "block" event
        #lastBlockNumber;
        #nextTimer;
        #timers;
        #options;
        _initFailed;
        initResolvePromise;
        initRejectPromise;
        initPromise;
        attemptConnect;
        /**
         * Create a new **AbstractProvider** connected to `network`, or use the various network detection capabilities to
         * discover the {@link Network | **Network**} if necessary.
         *
         * @param _network - The network to connect to, or `"any"` to
         * @param options - The options to configure the provider.
         */
        constructor(_network, options) {
            this._initFailed = false;
            this.attemptConnect = true;
            this.#options = Object.assign({}, defaultOptions$1, options || {});
            if (_network === 'any') {
                this.#anyNetwork = true;
                this.#networkPromise = null;
            }
            else if (_network) {
                const network = Network.from(_network);
                this.#anyNetwork = false;
                this.#networkPromise = Promise.resolve(network);
                setTimeout(() => {
                    this.emit('network', undefined, network, null);
                }, 0);
            }
            else {
                this.#anyNetwork = false;
                this.#networkPromise = null;
            }
            this.#lastBlockNumber = -1;
            this.#performCache = new Map();
            this.#subs = new Map();
            this.#pausedState = null;
            this.#destroyed = false;
            this.#nextTimer = 1;
            this.#timers = new Map();
            this.#connect = [];
            this._urlMap = new Map();
            this.initResolvePromise = null;
            this.initRejectPromise = null;
            this.initPromise = new Promise((resolve, reject) => {
                this.initResolvePromise = resolve;
                this.initRejectPromise = reject;
            });
        }
        /**
         * Initialize the URL map with the provided URLs.
         *
         * @param {U} urls - The URLs to initialize the map with.
         * @returns {Promise<void>} A promise that resolves when the map is initialized.
         */
        async initialize(urls) {
            this.initPromise = new Promise((resolve, reject) => {
                this.initResolvePromise = resolve;
                this.initRejectPromise = reject;
            });
            try {
                const primeSuffix = this.#options.usePathing ? `/${fromShard(exports.Shard.Prime, 'nickname')}` : ':9001';
                if (urls instanceof FetchRequest) {
                    urls.url = urls.url.split(':')[0] + ':' + urls.url.split(':')[1] + primeSuffix;
                    this._urlMap.set(exports.Shard.Prime, urls);
                    this.#connect.push(urls);
                    const shards = await this._waitGetRunningLocations(exports.Shard.Prime, true);
                    shards.forEach((shard) => {
                        const port = 9200 + 20 * shard[0] + shard[1];
                        const shardEnum = toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);
                        const shardSuffix = this.#options.usePathing ? `/${fromShard(shardEnum, 'nickname')}` : `:${port}`;
                        this._urlMap.set(shardEnum, new FetchRequest(urls.url.split(':')[0] + ':' + urls.url.split(':')[1] + shardSuffix));
                    });
                    return;
                }
                if (Array.isArray(urls)) {
                    for (const url of urls) {
                        const primeUrl = url.split(':')[0] + ':' + url.split(':')[1] + primeSuffix;
                        const primeConnect = new FetchRequest(primeUrl);
                        this._urlMap.set(exports.Shard.Prime, primeConnect);
                        this.#connect.push(primeConnect);
                        const shards = await this._waitGetRunningLocations(exports.Shard.Prime, true);
                        shards.forEach((shard) => {
                            const port = 9200 + 20 * shard[0] + shard[1];
                            const shardEnum = toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);
                            const shardSuffix = this.#options.usePathing
                                ? `/${fromShard(shardEnum, 'nickname')}`
                                : `:${port}`;
                            this._urlMap.set(toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`), new FetchRequest(url.split(':')[0] + ':' + url.split(':')[1] + shardSuffix));
                        });
                    }
                }
                if (this.initResolvePromise)
                    this.initResolvePromise();
            }
            catch (error) {
                this._initFailed = true;
                console.log('Error initializing URL map:', error);
                if (this.initRejectPromise)
                    this.initRejectPromise(error);
            }
        }
        /**
         * Get the list of connected FetchRequests.
         *
         * @returns {FetchRequest[]} The list of connected FetchRequests.
         */
        get connect() {
            return this.#connect;
        }
        /**
         * Get the zone from an address.
         *
         * @param {AddressLike} _address - The address to get the zone from.
         * @returns {Promise<Zone>} A promise that resolves to the zone.
         */
        async zoneFromAddress(_address) {
            const address = this._getAddress(_address);
            return toZone((await address).slice(0, 4));
        }
        /**
         * Get the shard from a hash.
         *
         * @param {string} hash - The hash to get the shard from.
         * @returns {Shard} The shard.
         */
        shardFromHash(hash) {
            return toShard(hash.slice(0, 4));
        }
        /**
         * Get the zone from a hash.
         *
         * @param {string} hash - The hash to get the zone from.
         * @returns {Zone} The zone.
         */
        zoneFromHash(hash) {
            return toZone(hash.slice(0, 4));
        }
        /**
         * Get the latest Quai rate for a zone.
         *
         * @param {Zone} zone - The zone to get the rate for.
         * @param {number} [amt=1] - The amount in quais to get the rate for. Default is `1`
         * @returns {Promise<bigint>} A promise that resolves to the latest Quai -> Qi rate for the given amount.
         */
        async getLatestQuaiRate(zone, amt) {
            const blockNumber = await this.getBlockNumber(toShard(zone));
            return this.getQuaiRateAtBlock(zone, blockNumber, amt);
        }
        /**
         * Get the Quai rate at a specific block.
         *
         * @param {Zone} zone - The zone to get the rate for.
         * @param {BlockTag} blockTag - The block tag to get the rate at.
         * @param {number} [amt=1] - The amount to get the rate for. Default is `1`
         * @returns {Promise<bigint>} A promise that resolves to the Quai rate at the specified block.
         */
        async getQuaiRateAtBlock(zone, blockTag, amt) {
            let resolvedBlockTag = this._getBlockTag(toShard(zone), blockTag);
            if (typeof resolvedBlockTag !== 'string') {
                resolvedBlockTag = await resolvedBlockTag;
            }
            return getBigInt(await this.#perform({
                method: 'getQuaiRateAtBlock',
                blockTag: resolvedBlockTag,
                amt: toQuantity(String(amt)),
                zone: zone,
            }));
        }
        /**
         * Get the protocol expansion number.
         *
         * @returns {Promise<number>} A promise that resolves to the protocol expansion number.
         */
        async getProtocolExpansionNumber() {
            return getNumber(await this.#perform({ method: 'getProtocolExpansionNumber' }));
        }
        /**
         * Get the active region shards based on the protocol expansion number.
         *
         * @returns {Promise<Shard[]>} A promise that resolves to the active shards.
         */
        async getActiveRegions() {
            const protocolExpansionNumber = await this.getProtocolExpansionNumber();
            const shards = [exports.Shard.Cyprus];
            if (protocolExpansionNumber >= 1) {
                shards.push(exports.Shard.Paxos);
            }
            if (protocolExpansionNumber >= 3) {
                shards.push(exports.Shard.Hydra);
            }
            return shards.sort((a, b) => a.localeCompare(b));
        }
        /**
         * Get the active zones for a shard based on the protocol expansion number.
         *
         * @returns {Promise<Zone[]>} A promise that resolves to the active zones.
         */
        async getActiveZones() {
            const protocolExpansionNumber = await this.getProtocolExpansionNumber();
            const zones = [exports.Zone.Cyprus1];
            if (protocolExpansionNumber >= 1) {
                zones.push(exports.Zone.Cyprus2);
            }
            if (protocolExpansionNumber >= 2) {
                zones.push(exports.Zone.Paxos1, exports.Zone.Paxos2);
            }
            if (protocolExpansionNumber >= 3) {
                zones.push(exports.Zone.Cyprus3, exports.Zone.Paxos3, exports.Zone.Hydra1, exports.Zone.Hydra2, exports.Zone.Hydra3);
            }
            return zones.sort((a, b) => a.localeCompare(b));
        }
        /**
         * Get the latest Qi rate for a zone.
         *
         * @param {Zone} zone - The zone to get the rate for.
         * @param {number} [amt=1] - The amount to get the rate for. Default is `1`
         * @returns {Promise<bigint>} A promise that resolves to the latest Qi rate.
         */
        async getLatestQiRate(zone, amt) {
            const blockNumber = await this.getBlockNumber(toShard(zone));
            return this.getQiRateAtBlock(zone, blockNumber, amt);
        }
        /**
         * Get the Qi rate at a specific block.
         *
         * @param {Zone} zone - The zone to get the rate for.
         * @param {BlockTag} blockTag - The block tag to get the rate at.
         * @param {number} [amt=1] - The amount to get the rate for. Default is `1`
         * @returns {Promise<bigint>} A promise that resolves to the Qi rate at the specified block.
         */
        async getQiRateAtBlock(zone, blockTag, amt) {
            let resolvedBlockTag = this._getBlockTag(toShard(zone), blockTag);
            if (typeof resolvedBlockTag !== 'string') {
                resolvedBlockTag = await resolvedBlockTag;
            }
            return getBigInt(await this.#perform({
                method: 'getQiRateAtBlock',
                blockTag: resolvedBlockTag,
                amt: toQuantity(String(amt)),
                zone: zone,
            }));
        }
        /**
         * Get the polling interval.
         *
         * @returns {number} The polling interval.
         */
        get pollingInterval() {
            return this.#options.pollingInterval;
        }
        /**
         * Returns `this`, to allow an **AbstractProvider** to implement the [Contract Runner](../classes/ContractRunner)
         * interface.
         *
         * @returns {this} The provider instance.
         */
        get provider() {
            return this;
        }
        /**
         * Shares multiple identical requests made during the same 250ms.
         *
         * @ignore
         * @param {PerformActionRequest} req - The request to perform.
         * @returns {Promise<T>} A promise that resolves to the result of the operation.
         */
        async #perform(req) {
            this.attemptConnect = true;
            const timeout = this.#options.cacheTimeout;
            // Caching disabled
            if (timeout < 0) {
                return await this._perform(req);
            }
            // Create a tag
            const tag = getTag(req.method, req);
            let perform = this.#performCache.get(tag);
            if (!perform || tag.includes('pending') || tag.includes('latest')) {
                perform = this._perform(req);
                this.#performCache.set(tag, perform);
                setTimeout(() => {
                    if (this.#performCache.get(tag) === perform) {
                        this.#performCache.delete(tag);
                    }
                }, timeout);
            }
            return await perform;
        }
        /**
         * Provides the opportunity for a sub-class to wrap a block before returning it, to add additional properties or an
         * alternate sub-class of {@link Block | **Block**}.
         *
         * @ignore
         * @param {BlockParams} value - The block to wrap.
         * @param {Network} network - The network the block was on.
         * @returns {Block} The wrapped block.
         */
        // @todo `network` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _wrapBlock(value, network) {
            return new Block(formatBlock(value), this);
        }
        /**
         * Provides the opportunity for a sub-class to wrap a log before returning it, to add additional properties or an
         * alternate sub-class of {@link Log | **Log**}.
         *
         * @ignore
         * @param {LogParams} value - The log to wrap.
         * @param {Network} network - The network the log was on.
         * @returns {Log} The wrapped log.
         */
        // @todo `network` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _wrapLog(value, network) {
            return new Log(formatLog(value), this);
        }
        /**
         * Provides the opportunity for a sub-class to wrap a transaction receipt before returning it, to add additional
         * properties or an {@link TransactionReceipt | **TransactionReceipt**}.
         *
         * @ignore
         * @param {TransactionReceiptParams} value - The transaction receipt to wrap.
         * @param {Network} network - The network the transaction was on.
         * @returns {TransactionReceipt} The wrapped transaction receipt.
         */
        // @todo `network` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _wrapTransactionReceipt(value, network) {
            const formattedReceipt = formatTransactionReceipt(value);
            return new TransactionReceipt(formattedReceipt, this);
        }
        /**
         * Provides the opportunity for a sub-class to wrap a transaction response before returning it, to add additional
         * properties or an alternate sub-class of {@link TransactionResponse | **TransactionResponse**}.
         *
         * @ignore
         * @param {TransactionResponseParams} tx - The transaction response to wrap.
         * @param {Network} network - The network the transaction was on.
         * @returns {TransactionResponse} The wrapped transaction response.
         */
        // TODO: `newtork` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _wrapTransactionResponse(tx, network) {
            try {
                const formattedTx = formatTransactionResponse(tx);
                if (tx.type === '0x0' || tx.type === 0) {
                    return new QuaiTransactionResponse(formattedTx, this);
                }
                else if (tx.type === '0x1' || tx.type === 1) {
                    return new ExternalTransactionResponse(formattedTx, this);
                }
                else if (tx.type === '0x2' || tx.type === 2) {
                    return new QiTransactionResponse(formattedTx, this);
                }
                else {
                    throw new Error(`Unknown transaction type: ${tx.type}`);
                }
            }
            catch (error) {
                console.error('Error in _wrapTransactionResponse:', error);
                throw error;
            }
        }
        /**
         * Resolves to the Network, forcing a network detection using whatever technique the sub-class requires.
         *
         * Sub-classes **must** override this.
         *
         * @ignore
         * @param {Shard} [shard] - The shard to use for the network detection.
         * @returns {Promise<Network>} A promise resolving to the network.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _detectNetwork() {
            assert$1(false, 'sub-classes must implement this', 'UNSUPPORTED_OPERATION', {
                operation: '_detectNetwork',
            });
        }
        /**
         * Sub-classes should use this to perform all built-in operations. All methods sanitizes and normalizes the values
         * passed into this.
         *
         * Sub-classes **must** override this.
         *
         * @ignore
         * @param {PerformActionRequest} req - The request to perform.
         * @returns {Promise<T>} A promise resolving to the result of the operation.
         */
        async _perform(req) {
            assert$1(false, `unsupported method: ${req.method}`, 'UNSUPPORTED_OPERATION', {
                operation: req.method,
                info: req,
            });
        }
        // State
        async getBlockNumber(shard) {
            const blockNumber = getNumber(await this.#perform({ method: 'getBlockNumber', shard: shard }), '%response');
            if (this.#lastBlockNumber >= 0) {
                this.#lastBlockNumber = blockNumber;
            }
            return blockNumber;
        }
        /**
         * Returns or resolves to the address for `address`, resolving {@link Addressable | **Addressable**} objects and
         * returning if already an address.
         *
         * @ignore
         * @param {AddressLike} address - The address to normalize.
         * @returns {string | Promise<string>} The normalized address.
         */
        _getAddress(address) {
            return resolveAddress(address);
        }
        /**
         * Returns or resolves to a valid block tag for `blockTag`, resolving negative values and returning if already a
         * valid block tag.
         *
         * @ignore
         * @param {Shard} [shard] - The shard to use for the block tag.
         * @param {BlockTag} [blockTag] - The block tag to normalize.
         * @returns {string | Promise<string>} A promise that resolves to a valid block tag.
         */
        _getBlockTag(shard, blockTag) {
            if (blockTag == null) {
                return 'latest';
            }
            switch (blockTag) {
                case 'earliest':
                    return '0x0';
                case 'finalized':
                case 'latest':
                case 'pending':
                case 'safe':
                    return blockTag;
            }
            if (isHexString(blockTag)) {
                if (isHexString(blockTag, 32)) {
                    return blockTag;
                }
                return toQuantity(blockTag);
            }
            if (typeof blockTag === 'bigint') {
                blockTag = getNumber(blockTag, 'blockTag');
            }
            if (typeof blockTag === 'number') {
                if (blockTag >= 0) {
                    return toQuantity(blockTag);
                }
                if (this.#lastBlockNumber >= 0) {
                    return toQuantity(this.#lastBlockNumber + blockTag);
                }
                return this.getBlockNumber(shard).then((b) => toQuantity(b + blockTag));
            }
            assertArgument(false, 'invalid blockTag', 'blockTag', blockTag);
        }
        /**
         * Returns or resolves to a filter for `filter`, resolving any {@link Addressable | **Addressable**} object and
         * returning if already a valid filter.
         *
         * @ignore
         * @param {Filter | FilterByBlockHash} filter - The filter to normalize.
         * @returns {PerformActionFilter | Promise<PerformActionFilter>} A promise that resolves to a valid filter.
         */
        _getFilter(filter) {
            // Create a canonical representation of the topics
            const topics = (filter.topics || []).map((t) => {
                if (t == null) {
                    return null;
                }
                if (Array.isArray(t)) {
                    return concisify(t.map((t) => t.toLowerCase()));
                }
                return t.toLowerCase();
            });
            const blockHash = 'blockHash' in filter ? filter.blockHash : undefined;
            const resolve = (_address, fromBlock, toBlock, nodeLocation) => {
                let address = undefined;
                switch (_address.length) {
                    case 0:
                        break;
                    case 1:
                        address = _address[0];
                        break;
                    default:
                        _address.sort();
                        address = _address;
                }
                if (blockHash) {
                    if (fromBlock != null || toBlock != null) {
                        throw new Error('invalid filter');
                    }
                }
                const filter = {};
                if (address) {
                    filter.address = address;
                }
                if (topics.length) {
                    filter.topics = topics;
                }
                if (fromBlock) {
                    filter.fromBlock = fromBlock;
                }
                if (toBlock) {
                    filter.toBlock = toBlock;
                }
                if (blockHash) {
                    filter.blockHash = blockHash;
                }
                if (nodeLocation) {
                    filter.nodeLocation = nodeLocation;
                }
                return filter;
            };
            // Addresses could be async (Addressables)
            const address = [];
            if (filter.address) {
                if (Array.isArray(filter.address)) {
                    for (const addr of filter.address) {
                        address.push(this._getAddress(addr));
                    }
                }
                else {
                    address.push(this._getAddress(filter.address));
                }
            }
            const zone = getZoneFromNodeLocation(filter.nodeLocation);
            let fromBlock = undefined;
            if ('fromBlock' in filter) {
                fromBlock = this._getBlockTag(toShard(zone), filter.fromBlock);
            }
            let toBlock = undefined;
            if ('toBlock' in filter) {
                toBlock = this._getBlockTag(toShard(zone), filter.toBlock);
            }
            let nodeLocation = undefined;
            if (filter.nodeLocation) {
                nodeLocation = filter.nodeLocation;
            }
            if (address.filter((a) => typeof a !== 'string').length ||
                (fromBlock != null && typeof fromBlock !== 'string') ||
                (toBlock != null && typeof toBlock !== 'string')) {
                return Promise.all([Promise.all(address), fromBlock, toBlock, nodeLocation]).then((result) => {
                    return resolve(result[0], result[1], result[2], result[3]);
                });
            }
            return resolve(address, fromBlock, toBlock, nodeLocation);
        }
        /**
         * Returns or resovles to a transaction for `request`, resolving any {@link Addressable | **Addressable**} and
         * returning if already a valid transaction.
         *
         * @ignore
         * @param {PerformActionTransaction} _request - The transaction to normalize.
         * @returns {PerformActionTransaction | Promise<PerformActionTransaction>} A promise that resolves to a valid
         *   transaction.
         */
        _getTransactionRequest(_request) {
            const request = copyRequest(_request);
            const promises = [];
            ['to', 'from', 'inputs', 'outputs'].forEach((key) => {
                if (request[key] == null) {
                    return;
                }
                const addr = Array.isArray(request[key])
                    ? 'address' in request[key][0]
                        ? request[key].map((it) => it.address)
                        : request[key].map((it) => computeAddress(it.pubkey))
                    : resolveAddress(request[key]);
                if (isPromise(addr)) {
                    if (Array.isArray(addr)) {
                        for (let i = 0; i < addr.length; i++) {
                            promises.push((async function () {
                                request[key][i].address = await addr[i];
                            })());
                        }
                    }
                    else {
                        promises.push((async function () {
                            request[key] = await addr;
                        })());
                    }
                }
                else {
                    request[key] = addr;
                }
            });
            if (request.blockTag != null) {
                const getBlockTag = async () => {
                    const zone = await this.zoneFromAddress(addressFromTransactionRequest(_request));
                    const shard = toShard(zone);
                    const blockTag = this._getBlockTag(shard, request.blockTag);
                    if (isPromise(blockTag)) {
                        return await blockTag;
                    }
                    return blockTag;
                };
                promises.push((async function () {
                    request.blockTag = await getBlockTag();
                })());
            }
            if (promises.length) {
                return (async function () {
                    await Promise.all(promises);
                    return request;
                })();
            }
            return request;
        }
        async getNetwork() {
            // No explicit network was set and this is our first time
            if (this.#networkPromise == null) {
                // Detect the current network (shared with all calls)
                const detectNetwork = (async () => {
                    try {
                        const network = await this._detectNetwork();
                        this.emit('network', undefined, network, null);
                        return network;
                    }
                    catch (error) {
                        if (this.#networkPromise === detectNetwork) {
                            this.#networkPromise = null;
                        }
                        throw error;
                    }
                })();
                this.#networkPromise = detectNetwork;
                return (await detectNetwork).clone();
            }
            const networkPromise = this.#networkPromise;
            const [expected, actual] = await Promise.all([
                networkPromise,
                this._detectNetwork(), // The actual connected network
            ]);
            if (expected.chainId !== actual.chainId) {
                if (this.#anyNetwork) {
                    // The "any" network can change, so notify listeners
                    this.emit('network', undefined, actual, expected);
                    // Update the network if something else hasn't already changed it
                    if (this.#networkPromise === networkPromise) {
                        this.#networkPromise = Promise.resolve(actual);
                    }
                }
                else {
                    // Otherwise, we do not allow changes to the underlying network
                    assert$1(false, `network changed: ${expected.chainId} => ${actual.chainId} `, 'NETWORK_ERROR', {
                        event: 'changed',
                    });
                }
            }
            return expected.clone();
        }
        async _waitGetRunningLocations(shard, now) {
            let retries = 0;
            let locations = [];
            // eslint-disable-next-line no-constant-condition
            while (true) {
                try {
                    if (this.attemptConnect) {
                        if (retries > 5) {
                            retries = 0;
                        }
                        locations = await this._getRunningLocations(shard, now);
                        break;
                    }
                    else {
                        await new Promise((resolve) => setTimeout(resolve, 1000));
                    }
                }
                catch (error) {
                    retries++;
                    if (retries > 5) {
                        this.attemptConnect = false;
                    }
                    await new Promise((resolve) => setTimeout(resolve, 1000));
                }
            }
            if (locations.length === 0) {
                throw new Error('could not get running locations');
            }
            return locations;
        }
        async _getRunningLocations(shard, now) {
            now = now ? now : false;
            return await this.#perform(shard
                ? { method: 'getRunningLocations', shard: shard, now: now }
                : { method: 'getRunningLocations', now: now });
        }
        async getRunningLocations(shard) {
            return await this._getRunningLocations(shard);
        }
        async getProtocolTrieExpansionCount(shard) {
            return await this.#perform({ method: 'getProtocolTrieExpansionCount', shard: shard });
        }
        async getFeeData(zone, txType = true) {
            const getFeeDataFunc = async () => {
                const { gasPrice, minerTip } = await resolveProperties({
                    gasPrice: (async () => {
                        try {
                            const value = await this.#perform({ method: 'getGasPrice', txType, zone: zone });
                            return getBigInt(value, '%response');
                        }
                        catch (error) {
                            console.log(error);
                        }
                        return null;
                    })(),
                    minerTip: (async () => {
                        try {
                            const value = txType ? await this.#perform({ method: 'getMinerTip', zone: zone }) : 0;
                            return getBigInt(value, '%response');
                            // eslint-disable-next-line no-empty
                        }
                        catch (error) { }
                        return null;
                    })(),
                });
                if (gasPrice == null) {
                    throw new Error('could not determine gasPrice');
                }
                let baseMinerTip = null;
                // These are the recommended EIP-1559 heuristics for fee data
                baseMinerTip = minerTip != null ? minerTip : BigInt('1000000000');
                return new FeeData(gasPrice, baseMinerTip);
            };
            return await getFeeDataFunc();
        }
        async estimateGas(_tx) {
            let tx = this._getTransactionRequest(_tx);
            if (isPromise(tx)) {
                tx = await tx;
            }
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(tx));
            return (getBigInt(await this.#perform({
                method: 'estimateGas',
                transaction: tx,
                zone: zone,
            }), '%response') * BigInt(2));
        }
        async estimateFeeForQi(_tx) {
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(_tx));
            return getBigInt(await this.#perform({
                method: 'estimateFeeForQi',
                transaction: _tx,
                zone: zone,
            }), '%response');
        }
        async createAccessList(_tx) {
            let tx = this._getTransactionRequest(_tx);
            if (isPromise(tx)) {
                tx = await tx;
            }
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(tx));
            return (await this.#perform({
                method: 'createAccessList',
                transaction: tx,
                zone: zone,
            })).accessList;
        }
        // TODO: `attempt` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async #call(tx, blockTag, attempt, zone) {
            // This came in as a PerformActionTransaction, so to/from are safe; we can cast
            const transaction = copyRequest(tx);
            return hexlify(await this._perform({ method: 'call', transaction, blockTag, zone }));
        }
        // TODO: `shard` is not used, remove or re-write
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async #checkNetwork(promise, shard) {
            const { value } = await resolveProperties({
                network: this.getNetwork(),
                value: promise,
            });
            return value;
        }
        async call(_tx) {
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(_tx));
            const shard = toShard(zone);
            const { tx, blockTag } = await resolveProperties({
                tx: this._getTransactionRequest(_tx),
                blockTag: this._getBlockTag(shard, _tx.blockTag),
            });
            return await this.#checkNetwork(this.#call(tx, blockTag, -1, zone), shard);
        }
        // Account
        async #getAccountValue(request, _address, _blockTag) {
            let address = this._getAddress(_address);
            const zone = await this.zoneFromAddress(_address);
            const shard = toShard(zone);
            let blockTag = this._getBlockTag(shard, _blockTag);
            if (typeof address !== 'string' || typeof blockTag !== 'string') {
                [address, blockTag] = await Promise.all([address, blockTag]);
            }
            return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag, zone: zone })), shard);
        }
        async getBalance(address, blockTag) {
            return getBigInt(await this.#getAccountValue({ method: 'getBalance' }, address, blockTag), '%response');
        }
        async getLockedBalance(address) {
            return getBigInt(await this.#getAccountValue({ method: 'getLockedBalance' }, address), '%response');
        }
        async getOutpointsByAddress(address) {
            return formatOutpoints(await this.#getAccountValue({ method: 'getOutpointsByAddress' }, address, 'latest'));
        }
        async getTransactionCount(address, blockTag) {
            return getNumber(await this.#getAccountValue({ method: 'getTransactionCount' }, address, blockTag), '%response');
        }
        async getCode(address, blockTag) {
            return hexlify(await this.#getAccountValue({ method: 'getCode' }, address, blockTag));
        }
        async getStorage(address, _position, blockTag) {
            const position = getBigInt(_position, 'position');
            return hexlify(await this.#getAccountValue({ method: 'getStorage', position }, address, blockTag));
        }
        async getPendingHeader() {
            return await this.#perform({ method: 'getPendingHeader' });
        }
        async getTxPoolContent(zone) {
            return await this.#perform({ method: 'getTxPoolContent', zone: zone });
        }
        async txPoolInspect(zone) {
            return await this.#perform({ method: 'txPoolInspect', zone: zone });
        }
        // Write
        async broadcastTransaction(zone, signedTx) {
            const type = decodeProtoTransaction(getBytes(signedTx)).type;
            try {
                const { blockNumber, hash, network } = await resolveProperties({
                    blockNumber: this.getBlockNumber(toShard(zone)),
                    hash: this._perform({
                        method: 'broadcastTransaction',
                        signedTransaction: signedTx,
                        zone: zone,
                    }),
                    network: this.getNetwork(),
                });
                const tx = type == 2 ? QiTransaction.from(signedTx) : QuaiTransaction.from(signedTx);
                const txObj = tx.toJSON();
                this.#validateTransactionHash(tx.hash || '', hash);
                if (type == 2) {
                    return new QiTransactionResponse(txObj, this);
                }
                const wrappedTx = this._wrapTransactionResponse(txObj, network);
                return wrappedTx.replaceableTransaction(blockNumber);
            }
            catch (error) {
                console.error('Error in broadcastTransaction:', error);
                throw error;
            }
        }
        #validateTransactionHash(computedHash, nodehash) {
            if (computedHash !== nodehash) {
                throw new Error(`Transaction hash mismatch: ${computedHash} !== ${nodehash}`);
            }
        }
        validateUrl(url) {
            const urlPattern = /^(https?):\/\/[a-zA-Z0-9.-]+(:\d+)?$/;
            if (!urlPattern.test(url)) {
                let errorMessage = 'Invalid URL: ';
                if (!/^https?:\/\//.test(url)) {
                    errorMessage += 'URL must start with http:// or https://. ';
                }
                if (url.endsWith('/')) {
                    errorMessage += 'URL should not end with a /. ';
                }
                if (/\/[^/]+/.test(url)) {
                    errorMessage += 'URL should not contain a path, query string, or fragment. ';
                }
                throw new Error(errorMessage.trim());
            }
        }
        async #getBlock(shard, block, includeTransactions) {
            if (isHexString(block, 32)) {
                return await this.#perform({
                    method: 'getBlock',
                    blockHash: block,
                    includeTransactions,
                    shard: shard,
                });
            }
            let blockTag = this._getBlockTag(shard, block);
            if (typeof blockTag !== 'string') {
                blockTag = await blockTag;
            }
            return await this.#perform({
                method: 'getBlock',
                blockTag,
                includeTransactions,
                shard: shard,
            });
        }
        // Queries
        async getBlock(shard, block, prefetchTxs) {
            const { network, params } = await resolveProperties({
                network: this.getNetwork(),
                params: this.#getBlock(shard, block, !!prefetchTxs),
            });
            if (params == null) {
                return null;
            }
            return this._wrapBlock(params, network);
        }
        async getTransaction(hash) {
            const zone = toZone(this.shardFromHash(hash));
            const { network, params } = await resolveProperties({
                network: this.getNetwork(),
                params: this.#perform({ method: 'getTransaction', hash, zone: zone }),
            });
            if (params == null) {
                return null;
            }
            return this._wrapTransactionResponse(params, network);
        }
        async getTransactionReceipt(hash) {
            const zone = toZone(this.shardFromHash(hash));
            const { network, params } = await resolveProperties({
                network: this.getNetwork(),
                params: this.#perform({ method: 'getTransactionReceipt', hash, zone: zone }),
            });
            if (params == null) {
                return null;
            }
            // Some backends did not backfill the effectiveGasPrice in to old transactions
            // in the receipt, so we look it up manually and inject it.
            if (params.gasPrice == null && params.effectiveGasPrice == null) {
                const tx = await this.#perform({ method: 'getTransaction', hash, zone: zone });
                if (tx == null) {
                    throw new Error('report this; could not find tx or effectiveGasPrice');
                }
                params.effectiveGasPrice = tx.gasPrice;
            }
            return this._wrapTransactionReceipt(params, network);
        }
        async getTransactionResult(hash) {
            const zone = toZone(this.shardFromHash(hash));
            const { result } = await resolveProperties({
                network: this.getNetwork(),
                result: this.#perform({ method: 'getTransactionResult', hash, zone: zone }),
            });
            if (result == null) {
                return null;
            }
            return hexlify(result);
        }
        async getOutpointDeltas(addresses, startHash, endHash) {
            // Validate addresses are Qi addresses
            for (const addr of addresses) {
                assertArgument(isQiAddress(addr), `Invalid Qi address: ${addr}`, 'addresses', addresses);
            }
            // Validate block hashes
            assertArgument(isHexString(startHash, 32), 'invalid startHash', 'startHash', startHash);
            if (endHash) {
                assertArgument(isHexString(endHash, 32), 'invalid endHash', 'endHash', endHash);
            }
            else {
                endHash = 'latest';
            }
            // Get the zone from the first address
            const zone = await this.zoneFromAddress(addresses[0]);
            const shard = toShard(zone);
            // Fetch the block numbers for startHash and endHash in parallel
            const [startBlock, endBlock] = await Promise.all([
                this.getBlock(shard, startHash),
                this.getBlock(shard, endHash),
            ]);
            if (startBlock == null) {
                throw new Error('Could not find start block');
            }
            if (endBlock == null) {
                throw new Error('Could not find end block');
            }
            const startBlockNumber = getNumber(startBlock.woHeader.number, 'startBlockNumber');
            const endBlockNumber = getNumber(endBlock.woHeader.number, 'endBlockNumber');
            assertArgument(startBlockNumber <= endBlockNumber, 'startBlockNumber must be less than or equal to endBlockNumber', 'startBlockNumber', startBlockNumber);
            // Precompute the ranges and collect end block numbers
            const ranges = [];
            const endBlockNumbers = [];
            let currentStartBlockNumber = startBlockNumber;
            let currentStartHash = startHash;
            while (currentStartBlockNumber <= endBlockNumber) {
                // Calculate end of this segment
                const currentEndBlockNumber = Math.min(currentStartBlockNumber + 999, endBlockNumber);
                endBlockNumbers.push(currentEndBlockNumber);
                // Update for next segment
                currentStartBlockNumber = currentEndBlockNumber + 1;
            }
            // Fetch all the end block hashes in parallel
            const endBlocksPromises = endBlockNumbers.map((blockNumber) => this.getBlock(shard, blockNumber));
            const endBlocks = await Promise.all(endBlocksPromises);
            // Build the ranges using the fetched block hashes
            currentStartBlockNumber = startBlockNumber;
            currentStartHash = startHash;
            for (let i = 0; i < endBlocks.length; i++) {
                const currentEndBlock = endBlocks[i];
                if (!currentEndBlock) {
                    throw new Error(`Could not find block for block number ${endBlockNumbers[i]}`);
                }
                const currentEndHash = currentEndBlock.hash;
                ranges.push({ startHash: currentStartHash, endHash: currentEndHash });
                // Update for next segment
                currentStartBlockNumber = endBlockNumbers[i] + 1;
                currentStartHash = currentEndHash;
            }
            // Issue all RPC calls in parallel
            const promises = ranges.map((range) => {
                return this.#perform({
                    method: 'getOutpointDeltasForAddressesInRange',
                    addresses: addresses,
                    startHash: range.startHash,
                    endHash: range.endHash,
                    zone: zone,
                }).then(formatOutpointDeltas);
            });
            // Wait for all promises to resolve
            const deltasArray = await Promise.all(promises);
            // Merge all the results
            const deltas = {};
            for (const delta of deltasArray) {
                for (const [address, data] of Object.entries(delta)) {
                    if (!deltas[address]) {
                        deltas[address] = { created: [], deleted: [] };
                    }
                    deltas[address].created.push(...data.created);
                    deltas[address].deleted.push(...data.deleted);
                }
            }
            return deltas;
        }
        // Bloom-filter Queries
        async getLogs(_filter) {
            let filter = this._getFilter(_filter);
            if (isPromise(filter)) {
                filter = await filter;
            }
            const { network, params } = await resolveProperties({
                network: this.getNetwork(),
                params: this.#perform({
                    method: 'getLogs',
                    filter,
                    zone: getZoneFromNodeLocation(filter.nodeLocation),
                }),
            });
            return params.map((p) => this._wrapLog(p, network));
        }
        /**
         * @ignore
         */
        // TODO: unsupported, remove?
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _getProvider(chainId) {
            assert$1(false, 'provider cannot connect to target network', 'UNSUPPORTED_OPERATION', {
                operation: '_getProvider()',
            });
        }
        async waitForTransaction(hash, _confirms, timeout) {
            const zone = this.zoneFromHash(hash);
            const confirms = _confirms != null ? _confirms : 1;
            if (confirms === 0) {
                return this.getTransactionReceipt(hash);
            }
            // eslint-disable-next-line no-async-promise-executor
            return new Promise(async (resolve, reject) => {
                let timer = null;
                const listener = async (blockNumber) => {
                    try {
                        const receipt = await this.getTransactionReceipt(hash);
                        if (receipt != null) {
                            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                                resolve(receipt);
                                //this.off("block", listener);
                                if (timer) {
                                    clearTimeout(timer);
                                    timer = null;
                                }
                                return;
                            }
                        }
                    }
                    catch (error) {
                        console.log('Error occured while waiting for transaction:', error);
                    }
                    this.once('block', listener, zone);
                };
                if (timeout != null) {
                    timer = setTimeout(() => {
                        if (timer == null) {
                            return;
                        }
                        timer = null;
                        this.off('block', listener, zone);
                        reject(makeError('timeout', 'TIMEOUT', { reason: 'timeout' }));
                    }, timeout);
                }
                listener(await this.getBlockNumber(toShard(zone)));
            });
        }
        // TODO: not implemented yet
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async waitForBlock(shard, blockTag) {
            assert$1(false, 'not implemented yet', 'NOT_IMPLEMENTED', {
                operation: 'waitForBlock',
            });
        }
        /**
         * Clear a timer created using the {@link AbstractProvider._setTimeout | **_setTimeout**} method.
         *
         * @param {number} timerId - The ID of the timer to clear.
         */
        _clearTimeout(timerId) {
            const timer = this.#timers.get(timerId);
            if (!timer) {
                return;
            }
            if (timer.timer) {
                clearTimeout(timer.timer);
            }
            this.#timers.delete(timerId);
        }
        /**
         * Create a timer that will execute `func` after at least `timeout` (in ms). If `timeout` is unspecified, then
         * `func` will execute in the next event loop.
         *
         * {@link AbstractProvider.pause | **Pausing**} the provider will pause any associated timers.
         *
         * @ignore
         * @ignore
         * @param {() => void} _func - The function to execute.
         * @param {number} [timeout] - The time to wait before executing `func`.
         * @returns {number} The ID of the timer.
         */
        _setTimeout(_func, timeout) {
            if (timeout == null) {
                timeout = 0;
            }
            const timerId = this.#nextTimer++;
            const func = () => {
                this.#timers.delete(timerId);
                _func();
            };
            if (this.paused) {
                this.#timers.set(timerId, { timer: null, func, time: timeout });
            }
            else {
                const timer = setTimeout(func, timeout);
                this.#timers.set(timerId, { timer, func, time: getTime() });
            }
            return timerId;
        }
        /**
         * Perform `func` on each subscriber.
         *
         * @ignore
         * @param {(s: Subscriber) => void} func - The function to perform.
         */
        _forEachSubscriber(func) {
            for (const sub of this.#subs.values()) {
                func(sub.subscriber);
            }
        }
        /**
         * Sub-classes may override this to customize subscription implementations.
         *
         * @ignore
         * @param {Subscription} sub - The subscription to get the subscriber for.
         */
        _getSubscriber(sub) {
            switch (sub.type) {
                case 'debug':
                case 'error':
                case 'network':
                    return new UnmanagedSubscriber(sub.type);
                case 'block': {
                    const subscriber = new PollingBlockSubscriber(this, sub.zone);
                    subscriber.pollingInterval = this.pollingInterval;
                    return subscriber;
                }
                //! TODO: implement this for quais
                // case "safe": case "finalized":
                //     return new PollingBlockTagSubscriber(this, sub.type);
                case 'event':
                    return new PollingEventSubscriber(this, sub.filter);
                case 'transaction':
                    return new PollingTransactionSubscriber(this, sub.hash, sub.zone);
                case 'qiTransaction':
                    return new PollingQiTransactionSubscriber(this, sub.hash, sub.zone);
                case 'orphan':
                    return new PollingOrphanSubscriber(this, sub.filter, sub.zone);
            }
            throw new Error(`unsupported event: ${sub.type}`);
        }
        /**
         * If a {@link Subscriber | **Subscriber**} fails and needs to replace itself, this method may be used.
         *
         * For example, this is used for providers when using the `quai_getFilterChanges` method, which can return null if
         * state filters are not supported by the backend, allowing the Subscriber to swap in a `PollingEventSubscriber`.
         *
         * @ignore
         * @param {Subscriber} oldSub - The subscriber to replace.
         * @param {Subscriber} newSub - The new subscriber.
         */
        _recoverSubscriber(oldSub, newSub) {
            for (const sub of this.#subs.values()) {
                if (sub.subscriber === oldSub) {
                    if (sub.started) {
                        sub.subscriber.stop();
                    }
                    sub.subscriber = newSub;
                    if (sub.started) {
                        newSub.start();
                    }
                    if (this.#pausedState != null) {
                        newSub.pause(this.#pausedState);
                    }
                    break;
                }
            }
        }
        async #hasSub(event, emitArgs, zone) {
            let sub = await getSubscription(event, zone);
            // This is a log that is removing an existing log; we actually want
            // to emit an orphan event for the removed log
            if (sub.type === 'event' && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
                sub = await getSubscription({ orphan: 'drop-log', log: emitArgs[0] }, zone);
            }
            return this.#subs.get(sub.tag) || null;
        }
        async #getSub(event, zone) {
            const subscription = await getSubscription(event, zone);
            // Prevent tampering with our tag in any subclass' _getSubscriber
            const tag = subscription.tag;
            let sub = this.#subs.get(tag);
            if (!sub) {
                const subscriber = this._getSubscriber(subscription);
                const addressableMap = new WeakMap();
                const nameMap = new Map();
                sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [], zone: subscription.zone };
                this.#subs.set(tag, sub);
            }
            return sub;
        }
        async startZoneSubscriptions(zone) {
            for (const sub of Array.from(this.#subs.values())) {
                if (sub.zone === zone) {
                    if (sub.started) {
                        await sub.subscriber.start();
                    }
                }
            }
        }
        async on(event, listener, zone) {
            const sub = await this.#getSub(event, zone);
            sub.listeners.push({ listener, once: false });
            if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (this.#pausedState != null) {
                    sub.subscriber.pause(this.#pausedState);
                }
            }
            return this;
        }
        async once(event, listener, zone) {
            const sub = await this.#getSub(event, zone);
            sub.listeners.push({ listener, once: true });
            if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (this.#pausedState != null) {
                    sub.subscriber.pause(this.#pausedState);
                }
            }
            return this;
        }
        async emit(event, zone, ...args) {
            const sub = await this.#hasSub(event, args, zone);
            // If there is not subscription or if a recent emit removed
            // the last of them (which also deleted the sub) do nothing
            if (!sub || sub.listeners.length === 0) {
                return false;
            }
            const count = sub.listeners.length;
            sub.listeners = sub.listeners.filter(({ listener, once }) => {
                const payload = new EventPayload(this, once ? null : listener, event);
                try {
                    listener.call(this, ...args, payload);
                    // eslint-disable-next-line no-empty
                }
                catch (error) { }
                return !once;
            });
            if (sub.listeners.length === 0) {
                if (sub.started) {
                    sub.subscriber.stop();
                }
                this.#subs.delete(sub.tag);
            }
            return count > 0;
        }
        async listenerCount(event) {
            if (event) {
                const sub = await this.#hasSub(event);
                if (!sub) {
                    return 0;
                }
                return sub.listeners.length;
            }
            let total = 0;
            for (const { listeners } of this.#subs.values()) {
                total += listeners.length;
            }
            return total;
        }
        async listeners(event) {
            if (event) {
                const sub = await this.#hasSub(event);
                if (!sub) {
                    return [];
                }
                return sub.listeners.map(({ listener }) => listener);
            }
            let result = [];
            for (const { listeners } of this.#subs.values()) {
                result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
        }
        async off(event, listener, zone) {
            const sub = await this.#hasSub(event, [], zone);
            if (!sub) {
                return this;
            }
            if (listener) {
                const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);
                if (index >= 0) {
                    sub.listeners.splice(index, 1);
                }
            }
            if (!listener || sub.listeners.length === 0) {
                if (sub.started) {
                    sub.subscriber.stop();
                }
                this.#subs.delete(sub.tag);
            }
            return this;
        }
        async removeAllListeners(event) {
            if (event) {
                const { tag, started, subscriber } = await this.#getSub(event);
                if (started) {
                    subscriber.stop();
                }
                this.#subs.delete(tag);
            }
            else {
                for (const [tag, { started, subscriber }] of this.#subs) {
                    if (started) {
                        subscriber.stop();
                    }
                    this.#subs.delete(tag);
                }
            }
            return this;
        }
        // Alias for "on"
        async addListener(event, listener, zone) {
            return await this.on(event, listener, zone);
        }
        // Alias for "off"
        async removeListener(event, listener, zone) {
            return this.off(event, listener, zone);
        }
        /**
         * If this provider has been destroyed using the {@link AbstractProvider.destroy | **destroy**} method.
         *
         * Once destroyed, all resources are reclaimed, internal event loops and timers are cleaned up and no further
         * requests may be sent to the provider.
         */
        get destroyed() {
            return this.#destroyed;
        }
        /**
         * Sub-classes may use this to shutdown any sockets or release their resources and reject any pending requests.
         *
         * Sub-classes **must** call `super.destroy()`.
         */
        destroy() {
            // Stop all listeners
            this.removeAllListeners();
            // Shut down all tiemrs
            for (const timerId of this.#timers.keys()) {
                this._clearTimeout(timerId);
            }
            this.#destroyed = true;
        }
        /**
         * Whether the provider is currently paused.
         *
         * A paused provider will not emit any events, and generally should not make any requests to the network, but that
         * is up to sub-classes to manage.
         *
         * Setting `paused = true` is identical to calling `.pause(false)`, which will buffer any events that occur while
         * paused until the provider is unpaused.
         *
         * @returns {boolean} Whether the provider is paused.
         */
        get paused() {
            return this.#pausedState != null;
        }
        set paused(pause) {
            if (!!pause === this.paused) {
                return;
            }
            if (this.paused) {
                this.resume();
            }
            else {
                this.pause(false);
            }
        }
        /**
         * Pause the provider. If `dropWhilePaused`, any events that occur while paused are dropped, otherwise all events
         * will be emitted once the provider is unpaused.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop events while paused.
         */
        pause(dropWhilePaused) {
            this.#lastBlockNumber = -1;
            if (this.#pausedState != null) {
                if (this.#pausedState == !!dropWhilePaused) {
                    return;
                }
                assert$1(false, 'cannot change pause type; resume first', 'UNSUPPORTED_OPERATION', {
                    operation: 'pause',
                });
            }
            this._forEachSubscriber((s) => s.pause(dropWhilePaused));
            this.#pausedState = !!dropWhilePaused;
            for (const timer of this.#timers.values()) {
                // Clear the timer
                if (timer.timer) {
                    clearTimeout(timer.timer);
                }
                // Remaining time needed for when we become unpaused
                timer.time = getTime() - timer.time;
            }
        }
        /**
         * Resume the provider.
         */
        resume() {
            if (this.#pausedState == null) {
                return;
            }
            this._forEachSubscriber((s) => s.resume());
            this.#pausedState = null;
            for (const timer of this.#timers.values()) {
                // Remaining time when we were paused
                let timeout = timer.time;
                if (timeout < 0) {
                    timeout = 0;
                }
                // Start time (in cause paused, so we con compute remaininf time)
                timer.time = getTime();
                // Start the timer
                setTimeout(timer.func, timeout);
            }
        }
    }

    /**
     * Deep copies an object.
     *
     * @param {any} obj - The object to copy.
     * @returns {any} A deep copy of the object.
     */
    function copy(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * Some backends support subscribing to events using a Filter ID.
     *
     * When subscribing with this technique, the node issues a unique **Filter ID**. At this point the node dedicates
     * resources to the filter, so that periodic calls to follow up on the **Filter ID** will receive any events since the
     * last call.
     *
     * @category Providers
     */
    class FilterIdSubscriber {
        #provider;
        #filterIdPromise;
        #poller;
        #running;
        #network;
        #hault;
        zone;
        /**
         * @ignore Creates A new **FilterIdSubscriber** which will use {@link FilterIdSubscriber._subscribe | **_subscribe**}
         *   and {@link FilterIdSubscriber._emitResults | **_emitResults**} to setup the subscription and provide the event
         *   to the `provider`.
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         */
        constructor(provider, zone) {
            this.#provider = provider;
            this.#filterIdPromise = null;
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#network = null;
            this.#hault = false;
            this.zone = zone;
        }
        /**
         * Sub-classes **must** override this to begin the subscription.
         *
         * @ignore
         * @param {JsonRpcApiProvider} provider - The provider to use.
         * @returns {Promise<string>} A promise that resolves to the subscription ID.
         * @throws {Error} If the method is not overridden.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _subscribe(provider) {
            throw new Error('subclasses must override this');
        }
        /**
         * Sub-classes **must** override this to handle the events.
         *
         * @ignore
         * @param {AbstractProvider} provider - The provider to use.
         * @param {any[]} result - The results to handle.
         * @returns {Promise<void>} A promise that resolves when the results are handled.
         * @throws {Error} If the method is not overridden.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _emitResults(provider, result) {
            throw new Error('subclasses must override this');
        }
        /**
         * Sub-classes **must** override this to handle recovery on errors.
         *
         * @ignore
         * @param {AbstractProvider} provider - The provider to use.
         * @returns {Subscriber} The recovered subscriber.
         * @throws {Error} If the method is not overridden.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _recover(provider) {
            throw new Error('subclasses must override this');
        }
        /**
         * Polls for new events.
         *
         * @ignore
         * @param {number} blockNumber - The block number to poll from.
         * @returns {Promise<void>} A promise that resolves when polling is complete.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async #poll(blockNumber) {
            try {
                // Subscribe if necessary
                if (this.#filterIdPromise == null) {
                    this.#filterIdPromise = this._subscribe(this.#provider);
                }
                // Get the Filter ID
                let filterId = null;
                try {
                    filterId = await this.#filterIdPromise;
                }
                catch (error) {
                    if (!isError(error, 'UNSUPPORTED_OPERATION') || error.operation !== 'quai_newFilter') {
                        throw error;
                    }
                }
                // The backend does not support Filter ID; downgrade to
                // polling
                if (filterId == null) {
                    this.#filterIdPromise = null;
                    this.#provider._recoverSubscriber(this, this._recover(this.#provider));
                    return;
                }
                const network = await this.#provider.getNetwork();
                if (!this.#network) {
                    this.#network = network;
                }
                if (this.#network.chainId !== network.chainId) {
                    throw new Error('chain changed');
                }
                if (this.#hault) {
                    return;
                }
                const result = await this.#provider.send('quai_getFilterChanges', [filterId]);
                await this._emitResults(this.#provider, result);
            }
            catch (error) {
                console.log('@TODO', error);
            }
            this.#provider.once('block', this.#poller, this.zone);
        }
        /**
         * Tears down the subscription.
         *
         * @ignore
         */
        #teardown() {
            const filterIdPromise = this.#filterIdPromise;
            if (filterIdPromise) {
                this.#filterIdPromise = null;
                filterIdPromise.then((filterId) => {
                    this.#provider.send('quai_uninstallFilter', [filterId]);
                });
            }
        }
        /**
         * Starts the subscriber.
         */
        start() {
            if (this.#running) {
                return;
            }
            this.#running = true;
            this.#poll(-2);
        }
        /**
         * Stops the subscriber.
         */
        stop() {
            if (!this.#running) {
                return;
            }
            this.#running = false;
            this.#hault = true;
            this.#teardown();
            this.#provider.off('block', this.#poller, this.zone);
        }
        /**
         * Pauses the subscriber.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop the subscription while paused.
         */
        pause(dropWhilePaused) {
            if (dropWhilePaused) {
                this.#teardown();
            }
            this.#provider.off('block', this.#poller, this.zone);
        }
        /**
         * Resumes the subscriber.
         */
        resume() {
            this.start();
        }
    }
    /**
     * A **FilterIdSubscriber** for receiving contract events.
     *
     * @category Providers
     */
    class FilterIdEventSubscriber extends FilterIdSubscriber {
        #event;
        /**
         * @ignore Creates A new **FilterIdEventSubscriber** attached to `provider` listening for `filter`.
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         * @param {EventFilter} filter - The event filter to use.
         */
        constructor(provider, filter) {
            const zone = getZoneFromEventFilter(filter);
            if (zone == null) {
                throw new Error('Unable to determine zone for event filter');
            }
            super(provider, zone);
            this.#event = copy(filter);
        }
        /**
         * Recovers the subscriber.
         *
         * @ignore
         * @param {AbstractProvider<any>} provider - The provider to use.
         * @returns {Subscriber} The recovered subscriber.
         */
        _recover(provider) {
            return new PollingEventSubscriber(provider, this.#event);
        }
        /**
         * Subscribes to the event filter.
         *
         * @ignore
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         * @returns {Promise<string>} A promise that resolves to the subscription ID.
         */
        async _subscribe(provider) {
            const filterId = await provider.send('quai_newFilter', [this.#event]);
            return filterId;
        }
        /**
         * Emits the results of the event filter.
         *
         * @ignore
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         * @param {any[]} results - The results to emit.
         * @returns {Promise<void>} A promise that resolves when the results are emitted.
         */
        async _emitResults(provider, results) {
            for (const result of results) {
                provider.emit(this.#event, this.zone, provider._wrapLog(result, provider._network));
            }
        }
    }
    /**
     * A **FilterIdSubscriber** for receiving pending transactions events.
     *
     * @category Providers
     */
    class FilterIdPendingSubscriber extends FilterIdSubscriber {
        /**
         * Subscribes to the pending transactions filter.
         *
         * @ignore
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         * @returns {Promise<string>} A promise that resolves to the subscription ID.
         */
        async _subscribe(provider) {
            return await provider.send('quai_newPendingTransactionFilter', []);
        }
        /**
         * Emits the results of the pending transactions filter.
         *
         * @ignore
         * @param {JsonRpcApiProvider<any>} provider - The provider to use.
         * @param {any[]} results - The results to emit.
         * @returns {Promise<void>} A promise that resolves when the results are emitted.
         */
        async _emitResults(provider, results) {
            for (const result of results) {
                provider.emit('pending', this.zone, result);
            }
        }
    }

    /**
     * One of the most common ways to interact with the blockchain is by a node running a JSON-RPC interface which can be
     * connected to, based on the transport, using:
     *
     * - HTTP or HTTPS - {@link JsonRpcProvider | **JsonRpcProvider**}
     * - WebSocket - {@link WebSocketProvider | **WebSocketProvider**}
     * - IPC - {@link IpcSocketProvider | **IpcSocketProvider**}
     */
    // @TODO:
    // - Add the batching API
    // https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false
    const Primitive = 'bigint,boolean,function,number,string,symbol'.split(/,/g);
    /**
     * Deeply copies a value.
     *
     * @ignore
     * @param {T} value - The value to copy.
     * @returns {T} The copied value.
     */
    function deepCopy(value) {
        if (value == null || Primitive.indexOf(typeof value) >= 0) {
            return value;
        }
        // Keep any Addressable
        if (typeof value.getAddress === 'function') {
            return value;
        }
        if (Array.isArray(value)) {
            return value.map(deepCopy);
        }
        if (typeof value === 'object') {
            return Object.keys(value).reduce((accum, key) => {
                accum[key] = value[key];
                return accum;
            }, {});
        }
        throw new Error(`should not happen: ${value} (${typeof value})`);
    }
    /**
     * Stalls execution for a specified duration.
     *
     * @ignore
     * @param {number} duration - The duration to stall in milliseconds.
     * @returns {Promise<void>} A promise that resolves after the duration.
     */
    function stall(duration) {
        return new Promise((resolve) => {
            setTimeout(resolve, duration);
        });
    }
    const defaultOptions = {
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1 << 20,
        batchMaxCount: 100,
        cacheTimeout: 250,
        usePathing: true,
    };
    // @TODO: Unchecked Signers
    /**
     * A signer that uses JSON-RPC to sign transactions and messages.
     *
     * @category Providers
     */
    class JsonRpcSigner extends AbstractSigner {
        address;
        /**
         * Creates a new JsonRpcSigner instance.
         *
         * @param {JsonRpcApiProvider<any>} provider - The JSON-RPC provider.
         * @param {string} address - The address of the signer.
         */
        constructor(provider, address) {
            super(provider);
            address = getAddress(address);
            defineProperties(this, { address });
        }
        /**
         * Connects the signer to a provider.
         *
         * @param {null | Provider} provider - The provider to connect to.
         * @returns {Signer} The connected signer.
         * @throws {Error} If the signer cannot be reconnected.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        connect(provider) {
            assert$1(false, 'cannot reconnect JsonRpcSigner', 'UNSUPPORTED_OPERATION', {
                operation: 'signer.connect',
            });
        }
        /**
         * Gets the address of the signer.
         *
         * @returns {Promise<string>} The address of the signer.
         */
        async getAddress() {
            return this.address;
        }
        /**
         * Populates a Quai transaction.
         *
         * @ignore
         * @param {QuaiTransactionRequest} tx - The transaction request.
         * @returns {Promise<QuaiTransactionLike>} The populated transaction.
         */
        async populateQuaiTransaction(tx) {
            return (await this.populateCall(tx));
        }
        /**
         * Sends an unchecked transaction.
         *
         * @ignore
         * @param {TransactionRequest} _tx - The transaction request.
         * @returns {Promise<string>} The transaction hash.
         */
        async sendUncheckedTransaction(_tx) {
            const tx = deepCopy(_tx);
            const promises = [];
            if ('from' in tx) {
                // Make sure the from matches the sender
                if (tx.from) {
                    const _from = tx.from;
                    promises.push((async () => {
                        const from = await resolveAddress(_from);
                        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), 'from address mismatch', 'transaction', _tx);
                        tx.from = from;
                    })());
                }
                else {
                    tx.from = this.address;
                }
                // The JSON-RPC for quai_sendTransaction uses 90000 gas; if the user
                // wishes to use this, it is easy to specify explicitly, otherwise
                // we look it up for them.
                if (tx.gasLimit == null) {
                    promises.push((async () => {
                        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
                    })());
                }
                // The address may be an ENS name or Addressable
                if (tx.to != null) {
                    const _to = tx.to;
                    promises.push((async () => {
                        tx.to = await resolveAddress(_to);
                    })());
                }
            }
            // Wait until all of our properties are filled in
            if (promises.length) {
                await Promise.all(promises);
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return this.provider.send('quai_sendTransaction', [hexTx]);
        }
        /**
         * Sends a transaction.
         *
         * @param {TransactionRequest} tx - The transaction request.
         * @returns {Promise<TransactionResponse>} The transaction response.
         * @throws {Error} If the transaction cannot be sent.
         */
        async sendTransaction(tx) {
            const zone = await this.zoneFromAddress(addressFromTransactionRequest(tx));
            // This cannot be mined any earlier than any recent block
            const blockNumber = await this.provider.getBlockNumber(toShard(zone));
            // Send the transaction
            const hash = await this.sendUncheckedTransaction(tx);
            // Unfortunately, JSON-RPC only provides and opaque transaction hash
            // for a response, and we need the actual transaction, so we poll
            // for it; it should show up very quickly
            return await new Promise((resolve, reject) => {
                const timeouts = [1000, 100];
                let invalids = 0;
                const checkTx = async () => {
                    try {
                        // Try getting the transaction
                        const tx = await this.provider.getTransaction(hash);
                        if (tx != null) {
                            resolve(tx.replaceableTransaction(blockNumber));
                            return;
                        }
                    }
                    catch (error) {
                        // If we were cancelled: stop polling.
                        // If the data is bad: the node returns bad transactions
                        // If the network changed: calling again will also fail
                        // If unsupported: likely destroyed
                        if (isError(error, 'CANCELLED') ||
                            isError(error, 'BAD_DATA') ||
                            isError(error, 'NETWORK_ERROR') ||
                            isError(error, 'UNSUPPORTED_OPERATION')) {
                            if (error.info == null) {
                                error.info = {};
                            }
                            error.info.sendTransactionHash = hash;
                            reject(error);
                            return;
                        }
                        // Stop-gap for misbehaving backends; see #4513
                        if (isError(error, 'INVALID_ARGUMENT')) {
                            invalids++;
                            if (error.info == null) {
                                error.info = {};
                            }
                            error.info.sendTransactionHash = hash;
                            if (invalids > 10) {
                                reject(error);
                                return;
                            }
                        }
                        // Notify anyone that cares; but we will try again, since
                        // it is likely an intermittent service error
                        this.provider.emit('error', zoneFromHash(hash), makeError('failed to fetch transation after sending (will try again)', 'UNKNOWN_ERROR', {
                            error,
                        }));
                    }
                    // Wait another 4 seconds
                    this.provider._setTimeout(() => {
                        checkTx();
                    }, timeouts.pop() || 4000);
                };
                checkTx();
            });
        }
        /**
         * Signs a transaction.
         *
         * @param {TransactionRequest} _tx - The transaction request.
         * @returns {Promise<string>} The signed transaction.
         * @throws {Error} If the transaction cannot be signed.
         */
        async signTransaction(_tx) {
            const tx = deepCopy(_tx);
            // QuaiTransactionRequest
            if ('from' in tx) {
                if (tx.from) {
                    const from = await resolveAddress(tx.from);
                    assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), 'from address mismatch', 'transaction', _tx);
                    tx.from = from;
                }
                else {
                    tx.from = this.address;
                }
            }
            else {
                throw new Error('No QI signing implementation in provider-jsonrpc');
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return await this.provider.send('quai_signTransaction', [hexTx]);
        }
        /**
         * Signs a message.
         *
         * @param {string | Uint8Array} _message - The message to sign.
         * @returns {Promise<string>} The signed message.
         */
        async signMessage(_message) {
            const message = typeof _message === 'string' ? toUtf8Bytes(_message) : _message;
            return await this.provider.send('personal_sign', [hexlify(message), this.address.toLowerCase()]);
        }
        /**
         * Signs typed data.
         *
         * @param {TypedDataDomain} domain - The domain of the typed data.
         * @param {Record<string, TypedDataField[]>} types - The types of the typed data.
         * @param {Record<string, any>} _value - The value of the typed data.
         * @returns {Promise<string>} The signed typed data.
         */
        async signTypedData(domain, types, _value) {
            const value = deepCopy(_value);
            return await this.provider.send('quai_signTypedData_v4', [
                this.address.toLowerCase(),
                JSON.stringify(TypedDataEncoder.getPayload(domain, types, value)),
            ]);
        }
        /**
         * Unlocks the account.
         *
         * @param {string} password - The password to unlock the account.
         * @returns {Promise<boolean>} True if the account is unlocked, false otherwise.
         */
        async unlock(password) {
            return this.provider.send('personal_unlockAccount', [this.address.toLowerCase(), password, null]);
        }
        /**
         * Signs a message using the legacy method.
         *
         * @ignore
         * @param {string | Uint8Array} _message - The message to sign.
         * @returns {Promise<string>} The signed message.
         */
        async _legacySignMessage(_message) {
            const message = typeof _message === 'string' ? toUtf8Bytes(_message) : _message;
            return await this.provider.send('quai_sign', [this.address.toLowerCase(), hexlify(message)]);
        }
    }
    /**
     * The JsonRpcApiProvider is an abstract class and **MUST** be sub-classed.
     *
     * It provides the base for all JSON-RPC-based Provider interaction.
     *
     * Sub-classing Notes:
     *
     * - A sub-class MUST override _send
     * - A sub-class MUST call the `_start()` method once connected
     *
     * @category Providers
     */
    class JsonRpcApiProvider extends AbstractProvider {
        #options;
        // The next ID to use for the JSON-RPC ID field
        #nextId;
        // Payloads are queued and triggered in batches using the drainTimer
        #payloads;
        #drainTimer;
        #notReady;
        #network;
        #pendingDetectNetwork;
        /**
         * Schedules the draining of the payload queue.
         *
         * @ignore
         */
        #scheduleDrain() {
            if (this.#drainTimer) {
                return;
            }
            // If we aren't using batching, no harm in sending it immediately
            const stallTime = this._getOption('batchMaxCount') === 1 ? 0 : this._getOption('batchStallTime');
            this.#drainTimer = setTimeout(() => {
                this.#drainTimer = null;
                const payloads = this.#payloads;
                this.#payloads = [];
                while (payloads.length) {
                    // Create payload batches that satisfy our batch constraints
                    const batch = [payloads.shift()];
                    while (payloads.length) {
                        if (batch.length === this.#options.batchMaxCount) {
                            break;
                        }
                        batch.push(payloads.shift());
                        const bytes = JSON.stringify(batch.map((p) => p.payload));
                        if (bytes.length > this.#options.batchMaxSize) {
                            payloads.unshift(batch.pop());
                            break;
                        }
                    }
                    // Process the result to each payload
                    (async () => {
                        const payloadMap = new Map();
                        const nowPayloadMap = new Map();
                        for (let i = 0; i < batch.length; i++) {
                            if (batch[i].now) {
                                if (!nowPayloadMap.has(batch[i].shard)) {
                                    if (batch[i].payload != null) {
                                        nowPayloadMap.set(batch[i].shard, [batch[i].payload]);
                                    }
                                }
                                else {
                                    nowPayloadMap.get(batch[i].shard)?.push(batch[i].payload);
                                }
                            }
                            else {
                                if (!payloadMap.has(batch[i].shard)) {
                                    if (batch[i].payload != null) {
                                        payloadMap.set(batch[i].shard, [batch[i].payload]);
                                    }
                                }
                                else {
                                    payloadMap.get(batch[i].shard)?.push(batch[i].payload);
                                }
                            }
                        }
                        const rawResult = [];
                        const processPayloads = async (key, value, now) => {
                            const payload = value.length === 1 ? value[0] : value;
                            const shard = key ? toShard(key) : exports.Shard.Prime;
                            const zone = shard.length < 4 ? undefined : toZone(shard);
                            this.emit('debug', zone, { action: 'sendRpcPayload', payload });
                            rawResult.push(await this._send(payload, shard, now));
                            this.emit('debug', zone, { action: 'receiveRpcResult', payload });
                        };
                        await Promise.all(Array.from(nowPayloadMap)
                            .map(async ([key, value]) => {
                            await processPayloads(key, value, true);
                        })
                            .concat(Array.from(payloadMap).map(async ([key, value]) => {
                            await processPayloads(key, value);
                        })));
                        const result = rawResult.flat();
                        let lastZone;
                        try {
                            // Process results in batch order
                            for (const { resolve, reject, payload, shard } of batch) {
                                if (this.destroyed) {
                                    reject(makeError('provider destroyed; cancelled request', 'UNSUPPORTED_OPERATION', {
                                        operation: payload.method,
                                    }));
                                    continue;
                                }
                                if (shard) {
                                    lastZone = shard.length < 4 ? undefined : toZone(shard);
                                }
                                else {
                                    lastZone = undefined;
                                }
                                // Find the matching result
                                const resp = result.filter((r) => r.id === payload.id)[0];
                                // No result; the node failed us in unexpected ways
                                if (resp == null) {
                                    const error = makeError('missing response for request', 'BAD_DATA', {
                                        value: result,
                                        info: { payload },
                                    });
                                    this.emit('error', lastZone, error);
                                    reject(error);
                                    continue;
                                }
                                // The response is an error
                                if ('error' in resp) {
                                    reject(this.getRpcError(payload, resp, shard));
                                    continue;
                                }
                                // All good; send the result
                                resolve(resp.result);
                            }
                        }
                        catch (error) {
                            this.emit('debug', lastZone, { action: 'receiveRpcError', error });
                            for (const { reject } of batch) {
                                // @TODO: augment the error with the payload
                                reject(error);
                            }
                        }
                    })();
                }
            }, stallTime);
        }
        /**
         * Creates a new JsonRpcApiProvider instance.
         *
         * @param {Networkish} [network] - The network to connect to.
         * @param {JsonRpcApiProviderOptions} [options] - The options for the provider.
         */
        constructor(network, options) {
            super(network, options);
            this.#nextId = 1;
            this.#options = Object.assign({}, defaultOptions, options || {});
            this.#payloads = [];
            this.#drainTimer = null;
            this.#network = null;
            this.#pendingDetectNetwork = null;
            {
                let resolve = null;
                const promise = new Promise((_resolve) => {
                    resolve = _resolve;
                });
                this.#notReady = { promise, resolve };
            }
            const staticNetwork = this._getOption('staticNetwork');
            if (typeof staticNetwork === 'boolean') {
                assertArgument(!staticNetwork || network !== 'any', "staticNetwork cannot be used on special network 'any'", 'options', options);
                if (staticNetwork && network != null) {
                    this.#network = Network.from(network);
                }
            }
            else if (staticNetwork) {
                // Make sure any static network is compatbile with the provided netwrok
                assertArgument(network == null || staticNetwork.matches(network), 'staticNetwork MUST match network object', 'options', options);
                this.#network = staticNetwork;
            }
        }
        /**
         * Returns the value associated with the option `key`.
         *
         * Sub-classes can use this to inquire about configuration options.
         *
         * @ignore
         * @param {keyof JsonRpcApiProviderOptions} key - The option key.
         * @returns {JsonRpcApiProviderOptions[key]} The option value.
         */
        _getOption(key) {
            return this.#options[key];
        }
        /**
         * Gets the {@link Network | **Network**} this provider has committed to. On each call, the network is detected, and
         * if it has changed, the call will reject.
         *
         * @ignore
         * @returns {Network} The network.
         * @throws {Error} If the network is not available yet.
         */
        get _network() {
            assert$1(this.#network, 'network is not available yet', 'NETWORK_ERROR');
            return this.#network;
        }
        /**
         * Resolves to the non-normalized value by performing `req`.
         *
         * Sub-classes may override this to modify behavior of actions, and should generally call `super._perform` as a
         * fallback.
         *
         * @ignore
         * @param {PerformActionRequest} req - The request to perform.
         * @returns {Promise<any>} The result of the request.
         * @throws {Error} If the request fails.
         */
        async _perform(req) {
            // Legacy networks do not like the type field being passed along (which
            // is fair), so we delete type if it is 0 and a non-EIP-1559 network
            if (req.method !== 'getRunningLocations') {
                await this.initPromise;
            }
            if (req.method === 'call' || req.method === 'estimateGas') {
                const tx = req.transaction;
                if (tx && tx.type != null && getBigInt(tx.type)) {
                    // If there are no EIP-1559 properties, it might be non-EIP-a559
                    if (tx.gasPrice == null && tx.minerTip == null) {
                        const feeData = await this.getFeeData(req.zone, tx.type === 1);
                        if (feeData.gasPrice == null && feeData.minerTip == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            req = Object.assign({}, req, {
                                transaction: Object.assign({}, tx, { type: undefined }),
                            });
                        }
                    }
                }
            }
            const request = this.getRpcRequest(req);
            if (request != null) {
                const shard = 'shard' in req ? req.shard : 'zone' in req ? toShard(req.zone) : undefined;
                if (req.method === 'getRunningLocations') {
                    return await this.send(request.method, request.args, shard, req.now);
                }
                else {
                    return await this.send(request.method, request.args, shard);
                }
            }
            return super._perform(req);
        }
        /**
         * Sub-classes may override this; it detects the _actual_ network that we are **currently** connected to.
         *
         * Keep in mind that {@link JsonRpcApiProvider.send | **send**} may only be used once
         * {@link JsonRpcApiProvider.ready | **ready**}, otherwise the _send primitive must be used instead.
         *
         * @ignore
         * @returns {Promise<Network>} The detected network.
         * @throws {Error} If network detection fails.
         */
        async _detectNetwork() {
            const network = this._getOption('staticNetwork');
            if (network) {
                if (network === true) {
                    if (this.#network) {
                        return this.#network;
                    }
                }
                else {
                    return network;
                }
            }
            if (this.#pendingDetectNetwork) {
                return await this.#pendingDetectNetwork;
            }
            // If we are ready, use `send`, which enabled requests to be batched
            if (this.ready) {
                this.#pendingDetectNetwork = (async () => {
                    try {
                        const result = Network.from(getBigInt(await this.send('quai_chainId', [])));
                        this.#pendingDetectNetwork = null;
                        return result;
                    }
                    catch (error) {
                        this.#pendingDetectNetwork = null;
                        throw error;
                    }
                })();
                return await this.#pendingDetectNetwork;
            }
            // We are not ready yet; use the primitive _send
            this.#pendingDetectNetwork = (async () => {
                const payload = {
                    id: this.#nextId++,
                    method: 'quai_chainId',
                    params: [],
                    jsonrpc: '2.0',
                };
                this.emit('debug', undefined, { action: 'sendRpcPayload', payload });
                let result;
                try {
                    result = (await this._send(payload))[0];
                    this.#pendingDetectNetwork = null;
                }
                catch (error) {
                    this.#pendingDetectNetwork = null;
                    this.emit('debug', undefined, { action: 'receiveRpcError', error });
                    throw error;
                }
                this.emit('debug', undefined, { action: 'receiveRpcResult', result });
                if ('result' in result) {
                    return Network.from(getBigInt(result.result));
                }
                throw this.getRpcError(payload, result);
            })();
            return await this.#pendingDetectNetwork;
        }
        /**
         * Sub-classes **MUST** call this. Until {@link JsonRpcApiProvider._start | **_start**} has been called, no calls
         * will be passed to {@link JsonRpcApiProvider._send | **_send**} from {@link JsonRpcApiProvider.send | **send**} . If
         * it is overridden, then `super._start()` **MUST** be called.
         *
         * Calling it multiple times is safe and has no effect.
         *
         * @ignore
         */
        _start() {
            this.attemptConnect = true;
            if (this.#notReady == null || this.#notReady.resolve == null) {
                return;
            }
            this.#notReady.resolve();
            this.#notReady = null;
            (async () => {
                let retries = 0;
                const maxRetries = 5;
                while (this.#network == null && !this.destroyed && retries < maxRetries) {
                    try {
                        this.#network = await this._detectNetwork();
                    }
                    catch (error) {
                        if (this.destroyed) {
                            break;
                        }
                        console.log('JsonRpcProvider failed to detect network and cannot start up; retrying (perhaps the URL is wrong or the node is not started)');
                        this.emit('error', undefined, makeError('failed to bootstrap network detection', 'NETWORK_ERROR', {
                            event: 'initial-network-discovery',
                            info: { error },
                        }));
                        await stall(1000 * Math.pow(2, retries));
                        retries++;
                    }
                }
                if (retries >= maxRetries) {
                    console.log('JsonRpcProvider failed to detect network and cannot start up; retry limit reached');
                    makeError('failed to bootstrap network detection', 'NETWORK_ERROR', {
                        event: 'initial-network-discovery',
                        info: { retries },
                    });
                }
                // Start dispatching requests
                this.#scheduleDrain();
            })();
        }
        /**
         * Resolves once the {@link JsonRpcApiProvider._start | **_start**} has been called. This can be used in sub-classes
         * to defer sending data until the connection has been established.
         *
         * @ignore
         * @returns {Promise<void>} A promise that resolves once the provider is ready.
         */
        async _waitUntilReady() {
            if (this._initFailed) {
                console.log('init failed');
                throw new Error('Provider failed to initialize on creation. Run initialize or create a new provider.');
            }
            // Flag to control the loop in setAttemptConnect
            let keepAttempting = true;
            // Function to set attemptConnect every 2 seconds
            const setAttemptConnect = async () => {
                while (keepAttempting) {
                    this.attemptConnect = true;
                    await new Promise((resolve) => setTimeout(resolve, 2000));
                }
            };
            // Start setting attemptConnect in the background
            setAttemptConnect();
            try {
                // Wait until initPromise resolves
                await this.initPromise;
            }
            finally {
                // Stop setting attemptConnect once initPromise resolves
                keepAttempting = false;
            }
        }
        /**
         * Return a Subscriber that will manage the `sub`.
         *
         * Sub-classes may override this to modify the behavior of subscription management.
         *
         * @ignore
         * @param {Subscription} sub - The subscription to manage.
         * @returns {Subscriber} The subscriber that will manage the subscription.
         */
        _getSubscriber(sub) {
            // Pending Filters aren't availble via polling
            if (sub.type === 'pending') {
                return new FilterIdPendingSubscriber(this, sub.zone);
            }
            if (sub.type === 'event') {
                return new FilterIdEventSubscriber(this, sub.filter);
            }
            // Orphaned Logs are handled automatically, by the filter, since
            // logs with removed are emitted by it
            if (sub.type === 'orphan' && sub.filter.orphan === 'drop-log') {
                return new UnmanagedSubscriber('orphan');
            }
            return super._getSubscriber(sub);
        }
        /**
         * Returns true only if the {@link JsonRpcApiProvider._start | **_start**} has been called.
         *
         * @returns {boolean} True if the provider is ready.
         */
        get ready() {
            return this.#notReady == null;
        }
        /**
         * Returns `tx` as a normalized JSON-RPC transaction request, which has all values hexlified and any numeric values
         * converted to Quantity values.
         *
         * @ignore
         * @param {TransactionRequest} tx - The transaction to normalize.
         * @returns {JsonRpcTransactionRequest} The normalized transaction.
         * @throws {Error} If the transaction is invalid.
         */
        getRpcTransaction(tx) {
            const result = {};
            if ('from' in tx || ('to' in tx && 'data' in tx)) {
                // JSON-RPC now requires numeric values to be "quantity" values
                ['chainId', 'gasLimit', 'gasPrice', 'type', 'gasPrice', 'minerTip', 'nonce', 'value'].forEach((key) => {
                    if (tx[key] == null) {
                        return;
                    }
                    let dstKey = key;
                    if (key === 'gasLimit') {
                        dstKey = 'gas';
                    }
                    result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
                });
                ['from', 'to', 'data'].forEach((key) => {
                    if (tx[key] == null) {
                        return;
                    }
                    result[key] = hexlify(tx[key]);
                });
                // Normalize the access list object
                if ('accessList' in tx && tx.accessList) {
                    result['accessList'] = accessListify(tx.accessList);
                }
            }
            else {
                if (tx.txInputs != null) {
                    result['txInputs'] = tx.txInputs.map((input) => ({
                        txhash: hexlify(input.txhash),
                        index: toQuantity(getBigInt(input.index, `tx.txInputs.${input.index}`)),
                        pubkey: hexlify(input.pubkey),
                    }));
                }
                if (tx.txOutputs != null) {
                    result['txOutputs'] = tx.txOutputs.map((output) => ({
                        address: hexlify(output.address),
                        denomination: toQuantity(getBigInt(output.denomination, `tx.txOutputs.${output.denomination}`)),
                    }));
                }
            }
            return result;
        }
        /**
         * Returns the request method and arguments required to perform `req`.
         *
         * @ignore
         * @param {PerformActionRequest} req - The request to perform.
         * @returns {null | { method: string; args: any[] }} The method and arguments to use.
         * @throws {Error} If the request is not supported or invalid.
         */
        getRpcRequest(req) {
            switch (req.method) {
                case 'chainId':
                    return { method: 'quai_chainId', args: [] };
                case 'getBlockNumber':
                    return { method: 'quai_blockNumber', args: [] };
                case 'getGasPrice':
                    return {
                        method: 'quai_gasPrice',
                        args: [],
                    };
                case 'getMinerTip':
                    return { method: 'quai_minerTip', args: [] };
                case 'getPendingHeader':
                    return { method: 'quai_getPendingHeader', args: [] };
                case 'getBalance':
                    return {
                        method: 'quai_getBalance',
                        args: [req.address, req.blockTag],
                    };
                case 'getLockedBalance':
                    return {
                        method: 'quai_getLockedBalance',
                        args: [req.address],
                    };
                case 'getOutpointsByAddress':
                    return {
                        method: 'quai_getOutpointsByAddress',
                        args: [req.address],
                    };
                case 'getTransactionCount':
                    return {
                        method: 'quai_getTransactionCount',
                        args: [req.address, req.blockTag],
                    };
                case 'getCode':
                    return {
                        method: 'quai_getCode',
                        args: [req.address, req.blockTag],
                    };
                case 'getStorage':
                    return {
                        method: 'quai_getStorageAt',
                        args: [req.address, '0x' + req.position.toString(16), req.blockTag],
                    };
                case 'broadcastTransaction':
                    return {
                        method: 'quai_sendRawTransaction',
                        args: [req.signedTransaction],
                    };
                case 'getBlock':
                    if ('blockTag' in req) {
                        return {
                            method: 'quai_getBlockByNumber',
                            args: [req.blockTag, !!req.includeTransactions],
                        };
                    }
                    else if ('blockHash' in req) {
                        return {
                            method: 'quai_getBlockByHash',
                            args: [req.blockHash, !!req.includeTransactions],
                        };
                    }
                    break;
                case 'getTransaction':
                    return {
                        method: 'quai_getTransactionByHash',
                        args: [req.hash],
                    };
                case 'getTransactionReceipt':
                    return {
                        method: 'quai_getTransactionReceipt',
                        args: [req.hash],
                    };
                case 'call':
                    return {
                        method: 'quai_call',
                        args: [this.getRpcTransaction(req.transaction), req.blockTag],
                    };
                case 'estimateGas': {
                    return {
                        method: 'quai_estimateGas',
                        args: [this.getRpcTransaction(req.transaction)],
                    };
                }
                case 'estimateFeeForQi': {
                    return {
                        method: 'quai_estimateFeeForQi',
                        args: [req.transaction],
                    };
                }
                case 'createAccessList': {
                    return {
                        method: 'quai_createAccessList',
                        args: [this.getRpcTransaction(req.transaction)],
                    };
                }
                case 'getRunningLocations': {
                    return {
                        method: 'quai_listRunningChains',
                        args: [],
                    };
                }
                case 'getProtocolTrieExpansionCount': {
                    return {
                        method: 'quai_getProtocolExpansionNumber',
                        args: [],
                    };
                }
                case 'getProtocolExpansionNumber': {
                    return {
                        method: 'quai_getProtocolExpansionNumber',
                        args: [],
                    };
                }
                case 'getQiRateAtBlock': {
                    return {
                        method: 'quai_qiRateAtBlock',
                        args: [req.blockTag, req.amt],
                    };
                }
                case 'getQuaiRateAtBlock': {
                    return {
                        method: 'quai_quaiRateAtBlock',
                        args: [req.blockTag, req.amt],
                    };
                }
                case 'getLogs':
                    return { method: 'quai_getLogs', args: [req.filter] };
                case 'getTxPoolContent':
                    return { method: 'txpool_content', args: [] };
                case 'txPoolInspect':
                    return { method: 'txpool_inspect', args: [] };
                case 'getOutpointDeltasForAddressesInRange':
                    return {
                        method: 'quai_getOutpointDeltasForAddressesInRange',
                        args: [req.addresses, req.startHash, req.endHash],
                    };
            }
            return null;
        }
        /**
         * Returns an quais-style Error for the given JSON-RPC error `payload`, coalescing the various strings and error
         * shapes that different nodes return, coercing them into a machine-readable standardized error.
         *
         * @ignore
         * @param {JsonRpcPayload} payload - The payload that was sent.
         * @param {JsonRpcError} _error - The error that was received.
         * @returns {Error} The coalesced error.
         */
        getRpcError(payload, _error, shard) {
            const { method } = payload;
            const { error } = _error;
            if (method === 'quai_estimateGas' && error.message) {
                const msg = error.message;
                if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
                    return makeError('insufficient funds', 'INSUFFICIENT_FUNDS', {
                        transaction: payload.params[0],
                        info: { payload, error, shard },
                    });
                }
            }
            if (method === 'quai_call' || method === 'quai_estimateGas') {
                const result = spelunkData(error);
                const e = AbiCoder.getBuiltinCallException(method === 'quai_call' ? 'call' : 'estimateGas', payload.params[0], result ? result.data : null);
                e.info = { error, payload, shard };
                return e;
            }
            // Only estimateGas and call can return arbitrary contract-defined text, so now we
            // we can process text safely.
            const message = JSON.stringify(spelunkMessage(error));
            if (method === 'quai_getTransactionByHash' && error.message && error.message.match(/transaction not found/i)) {
                return makeError('transaction not found', 'TRANSACTION_NOT_FOUND', { info: { payload, error, shard } });
            }
            if (typeof error.message === 'string' && error.message.match(/user denied|quais-user-denied/i)) {
                const actionMap = {
                    quai_sign: 'signMessage',
                    personal_sign: 'signMessage',
                    quai_signTypedData_v4: 'signTypedData',
                    quai_signTransaction: 'signTransaction',
                    quai_sendTransaction: 'sendTransaction',
                    quai_requestAccounts: 'requestAccess',
                    wallet_requestAccounts: 'requestAccess',
                };
                return makeError(`user rejected action`, 'ACTION_REJECTED', {
                    action: actionMap[method] || 'unknown',
                    reason: 'rejected',
                    info: { payload, error, shard },
                });
            }
            if (method === 'quai_sendRawTransaction' || method === 'quai_sendTransaction') {
                const transaction = payload.params[0];
                if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
                    return makeError('insufficient funds for intrinsic transaction cost', 'INSUFFICIENT_FUNDS', {
                        transaction,
                        info: { error, shard },
                    });
                }
                if (message.match(/nonce/i) && message.match(/too low/i)) {
                    return makeError('nonce has already been used', 'NONCE_EXPIRED', {
                        transaction,
                        info: { error, shard },
                    });
                }
                // "replacement transaction underpriced"
                if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
                    return makeError('replacement fee too low', 'REPLACEMENT_UNDERPRICED', {
                        transaction,
                        info: { error, shard },
                    });
                }
                if (message.match(/only replay-protected/i)) {
                    return makeError('legacy pre-eip-155 transactions not supported', 'UNSUPPORTED_OPERATION', {
                        operation: method,
                        info: { transaction, info: { error, shard } },
                    });
                }
                if (message.match(/already known/i)) {
                    return makeError('transaction already known', 'TRANSACTION_ALREADY_KNOWN', { info: { error, shard } });
                }
            }
            let unsupported = !!message.match(/the method .* does not exist/i);
            if (!unsupported) {
                if (error && error.details && error.details.startsWith('Unauthorized method:')) {
                    unsupported = true;
                }
            }
            if (unsupported) {
                return makeError('unsupported operation', 'UNSUPPORTED_OPERATION', {
                    operation: payload.method,
                    info: { error, payload, shard },
                });
            }
            if (message.match('Provider failed to initialize on creation. Run initialize or create a new provider.')) {
                return makeError('Provider failed to initialize on creation. Run initUrlMap or create a new provider.', 'PROVIDER_FAILED_TO_INITIALIZE', {
                    info: { payload, error, shard },
                });
            }
            return makeError('could not coalesce error', 'UNKNOWN_ERROR', { error, payload, shard });
        }
        /**
         * Requests the `method` with `params` via the JSON-RPC protocol over the underlying channel. This can be used to
         * call methods on the backend that do not have a high-level API within the Provider API.
         *
         * This method queues requests according to the batch constraints in the options, assigns the request a unique ID.
         *
         * **Do NOT override** this method in sub-classes; instead override {@link JsonRpcApiProvider._send | **_send**} or
         * force the options values in the call to the constructor to modify this method's behavior.
         *
         * @param {string} method - The method to call.
         * @param {any[] | Record<string, any>} params - The parameters to pass to the method.
         * @param {Shard} shard - The shard to send the request to.
         * @param {boolean} now - If true, the request will be sent immediately.
         * @returns {Promise<any>} A promise that resolves to the result of the method call.
         */
        send(method, params, shard, now) {
            const continueSend = () => {
                if (this.destroyed) {
                    return Promise.reject(makeError('provider destroyed; cancelled request', 'UNSUPPORTED_OPERATION', { operation: method }));
                }
                const id = this.#nextId++;
                const promise = new Promise((resolve, reject) => {
                    this.#payloads.push({
                        resolve,
                        reject,
                        payload: { method, params, id, jsonrpc: '2.0' },
                        shard: shard,
                        now: now,
                    });
                });
                // If there is not a pending drainTimer, set one
                this.#scheduleDrain();
                return promise;
            };
            // @TODO: cache chainId?? purge on switch_networks
            // We have been destroyed; no operations are supported anymore
            if (method !== 'quai_listRunningChains') {
                return this.initPromise.then(() => {
                    return continueSend();
                });
            }
            else {
                return continueSend();
            }
        }
        /**
         * Returns a JsonRpcSigner for the given address.
         *
         * @param {number | string} [address] - The address or index of the account.
         * @returns {Promise<JsonRpcSigner>} A promise that resolves to the JsonRpcSigner.
         * @throws {Error} If the account is invalid.
         */
        async getSigner(address) {
            if (address == null) {
                address = 0;
            }
            const accountsPromise = this.send('quai_accounts', []);
            // Account index
            if (typeof address === 'number') {
                const accounts = await accountsPromise;
                if (address >= accounts.length) {
                    throw new Error('no such account');
                }
                return new JsonRpcSigner(this, accounts[address]);
            }
            const { accounts } = await resolveProperties({
                network: this.getNetwork(),
                accounts: accountsPromise,
            });
            // Account address
            address = getAddress(address);
            for (const account of accounts) {
                if (getAddress(account) === address) {
                    return new JsonRpcSigner(this, address);
                }
            }
            throw new Error('invalid account');
        }
        /**
         * Returns a list of JsonRpcSigners for all accounts.
         *
         * @returns {Promise<JsonRpcSigner[]>} A promise that resolves to an array of JsonRpcSigners.
         */
        async listAccounts() {
            const accounts = await this.send('quai_accounts', []);
            return accounts.map((a) => new JsonRpcSigner(this, a));
        }
        /**
         * Destroys the provider, stopping all processing and canceling all pending requests.
         */
        destroy() {
            // Stop processing requests
            if (this.#drainTimer) {
                clearTimeout(this.#drainTimer);
                this.#drainTimer = null;
            }
            // Cancel all pending requests
            for (const { payload, reject } of this.#payloads) {
                reject(makeError('provider destroyed; cancelled request', 'UNSUPPORTED_OPERATION', {
                    operation: payload.method,
                }));
            }
            this.#payloads = [];
            // Parent clean-up
            super.destroy();
        }
    }
    /**
     * The JsonRpcProvider is one of the most common Providers, which performs all operations over HTTP (or HTTPS) requests.
     *
     * Events are processed by polling the backend for the current block number; when it advances, all block-base events are
     * then checked for updates.
     *
     * @category Providers
     */
    class JsonRpcProvider extends JsonRpcApiProvider {
        constructor(urls, network, options) {
            if (urls == null) {
                urls = ['http://localhost:8545'];
            }
            super(network, options);
            if (Array.isArray(urls)) {
                urls.forEach((url) => {
                    this.validateUrl(url);
                });
                this.initialize(urls);
            }
            else if (typeof urls === 'string') {
                this.validateUrl(urls);
                this.initialize([urls]);
            }
            else {
                this.validateUrl(urls.url);
                this.initialize(urls.clone());
            }
        }
        _getSubscriber(sub) {
            const subscriber = super._getSubscriber(sub);
            return subscriber;
        }
        _getConnection(shard) {
            if (this._initFailed) {
                throw new Error('Provider failed to initialize on creation. Run initUrlMap or create a new provider.');
            }
            let connection;
            if (shard !== undefined) {
                connection = this._urlMap.get(shard) ?? this.connect[this.connect.length - 1].clone();
            }
            else {
                connection = this.connect[this.connect.length - 1].clone();
            }
            return new FetchRequest(connection.url);
        }
        async send(method, params, shard, now) {
            try {
                this._start();
                return await super.send(method, params, shard, now);
            }
            catch (error) {
                return Promise.reject(error);
            }
            // All requests are over HTTP, so we can just start handling requests
            // We do this here rather than the constructor so that we don't send any
            // requests to the network (i.e. quai_chainId) until we absolutely have to.
        }
        async _send(payload, shard, now) {
            if (this._initFailed) {
                return [
                    {
                        id: Array.isArray(payload) ? payload[0].id : payload.id,
                        error: {
                            code: -32000,
                            message: 'Provider failed to initialize on creation. Run initialize or create a new provider.',
                        },
                    },
                ];
            }
            try {
                if (!now) {
                    await this._waitUntilReady();
                }
            }
            catch (error) {
                return [
                    {
                        id: Array.isArray(payload) ? payload[0].id : payload.id,
                        error: {
                            code: -32000,
                            message: 'Provider failed to initialize on creation. Run initialize or create a new provider.',
                        },
                    },
                ];
            }
            // Configure a POST connection for the requested method
            try {
                const request = this._getConnection(shard);
                request.body = JSON.stringify(payload);
                request.setHeader('content-type', 'application/json');
                const response = await request.send();
                response.assertOk();
                let resp = response.bodyJson;
                if (!Array.isArray(resp)) {
                    resp = [resp];
                }
                return resp;
            }
            catch (error) {
                return [
                    {
                        id: Array.isArray(payload) ? payload[0].id : payload.id,
                        error: {
                            code: -32000,
                            message: error instanceof Error ? error.message : String(error),
                        },
                    },
                ];
            }
        }
    }
    function spelunkData(value) {
        if (value == null) {
            return null;
        }
        // These *are* the droids we're looking for.
        if (typeof value.message === 'string' && value.message.match(/revert/i) && isHexString(value.data)) {
            return { message: value.message, data: value.data };
        }
        // Spelunk further...
        if (typeof value === 'object') {
            for (const key in value) {
                const result = spelunkData(value[key]);
                if (result) {
                    return result;
                }
            }
            return null;
        }
        // Might be a JSON string we can further descend...
        if (typeof value === 'string') {
            try {
                return spelunkData(JSON.parse(value));
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
        }
        return null;
    }
    function _spelunkMessage(value, result) {
        if (value == null) {
            return;
        }
        // These *are* the droids we're looking for.
        if (typeof value.message === 'string') {
            result.push(value.message);
        }
        // Spelunk further...
        if (typeof value === 'object') {
            for (const key in value) {
                _spelunkMessage(value[key], result);
            }
        }
        // Might be a JSON string we can further descend...
        if (typeof value === 'string') {
            try {
                return _spelunkMessage(JSON.parse(value), result);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
        }
    }
    function spelunkMessage(value) {
        const result = [];
        _spelunkMessage(value, result);
        return result;
    }

    // A = Arguments to the constructor
    // I = Interface of deployed contracts
    /**
     * A **ContractFactory** is used to deploy a Contract to the blockchain.
     *
     * @category Contract
     */
    class ContractFactory {
        /**
         * The Contract Interface.
         */
        interface;
        /**
         * The Contract deployment bytecode. Often called the initcode.
         */
        bytecode;
        /**
         * The ContractRunner to deploy the Contract as.
         */
        runner;
        /**
         * Create a new **ContractFactory** with `abi` and `bytecode`, optionally connected to `runner`.
         *
         * The `bytecode` may be the `bytecode` property within the standard Solidity JSON output.
         */
        constructor(abi, bytecode, runner) {
            const iface = Interface.from(abi);
            // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
            if (bytecode instanceof Uint8Array) {
                bytecode = hexlify(getBytes(bytecode));
            }
            else {
                if (typeof bytecode === 'object') {
                    bytecode = bytecode.object;
                }
                if (!bytecode.startsWith('0x')) {
                    bytecode = '0x' + bytecode;
                }
                bytecode = hexlify(getBytes(bytecode));
            }
            defineProperties(this, {
                bytecode,
                interface: iface,
                runner: runner || null,
            });
        }
        attach(target) {
            return new BaseContract(target, this.interface, this.runner);
        }
        /**
         * Resolves to the transaction to deploy the contract, passing `args` into the constructor.
         *
         * @param {ContractMethods<A>} args - The arguments to the constructor.
         * @returns {Promise<ContractDeployTransaction>} A promise resolving to the deployment transaction.
         */
        async getDeployTransaction(...args) {
            let overrides;
            const fragment = this.interface.deploy;
            if (fragment.inputs.length + 1 === args.length) {
                overrides = await copyOverrides(args.pop());
                const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
                const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
                return Object.assign({}, overrides, { data });
            }
            if (fragment.inputs.length !== args.length) {
                throw new Error('incorrect number of arguments to constructor');
            }
            const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
            const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
            const from = args.pop()?.from || undefined;
            return Object.assign({}, from, { data });
        }
        /**
         * Resolves to the Contract deployed by passing `args` into the constructor.
         *
         * This will resovle to the Contract before it has been deployed to the network, so the
         * [baseContract.waitForDeployment](../classes/BaseContract#waitForDeployment) should be used before sending any
         * transactions to it.
         *
         * @param {ContractMethods<A>} args - The arguments to the constructor.
         * @returns {Promise<
         *     BaseContract & { deploymentTransaction(): ContractTransactionResponse } & Omit<I, keyof BaseContract>
         * >}
         *   A promise resolving to the Contract.
         */
        async deploy(...args) {
            const tx = await this.getDeployTransaction(...args);
            assert$1(this.runner && typeof this.runner.sendTransaction === 'function', 'factory runner does not support sending transactions', 'UNSUPPORTED_OPERATION', {
                operation: 'sendTransaction',
            });
            if (this.runner instanceof Wallet || this.runner instanceof JsonRpcSigner) {
                validateAddress(this.runner.address);
                tx.from = this.runner.address;
            }
            const grindedTx = await this.grindContractAddress(tx);
            grindedTx.accessList = await this.runner.createAccessList?.(grindedTx);
            const sentTx = await this.runner.sendTransaction(grindedTx);
            const address = getStatic(this.constructor, 'getContractAddress')?.(tx);
            return new BaseContract(address, this.interface, this.runner, sentTx);
        }
        static getContractAddress(transaction) {
            return getContractAddress(transaction.from, BigInt(transaction.nonce), // Fix: Convert BigInt to bigint
            transaction.data);
        }
        async grindContractAddress(tx) {
            if (tx.nonce == null && tx.from) {
                tx.nonce = await this.runner?.provider?.getTransactionCount(tx.from);
            }
            const sender = String(tx.from);
            const toShard = getZoneForAddress(sender);
            let i = 0;
            const startingData = tx.data;
            const salt = new Uint8Array(4);
            // initialize salt with the lower 32 bits of the nonce
            new DataView(salt.buffer).setUint32(0, Number(tx.nonce) & 0xffffffff, false);
            while (i < 10000) {
                tx.data = hexlify(concat([String(startingData), salt]));
                const contractAddress = getContractAddress(sender, BigInt(tx.nonce || 0), tx.data || '');
                const contractShard = getZoneForAddress(contractAddress);
                const utxo = isQiAddress(contractAddress);
                if (contractShard === toShard && !utxo) {
                    return tx;
                }
                // Increment the salt
                let saltValue = new DataView(salt.buffer).getUint32(0, false);
                saltValue++;
                new DataView(salt.buffer).setUint32(0, saltValue, false);
                i++;
            }
            return tx;
        }
        /**
         * Return a new **ContractFactory** with the same ABI and bytecode, but connected to `runner`.
         *
         * @param {ContractRunner} runner - The runner to connect to.
         * @returns {ContractFactory<A, I>} A new ContractFactory.
         */
        connect(runner) {
            return new ContractFactory(this.interface, this.bytecode, runner);
        }
        /**
         * Create a new **ContractFactory** from the standard Solidity JSON output.
         *
         * @param {any} output - The Solidity JSON output.
         * @param {ContractRunner} runner - The runner to connect to.
         * @returns {ContractFactory<A, I>} A new ContractFactory.
         */
        static fromSolidity(output, runner) {
            assertArgument(output != null, 'bad compiler output', 'output', output);
            if (typeof output === 'string') {
                output = JSON.parse(output);
            }
            const abi = output.abi;
            let bytecode = '';
            if (output.bytecode) {
                bytecode = output.bytecode;
            }
            else if (output.evm && output.evm.bytecode) {
                bytecode = output.evm.bytecode;
            }
            return new this(abi, bytecode, runner);
        }
    }

    /**
     * A **BrowserProvider** is intended to wrap an injected provider which adheres to the
     * [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) standard, which most (if not all) currently do.
     *
     * @category Providers
     * @class
     * @extends JsonRpcApiProvider
     */
    class BrowserProvider extends JsonRpcApiProvider {
        #request;
        /**
         * Connect to the `ethereum` provider, optionally forcing the `network`.
         *
         * @class
         * @param {Eip1193Provider} ethereum - The EIP-1193 provider.
         * @param {Networkish} [network] - The network to connect to.
         */
        constructor(ethereum, network) {
            super(network, { batchMaxCount: 1 });
            if (this.initResolvePromise)
                this.initResolvePromise();
            this.#request = async (method, params, shard) => {
                const payload = { method, params, shard };
                this.emit('debug', undefined, { action: 'sendEip1193Request', payload });
                try {
                    const result = await ethereum.request(payload);
                    this.emit('debug', undefined, { action: 'receiveEip1193Result', result });
                    return result;
                }
                catch (e) {
                    const error = new Error(e.message);
                    error.code = e.code;
                    error.data = e.data;
                    error.payload = payload;
                    this.emit('debug', undefined, { action: 'receiveEip1193Error', error });
                    throw error;
                }
            };
        }
        /**
         * Resolves to `true` if the provider manages the `address`.
         *
         * @param {number | string} address - The address to check.
         * @returns {Promise<boolean>} Resolves to `true` if the provider manages the `address`.
         */
        async hasSigner(address) {
            if (address == null) {
                address = 0;
            }
            const accounts = await this.send('quai_accounts', []);
            if (typeof address === 'number') {
                return accounts.length > address;
            }
            address = address.toLowerCase();
            return accounts.filter((a) => a.toLowerCase() === address).length !== 0;
        }
        /**
         * Sends a JSON-RPC request.
         *
         * @param {string} method - The method name.
         * @param {any[] | Record<string, any>} params - The parameters for the method.
         * @returns {Promise<any>} The result of the request.
         */
        async send(method, params, shard) {
            await this._start();
            return await super.send(method, params, shard);
        }
        /**
         * Sends a JSON-RPC payload.
         *
         * @ignore
         * @ignore
         * @param {JsonRpcPayload | JsonRpcPayload[]} payload - The JSON-RPC payload.
         * @returns {Promise<(JsonRpcResult | JsonRpcError)[]>} The result of the request.
         */
        async _send(payload, shard) {
            assertArgument(!Array.isArray(payload), 'EIP-1193 does not support batch request', 'payload', payload);
            try {
                const result = await this.#request(payload.method, payload.params || [], shard);
                return [{ id: payload.id, result }];
            }
            catch (e) {
                return [
                    {
                        id: payload.id,
                        error: { code: e.code, data: e.data, message: e.message, shard: shard || undefined },
                    },
                ];
            }
        }
        /**
         * Gets the RPC error.
         *
         * @param {JsonRpcPayload} payload - The JSON-RPC payload.
         * @param {JsonRpcError} error - The JSON-RPC error.
         * @returns {Error} The RPC error.
         */
        getRpcError(payload, error) {
            error = JSON.parse(JSON.stringify(error));
            // EIP-1193 gives us some machine-readable error codes, so rewrite
            // them into
            switch (error.error.code || -1) {
                case 4001:
                    error.error.message = `quais-user-denied: ${error.error.message}`;
                    break;
                case 4200:
                    error.error.message = `quais-unsupported: ${error.error.message}`;
                    break;
            }
            return super.getRpcError(payload, error);
        }
        /**
         * Gets the signer for the given address.
         *
         * @param {number | string} [address] - The address to get the signer for.
         * @returns {Promise<JsonRpcSigner>} The signer for the address.
         */
        async getSigner(address) {
            if (address == null) {
                address = 0;
            }
            if (!(await this.hasSigner(address))) {
                try {
                    await this.#request('quai_requestAccounts', []);
                }
                catch (error) {
                    const payload = error.payload;
                    throw this.getRpcError(payload, { id: payload.id, error });
                }
            }
            return await super.getSigner(address);
        }
    }

    /**
     * A **SocketSubscriber** uses a socket transport to handle events and should use
     * {@link SocketSubscriber._emit | **_emit**} to manage the events.
     *
     * - A sub-class MUST call the `_start()` method once connected
     * - A sub-class MUST override the `_write(string)` method
     * - A sub-class MUST call `_processMessage(string)` for each message
     *
     * @category Providers
     */
    class SocketSubscriber {
        #provider;
        #filter;
        /**
         * The filter.
         *
         * @type {any[]}
         */
        get filter() {
            return JSON.parse(this.#filter);
        }
        #filterId;
        #paused;
        #emitPromise;
        zone;
        shard;
        /**
         * Creates a new **SocketSubscriber** attached to `provider` listening to `filter`.
         *
         * @param {SocketProvider} provider - The socket provider.
         * @param {any[]} filter - The filter.
         */
        constructor(provider, filter, zone) {
            this.#provider = provider;
            this.#filter = JSON.stringify(filter);
            this.#filterId = null;
            this.#paused = null;
            this.#emitPromise = null;
            this.zone = zone;
            this.shard = toShard(zone);
        }
        /**
         * Start the subscriber.
         */
        start() {
            this.#filterId = this.#provider.send('quai_subscribe', this.filter, this.shard).then((filterId) => {
                this.#provider._register(filterId, this);
                return filterId;
            });
        }
        /**
         * Stop the subscriber.
         */
        stop() {
            this.#filterId.then((filterId) => {
                this.#provider.send('quai_unsubscribe', [filterId], this.shard);
            });
            this.#filterId = null;
        }
        /**
         * Pause the subscriber.
         *
         * @param {boolean} [dropWhilePaused] - Whether to drop logs while paused.
         */
        pause(dropWhilePaused) {
            assert$1(dropWhilePaused, 'preserve logs while paused not supported by SocketSubscriber yet', 'UNSUPPORTED_OPERATION', { operation: 'pause(false)' });
            this.#paused = !!dropWhilePaused;
        }
        /**
         * Resume the subscriber.
         */
        resume() {
            this.#paused = null;
        }
        /**
         * Handle incoming messages.
         *
         * @ignore
         * @param {any} message - The message to handle.
         */
        _handleMessage(message) {
            if (this.#filterId == null) {
                return;
            }
            if (this.#paused === null) {
                let emitPromise = this.#emitPromise;
                if (emitPromise == null) {
                    emitPromise = this._emit(this.#provider, message);
                }
                else {
                    emitPromise = emitPromise.then(async () => {
                        await this._emit(this.#provider, message);
                    });
                }
                this.#emitPromise = emitPromise.then(() => {
                    if (this.#emitPromise === emitPromise) {
                        this.#emitPromise = null;
                    }
                });
            }
        }
        /**
         * Sub-classes **must** override this to emit the events on the provider.
         *
         * @abstract
         * @param {SocketProvider} provider - The socket provider.
         * @param {any} message - The message to emit.
         * @returns {Promise<void>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async _emit(provider, message) {
            throw new Error('sub-classes must implement this; _emit');
        }
    }
    /**
     * A **SocketBlockSubscriber** listens for `newHeads` events and emits `"block"` events.
     *
     * @category Providers
     */
    class SocketBlockSubscriber extends SocketSubscriber {
        /**
         * Creates a new **SocketBlockSubscriber**.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         */
        constructor(provider, zone) {
            super(provider, ['newHeads'], zone);
        }
        /**
         * Emit the block event.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param {any} message - The message to emit.
         * @returns {Promise<void>}
         */
        async _emit(provider, message) {
            provider.emit('block', this.zone, parseInt(message.woHeader.number));
        }
    }
    /**
     * A **SocketAccessesSubscriber** listens for `acceses` events and emits `accesses` events.
     *
     * @category Providers
     */
    class SocketAccessesSubscriber extends SocketSubscriber {
        #accessesFilter;
        get accessesFilter() {
            return JSON.parse(this.#accessesFilter);
        }
        /**
         * Creates a new **SocketBlockSubscriber**.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param filter
         * @param zone
         */
        constructor(provider, filter, zone) {
            super(provider, ['accesses', filter.address], zone);
            this.#accessesFilter = JSON.stringify(filter);
        }
        /**
         * Emit the block event.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param {any} message - The message to emit.
         * @returns {Promise<void>}
         */
        async _emit(provider, message) {
            if (this.accessesFilter.type === 'balance') {
                message = await provider.getBalance(this.accessesFilter.address);
            }
            provider.emit(this.accessesFilter, this.zone, message);
        }
    }
    /**
     * A **SocketPendingSubscriber** listens for pending transactions and emits `"pending"` events.
     *
     * @category Providers
     */
    class SocketPendingSubscriber extends SocketSubscriber {
        /**
         * Creates a new **SocketPendingSubscriber**.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         */
        constructor(provider, zone) {
            super(provider, ['newPendingTransactions'], zone);
        }
        /**
         * Emit the pending event.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param {any} message - The message to emit.
         * @returns {Promise<void>}
         */
        async _emit(provider, message) {
            provider.emit('pending', message);
        }
    }
    /**
     * A **SocketEventSubscriber** listens for event logs.
     *
     * @category Providers
     */
    class SocketEventSubscriber extends SocketSubscriber {
        #logFilter;
        /**
         * The filter.
         *
         * @type {EventFilter}
         */
        get logFilter() {
            return JSON.parse(this.#logFilter);
        }
        /**
         * Creates a new **SocketEventSubscriber**.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param {EventFilter} filter - The event filter.
         */
        constructor(provider, filter, zone) {
            super(provider, ['logs', filter], zone);
            this.#logFilter = JSON.stringify(filter);
        }
        /**
         * Emit the event log.
         *
         * @ignore
         * @param {SocketProvider} provider - The socket provider.
         * @param {any} message - The message to emit.
         * @returns {Promise<void>}
         */
        async _emit(provider, message) {
            provider.emit(this.logFilter, this.zone, provider._wrapLog(message, provider._network));
        }
    }
    /**
     * A **SocketProvider** is backed by a long-lived connection over a socket, which can subscribe and receive real-time
     * messages over its communication channel.
     *
     * @category Providers
     */
    class SocketProvider extends JsonRpcApiProvider {
        #callbacks;
        // Maps each filterId to its subscriber
        #subs;
        // If any events come in before a subscriber has finished
        // registering, queue them
        #pending;
        /**
         * Creates a new **SocketProvider** connected to `network`.
         *
         * If unspecified, the network will be discovered.
         *
         * @param {Networkish} [network] - The network to connect to.
         * @param {JsonRpcApiProviderOptions} [_options] - The options for the provider.
         */
        constructor(network, _options) {
            // Copy the options
            const options = Object.assign({}, _options != null ? _options : {});
            // Support for batches is generally not supported for
            // connection-base providers; if this changes in the future
            // the _send should be updated to reflect this
            assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, 'sockets-based providers do not support batches', 'options.batchMaxCount', _options);
            options.batchMaxCount = 1;
            // Socket-based Providers (generally) cannot change their network,
            // since they have a long-lived connection; but let people override
            // this if they have just cause.
            if (options.staticNetwork == null) {
                options.staticNetwork = true;
            }
            super(network, options);
            this.#callbacks = new Map();
            this.#subs = new Map();
            this.#pending = new Map();
        }
        /**
         * Get the subscriber for a given subscription.
         *
         * @ignore
         * @param {Subscription} sub - The subscription.
         * @returns {Subscriber} The subscriber.
         */
        _getSubscriber(sub) {
            switch (sub.type) {
                case 'close':
                    return new UnmanagedSubscriber('close');
                case 'block':
                    return new SocketBlockSubscriber(this, sub.zone);
                case 'accesses':
                    return new SocketAccessesSubscriber(this, sub.filter, sub.zone);
                case 'pending':
                    return new SocketPendingSubscriber(this, sub.zone);
                case 'event':
                    return new SocketEventSubscriber(this, sub.filter, sub.zone);
                case 'orphan':
                    // Handled auto-matically within AbstractProvider
                    // when the log.removed = true
                    if (sub.filter.orphan === 'drop-log') {
                        return new UnmanagedSubscriber('drop-log');
                    }
            }
            return super._getSubscriber(sub);
        }
        /**
         * Register a new subscriber. This is used internally by Subscribers and generally is unnecessary unless extending
         * capabilities.
         *
         * @ignore
         * @param {number | string} filterId - The filter ID.
         * @param {SocketSubscriber} subscriber - The subscriber.
         */
        _register(filterId, subscriber) {
            this.#subs.set(filterId, subscriber);
            const pending = this.#pending.get(filterId);
            if (pending) {
                for (const message of pending) {
                    subscriber._handleMessage(message);
                }
                this.#pending.delete(filterId);
            }
        }
        /**
         * Send a JSON-RPC payload.
         *
         * @ignore
         * @param {JsonRpcPayload | JsonRpcPayload[]} payload - The payload to send.
         * @param {Shard} [shard] - The shard.
         * @param {boolean} [now] - Whether to send immediately.
         * @returns {Promise<(JsonRpcResult | JsonRpcError)[]>} The result or error.
         */
        async _send(payload, shard, now) {
            if (this._initFailed) {
                console.log('Provider failed to initialize on creation. Run initialize or create a new provider.');
                return [
                    {
                        id: Array.isArray(payload) ? payload[0].id : payload.id,
                        error: {
                            code: -32000,
                            message: 'Provider failed to initialize on creation. Run initialize or create a new provider.',
                        },
                    },
                ];
            }
            // WebSocket provider doesn't accept batches
            assertArgument(!Array.isArray(payload), 'WebSocket does not support batch send', 'payload', payload);
            // @TODO: stringify payloads here and store to prevent mutations
            // Prepare a promise to respond to
            const promise = new Promise((resolve, reject) => {
                this.#callbacks.set(payload.id, { payload, resolve, reject });
            });
            // Wait until the socket is connected before writing to it
            try {
                if (!now) {
                    await this._waitUntilReady();
                }
            }
            catch (error) {
                this.#callbacks.delete(payload.id);
                return [
                    {
                        id: Array.isArray(payload) ? payload[0].id : payload.id,
                        error: {
                            code: -32000,
                            message: 'Provider failed to initialize on creation. Run initialize or create a new provider.',
                        },
                    },
                ];
            }
            // Write the request to the socket
            await this._write(JSON.stringify(payload), shard);
            return [await promise];
        }
        /**
         * Sub-classes **must** call this with messages received over their transport to be processed and dispatched.
         *
         * @ignore
         * @param {string} message - The message to process.
         */
        async _processMessage(message) {
            const result = JSON.parse(message);
            if (result && typeof result === 'object' && 'id' in result) {
                const callback = this.#callbacks.get(result.id);
                if (callback == null) {
                    this.emit('error', undefined, makeError('received result for unknown id', 'UNKNOWN_ERROR', {
                        reasonCode: 'UNKNOWN_ID',
                        result,
                    }));
                    return;
                }
                this.#callbacks.delete(result.id);
                callback.resolve(result);
            }
            else if (result && result.method === 'quai_subscription') {
                const filterId = result.params.subscription;
                const subscriber = this.#subs.get(filterId);
                if (subscriber) {
                    subscriber._handleMessage(result.params.result);
                }
                else {
                    let pending = this.#pending.get(filterId);
                    if (pending == null) {
                        pending = [];
                        this.#pending.set(filterId, pending);
                    }
                    pending.push(result.params.result);
                }
            }
            else {
                this.emit('error', undefined, makeError('received unexpected message', 'UNKNOWN_ERROR', {
                    reasonCode: 'UNEXPECTED_MESSAGE',
                    result,
                }));
                return;
            }
        }
        /**
         * Sub-classes **must** override this to send `message` over their transport.
         *
         * @ignore
         * @param {string} message - The message to send.
         * @param {Shard} [shard] - The shard.
         * @returns {Promise<void>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async _write(message, shard) {
            throw new Error('sub-classes must override this');
        }
        validateUrl(url) {
            const urlPattern = /^(wss?):\/\/[a-zA-Z0-9.-]+(:\d+)?$/;
            if (!urlPattern.test(url)) {
                let errorMessage = 'Invalid URL: ';
                if (!/^wss?:\/\//.test(url)) {
                    errorMessage += 'URL must start with ws:// or wss://. ';
                }
                if (url.endsWith('/')) {
                    errorMessage += 'URL should not end with a /. ';
                }
                if (/\/[^/]+/.test(url)) {
                    errorMessage += 'URL should not contain a path, query string, or fragment. ';
                }
                throw new Error(errorMessage.trim());
            }
        }
    }

    function getGlobal() {
        if (typeof self !== 'undefined') {
            return self;
        }
        if (typeof window !== 'undefined') {
            return window;
        }
        if (typeof global !== 'undefined') {
            return global;
        }
        throw new Error('unable to locate global object');
    }
    const _WebSocket = getGlobal().WebSocket;

    /**
     * A JSON-RPC provider which is backed by a WebSocket.
     *
     * WebSockets are often preferred because they retain a live connection to a server, which permits more instant access
     * to events.
     *
     * However, this incurs higher server infrastructure costs, so additional resources may be required to host your own
     * WebSocket nodes and many third-party services charge additional fees for WebSocket endpoints.
     *
     * @category Providers
     * @extends SocketProvider
     */
    class WebSocketProvider extends SocketProvider {
        #websockets;
        /**
         * A map to track the readiness of each shard.
         *
         * @type {Map<Shard, boolean>}
         */
        readyMap = new Map();
        /**
         * Get the array of WebSocketLike objects.
         *
         * @returns {WebSocketLike[]} The array of WebSocketLike objects.
         * @throws {Error} If the websocket is closed.
         */
        get websocket() {
            if (this.#websockets == null) {
                throw new Error('websocket closed');
            }
            return this.#websockets;
        }
        /**
         * Create a new WebSocketProvider.
         *
         * @param {string | string[] | WebSocketLike | WebSocketCreator} url - The URL(s) or WebSocket object or creator.
         * @param {Networkish} [network] - The network to connect to.
         * @param {JsonRpcApiProviderOptions} [options] - The options for the JSON-RPC API provider.
         */
        constructor(url, network, options) {
            super(network, options);
            this.#websockets = [];
            if (typeof url === 'string') {
                this.validateUrl(url);
            }
            else if (Array.isArray(url)) {
                url.forEach((it) => this.validateUrl(it));
            }
            else if (typeof url === 'function') {
                this.validateUrl(url().url);
            }
            else {
                this.validateUrl(url.url);
            }
            this.initialize(typeof url === 'string' ? [url] : url);
        }
        /**
         * Initialize a WebSocket connection for a shard.
         *
         * @ignore
         * @param {WebSocketLike} websocket - The WebSocket object.
         * @param {Shard} shard - The shard identifier.
         */
        initWebSocket(websocket, shard, port) {
            websocket.onerror = (error) => {
                console.log('WebsocketProvider error', error);
                websocket.close();
            };
            websocket.onopen = async () => {
                try {
                    await this._start();
                    this.resume();
                    this.readyMap.set(shard, true);
                    try {
                        const zone = toZone(shard);
                        this.provider.startZoneSubscriptions(zone);
                    }
                    catch (error) {
                        // Intentionally left empty. Will catch if shard is prime or region, which isn't a zone
                    }
                }
                catch (error) {
                    console.log('failed to start WebsocketProvider', error);
                    this.readyMap.set(shard, false);
                    // @TODO: now what? Attempt reconnect?
                }
            };
            websocket.onclose = () => {
                setTimeout(() => {
                    const baseUrl = websocket.url.split(':').slice(0, 2).join(':').split('/').slice(0, 3).join('/');
                    const shardSuffix = this._getOption('usePathing') ? `/${fromShard(shard, 'nickname')}` : `:${port}`;
                    const newWebSocket = this.createWebSocket(baseUrl, shardSuffix);
                    this.initWebSocket(newWebSocket, shard, port);
                    this.#websockets.push(newWebSocket);
                    this._urlMap.set(shard, newWebSocket);
                }, 500); // Reconnect after .5 seconds
            };
            websocket.onmessage = (message) => {
                this._processMessage(message.data);
            };
        }
        /**
         * Wait until the shard is ready. Max wait time is ~8 seconds.
         *
         * @param {Shard} shard - The shard identifier.
         * @returns {Promise<void>} A promise that resolves when the shard is ready.
         * @throws {Error} If the shard is not ready within the timeout period.
         */
        async waitShardReady(shard) {
            let count = 0;
            while (!this.readyMap.get(shard)) {
                await new Promise((resolve) => setTimeout(resolve, Math.pow(2, count)));
                if (count > 11) {
                    throw new Error('Timeout waiting for shard to be ready');
                }
                count++;
            }
        }
        createWebSocket = (baseUrl, suffix) => {
            const tempWs = new _WebSocket(`${baseUrl}${suffix}`);
            return tempWs;
            // wait 2 minutes
        };
        /**
         * Initialize the URL map with WebSocket connections.
         *
         * @ignore
         * @param {U} urls - The URLs or WebSocket object or creator.
         * @returns {Promise<void>} A promise that resolves when the URL map is initialized.
         */
        async initialize(urls) {
            //clear websockets
            this.#websockets = [];
            this._urlMap.clear();
            try {
                const primeSuffix = this._getOption('usePathing') ? `/${fromShard(exports.Shard.Prime, 'nickname')}` : ':8001';
                const initShardWebSockets = async (baseUrl) => {
                    const shards = await this._getRunningLocations(exports.Shard.Prime, true);
                    await Promise.all(shards.map(async (shard) => {
                        const port = 8200 + 20 * shard[0] + shard[1];
                        const shardEnum = toShard(`0x${shard[0].toString(16)}${shard[1].toString(16)}`);
                        const shardSuffix = this._getOption('usePathing')
                            ? `/${fromShard(shardEnum, 'nickname')}`
                            : `:${port}`;
                        const shardUrl = baseUrl.split(':').slice(0, 2).join(':');
                        const websocket = this.createWebSocket(shardUrl, shardSuffix);
                        this.initWebSocket(websocket, shardEnum, port);
                        this.#websockets.push(websocket);
                        this._urlMap.set(shardEnum, websocket);
                        try {
                            await this.waitShardReady(shardEnum);
                        }
                        catch (error) {
                            console.log('failed to waitShardReady', error);
                            this._initFailed = true;
                        }
                    }));
                };
                if (Array.isArray(urls)) {
                    for (const url of urls) {
                        const baseUrl = `${url.split(':')[0]}:${url.split(':')[1]}`;
                        const primeWebsocket = this.createWebSocket(baseUrl, primeSuffix);
                        this.initWebSocket(primeWebsocket, exports.Shard.Prime, 8001);
                        this.#websockets.push(primeWebsocket);
                        this._urlMap.set(exports.Shard.Prime, primeWebsocket);
                        await this.waitShardReady(exports.Shard.Prime);
                        await initShardWebSockets(baseUrl);
                    }
                }
                else if (typeof urls === 'function') {
                    const primeWebsocket = urls();
                    this.initWebSocket(primeWebsocket, exports.Shard.Prime, 8001);
                    this.#websockets.push(primeWebsocket);
                    this._urlMap.set(exports.Shard.Prime, primeWebsocket);
                    await this.waitShardReady(exports.Shard.Prime);
                    const baseUrl = this.#websockets[0].url.split(':').slice(0, 2).join(':');
                    await initShardWebSockets(baseUrl);
                }
                else {
                    const primeWebsocket = urls;
                    this.initWebSocket(primeWebsocket, exports.Shard.Prime, 8001);
                    this.#websockets.push(primeWebsocket);
                    this._urlMap.set(exports.Shard.Prime, primeWebsocket);
                    await this.waitShardReady(exports.Shard.Prime);
                    const baseUrl = primeWebsocket.url.split(':').slice(0, 2).join(':');
                    await initShardWebSockets(baseUrl);
                }
                if (this.initResolvePromise)
                    this.initResolvePromise();
            }
            catch (error) {
                this._initFailed = true;
                console.log('failed to initialize', error);
                //clear websockets
                this.#websockets = [];
                if (this.initRejectPromise)
                    this.initRejectPromise(error);
                return;
            }
        }
        /**
         * Write a message to the WebSocket.
         *
         * @ignore
         * @param {string} message - The message to send.
         * @param {Shard} [shard] - The shard identifier.
         * @returns {Promise<void>} A promise that resolves when the message is sent.
         * @throws {Error} If the WebSocket is closed or the shard is not found.
         */
        async _write(message, shard) {
            if (this.websocket.length < 1) {
                throw new Error('Websocket closed');
            }
            if (shard && !this._urlMap.has(shard)) {
                throw new Error('Shard not found');
            }
            const websocket = shard ? this._urlMap.get(shard) : this.websocket[this.websocket.length - 1];
            if (!websocket) {
                throw new Error('Websocket is undefined');
            }
            if (shard) {
                await this.waitShardReady(shard);
            }
            websocket.send(message);
        }
        /**
         * Destroy the WebSocket connections and clean up resources.
         *
         * @returns {Promise<void>} A promise that resolves when the WebSocket connections are closed.
         */
        async destroy() {
            this.#websockets.forEach((it) => it.close());
            this.#websockets = [];
            super.destroy();
        }
    }

    const Base64 = ')!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_';
    /**
     * @ignore
     */
    function decodeBits(width, data) {
        const maxValue = (1 << width) - 1;
        const result = [];
        let accum = 0, bits = 0, flood = 0;
        for (let i = 0; i < data.length; i++) {
            // Accumulate 6 bits of data
            accum = (accum << 6) | Base64.indexOf(data[i]);
            bits += 6;
            // While we have enough for a word...
            while (bits >= width) {
                // ...read the word
                const value = accum >> (bits - width);
                accum &= (1 << (bits - width)) - 1;
                bits -= width;
                // A value of 0 indicates we exceeded maxValue, it
                // floods over into the next value
                if (value === 0) {
                    flood += maxValue;
                }
                else {
                    result.push(value + flood);
                    flood = 0;
                }
            }
        }
        return result;
    }

    /**
     * @ignore
     */
    function decodeOwlA(data, accents) {
        let words = decodeOwl(data).join(',');
        // Inject the accents
        accents.split(/,/g).forEach((accent) => {
            const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
            assertArgument(match !== null, 'internal error parsing accents', 'accents', accents);
            let posOffset = 0;
            const positions = decodeBits(parseInt(match[3]), match[4]);
            const charCode = parseInt(match[2]);
            const regex = new RegExp(`([${match[1]}])`, 'g');
            words = words.replace(regex, (all, letter) => {
                const rem = --positions[posOffset];
                if (rem === 0) {
                    letter = String.fromCharCode(letter.charCodeAt(0), charCode);
                    posOffset++;
                }
                return letter;
            });
        });
        return words.split(',');
    }

    /**
     * An OWL-A format Wordlist extends the OWL format to add an overlay onto an OWL format Wordlist to support diacritic
     * marks.
     *
     * This class is generally not useful to most developers as it is used mainly internally to keep Wordlists for languages
     * based on latin-1 small.
     *
     * If necessary, there are tools within the `generation/` folder to create the necessary data.
     *
     * @category Wordlists
     */
    class WordlistOwlA extends WordlistOwl {
        #accent;
        /**
         * Creates a new Wordlist for `locale` using the OWLA `data` and `accent` data and validated against the `checksum`.
         */
        constructor(locale, data, accent, checksum) {
            super(locale, data, checksum);
            this.#accent = accent;
        }
        /**
         * The OWLA-encoded accent data.
         *
         * @ignore
         */
        get _accent() {
            return this.#accent;
        }
        /**
         * Decode all the words for the wordlist.
         *
         * @ignore
         */
        _decodeWords() {
            return decodeOwlA(this._data, this._accent);
        }
    }

    const words = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
    const accents = 'aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M';
    const checksum = '0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300';
    let wordlist = null;
    /**
     * The [Spanish wordlist](https://github.com/bitcoin/bips/blob/master/bip-0039/spanish.txt) for [mnemonic
     * phrases](https://en.bitcoin.it/wiki/BIP_0039).
     *
     * @category Wordlists
     */
    class LangEs extends WordlistOwlA {
        /**
         * Creates a new instance of the Spanish language Wordlist.
         *
         * This should be unnecessary most of the time as the exported {@link langEs} should suffice.
         *
         * @ignore
         */
        constructor() {
            super('es', words, accents, checksum);
        }
        /**
         * Returns a singleton instance of a `LangEs`, creating it if this is the first time being called.
         */
        static wordlist() {
            if (wordlist == null) {
                wordlist = new LangEs();
            }
            return wordlist;
        }
    }

    const wordlists = {
        en: LangEn.wordlist(),
        es: LangEs.wordlist(),
    };

    // VERSION

    var quais = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AbiCoder: AbiCoder,
        AbstractProvider: AbstractProvider,
        AbstractSigner: AbstractSigner,
        get AddressStatus () { return exports.AddressStatus; },
        BaseContract: BaseContract,
        Block: Block,
        BrowserProvider: BrowserProvider,
        ConstructorFragment: ConstructorFragment,
        Contract: Contract,
        ContractEventPayload: ContractEventPayload,
        ContractFactory: ContractFactory,
        ContractTransactionReceipt: ContractTransactionReceipt,
        ContractTransactionResponse: ContractTransactionResponse,
        ContractUnknownEventPayload: ContractUnknownEventPayload,
        ErrorDescription: ErrorDescription,
        ErrorFragment: ErrorFragment,
        EventFragment: EventFragment,
        EventLog: EventLog,
        EventPayload: EventPayload,
        FallbackFragment: FallbackFragment,
        FeeData: FeeData,
        FetchCancelSignal: FetchCancelSignal,
        FetchRequest: FetchRequest,
        FetchResponse: FetchResponse,
        FewestCoinSelector: FewestCoinSelector,
        FixedNumber: FixedNumber,
        Fragment: Fragment,
        FunctionFragment: FunctionFragment,
        Indexed: Indexed,
        Interface: Interface,
        JsonRpcApiProvider: JsonRpcApiProvider,
        JsonRpcProvider: JsonRpcProvider,
        JsonRpcSigner: JsonRpcSigner,
        LangEn: LangEn,
        LangEs: LangEs,
        get Ledger () { return exports.Ledger; },
        Log: Log,
        LogDescription: LogDescription,
        MaxInt256: MaxInt256,
        MaxUint256: MaxUint256,
        MessagePrefix: MessagePrefix,
        MinInt256: MinInt256,
        Mnemonic: Mnemonic,
        N: N$1,
        NamedFragment: NamedFragment,
        Network: Network,
        ParamType: ParamType,
        QiHDWallet: QiHDWallet,
        QiTransaction: QiTransaction,
        QuaiHDWallet: QuaiHDWallet,
        QuaiTransaction: QuaiTransaction,
        Result: Result,
        get Shard () { return exports.Shard; },
        Signature: Signature,
        SigningKey: SigningKey,
        SocketBlockSubscriber: SocketBlockSubscriber,
        SocketEventSubscriber: SocketEventSubscriber,
        SocketPendingSubscriber: SocketPendingSubscriber,
        SocketProvider: SocketProvider,
        SocketSubscriber: SocketSubscriber,
        StructFragment: StructFragment,
        TransactionDescription: TransactionDescription,
        TransactionReceipt: TransactionReceipt,
        Typed: Typed,
        TypedDataEncoder: TypedDataEncoder,
        UTXO: UTXO,
        UndecodedEventLog: UndecodedEventLog,
        UnmanagedSubscriber: UnmanagedSubscriber,
        VoidSigner: VoidSigner,
        Wallet: Wallet,
        WebSocketProvider: WebSocketProvider,
        WeiPerEther: WeiPerEther,
        Wordlist: Wordlist,
        WordlistOwl: WordlistOwl,
        WordlistOwlA: WordlistOwlA,
        ZeroAddress: ZeroAddress,
        ZeroHash: ZeroHash,
        get Zone () { return exports.Zone; },
        accessListify: accessListify,
        checkResultErrors: checkResultErrors,
        computeAddress: computeAddress,
        computeHmac: computeHmac,
        concat: concat,
        copyRequest: copyRequest,
        dataLength: dataLength,
        dataSlice: dataSlice,
        decodeBase58: decodeBase58,
        decodeBase64: decodeBase64,
        decodeBytes32: decodeBytes32,
        decryptKeystoreJson: decryptKeystoreJson,
        decryptKeystoreJsonSync: decryptKeystoreJsonSync,
        denominations: denominations,
        encodeBase58: encodeBase58,
        encodeBase64: encodeBase64,
        encodeBytes32: encodeBytes32,
        encryptKeystoreJson: encryptKeystoreJson,
        encryptKeystoreJsonSync: encryptKeystoreJsonSync,
        formatMixedCaseChecksumAddress: formatMixedCaseChecksumAddress,
        formatQi: formatQi,
        formatQuai: formatQuai,
        formatUnits: formatUnits,
        fromTwos: fromTwos,
        getAddress: getAddress,
        getAddressDetails: getAddressDetails,
        getBigInt: getBigInt,
        getBytes: getBytes,
        getBytesCopy: getBytesCopy,
        getCreate2Address: getCreate2Address,
        getCreateAddress: getCreateAddress,
        getNumber: getNumber,
        getTxType: getTxType,
        getUint: getUint,
        getZoneForAddress: getZoneForAddress,
        hashMessage: hashMessage,
        hexlify: hexlify,
        id: id,
        isAddress: isAddress,
        isAddressable: isAddressable,
        isBytesLike: isBytesLike,
        isCallException: isCallException,
        isError: isError,
        isHexString: isHexString,
        isKeystoreJson: isKeystoreJson,
        isQiAddress: isQiAddress,
        isQuaiAddress: isQuaiAddress,
        keccak256: keccak256,
        lock: lock,
        makeError: makeError,
        mask: mask,
        musigCrypto: musigCrypto,
        parseQi: parseQi,
        parseQuai: parseQuai,
        parseUnits: parseUnits,
        pbkdf2: pbkdf2,
        quaisymbol: quaisymbol,
        randomBytes: randomBytes,
        recoverAddress: recoverAddress,
        resolveAddress: resolveAddress,
        ripemd160: ripemd160,
        scrypt: scrypt,
        scryptSync: scryptSync,
        sha256: sha256,
        sha512: sha512,
        solidityPacked: solidityPacked,
        solidityPackedKeccak256: solidityPackedKeccak256,
        solidityPackedSha256: solidityPackedSha256,
        stripZerosLeft: stripZerosLeft,
        toBeArray: toBeArray,
        toBeHex: toBeHex,
        toBigInt: toBigInt,
        toNumber: toNumber,
        toQuantity: toQuantity,
        toShard: toShard,
        toTwos: toTwos,
        toUtf8Bytes: toUtf8Bytes,
        toUtf8CodePoints: toUtf8CodePoints,
        toUtf8String: toUtf8String,
        toZone: toZone,
        uuidV4: uuidV4,
        validateAddress: validateAddress,
        verifyMessage: verifyMessage,
        verifyTypedData: verifyTypedData,
        version: version,
        wordlists: wordlists,
        zeroPadBytes: zeroPadBytes,
        zeroPadValue: zeroPadValue
    });

    exports.AbiCoder = AbiCoder;
    exports.AbstractProvider = AbstractProvider;
    exports.AbstractSigner = AbstractSigner;
    exports.BaseContract = BaseContract;
    exports.Block = Block;
    exports.BrowserProvider = BrowserProvider;
    exports.ConstructorFragment = ConstructorFragment;
    exports.Contract = Contract;
    exports.ContractEventPayload = ContractEventPayload;
    exports.ContractFactory = ContractFactory;
    exports.ContractTransactionReceipt = ContractTransactionReceipt;
    exports.ContractTransactionResponse = ContractTransactionResponse;
    exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
    exports.ErrorDescription = ErrorDescription;
    exports.ErrorFragment = ErrorFragment;
    exports.EventFragment = EventFragment;
    exports.EventLog = EventLog;
    exports.EventPayload = EventPayload;
    exports.FallbackFragment = FallbackFragment;
    exports.FeeData = FeeData;
    exports.FetchCancelSignal = FetchCancelSignal;
    exports.FetchRequest = FetchRequest;
    exports.FetchResponse = FetchResponse;
    exports.FewestCoinSelector = FewestCoinSelector;
    exports.FixedNumber = FixedNumber;
    exports.Fragment = Fragment;
    exports.FunctionFragment = FunctionFragment;
    exports.Indexed = Indexed;
    exports.Interface = Interface;
    exports.JsonRpcApiProvider = JsonRpcApiProvider;
    exports.JsonRpcProvider = JsonRpcProvider;
    exports.JsonRpcSigner = JsonRpcSigner;
    exports.LangEn = LangEn;
    exports.LangEs = LangEs;
    exports.Log = Log;
    exports.LogDescription = LogDescription;
    exports.MaxInt256 = MaxInt256;
    exports.MaxUint256 = MaxUint256;
    exports.MessagePrefix = MessagePrefix;
    exports.MinInt256 = MinInt256;
    exports.Mnemonic = Mnemonic;
    exports.N = N$1;
    exports.NamedFragment = NamedFragment;
    exports.Network = Network;
    exports.ParamType = ParamType;
    exports.QiHDWallet = QiHDWallet;
    exports.QiTransaction = QiTransaction;
    exports.QuaiHDWallet = QuaiHDWallet;
    exports.QuaiTransaction = QuaiTransaction;
    exports.Result = Result;
    exports.Signature = Signature;
    exports.SigningKey = SigningKey;
    exports.SocketBlockSubscriber = SocketBlockSubscriber;
    exports.SocketEventSubscriber = SocketEventSubscriber;
    exports.SocketPendingSubscriber = SocketPendingSubscriber;
    exports.SocketProvider = SocketProvider;
    exports.SocketSubscriber = SocketSubscriber;
    exports.StructFragment = StructFragment;
    exports.TransactionDescription = TransactionDescription;
    exports.TransactionReceipt = TransactionReceipt;
    exports.Typed = Typed;
    exports.TypedDataEncoder = TypedDataEncoder;
    exports.UTXO = UTXO;
    exports.UndecodedEventLog = UndecodedEventLog;
    exports.UnmanagedSubscriber = UnmanagedSubscriber;
    exports.VoidSigner = VoidSigner;
    exports.Wallet = Wallet;
    exports.WebSocketProvider = WebSocketProvider;
    exports.WeiPerEther = WeiPerEther;
    exports.Wordlist = Wordlist;
    exports.WordlistOwl = WordlistOwl;
    exports.WordlistOwlA = WordlistOwlA;
    exports.ZeroAddress = ZeroAddress;
    exports.ZeroHash = ZeroHash;
    exports.accessListify = accessListify;
    exports.checkResultErrors = checkResultErrors;
    exports.computeAddress = computeAddress;
    exports.computeHmac = computeHmac;
    exports.concat = concat;
    exports.copyRequest = copyRequest;
    exports.dataLength = dataLength;
    exports.dataSlice = dataSlice;
    exports.decodeBase58 = decodeBase58;
    exports.decodeBase64 = decodeBase64;
    exports.decodeBytes32 = decodeBytes32;
    exports.decryptKeystoreJson = decryptKeystoreJson;
    exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
    exports.denominations = denominations;
    exports.encodeBase58 = encodeBase58;
    exports.encodeBase64 = encodeBase64;
    exports.encodeBytes32 = encodeBytes32;
    exports.encryptKeystoreJson = encryptKeystoreJson;
    exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
    exports.formatMixedCaseChecksumAddress = formatMixedCaseChecksumAddress;
    exports.formatQi = formatQi;
    exports.formatQuai = formatQuai;
    exports.formatUnits = formatUnits;
    exports.fromTwos = fromTwos;
    exports.getAddress = getAddress;
    exports.getAddressDetails = getAddressDetails;
    exports.getBigInt = getBigInt;
    exports.getBytes = getBytes;
    exports.getBytesCopy = getBytesCopy;
    exports.getCreate2Address = getCreate2Address;
    exports.getCreateAddress = getCreateAddress;
    exports.getNumber = getNumber;
    exports.getTxType = getTxType;
    exports.getUint = getUint;
    exports.getZoneForAddress = getZoneForAddress;
    exports.hashMessage = hashMessage;
    exports.hexlify = hexlify;
    exports.id = id;
    exports.isAddress = isAddress;
    exports.isAddressable = isAddressable;
    exports.isBytesLike = isBytesLike;
    exports.isCallException = isCallException;
    exports.isError = isError;
    exports.isHexString = isHexString;
    exports.isKeystoreJson = isKeystoreJson;
    exports.isQiAddress = isQiAddress;
    exports.isQuaiAddress = isQuaiAddress;
    exports.keccak256 = keccak256;
    exports.lock = lock;
    exports.makeError = makeError;
    exports.mask = mask;
    exports.musigCrypto = musigCrypto;
    exports.parseQi = parseQi;
    exports.parseQuai = parseQuai;
    exports.parseUnits = parseUnits;
    exports.pbkdf2 = pbkdf2;
    exports.quais = quais;
    exports.quaisymbol = quaisymbol;
    exports.randomBytes = randomBytes;
    exports.recoverAddress = recoverAddress;
    exports.resolveAddress = resolveAddress;
    exports.ripemd160 = ripemd160;
    exports.scrypt = scrypt;
    exports.scryptSync = scryptSync;
    exports.sha256 = sha256;
    exports.sha512 = sha512;
    exports.solidityPacked = solidityPacked;
    exports.solidityPackedKeccak256 = solidityPackedKeccak256;
    exports.solidityPackedSha256 = solidityPackedSha256;
    exports.stripZerosLeft = stripZerosLeft;
    exports.toBeArray = toBeArray;
    exports.toBeHex = toBeHex;
    exports.toBigInt = toBigInt;
    exports.toNumber = toNumber;
    exports.toQuantity = toQuantity;
    exports.toShard = toShard;
    exports.toTwos = toTwos;
    exports.toUtf8Bytes = toUtf8Bytes;
    exports.toUtf8CodePoints = toUtf8CodePoints;
    exports.toUtf8String = toUtf8String;
    exports.toZone = toZone;
    exports.uuidV4 = uuidV4;
    exports.validateAddress = validateAddress;
    exports.verifyMessage = verifyMessage;
    exports.verifyTypedData = verifyTypedData;
    exports.version = version;
    exports.wordlists = wordlists;
    exports.zeroPadBytes = zeroPadBytes;
    exports.zeroPadValue = zeroPadValue;

}));
//# sourceMappingURL=quais.umd.js.map
